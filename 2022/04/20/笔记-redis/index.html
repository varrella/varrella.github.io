<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Varrella | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="title: Redis 笔记 0、关系型数据库和非关系型数据库1、关系型数据库采用关系模型来组织数据的数据库，关系模型就是二维表格模型。一张二维表就是关系，二维表中的一行就是记录，二维表中的一列就是一个字段。 优点：  容易理解 使用方便、通用的sql语言 易于维护、丰富的完整性（实体完整性、参照完整性、用户定义的完整性）大大降低了数据冗余和数据不一致的概率  缺点：  磁盘I&#x2F;O是并发的瓶颈">
<meta property="og:type" content="article">
<meta property="og:title" content="Varrella">
<meta property="og:url" content="https://varrella.github.io/2022/04/20/%E7%AC%94%E8%AE%B0-redis/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="title: Redis 笔记 0、关系型数据库和非关系型数据库1、关系型数据库采用关系模型来组织数据的数据库，关系模型就是二维表格模型。一张二维表就是关系，二维表中的一行就是记录，二维表中的一列就是一个字段。 优点：  容易理解 使用方便、通用的sql语言 易于维护、丰富的完整性（实体完整性、参照完整性、用户定义的完整性）大大降低了数据冗余和数据不一致的概率  缺点：  磁盘I&#x2F;O是并发的瓶颈">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg">
<meta property="article:published_time" content="2022-04-20T04:17:49.000Z">
<meta property="article:modified_time" content="2022-08-16T15:45:14.070Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2022/04/20/%E7%AC%94%E8%AE%B0-redis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-16 23:45:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-20T04:17:49.000Z" title="Created 2022-04-20 12:17:49">2022-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-08-16T15:45:14.070Z" title="Updated 2022-08-16 23:45:14">2022-08-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>title: Redis 笔记</p>
<h3 id="0、关系型数据库和非关系型数据库"><a href="#0、关系型数据库和非关系型数据库" class="headerlink" title="0、关系型数据库和非关系型数据库"></a>0、关系型数据库和非关系型数据库</h3><h4 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、关系型数据库</h4><p>采用关系模型来组织数据的数据库，关系模型就是二维表格模型。一张二维表就是关系，二维表中的一行就是记录，二维表中的一列就是一个字段。</p>
<p>优点：</p>
<ul>
<li>容易理解</li>
<li>使用方便、通用的sql语言</li>
<li>易于维护、丰富的完整性（实体完整性、参照完整性、用户定义的完整性）大大降低了数据冗余和数据不一致的概率</li>
</ul>
<p>缺点：</p>
<ul>
<li>磁盘I/O是并发的瓶颈</li>
<li>海量数据查询效率低</li>
<li>横向扩展困难，无法简单地通过添加硬件和服务节点来扩展性能和负载能力，当需要对数据库进行升级和扩展时，需要停机维护和数据迁移</li>
<li>多表的关联查询以及复杂的数据分析类型的复杂sql查询，性能欠佳</li>
</ul>
<p>数据库：Oracle、Sql Server、Mysql、DB2</p>
<h4 id="2、非关系型数据库"><a href="#2、非关系型数据库" class="headerlink" title="2、非关系型数据库"></a>2、非关系型数据库</h4><p>非关系型，分布式，一般不保证遵循ACID原则的数据存储系统，键值对存储，结构不固定。</p>
<p>优点：</p>
<ul>
<li>根据需要添加字段，不需要多表联查，仅需id取出对应的value</li>
<li>适用于SNS（社会化网络服务软件，比如facebook、微博等）</li>
<li>严格上讲不是一种数据库，而是一种数据结构化存储方法的集合</li>
</ul>
<p>缺点：</p>
<ul>
<li>只适合存储一些比较简单的数据</li>
<li>不适合复杂查询的数据</li>
<li>不适合持久存储海量数据</li>
</ul>
<p>数据库：</p>
<ul>
<li>K-V：Redis，Memcache</li>
<li>文档：MongoDB</li>
<li>搜索：Elasticsearch，Solr</li>
<li>可扩展性分布式：HBase</li>
</ul>
<h4 id="3、比较"><a href="#3、比较" class="headerlink" title="3、比较"></a>3、比较</h4><table>
<thead>
<tr>
<th>内容</th>
<th>关系型数据库</th>
<th>非关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td>成本</td>
<td>有些需要收费（Oracle）</td>
<td>基本都是开源</td>
</tr>
<tr>
<td>查询数据</td>
<td>存储存于硬盘中，速度慢</td>
<td>数据存于缓存中，速度快</td>
</tr>
<tr>
<td>存储格式</td>
<td>只支持基础类型</td>
<td>K-V，文档，图片等</td>
</tr>
<tr>
<td>扩展性</td>
<td>有多表查询机制，扩展困难</td>
<td>数据之间没有耦合，容易扩展</td>
</tr>
<tr>
<td>持久性</td>
<td>适用持久存储，海量数据</td>
<td>不适用持久存储，海量存储</td>
</tr>
<tr>
<td>数据一致性</td>
<td>事务能力强，强调数据的强一致性</td>
<td>事务能力弱，强调数据的最终一致性（不一定实时）</td>
</tr>
</tbody></table>
<h4 id="4、Redis概述"><a href="#4、Redis概述" class="headerlink" title="4、Redis概述"></a>4、Redis概述</h4><p>Redis（Remote Dictionary Server），即远程字典服务。是一个用C语言编写、支持网络、可基于内存、可持久化的日志型、Key-Value数据库，并提供多种语言的API。Redis会周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
<ul>
<li>内存存储、持久化，内存中是断电即失的，所以说持久化很重要（rdb、aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量）等</li>
</ul>
<h4 id="5、Redis单线程"><a href="#5、Redis单线程" class="headerlink" title="5、Redis单线程"></a>5、Redis单线程</h4><p><strong>Redis是单线程的。</strong>Redis是基于内存操作的，CPU不是Redis的瓶颈，Redis的瓶颈是根据及其的内容和网络带宽，既然可以使用单线程来实现，就使用单线程了。</p>
<p>【Redis为什么单线程还这么快？】</p>
<p>Redis是将所有的数据全部放在内存中，多次读写都是在一个CPU上的。多线程会引发上下文切换造成效率降低，对于内存系统来说，没有上下文切换，在内存情况下，单线程是最佳方案。</p>
<h3 id="一、内部数据结构"><a href="#一、内部数据结构" class="headerlink" title="一、内部数据结构"></a>一、内部数据结构</h3><h4 id="1、简单动态字符串（Sds，Simple-Dynamic-String）"><a href="#1、简单动态字符串（Sds，Simple-Dynamic-String）" class="headerlink" title="1、简单动态字符串（Sds，Simple Dynamic String）"></a>1、简单动态字符串（Sds，Simple Dynamic String）</h4><h5 id="（1）Sds在Redis中的作用"><a href="#（1）Sds在Redis中的作用" class="headerlink" title="（1）Sds在Redis中的作用"></a>（1）<code>Sds</code>在<code>Redis</code>中的作用</h5><ul>
<li>实现字符串对象（<code>StringObject</code>）；</li>
<li>在<code>Redis</code>程序内部用作<code>char*</code>类型的替代品；</li>
</ul>
<p><code>Redis</code>是一个键值对数据库，数据库的值可以是字符串、集合、列表等多种类型的对象，而数据库的键则总是字符串对象。 对于那些包含字符串值的字符串对象来说，每个字符串对象都包含一个<code>sds</code>值。（字符串还可以保存<code>long</code>类型的值，当字符串对象保存的是字符串时，它包含的才是<code>sds</code>值，否则的话，它就是一个<code>long</code>类型的值）</p>
<h5 id="（2）sds的实现"><a href="#（2）sds的实现" class="headerlink" title="（2）sds的实现"></a>（2）<code>sds</code>的实现</h5><p><code>sds</code>既可以高效地 实现追加和长度计算，并且它还是二进制安全的。<code>sds</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> len;     <span class="comment">// buf 已占用长度    </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;    <span class="comment">// buf 剩余可用长度   </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，类型<code>sds</code>是<code>char *</code>的别名，而结构<code>sdshdr</code>则保存了<code>len</code>、<code>free</code>和<code>buf</code>三个属性。通过对<code>buf</code>分配一些额外的空间（执行<code>APPEND</code>之后），并使用<code>free</code>记录未使用空间的大小，<code>sdshdr</code>可以让执行追加操作所需的内存重分配次数大大减少。</p>
<p>在目前版本的<code>Redis</code>中，<code>SDS_MAX_PREALLOC</code>的值为 1024 * 1024 ，也就是说，当大小小于 1MB 的字符串执行追加操作时，<code>sdsMakeRoomFor</code>就为它们分配多于所需大小一倍的空间；当 字符串的大小大于 1MB ，那么<code>sdsMakeRoomFor</code>就为它们额外多分配 1MB 的空间。</p>
<p><code>sds</code>模块基于<code>sds</code>类型和<code>sdshdr</code>结构提供了以下<code>API</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712214905.png"></p>
<h4 id="2、双端链表"><a href="#2、双端链表" class="headerlink" title="2、双端链表"></a>2、双端链表</h4><h5 id="（1）双端链表的作用"><a href="#（1）双端链表的作用" class="headerlink" title="（1）双端链表的作用"></a>（1）双端链表的作用</h5><p>双端链表还是<code>Redis</code>列表类型的底层实现之一，当对列表类型的键进行操作，比如执行<code>RPUSH</code>、<code>LPOP</code>或<code>LLEN</code>等命令时，程序在底层操作的可能就是双端链表。</p>
<ul>
<li>节点带有前驱和后继指针，访问前驱节点和后继节点的复杂度为<code>O(1)</code>，并且对链表的迭代可以在从表头到表尾和从表尾到表头两个方向进行；</li>
<li>链表带有指向表头和表尾的指针，因此对表头和表尾进行处理的复杂度为<code>O(1)</code>；</li>
<li>链表带有记录节点数量的属性，所以可以在<code>O(1)</code>复杂度内返回链表的节点数量；</li>
</ul>
<p><code>Redis</code>列表使用两种数据结构作为底层实现：<strong>双端链表</strong>和<strong>压缩列表</strong>。因为双端链表占用的内存比压缩列表要多，所以当创建新的列表键时，列表会优先考虑使用压缩列表作为底层实现，并且在有需要的时候，才从压缩列表实现转换到双端链表实现。 </p>
<h5 id="（2）双端链表的实现"><a href="#（2）双端链表的实现" class="headerlink" title="（2）双端链表的实现"></a>（2）双端链表的实现</h5><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712214831.png" style="zoom:70%;" />

<p>双端链表的实现由<code>listNode</code>和<code>list</code>两个数据结构构成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">其中，listNode 是双端链表的节点：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前驱节点    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 后继节点   </span></span><br><span class="line">    <span class="keyword">void</span> *value;            <span class="comment">// 值</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">而 <span class="built_in">list</span> 则是双端链表本身：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span>    </span><br><span class="line">    listNode *head;      <span class="comment">// 表头指针   </span></span><br><span class="line">    listNode *tail;      <span class="comment">// 表尾指针    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">// 节点数量    </span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  <span class="comment">// 复制函数    </span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  <span class="comment">// 释放函数   </span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 比对函数</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>以下是用于操作双端链表的<code>API</code>，它们的作用以及算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712215531.png"></p>
<h4 id="3、字典"><a href="#3、字典" class="headerlink" title="3、字典"></a>3、字典</h4><h5 id="（1）字典的作用"><a href="#（1）字典的作用" class="headerlink" title="（1）字典的作用"></a>（1）字典的作用</h5><ul>
<li><p>实现数据库键空间</p>
<p><code>Redis</code>是一个键值对数据库，数据库中的键值对就由字典保存：每个数据库都有一个与之相对应的字典，这个字典被称之为键空间。 当用户添加一个键值对到数据库时（不论键值对是什么类型），程序就将该键值对添加到键空间；当用户从数据库中删除一个键值对时，程序就会将这个键值对从键空间中删除；</p>
</li>
<li><p>用作<code>Hash</code>类型键的其中一种底层实现。因为压缩列表比字典更节省内存，所以程序在创建新<code>Hash</code>键时，默认使用压缩列表作为底层实现，当有需要时，程序才会将底层实现从压缩列表转换到字典。</p>
</li>
</ul>
<h5 id="（2）字典的实现"><a href="#（2）字典的实现" class="headerlink" title="（2）字典的实现"></a>（2）字典的实现</h5><p><code>Redis</code>选择了高效且实现简单的<strong>哈希表</strong>作为字典的底层实现。每个字典使用两个哈希表，用于实现渐进式<code>rehash</code>。0 号哈希表（<code>ht[0]</code>）是字典主要使用的哈希表，而 1 号哈希表（<code>ht[1]</code>）则只有在程序 对 0 号哈希表进行<code>rehash</code>时才使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;<span class="comment">// 特定于类型的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;<span class="comment">// 类型处理函数的私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// 哈希表（2 个）</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;<span class="comment">// 记录 rehash 进度的标志，值为-1 表示 rehash 未进行</span></span><br><span class="line">    <span class="keyword">int</span> iterators;<span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>以下是用于处理<code>dict</code>类型的<code>API</code>，它们的作用及相应的算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712215510.png"></p>
<h5 id="（3）哈希表的实现"><a href="#（3）哈希表的实现" class="headerlink" title="（3）哈希表的实现"></a>（3）哈希表的实现</h5><p>使用链地址法来处理碰撞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;   <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>      <span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 链往后继节点</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;     <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    <span class="comment">// 指针数组的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">// 指针数组的长度掩码，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;    <span class="comment">// 哈希表现有的节点数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p><strong>整个字典的结构：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712220052.png" style="zoom:70%;" />

<h5 id="（4）哈希算法"><a href="#（4）哈希算法" class="headerlink" title="（4）哈希算法"></a>（4）哈希算法</h5><p><code>Redis</code>目前使用两种不同的哈希算法：</p>
<ul>
<li><code>MurmurHash2 32 bit</code>算法：这种算法的分布率和速度都非常好</li>
<li>基于<code>djb</code>算法实现的一个大小写无关散列算法</li>
</ul>
<p>使用哪种算法取决于具体应用所处理的数据：</p>
<ul>
<li>命令表以及<code>Lua</code>脚本缓存都用到了算法 2 </li>
<li>算法 1 的应用则更加广泛：数据库、集群、哈希键、阻塞操作等功能都用到了这个算法。</li>
</ul>
<h5 id="（5）添加新元素操作"><a href="#（5）添加新元素操作" class="headerlink" title="（5）添加新元素操作"></a>（5）添加新元素操作</h5><ul>
<li><p>字典为空</p>
<p>当第一次往空字典里添加键值对时，程序会根据<code>dict.h/DICT_HT_INITIAL_SIZE</code>里指定的大小为<code>d-&gt;ht[0]-&gt;table</code>分配空间（在目前的版本中，<code>DICT_HT_INITIAL_SIZE</code>的值为 4 ）。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712220535.png" style="zoom:70%;" /></li>
<li><p>添加新键值对时发生碰撞处理，采用链地址法解决冲突。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712220726.png" style="zoom:70%;" /></li>
<li><p>添加新键值对时触发了<code>rehash</code>操作</p>
<p>为了在字典的键值对不断增多的情况下保持良好的性能，字典需要对所使用的哈希表（<code>ht[0]</code>） 进行<code>rehash</code>操作：在不修改任何键值对的情况下，对哈希表进行扩容，尽量将比率维持在 1:1 左右。</p>
<p><code>dictAdd</code>在每次向字典添加新键值对之前，都会对哈希表<code>ht[0]</code>进行检查，对于<code>ht[0]</code>的<code>size</code>和<code>used</code>属性，如果它们之间的比率<code>ratio = used / size</code>满足以下任何一个条件的话，<code>rehash</code>过程就会被激活：</p>
<ul>
<li>自然<code>rehash</code>：<code>ratio &gt;= 1</code>，且变量<code>dict_can_resize</code>为真</li>
<li>强制<code>rehash</code>：<code>ratio</code>大于变量<code>dict_force_resize_ratio</code>（目前版本中，<code>dict_force_resize_ratio</code>的值为 5 ）。</li>
</ul>
</li>
</ul>
<h5 id="（6）rehash的执行过程"><a href="#（6）rehash的执行过程" class="headerlink" title="（6）rehash的执行过程"></a>（6）<code>rehash</code>的执行过程</h5><ul>
<li>设置字典的<code>rehashidx</code>为 0 ，标识着<code>rehash</code>的开始；创建一个比<code>ht[0]-&gt;table</code>更大的<code>ht[1]-&gt;table</code>，大小至少为<code>ht[0]-&gt;used</code>的两倍；</li>
<li>将<code>ht[0]-&gt;table</code>中的所有键值对迁移到<code>ht[1]-&gt;table</code>；因为<code>rehash</code>是<strong>分多次进行</strong>的，字典的<code>rehashidx</code>变量会记录<code>rehash</code>进行到<code>ht[0]</code>的哪个索引位置上。</li>
<li>将原有<code>ht[0]</code>的数据清空，并将<code>ht[1]</code>替换为新的<code>ht[0]</code>。创建一个新的空哈希表，并将它设置为<code>ht[1]</code>，将字典的<code>rehashidx</code>属性设置为 -1 ，标识<code>rehash</code>已停止；</li>
</ul>
<p>采用渐进式<code>rehash</code>，由于要求服务器必须阻塞直到<code>rehash</code>完成，这对于<code>Redis</code>服务器本身也是不能接受的，因此使用了渐进式的<code>rehash</code>方式：通过将<code>rehash</code>分散到多个步骤中进行，从而避免了集中式的计算。渐进式<code>rehash</code>主要由 <code>_dictRehashStep</code>和<code>dictRehashMilliseconds</code>两个函数进行。</p>
<h5 id="（7）字典的收缩"><a href="#（7）字典的收缩" class="headerlink" title="（7）字典的收缩"></a>（7）字典的收缩</h5><p>收缩<code>rehash</code>和扩展<code>rehash</code>的操作几乎一样，它执行以下步骤：</p>
<ul>
<li>创建一个比<code>ht[0]-&gt;table</code>小的<code>ht[1]-&gt;table</code>；</li>
<li>将<code>ht[0]-&gt;table</code>中的所有键值对迁移到<code>ht[1]-&gt;table</code>；</li>
<li>将原有<code>ht[0]</code>的数据清空，并将<code>ht[1]</code>替换为新的<code>ht[0]</code>；</li>
</ul>
<p>以下函数是这个迭代器的<code>API</code>，它们的作用及相关算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712221632.png"></p>
<h4 id="4、跳跃表"><a href="#4、跳跃表" class="headerlink" title="4、跳跃表"></a>4、跳跃表</h4><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712222047.png" style="zoom:50%;" />

<p>跳跃表是一种随机化数据结构，它的查找、添加、删除操作都可以在对数期望时间下完成。跳跃表目前在<code>Redis</code>的唯一作用就是作为有序集类型的底层数据结构（之一，另一个构成有序集的结构是字典）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span><span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表的节点由 redis.h/zskiplistNode 定义：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;<span class="comment">// member 对象</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">// 分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span><span class="comment">// 层</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">// 前进指针</span></span><br><span class="line">    	<span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>以下是操作这两个数据结构的<code>API</code>，它们的作用以及相应的算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712221919.png"></p>
<h3 id="二、内存映射数据结构"><a href="#二、内存映射数据结构" class="headerlink" title="二、内存映射数据结构"></a>二、内存映射数据结构</h3><h4 id="1、整数集合（intset）"><a href="#1、整数集合（intset）" class="headerlink" title="1、整数集合（intset）"></a>1、整数集合（intset）</h4><h5 id="（1）整数集合"><a href="#（1）整数集合" class="headerlink" title="（1）整数集合"></a>（1）整数集合</h5><p>用于有序、无重复的保存多个整数值，它会根据元素的值，自动选择改用什么长度的整数类型来保存元素。<code>intset</code>是集合键的底层实现之一，如果一个集合只保存着整数元素、且元素数量不多的情况下，那么<code>redis</code>就会用<code>intset</code>来保存集合元素。<code>Intset</code>是有序的，程序使用二分查找算法来实现查找操作，复杂度为<code>O(lgN)</code> 。</p>
<h5 id="（2）数据结构和主要操作"><a href="#（2）数据结构和主要操作" class="headerlink" title="（2）数据结构和主要操作"></a>（2）数据结构和主要操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;    <span class="comment">// 保存元素所使用的的类型的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;      <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];    <span class="comment">// 保存元素的数组</span></span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p><code>encoding</code>的值可以使以下三种之一：</p>
<ul>
<li><code># define INTSET_ENC_INT16 (sizeof(int16_t))</code></li>
<li><code># define INTSET_ENC_INT32 (sizeof(int32_t))</code></li>
<li><code># define INTSET_ENC_INT64 (sizeof(int64_t))</code></li>
</ul>
<p><code>contents</code>数组是实际保存元素的地方，数组中的元素有以下另两个特性：</p>
<ul>
<li>无重复元素；</li>
<li>元素在数组中从小到大排列。</li>
</ul>
<p>下表列出了处理<code>intset</code>的一些主要操作，以及这些操作的算法复杂度：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712115759.png" style="zoom:80%;" />

<p><strong>实例：创建并插入元素：</strong></p>
<p>创建<code>intset</code>之后，就可以对它添加新元素了。 添加新元素到<code>intset</code>的工作由 <code>intset.c/intsetAdd</code>函数完成，它需要处理以下三种情况： </p>
<ul>
<li>元素已存在于集合，不做动作；</li>
<li>元素不存在于集合，并且添加新元素并不需要升级（现有的编码方式适用于新元素）；</li>
<li>元素不存在于集合，但是要在升级之后，才能添加新元素。在添加新元素时，如果<code>intsetAdd</code>发现新元素不能用现有的编码方式来保存，它就会将升级集 合和添加新元素的任务转交给<code>intsetUpgradeAndAdd</code>来完成：</li>
</ul>
<p>并且，<code>intsetAdd</code>需要维持<code>intset-&gt;contents</code>的以下性质：</p>
<ul>
<li>确保数组中没有重复元素；</li>
<li>确保数组中的元素按从小到大排序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">intset *is = intsetNew();   <span class="comment">// encoding 使用 INTSET_ENC_INT16 作为初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，不需要升级</span></span><br><span class="line">intsetAdd(is, <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">12</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/** 此时：</span></span><br><span class="line"><span class="comment"> is-&gt;encoding = INTSET_ENC_INT16;</span></span><br><span class="line"><span class="comment"> is-&gt;length = 3;</span></span><br><span class="line"><span class="comment"> is-&gt;contents = [5, 10, 12]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，需要升级</span></span><br><span class="line">intsetAdd(is, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">65535</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">70000</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/** 此时：</span></span><br><span class="line"><span class="comment"> is-&gt;encoding = INTSET_ENC_INT32;</span></span><br><span class="line"><span class="comment"> is-&gt;length = 3;</span></span><br><span class="line"><span class="comment"> is-&gt;contents = [1, 65535, 70000]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">intsetAdd(is, <span class="number">4294967295</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/** 此时：</span></span><br><span class="line"><span class="comment"> is-&gt;encoding = INTSET_ENC_INT64;</span></span><br><span class="line"><span class="comment"> is-&gt;length = 4;</span></span><br><span class="line"><span class="comment"> is-&gt;contents = [1, 65535, 70000, 4294967295]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p><strong>升级过程：</strong></p>
<p><code>intsetUpgradeAndAdd</code>需要完成以下几个任务：</p>
<ul>
<li>对新元素进行检测，看保存这个新元素需要什么类型的编码</li>
<li>将集合<code>encoding</code>属性的值设置为新编码类型，并根据新编码类型，对整个 <code>contents</code>数组进行内存重分配；</li>
<li>调整<code>contents</code>数组内原有元素在内存中的排列方式，让它们从旧编码调整为新编码。（<code>intset</code>只进行从较短整数到较长整数的转换，并不会更改元素里面的值；集合编码元素的方式，由元素中长度最大的那个值来决定）</li>
<li>将新元素添加到集合中。 </li>
</ul>
<p><strong>【一个实例帮助理解】：</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设有一个`intset`，里面包含三个用`<span class="keyword">int16_t</span>`方式保存的数值，分别是 <span class="number">1</span> 、<span class="number">2</span> 和 <span class="number">3</span> ，它的结构如下：</span><br><span class="line">intset-&gt;encoding = INTSET_ENC_INT16;</span><br><span class="line">intset-&gt;length = <span class="number">3</span>;</span><br><span class="line">intset-&gt;contents = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">其中，`intset-&gt;contents`在内存中的排列如下： </span><br><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span> </span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> |</span><br></pre></td></tr></table></figure>

<p>现在要将一个长度为<code>int32_t</code>的值 65535 加入到集合中，<code>intset</code>需要执行以下步骤：</p>
<ul>
<li>将<code>encoding</code>属性设置为<code>INTSET_ENC_INT32</code></li>
<li>根据<code>encoding</code>属性的值，对<code>contents</code>数组进行内存重分配。 重分配完成之后，<code>contents</code>在内存中的排列如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span>  <span class="number">63</span>  <span class="number">95</span>  <span class="number">127</span></span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | ? | ? | ? |</span><br><span class="line">contents 数组现在共有可容纳 <span class="number">4</span> 个 <span class="keyword">int32_t</span> 值的空间。</span><br></pre></td></tr></table></figure>

<p>因为原来的 3 个<code>int16_t</code>值还“挤在”<code>contents</code>前面的 48 个位里，所以程序需要对它们进行移动和类型转换，从而让它们适应集合的新编码方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">首先是移动 <span class="number">3</span> ：</span><br><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span>  <span class="number">63</span>  <span class="number">95</span>  <span class="number">127</span></span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | ? | <span class="number">3</span> | ? |</span><br><span class="line">                |       ^</span><br><span class="line">                |       |</span><br><span class="line">                +-------+</span><br><span class="line">           <span class="keyword">int16_t</span> -&gt; <span class="keyword">int32_t</span></span><br><span class="line"></span><br><span class="line">接着移动 <span class="number">2</span> ：</span><br><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span>  <span class="number">63</span>  <span class="number">95</span>  <span class="number">127</span></span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> |   <span class="number">2</span>   | <span class="number">3</span> | ? |</span><br><span class="line">            |     ^</span><br><span class="line">            |     |</span><br><span class="line">            +-----+</span><br><span class="line">      <span class="keyword">int16_t</span> -&gt; <span class="keyword">int32_t</span></span><br><span class="line">    </span><br><span class="line">最后，移动 <span class="number">1</span> ：</span><br><span class="line">bit   <span class="number">0</span>  <span class="number">15</span>  <span class="number">31</span> <span class="number">47</span> <span class="number">63</span> <span class="number">95</span> <span class="number">127</span></span><br><span class="line">value |  <span class="number">1</span>   |  <span class="number">2</span>  | <span class="number">3</span> | ? |</span><br><span class="line">        |^</span><br><span class="line">        V|</span><br><span class="line"><span class="keyword">int16_t</span> -&gt; <span class="keyword">int32_t</span></span><br><span class="line">    </span><br><span class="line">最后，将新值 <span class="number">65535</span> 添加到数组：</span><br><span class="line">bit   <span class="number">0</span> <span class="number">15</span>  <span class="number">31</span> <span class="number">47</span>  <span class="number">63</span>   <span class="number">95</span>     <span class="number">127</span></span><br><span class="line">value |  <span class="number">1</span>  |   <span class="number">2</span>  |  <span class="number">3</span> | <span class="number">65535</span> |</span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                           add</span><br><span class="line">将 intset-&gt;length 设置为 <span class="number">4</span> 。</span><br><span class="line">    </span><br><span class="line">至此，集合的升级和添加操作完成，现在的 intset 结构如下：</span><br><span class="line">intset-&gt;encoding = INTSET_ENC_INT32;</span><br><span class="line">intset-&gt;length = <span class="number">4</span>;</span><br><span class="line">intset-&gt;contents = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">65535</span>];</span><br></pre></td></tr></table></figure>

<h4 id="2、压缩列表（Ziplist）"><a href="#2、压缩列表（Ziplist）" class="headerlink" title="2、压缩列表（Ziplist）"></a>2、压缩列表（Ziplist）</h4><h5 id="（1）压缩列表"><a href="#（1）压缩列表" class="headerlink" title="（1）压缩列表"></a>（1）压缩列表</h5><p><code>Ziplist</code>是由一系列特殊编码的内存块构成的列表，一个<code>ziplist</code>可以包含多个节点，每 个节点可以保存一个长度受限的字符数组（不以<code>\0</code>结尾的<code>char</code>数组）或者整数。因为<code>ziplist</code>节约内存的性质，它被哈希键、列表键和有序集合键作为初始化的底层实现来使用。</p>
<h5 id="（2）ziplist的构成"><a href="#（2）ziplist的构成" class="headerlink" title="（2）ziplist的构成"></a>（2）ziplist的构成</h5><p><code>ziplist</code>的构成：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/ferufyheo.png"></p>
<p><code>ziplist</code>可以包含多个节点，每个节点可以划分为以下几个部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712142045.png"></p>
<ul>
<li><code>pre_entry_length</code>记录了前一个节点的长度，通过这个值，可以进行指针计算，从而跳转到 上一个节点。</li>
<li><code>encoding</code>和<code>length</code>两部分一起决定了<code>content</code>部分所保存的数据的类型（以及长度）。 其中，<code>encoding</code>域的长度为两个<code>bit</code>，它的值可以是00 、01 、10 和 11。00 、01 和 10 表示<code>content</code>部分保存着字符数组。 11 表示 <code>content</code>部分保存着整数。</li>
<li><code>content</code>部分保存着节点的内容，它的类型和长度由<code>encoding</code>和<code>length</code>决定。</li>
</ul>
<p><strong>用于操作<code>ziplist</code>的函数：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/gbklmglb.jpg"></p>
<p><strong>将节点添加到末端：</strong></p>
<p>将新节点添加到<code>ziplist</code>的末端需要执行以下三个步骤：</p>
<ul>
<li>记录到达<code>ziplist</code>末端所需的偏移量（因为之后的内存重分配可能会改变 <code>ziplist</code>的地址， 因此记录偏移量而不是保存指针）</li>
<li>根据新节点要保存的值，计算出编码这个值所需的空间大小，以及编码它前一个节点的长度所需的空间大小，然后对<code>ziplist</code>进行内存重分配。</li>
<li>设置新节点的各项属性：<code>pre_entry_length</code>、<code>encoding</code> 、<code>length</code>和 <code>content</code>。</li>
<li>更新<code>ziplist</code>的各项属性，比如记录空间占用的<code>zlbytes</code>，到达表尾节点的偏移量<code>zltail</code>，以及记录节点数量的<code>zllen</code>。</li>
</ul>
<h3 id="三、Redis-数据类型"><a href="#三、Redis-数据类型" class="headerlink" title="三、Redis 数据类型"></a>三、Redis 数据类型</h3><h4 id="1、redisObject-数据结构，以及-Redis-的数据类型"><a href="#1、redisObject-数据结构，以及-Redis-的数据类型" class="headerlink" title="1、redisObject 数据结构，以及 Redis 的数据类型"></a>1、redisObject 数据结构，以及 Redis 的数据类型</h4><p><code>redisObject</code>是<code>Redis</code>类型系统的核心，数据库中的每个键、值，以及<code>Redis</code>本身处理的参数， 都表示为这种数据类型。<code>redisObject</code>的定义位于<code>redis.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;      <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;   <span class="comment">// 对齐位</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;  <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;      <span class="comment">// LRU 时间（相对于 server.lruclock）</span></span><br><span class="line">    <span class="keyword">int</span> refcount;         <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;            <span class="comment">// 指向对象的值</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><code>type</code>、<code>encoding</code>和<code>ptr</code>是最重要的三个属性。<code>type</code>记录了对象所保存的值的类型，它的值可能是以下常量的其中一个（定义位于<code>redis.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1   <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2    <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3   <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4   <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure>

<p><code>encoding</code>记录了对象所保存的值的编码，它的值可能是以下常量的其中一个（定义位于<code>redis.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0        <span class="comment">// 编码为字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1        <span class="comment">// 编码为整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2         <span class="comment">// 编码为哈希表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3     <span class="comment">// 编码为 zipmap</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">// 编码为双端链表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5    <span class="comment">// 编码为压缩列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6     <span class="comment">// 编码为整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7   <span class="comment">// 编码为跳跃表</span></span></span><br></pre></td></tr></table></figure>

<p><code>ptr</code>是一个指针，指向实际保存值的数据结构，这个数据结构由<code>type</code>属性和 <code>encoding</code>属性决定。例如，如果一个<code>redisObject</code>的<code>type</code>属性为<code>REDIS_LIST</code>， <code>encoding</code>属性为<code>REDIS_ENCODING_LINKEDLIST</code>，那么这个对象就是一个<code>Redis</code>列表，它的值保存在一个双端链表内，而<code>ptr</code>指针就指向这个双端链表；如果一个 <code>redisObject</code>的<code>type</code>属性为<code>REDIS_HASH</code>，<code>encoding</code>属性为 <code>REDIS_ENCODING_ZIPMAP</code>，那么这个对象就是一个<code>Redis</code>哈希表，它的值保存在一个<code>zipmap</code>里，而<code>ptr</code>指针就指向这个<code>zipmap</code>，诸如此类。</p>
<p>下图展示了<code>redisObject</code>、<code>Redis</code>所有数据类型、以及<code>Redis</code>所有编码方式（底层实现）三者之间的关系：(<code>REDIS_ENCODING_ZIPMAP</code>没有出现在图中，因为从 <code>Redis 2.6</code>开始，它不再是任何数据类型的底层结构。)</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712144419.png" style="zoom: 70%;" />

<h4 id="2、命令的类型检查和多态"><a href="#2、命令的类型检查和多态" class="headerlink" title="2、命令的类型检查和多态"></a>2、命令的类型检查和多态</h4><p>对键<code>key</code>执行<code>LPOP</code>命令的完整过程：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712144643.png" style="zoom:70%;" />

<h4 id="3、对象共享"><a href="#3、对象共享" class="headerlink" title="3、对象共享"></a>3、对象共享</h4><p>有一些对象在<code>Redis</code>中非常常见，比如命令的返回值<code>OK</code>、<code>ERROR</code>、<code>WRONGTYPE</code> 等字符，另外， 一些小范围的整数，比如个位、十位、百位的整数都非常常见。为了利用这种常见情况，<code>Redis</code>在内部使用了一个<code>Flyweight</code>模式 ：通过预分配一些常见的值对象，并在多个数据结构之间共享这些对象，程序避免了重复分配的麻烦，也节约了一些 CPU 时间。 </p>
<p><code>Redis</code>预分配的值对象有如下这些：</p>
<ul>
<li>各种命令的返回值，比如执行成功时返回的<code>OK</code>，执行错误时返回的<code>ERROR</code>，类型错误时返回的<code>WRONGTYPE</code>，命令入队事务时返回的<code>QUEUED</code>等。 </li>
<li>包括0在内，小于<code>redis.h/REDIS_SHARED_INTEGERS</code>的所有整数 （<code>REDIS_SHARED_INTEGERS</code>的默认值为 10000）</li>
</ul>
<p>共享对象只能被字典和双端链表这类能<strong>带有指针</strong>的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构，就不能使用共享对象。</p>
<h4 id="4、-引用计数以及对象的销毁"><a href="#4、-引用计数以及对象的销毁" class="headerlink" title="4、 引用计数以及对象的销毁"></a>4、 引用计数以及对象的销毁</h4><p><code>Redis</code>的对象系统使用了引用计数技术来负责维持和销毁对象，它的运作机制：</p>
<ul>
<li>每个<code>redisObject</code>结构都带有一个<code>refcount</code>属性，指示这个对象被引用了多少次。 </li>
<li>当新创建一个对象时，它的<code>refcount</code>属性被设置为 1 。</li>
<li>当对一个对象进行共享时，<code>Redis</code>将这个对象的<code>refcount</code>增一。 </li>
<li>当使用完一个对象之后，或者取消对共享对象的引用之后，程序将对象的 <code>refcount</code>减 一。</li>
<li>当对象的<code>refcount</code>降至 0 时，这个<code>redisObject</code>结构，以及它所引用的数据结构的内存，都会被释放。</li>
</ul>
<h4 id="5、五大数据类型——字符串"><a href="#5、五大数据类型——字符串" class="headerlink" title="5、五大数据类型——字符串"></a>5、五大数据类型——字符串</h4><p>字符串类型分别使用<code>REDIS_ENCODING_INT</code>和<code>REDIS_ENCODING_RAW</code>两种编码： </p>
<ul>
<li><code>REDIS_ENCODING_INT</code>使用<code>long</code>类型来保存<code>long</code>类型值。</li>
<li><code>REDIS_ENCODING_RAW</code>则使用<code>sdshdr</code>结构来保存<code>sds（也即是 char* )</code>、<code>long long</code>、<code>double</code>和<code>long double</code>类型值。 换句话来说，在<code>Redis</code>中，只有能表示为<code>long</code>类型的值，才会以整数的形式保存，其他类型的整数、小数和字符串，都是用<code>sdshdr</code>结构来保存。</li>
</ul>
<p>新创建的字符串默认使用<code>REDIS_ENCODING_RAW</code>编码，在将字符串作为键或者值保存进数据库时，程序会尝试将字符串转为<code>REDIS_ENCODING_INT</code>编码。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712145626.png" style="zoom:70%;" />

<h4 id="6、五大数据类型——哈希表"><a href="#6、五大数据类型——哈希表" class="headerlink" title="6、五大数据类型——哈希表"></a>6、五大数据类型——哈希表</h4><p><code>REDIS_HASH</code>（哈 希 表）是<code>HSET</code>、<code>HLEN</code>等命令的操作对象，它使用 <code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_HT</code>两种编码方式：</p>
<ul>
<li><p>字典编码的哈希表：将哈希表的键保存为字典的键，将哈希表的值保存为字典的值。 哈希表所使用的字典的键和值都是字符串对象。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712145920.png" style="zoom:70%;" /></li>
<li><p>压缩列表编码的哈希表：程序通过将键和值一同推入压缩列表，从而形成保存哈希表所需的键-值对结构，新添加的<code>key-value</code>对会被添加到压缩列表的表尾。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/efvfv.png" style="zoom:70%;" /></li>
</ul>
<p>创建空白哈希表时，程序默认使用<code>REDIS_ENCODING_ZIPLIST</code>编码。</p>
<p>当以下任何一个条件被满足时，程序将编码从切换为<code>REDIS_ENCODING_HT</code>：哈希表中某个键或某个值的长度大于<code>server.hash_max_ziplist_value</code>（默认值为 64 ）；压缩列表中的节点数量大于<code>server.hash_max_ziplist_entries</code>（默认值为 512 ）。</p>
<h4 id="7、五大数据类型——列表"><a href="#7、五大数据类型——列表" class="headerlink" title="7、五大数据类型——列表"></a>7、五大数据类型——列表</h4><p><code>REDIS_LIST</code>是<code>LPUSH</code>、<code>LRANGE</code>等命令的操作对象，它使用 <code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_LINKEDLIST</code>这两种方式编码：</p>
<ul>
<li>创建新列表时<code>Redis</code>默认使用<code>REDIS_ENCODING_ZIPLIST</code>编码。</li>
<li>当以下任意一个条件被满足时，列表会被转换成<code>REDIS_ENCODING_LINKEDLIST</code>编码：试图往列表新添加一个字符串值，且这个字符串的长度超过<code>server.list_max_ziplist_value</code>（默认值为 64 ）。<code>ziplist</code>包含的节点超过<code>server.list_max_ziplist_entries</code>（默认值为 512 ）。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712150539.png" style="zoom:70%;" />

<p><strong>阻塞的条件：</strong></p>
<p><code>BLPOP</code>、<code>BRPOP</code>和<code>BRPOPLPUSH</code>三个命令都可能造成客户端被阻塞，以下将这些命令统称为列表的阻塞原语。 阻塞原语并不是一定会造成客户端阻塞：只有当这些命令被用于空列表时，它们才会阻塞客户端。如果被处理的列表不为空的话，它们就执行无阻塞版本的<code>LPOP</code>、<code>RPOP</code>或<code>RPOPLPUSH</code>命令。</p>
<p><strong>脱离阻塞：</strong></p>
<p>当客户端被阻塞之后，脱离阻塞状态有以下三种方法：</p>
<ul>
<li>被动脱离：有其他客户端为造成阻塞的键推入了新元素。<code>LPUSH</code>、<code>RPUSH</code>和 <code>LINSERT</code>这三个添加新元素到列表的命令， 在底层都由一个 <code>pushGenericCommand</code>的函数实现，</li>
<li>主动脱离：到达执行阻塞原语时设定的最大阻塞时间。</li>
<li>强制脱离：客户端强制终止和服务器的连接，或者服务器停机。</li>
</ul>
<h4 id="8、五大数据类型——集合"><a href="#8、五大数据类型——集合" class="headerlink" title="8、五大数据类型——集合"></a>8、五大数据类型——集合</h4><p><code>REDIS_SET</code>（集 合）是<code>SADD</code>、<code>SRANDMEMBER</code>等命令的操作对象，它使用<code>REDIS_ENCODING_INTSET</code>和<code>REDIS_ENCODING_HT</code>两种方式编码：</p>
<ul>
<li>第一个添加到集合的元素，决定了创建集合时所使用的编码：<ul>
<li>如果第一个元素可以表示为<code>long long</code>类型值（也即是，它是一个整数），那么集合的初始编码为<code>REDIS_ENCODING_INTSET</code>。</li>
<li>否则，集合的初始编码为<code>REDIS_ENCODING_HT</code>。</li>
</ul>
</li>
<li>如果一个集合使用<code>REDIS_ENCODING_INTSET</code>编码，那么当以下任何一个条件被满足时，这个集合会被转换成<code>REDIS_ENCODING_HT</code>编码：<ul>
<li><code>intset</code>保存的整数值个数超过<code>server.set_max_intset_entries</code>（默认值为 512 ）。</li>
<li>试图往集合里添加一个新元素，并且这个元素<strong>不能</strong>被表示为<code>long long</code>类型（也即是， 它不是一个整数）。</li>
</ul>
</li>
</ul>
<p>常用命令：</p>
<p><code>SINTER</code>和<code>SINTERSTORE</code>两个命令并交集；<code>SUNION</code>和<code>SUNIONSTORE</code> 两个命令求并集；<code>SDIFF</code>和<code>SDIFFSTORE</code>两个命令求集合差。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712151605.png" style="zoom:70%;" />

<h4 id="9、五大数据类型——有序集"><a href="#9、五大数据类型——有序集" class="headerlink" title="9、五大数据类型——有序集"></a>9、五大数据类型——有序集</h4><p><code>REDIS_ZSET</code>（有 序 集）是<code>ZADD</code>、<code>ZCOUNT</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_SKIPLIST</code>两种方式编码：</p>
<ul>
<li><p><code>ZIPLIST</code>编码的有序集：将元素保存到<code>ziplist</code>数据结构里面。其中，每个有序集元素以两个相邻的<code>ziplist</code>节点表示，第一个节点保存元素的<code>member</code>域， 第二个元素保存元素的<code>score</code>域。 多个元素之间按<code>score</code>值从小到大排序，如果两个元素的<code>score</code>相同，那么按字典序对<code>member</code>进行对比，决定那个元素排在前面，那个元素排在后面。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/E288HVL7RW3O8EL7.png" style="zoom:70%;" /></li>
<li><p><code>SKIPLIST</code>编码的有序集：元素由<code>redis.h/zset</code>结构来保存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;     <span class="comment">// 字典</span></span><br><span class="line">    zskiplist *zsl; <span class="comment">// 跳跃表</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>通过使用字典结构，并将<code>member</code>作为键，<code>score</code>作为值，有序集可以在 <code>O(1)</code>复杂度内：</p>
<ul>
<li>检查给定<code>member</code>是否存在于有序集（被很多底层函数使用）；</li>
<li>取出<code>member</code>对应的<code>score</code>值（实现<code>ZSCORE</code>命令）。</li>
</ul>
<p>通过使用跳跃表，可以让有序集支持以下两种操作：</p>
<ul>
<li>在<code>O(log N)</code>期望时间、<code>O(N)</code>最坏时间内根据<code>score</code>对<code>member</code>进行定位（被很多底层 函数使用）；</li>
<li>范围性查找和处理操作，这是（高效地）实现<code>ZRANGE</code>、<code>ZRANK</code>和 <code>ZINTERSTORE</code>等命令的关键。</li>
</ul>
</li>
<li><p>在通过<code>ZADD</code>命令添加第一个元素到空<code>key</code>时，程序通过检查输入的第一个元素来决定该创建什么编码的有序集。如果第一个元素符合以下条件的话，就创建一个<code>REDIS_ENCODING_ZIPLIST</code>编码的有序集：</p>
<ul>
<li>服务器属性<code>server.zset_max_ziplist_entries</code>的值大于 0 （默认为 128 ）。</li>
<li>元素的<code>member</code>长度小于服务器属性<code>server.zset_max_ziplist_value</code>的值（默认为 64 ）。 </li>
</ul>
</li>
<li><p>否则，程序就创建一个<code>REDIS_ENCODING_SKIPLIST</code>编码的有序集。</p>
</li>
<li><p>对于一个<code>REDIS_ENCODING_ZIPLIST</code>编码的有序集，只要满足以下任一条件，就将它转换为<code>REDIS_ENCODING_SKIPLIST</code>编码：</p>
<ul>
<li><code>ziplist</code>所保存的元素数量超过服务器属性 <code>server.zset_max_ziplist_entries</code>的值 （默认值为 128 ）</li>
<li>新添加元素的<code>member</code>的长度大于服务器属性 <code>server.zset_max_ziplist_value</code>的值 （默认值为 64 ）</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712152428.png" style="zoom:70%;" />

<h3 id="四、功能与实现"><a href="#四、功能与实现" class="headerlink" title="四、功能与实现"></a>四、功能与实现</h3><h4 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h4><ul>
<li><p>Redis事务本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务执行的过程中，会按照顺序执行。一次性、顺序性、排他性地执行一系列命令。</p>
</li>
<li><p>Redis事务没有隔离级别的概念。所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行。</p>
</li>
<li><p>Redis单条命令是保证原子性的，但是事务不保证原子性。</p>
</li>
</ul>
<p><code>Redis</code>通过<code>MULTI</code>、<code>DISCARD</code>、<code>EXEC</code>和<code>WATCH</code>四个命令来实现事务功能。事务在执行的期间不会主动中断，服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令。一个事务从开始到执行会经历以下三个阶段：开始事务、 命令入队、执行事务。</p>
<h5 id="（1）开始事务"><a href="#（1）开始事务" class="headerlink" title="（1）开始事务"></a>（1）开始事务</h5><p>以<code>MULTI</code>开始一个事务，这个命令唯一做的就是，将客户端的<code>REDIS_MULTI</code>选项打开，让客户端从非事务状态切换到事务状态。</p>
<h5 id="（2）命令入队"><a href="#（2）命令入队" class="headerlink" title="（2）命令入队"></a>（2）命令入队</h5><p>当客户端处于非事务状态下时，所有发送给服务器端的命令都会立即被服务器执行。但是，当客户端进入事务状态之后，服务器在收到来自客户端的命令时，不会立即执行命令， 而是将这些命令全部放进一个事务队列里，然后返回<code>QUEUED</code>，表示命令已入队。事务队列是一个数组，每个数组项是都包含三个属性：要执行的命令、命令的参数、参数的个数。</p>
<h5 id="（3）执行事务"><a href="#（3）执行事务" class="headerlink" title="（3）执行事务"></a>（3）执行事务</h5><p>并不是所有的命令都会被放进事务队列，其中的例外就是<code>EXEC</code>、<code>DISCARD</code>、<code>MULTI</code>和<code>WATCH</code>这四个命令。当这四个命令从客户端发送到服务器时，它们会像客户端处于非事务状态一样，直接被服务器执行。</p>
<p>如果客户端正处于事务状态，那么当<code>EXEC</code>命令执行时，服务器根据客户端所保存的事务队列，以先进先出（FIFO）的方式执行事务队列中的命令：最先入队的命令最先执行，而最后入队的命令最后执行。执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<h5 id="（4）事务状态下的-DISCARD-、MULTI-和-WATCH-命令"><a href="#（4）事务状态下的-DISCARD-、MULTI-和-WATCH-命令" class="headerlink" title="（4）事务状态下的 DISCARD 、MULTI 和 WATCH 命令"></a>（4）事务状态下的 DISCARD 、MULTI 和 WATCH 命令</h5><p><code>DISCARD</code>命令用于取消一个事务，它清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回字符串<code>OK</code>给客户端，说明事务已被取消。 </p>
<p><code>Redis</code>的事务是不可嵌套的，当客户端已经处于事务状态，而客户端又再向服务器发送<code>MULTI</code>时，服务器只是简单地向客户端发送一个错误，然后继续等待其他命令的入队。<code>MULTI</code>命令的发送不会造成整个事务失败，也不会修改事务队列中已有的数据。</p>
<ul>
<li><p><strong>WATCH命令</strong></p>
<ul>
<li><p><code>WATCH</code>只能在客户端进入事务状态之前执行，在事务状态下发送<code>WATCH</code>命令会引发一个错误，但它不会造成整个事务失败，也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。该命令用于在事务开始之前监视任意数量的键：当调用<code>EXEC</code>命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不再执行，直接返回失败，保证事务的安全性。</p>
</li>
<li><p><code>WATCH</code>的实现</p>
<p>在每个代表数据库的<code>redis.h/redisDb</code>结构类型中，都保存了一个 <code>watched_keys</code>字典，字典 的键是这个数据库被监视的键，而字典的值则是一个链表，链表中保存了所有监视这个键的客户端。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712155321.png" style="zoom:70%;" />

<p>通过<code>watched_keys</code>字典，如果程序想检查某个键是否被监视，那么它只要检查字典中是否存在这个键即可；如果程序要获取监视某个键的所有客户端，那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p>
</li>
<li><p> <code>WATCH</code>的触发</p>
</li>
</ul>
<p>  在任何对数据库键空间进行修改的命令成功执行之后（比如<code>FLUSHDB 、SET 、DEL 、LPUSH 、SADD 、ZREM</code>等），<code>multi.c/touchWatchKey</code>函数都会被调用 ——它检查数据库的<code>watched_keys</code>字典，看是否有客户端在监视已经被命令修改的键，如果有的话，程序将所有监视这个/这些被修改键的客户端的<code>REDIS_DIRTY_CAS</code>选项打开。</p>
<p>  当客户端发送<code>EXEC</code>命令、触发事务执行时，服务器会对客户端的状态进行检查：</p>
<ul>
<li><p>如果客户端的<code>REDIS_DIRTY_CAS</code>选项已经被打开，那么说明被客户端监视的键至少有一 个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</p>
</li>
<li><p>如果<code>REDIS_DIRTY_CAS</code>选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712155959.png" style="zoom:70%;" /></li>
</ul>
</li>
</ul>
<h5 id="（5）事务的-ACID-性质"><a href="#（5）事务的-ACID-性质" class="headerlink" title="（5）事务的 ACID 性质"></a>（5）事务的 ACID 性质</h5><p><code>Redis</code>的事务保证了<code>ACID</code>中的一致性和隔离性，但并不保证原子性和持久性。</p>
<ul>
<li><p>原子性</p>
<p>单个<code>Redis</code>命令的执行是原子性的，但<code>Redis</code>没有在事务上增加任何维持原子性的机制，所以<code>Redis</code>事务的执行并不是原子性的。当事务失败时，<code>Redis</code>也不会进行任何的重试或者回滚动作。</p>
</li>
<li><p>一致性</p>
<p>分为三部分来讨论：入队错误、执行错误、<code>Redis</code>进程被终结。</p>
<ul>
<li>入队错误：在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对等，那么服务器将向客户端返回一个出错信息，并且将客户端的事务状态设为<code>REDIS_DIRTY_EXEC</code>。 当客户端执行<code>EXEC</code>命令时，<code>Redis</code>会拒绝执行状态为<code>REDIS_DIRTY_EXEC</code>的事务，并返回失败信息。因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</li>
<li>执行错误：如果命令在事务执行的过程中发生错误，那么<code>Redis</code>只会将错误包含在事务的结果中，这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令，所以它对事务的一致性也没有影响。</li>
<li><code>Redis</code>进程被终结，根据<code>Redis</code>所使用的持久化模式，可能有以下情况出现：<ul>
<li>内存模式：如果<code>Redis</code>没有采取任何持久化机制，那么重启之后的数据库总是空白的，所 以数据总是一致的。</li>
<li><code>RDB</code>模式：在执行事务时，<code>Redis</code>不会中断事务去执行保存<code>RDB</code>的工作，只有在事务执行之后，保存<code>RDB</code>的工作才有可能开始。所以当 <code>RDB</code>模式下的<code>Redis</code>服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都<strong>不会</strong>被保存到<code>RDB</code>文件里。 恢复数据库需要使用现有的<code>RDB</code>文件，而这个<code>RDB</code>文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要<code>RDB</code>文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</li>
<li><code>AOF</code>模式：因为保存<code>AOF</code>文件的工作在后台线程进行，所以即使是在事务执行的中途， 保存<code>AOF</code>文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到<code>AOF</code>文件，有以下两种情况发生：<ul>
<li>如果事务语句未写入到<code>AOF</code>文件，或<code>AOF</code>未被<code>SYNC</code>调用保存到磁盘，那么当进程被杀死之后，<code>Redis</code>可以根据最近一次成功保存到磁盘的<code>AOF</code>文件来还原数据库，只要<code>AOF</code>文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</li>
<li>如果事务的部分语句被写入到<code>AOF</code>文件，并且<code>AOF</code>文件被成功保存，那么不完整的事务执行信息就会遗留在<code>AOF</code>文件里，当重启 <code>Redis</code>时，程序会检测到<code>AOF</code>文件并不完整，<code>Redis</code>会退出，并报告错误。需要使用<code>redis-check-aof</code>工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>隔离性</p>
<p><code>Redis</code>是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<code>Redis</code>的事务是总是带有隔离性的。</p>
</li>
<li><p>持久性</p>
<p>事 务的持久性由<code>Redis</code>所使用的持久化模式决定：</p>
<ul>
<li>在单纯的内存模式下，事务肯定是不持久的。</li>
<li>在<code>RDB</code>模式下，服务器可能在事务执行之后、<code>RDB</code>文件更新之前的这段时间失败，所以<code>RDB</code>模式下的<code>Redis</code>事务也是不持久的。 </li>
<li>在<code>AOF</code>的“总是<code>SYNC</code>”模式下，事务的每条命令在执行成功之后，都会立即调用<code>fsync</code>或<code>fdatasync</code>将事务数据写入到<code>AOF</code>文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。 其他<code>AOF</code>模式也和“总是<code>SYNC</code>”模式类似，所以它们都是不持久的。</li>
</ul>
</li>
</ul>
<h5 id="（7）示例"><a href="#（7）示例" class="headerlink" title="（7）示例"></a>（7）示例</h5><ul>
<li>开启和执行事务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multi    <span class="comment"># 开启事务，之后的操作均是在事务中进行操作</span></span><br><span class="line"><span class="built_in">exec</span>     <span class="comment"># 执行事务，按顺序执行事务中的命令，执行完成之后这个事务就不存在了，如果需要则重新开启事务</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220412204601.png" style="zoom:67%;" />

<ul>
<li>放弃事务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard    <span class="comment"># 取消事务，事务队列中的命令都不会执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>编译型异常（代码有问题，命令有错），事务中的所有命令都不会执行。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220412205535.png" style="zoom:67%;" />

<ul>
<li>运行时异常，如果事务队列中存在语法错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令会抛出异常。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220412212150.png" style="zoom:67%;" />

<ul>
<li><p>乐观锁：认为很么时候都不会出问题，所以不会上锁。更新数据的时候取判断一下，在此期间是否有人修改过这个数据；Redis能用<code>watch</code>实现乐观锁。</p>
<p>悲观锁：认为什么时候都会出现问题，无论做什么都会加锁；</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money   <span class="comment"># 监视money对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi  <span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功。</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure>

<p>测试多线程修改值后，使用watch可以当做redis的乐观锁操作：</p>
<p>线程1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>线程2，在线程1执行之前，修改了值，就会导致后续线程1执行事务失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>此时执行线程1的事务，则事务执行失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>如果发现事务执行失败则先用<code>unwatch</code>解锁，然后再加锁获取最新的值进行再次监视，比对监视的值是否发生变化，如果没有变化则执行成功，如果值发生变化则执行失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>     <span class="comment"># 事务执行失败</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; unwatch      <span class="comment"># 解锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money  <span class="comment"># 加锁，来获取最新的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby money 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>     <span class="comment"># 在此期间值未发生变化，则事务能执行成功</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 999</span><br><span class="line">2) (<span class="built_in">integer</span>) 1000</span><br></pre></td></tr></table></figure>

<h4 id="2、订阅与发布"><a href="#2、订阅与发布" class="headerlink" title="2、订阅与发布"></a>2、订阅与发布</h4><p><code>Redis</code>通过<code>PUBLISH</code>、<code>SUBSCRIBE</code>等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是<strong>订阅/发布到频道</strong>和<strong>订阅/发布到模式</strong>。</p>
<h5 id="2-1-订阅-发布到频道："><a href="#2-1-订阅-发布到频道：" class="headerlink" title="2.1 订阅/发布到频道："></a>2.1 订阅/发布到频道：</h5><h6 id="（1）频道的订阅与信息发送"><a href="#（1）频道的订阅与信息发送" class="headerlink" title="（1）频道的订阅与信息发送"></a>（1）频道的订阅与信息发送</h6><p><code>Redis</code>的<code>SUBSCRIBE</code>命令可以让客户端订阅任意数量的频道，每当有新信息发送到被订阅的频道时，信息就会被发送给所有订阅指定频道的客户端。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712163149.png" style="zoom:70%;" />

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712163243.png" style="zoom:50%;" />

<h6 id="（2）订阅频道-SUBSCRIBE"><a href="#（2）订阅频道-SUBSCRIBE" class="headerlink" title="（2）订阅频道 SUBSCRIBE"></a>（2）订阅频道 SUBSCRIBE</h6><p>每个<code>Redis</code>服务器进程都维持着一个表示服务器状态的<code>redis.h/redisServer</code>结构，结构的<code>pubsub_channels</code>属性是一个字典，这个字典就用于保存订阅频道的信息，其中字典的键为正在被订阅的频道，而字典的值则是一个链表，链表中保存了所有订阅这个频道的客户端。<code>SUBSCRIBE</code>命令的关键就是将客户端添加到给定频道的订阅链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *pubsub_channels;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712163444.png" style="zoom:70%;" />

<p>通过<code>pubsub_channels</code>字典，程序只要检查某个频道是否字典的键，就可以知道该频道是否正在被客户端订阅；只要取出某个键的值，就可以得到所有订阅该频道的客户端的信息。</p>
<h6 id="（3）发送信息到频道-PUBLISH"><a href="#（3）发送信息到频道-PUBLISH" class="headerlink" title="（3）发送信息到频道 PUBLISH"></a>（3）发送信息到频道 PUBLISH</h6><p>当调用<code>PUBLISH channel message</code>命令，程序首先根据<code>channel</code>定位到字典的键，在它所维护的频道字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将信息发送给所有客户端。</p>
<h6 id="（4）-退订频道-UNSUBSCRIBE"><a href="#（4）-退订频道-UNSUBSCRIBE" class="headerlink" title="（4） 退订频道 UNSUBSCRIBE"></a>（4） 退订频道 UNSUBSCRIBE</h6><p>它从<code>pubsub_channels</code>字典的给定频道（键）中，删除关于当前客户端的信息，这样被退订频道的信息就不会再发送给这个客户端。</p>
<h6 id="（5）测试"><a href="#（5）测试" class="headerlink" title="（5）测试"></a>（5）测试</h6><p>订阅端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe kuangshenshuo   <span class="comment"># 订阅一个频道kuangshenshuo</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;kuangshenshuo&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待读取推送的信息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span>          <span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">&quot;kuangshenshuo&quot;</span>    <span class="comment"># 哪个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;helloworld&quot;</span>       <span class="comment"># 消息的内容</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;kuangshenshuo&quot;</span></span><br><span class="line">3) <span class="string">&quot;helloredis&quot;</span></span><br></pre></td></tr></table></figure>

<p>发动端：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布者发布消息到频道</span></span><br><span class="line">127.0.0.1:6379&gt; publish kuangshenshuo helloworld </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; publish kuangshenshuo helloredis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>使用场景：实时消息系统、实时聊天（把频道当做聊天室，将信息回显给所有人），稍微复杂的场景推荐使用消息中间件。</p>
<h5 id="2-2-订阅-发布到模式："><a href="#2-2-订阅-发布到模式：" class="headerlink" title="2.2 订阅/发布到模式："></a>2.2 订阅/发布到模式：</h5><h6 id="（1）-模式的订阅与信息发送"><a href="#（1）-模式的订阅与信息发送" class="headerlink" title="（1） 模式的订阅与信息发送"></a>（1） 模式的订阅与信息发送</h6><p>当使用<code>PUBLISH</code>命令发送信息到某个频道时，不仅所有订阅该频道的客户端会收到信息，如果有某个/某些模式和这个频道匹配的话，那么所有订阅这个/这些频道的客户端也同样会收到信息。</p>
<p>例如：当有信息发送到<code>tweet.shop.kindle</code>频道时，信息除了发送给<code>clientX</code>和 <code>clientY</code>之外，还会发送给订阅<code>tweet.shop.*</code>模式的<code>client123</code>和<code>client256</code>。 </p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712164156.png" style="zoom:70%;" />

<h6 id="（2）订阅模式"><a href="#（2）订阅模式" class="headerlink" title="（2）订阅模式"></a>（2）订阅模式</h6><p><code>redisServer.pubsub_patterns</code>属性是一个链表，链表中保存着所有和模式相关的信息，链表中的每个节点都包含一个<code>redis.h/pubsubPattern</code>结构：：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    redisClient *client;  <span class="comment">// client 属性保存着订阅模式的客户端</span></span><br><span class="line">    robj *pattern;   <span class="comment">// pattern 属性则保存着被订阅的模式。</span></span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>

<p>每当调用<code>PSUBSCRIBE</code>命令订阅一个模式时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code>链表中。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712165227.png" style="zoom:70%;" />

<h6 id="（3）发送信息到模式"><a href="#（3）发送信息到模式" class="headerlink" title="（3）发送信息到模式"></a>（3）发送信息到模式</h6><p>发送信息到模式的工作也是由<code>PUBLISH</code>命令进行的，除了将<code>message</code>发送到所有订阅<code>channel</code>的客户端之外，它还会将<code>channel</code>和<code>pubsub_patterns</code>中的模式进行对比，如果<code>channel</code>和某个模式匹配的话，那么也将<code>message</code>发送到订阅那个模式的客户端。</p>
<h6 id="（4）退订模式"><a href="#（4）退订模式" class="headerlink" title="（4）退订模式"></a>（4）退订模式</h6><p>使用<code>PUNSUBSCRIBE</code>命令可以退订指定的模式，这个命令执行的是订阅模式的反操作：程序会删除<code>redisServer.pubsub_patterns</code>链表中，所有和被退订模式相关联的<code>pubsubPattern</code>结构，这样客户端就不会再收到和模式相匹配的频道发来的信息。</p>
<h4 id="3、Lua脚本"><a href="#3、Lua脚本" class="headerlink" title="3、Lua脚本"></a>3、Lua脚本</h4><p>使用<code>EVAL</code>和<code>EVALSHA</code>执行<code>Lua</code>脚本。如果一个脚本的执行对任何副作用产生了依赖，那么这个脚本每次执行所产生的结果都可能会不一样。因此，<code>Redis</code>对<code>Lua</code>环境所能执行的脚本做了一个严格的限制：所有脚本都必须是无副作用的纯函数。</p>
<p><code>EVAL</code>直接对输入的脚本代码体进行求值；</p>
<p><code>EVALSHA</code>则要求输入某个脚本的<code>SHA1</code>校验和，这个校验和所对应的脚本必须至少被<code>EVAL</code>执行过一次，或者曾经使用<code>SCRIPT LOAD</code>载入过这个脚本。</p>
<h4 id="4、-慢查询日志"><a href="#4、-慢查询日志" class="headerlink" title="4、 慢查询日志"></a>4、 慢查询日志</h4><p><code>Redis</code>用一个链表以<code>FIFO</code>的顺序保存着所有慢查询日志。</p>
<h5 id="（1）相关数据结构"><a href="#（1）相关数据结构" class="headerlink" title="（1）相关数据结构"></a>（1）相关数据结构</h5><p>每条慢查询日志都以一个<code>slowlog.h/slowlogEntry</code>结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span>    </span><br><span class="line">    robj **argv;  <span class="comment">// 命令参数    </span></span><br><span class="line">    <span class="keyword">int</span> argc;     <span class="comment">// 命令参数数量 </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="comment">// 执行命令消耗的时间，以纳秒（1 / 1,000,000,000 秒）为单位</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;    </span><br><span class="line">    <span class="keyword">time_t</span> time;  <span class="comment">// 命令执行时的时间</span></span><br><span class="line">&#125; slowlogEntry;</span><br></pre></td></tr></table></figure>

<p>记录服务器状态的<code>redis.h/redisServer</code>结构里保存了几个和慢查询有关的属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span>   </span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog; <span class="comment">// 保存慢查询日志的链表    </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id; <span class="comment">// 慢查询日志的当前 id 值    </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than; <span class="comment">// 慢查询时间限制   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len; <span class="comment">// 慢查询日志的最大条目数量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>slowlog</code>属性是一个链表，链表里的每个节点保存了一个慢查询日志结构，所有日志按添加时间从新到旧排序，新的日志在链表的左端，旧的日志在链表的右端。</p>
<p> <code>slowlog_entry_id</code>在创建每条新的慢查询日志时增一，用于产生慢查询日志的<code>ID</code>（这个 ID 在执行<code>SLOWLOG RESET</code>之后会被重置）。 </p>
<p><code>slowlog_log_slower_than</code>是用户指定的命令执行时间上限，执行时间大于等于这个值的命令会被慢查询日志记录。 在每次执行命令之前，<code>Redis</code>都会用一个参数记录命令执行前的时间，在命令执行完之后，再计算一次当前时间，然后将两个时间值相减，得出执行命令所耗费的时间值<code>duration</code>，并将<code>duration</code>传给 <code>slowlogPushEntryIfNeed</code>函数。 如果<code>duration</code>超过服务器设置的执行时间上限<code>server.slowlog_log_slower_than</code>的话，<code>slowlogPushEntryIfNeed</code>就会创建一条新的慢查询日志，并将它加入到慢查询日志链表里。</p>
<p><code>slowlog_max_len</code>慢查询日志的最大数量，当日志数量等于这个值时，添加一条新日志会造成最旧的一条日志被删除。</p>
<h3 id="五、内部运作机制"><a href="#五、内部运作机制" class="headerlink" title="五、内部运作机制"></a>五、内部运作机制</h3><h4 id="1、数据库"><a href="#1、数据库" class="headerlink" title="1、数据库"></a>1、数据库</h4><h5 id="（1）数据库的结构"><a href="#（1）数据库的结构" class="headerlink" title="（1）数据库的结构"></a>（1）数据库的结构</h5><p><code>Redis</code>中的每个数据库，都由一个<code>redis.h/redisDb</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> id;        <span class="comment">// 保存着数据库以整数表示的号码    </span></span><br><span class="line">    dict *dict;    <span class="comment">// 保存着数据库中的所有键值对数据，这个属性也被称为键空间（key space）    </span></span><br><span class="line">    dict *expires; <span class="comment">// 保存着键的过期信息    </span></span><br><span class="line">    dict *blocking_keys;  <span class="comment">// 实现列表阻塞原语，如 BLPOP</span></span><br><span class="line">    dict *ready_keys;    </span><br><span class="line">    dict *watched_keys;   <span class="comment">// 用于实现 WATCH 命令</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><code>redisDb</code>结构的<code>id</code>域保存着数据库的号码。当<code>Redis</code>服务器初始化时， 它会创建出<code>redis.h/REDIS_DEFAULT_DBNUM</code>个数据库， 并 将所有数据库保存到 <code>redis.h/redisServer.db</code>数组中， 每个数据库的<code>id</code>为从 0 到 <code>REDIS_DEFAULT_DBNUM - 1</code>的值。当执行<code>SELECT number</code>命令时，程序直接使用<code>redisServer.db[number]</code>来切换数据库。</p>
<h5 id="（2）数据库键空间"><a href="#（2）数据库键空间" class="headerlink" title="（2）数据库键空间"></a>（2）数据库键空间</h5><p>因为<code>Redis</code>是一个键值对数据库，所以它的数据库本身也是一个字典。字典的键是一个字符串对象。字典的值则可以是包括字符串、列表、哈希表、集合或有序集在内的任意一种<code>Redis</code>类型 对象。在<code>redisDb</code>结构的<code>dict</code>属性中，保存着数据库的所有键值对数据。</p>
<h5 id="（3）数据库键空间的操作"><a href="#（3）数据库键空间的操作" class="headerlink" title="（3）数据库键空间的操作"></a>（3）数据库键空间的操作</h5><p>添加一个新键对到数据库，实际上就是将一个新的键值对添加到键空间字典中，其中键为字符串对象，而值则是任意一种<code>Redis</code>类型值对象。</p>
<p>例如在客户端执行<code>SET date 2013.2.1</code>命令之后，数据库则更新为：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712182313.png" style="zoom:70%;" />

<p>删除数据库中的一个键，实际上就是删除字典空间中对应的键对象和值对象。例如在客户端执行<code>DEL message</code>命令之后，数据库更新为下图状态：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712182457.png" style="zoom:70%;" />

<p>当对一个已存在于数据库的键执行更新操作时，数据库释放键原来的值对象，然后将指针指向新的值对象。</p>
<p>在客户端执行<code>SET message &quot;blah blah&quot;</code>命令之后，数据库更新为下图状态：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712182642.png" style="zoom:70%;" />

<p>其他操作：</p>
<ul>
<li><code>FLUSHDB</code>命令：删除键空间中的所有键值对。</li>
<li><code>RANDOMKEY</code>命令：从键空间中随机返回一个键。</li>
<li><code>DBSIZE</code>命令：返回键空间中键值对的数量。</li>
<li><code>EXISTS</code>命令：检查给定键是否存在于键空间中。</li>
<li><code>RENAME</code>命令：在键空间中，对给定键进行改名。</li>
</ul>
<h5 id="（4）键的过期时间和生存时间"><a href="#（4）键的过期时间和生存时间" class="headerlink" title="（4）键的过期时间和生存时间"></a>（4）键的过期时间和生存时间</h5><p>通过<code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>和<code>PEXPIREAT</code>四个命令，客户端可以给某个存在的键设置过期时间，当键的过期时间到达时，键就不再可用。虽然有那么多种不同单位和不同形式的设置方式，但是<code>expires</code>字典的值只保存“以毫秒为单位的过期 <code>UNIX</code>时间戳” ，这就是说，通过进行转换，所有命令的效果最后都和<code>PEXPIREAT</code>命令的效果一样。</p>
<ul>
<li><code>EXPIRE</code>以秒为单位设置键的生存时间；</li>
<li><code>PEXPIRE</code>以毫秒为单位设置键的生存时间；</li>
<li><code>EXPIREAT</code>以秒为单位，设置键的过期<code>UNIX</code>时间戳；</li>
<li><code>PEXPIREAT</code>以毫秒为单位，设置键的过期<code>UNIX</code>时间戳。</li>
</ul>
<p>命令<code>TTL</code>和<code>PTTL</code>则用于返回给定键距离过期还有多长时间；</p>
<h5 id="（5）过期时间的保存"><a href="#（5）过期时间的保存" class="headerlink" title="（5）过期时间的保存"></a>（5）过期时间的保存</h5><p>在数据库中，所有键的过期时间都被保存在<code>redisDb</code>结构的<code>expires</code>字典里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><code>expires</code>字典的键是一个指向<code>dict</code>字典（键空间）里某个键的指针，而字典的值则是键所指向的数据库键的到期时间，这个值以<code>long long</code>类型表示。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712183229.png" style="zoom:70%;" />

<h5 id="（6）过期键的判定"><a href="#（6）过期键的判定" class="headerlink" title="（6）过期键的判定"></a>（6）过期键的判定</h5><p>通过<code>expires</code>字典，可以用以下步骤检查某个键是否过期：</p>
<ul>
<li>检查键是否存在于<code>expires</code>字典：如果存在，那么取出键的过期时间；</li>
<li>检查当前<code>UNIX</code>时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则， 键未过期。</li>
</ul>
<h5 id="（7）过期键的清除"><a href="#（7）过期键的清除" class="headerlink" title="（7）过期键的清除"></a>（7）过期键的清除</h5><ul>
<li><p>定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理 器自动执行键的删除操作。</p>
<p>定时删除策略对内存是最友好的，因为它保证过期键会在第一时间被删除，过期键所消耗的内 存会立即被释放。但它对 CPU 时间是最不友好的，因为删除操作可能会占用大量的 CPU 时间 ，在内存不紧张、但是 CPU 时间非常紧张的时候（比如说，进行交集计算或排序的时候）， 将 CPU 时间花在删除那些和当前任务无关的过期键上，这种做法毫无疑问会是低效的。</p>
</li>
<li><p>惰性删除：放任键过期不管，但是在每次从<code>dict</code>字典中取出键值时，要检查键是否过 期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值。</p>
<p>惰性删除对 CPU 时间来说是最友好的：它只会在取出键时进行检查，这可以保证删除操作只 会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。 惰性删除的缺点是，它对内存是最不友好的。</p>
</li>
<li><p>定期删除：每隔一段时间，对<code>expires</code>字典进行检查，删除里面的过期键。定期删除是上述两种策略的一种折中，它每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，籍此来减少删除操作对 CPU 时间的影响。另一方面，通过定期删除过期键，它有效地减少了因惰性删除而带来的内存浪费。</p>
</li>
</ul>
<p><code>Redis</code>使用惰性删除和定期删除两种策略来删除过期的键。</p>
<h4 id="2、持久化之RDB"><a href="#2、持久化之RDB" class="headerlink" title="2、持久化之RDB"></a>2、持久化之RDB</h4><p>在运行情况下，<code>Redis</code>以数据结构的形式将数据维持在内存中，为了让这些数据在<code>Redis</code>重启之后仍然可用，<code>Redis</code>分别提供了<code>RDB</code>和<code>AOF</code>两种持久化模式。 在 <code>Redis</code>运行时，<code>RDB</code>程序将当前内存中的<strong>数据库快照以二进制的方式</strong>保存到磁盘文件中，在<code>Redis</code>重启动时，<code>RDB</code>程序可以通过载入<code>RDB</code>文件来还原数据库的状态。在指定的时间间隔内将内存中的数据快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读入到内存中。</p>
<h5 id="（1）rdbSave-和-rdbLoad"><a href="#（1）rdbSave-和-rdbLoad" class="headerlink" title="（1）rdbSave 和 rdbLoad"></a>（1）rdbSave 和 rdbLoad</h5><p><code>RDB</code>功能最核心的是<code>rdbSave</code>和<code>rdbLoad</code>两个函数，前者用于生成<code>RDB</code>文件到磁盘，而后者则用于将<code>RDB</code>文件中的数据重新载入到内存中。</p>
<p><code>rdbSave</code>函数负责将内存中的数据库数据以<code>RDB</code>格式保存到磁盘中，如果<code>RDB</code>文件已存在， 那么新的<code>RDB</code>文件将替换已有的<code>RDB</code>文件。 在保存<code>RDB</code>文件期间，主进程会被阻塞，直到保存完成为止。<code>SAVE</code>和<code>BGSAVE</code>两个命令都会调用<code>rdbSave</code>函数，但它们调用的方式各有不同：</p>
<ul>
<li><code>SAVE</code>直接调用<code>rdbSave</code>，阻塞<code>Redis</code>主进程，直到保存完成为止。在主进程阻塞期间， 服务器不能处理客户端的任何请求。</li>
<li><code>BGSAVE</code>则<code>fork</code>出一个子进程，子进程负责调用<code>rdbSave</code>，并在保存完成之后向主进程发送信号，通知保存已完成。因为<code>rdbSave</code>在子进程被调用，所以 <code>Redis</code>服务器在<code>BGSAVE</code>执行期间仍然可以继续处理客户端的请求。</li>
</ul>
<h5 id="（2）SAVE-、BGSAVE-、AOF-写入和-BGREWRITEAOF"><a href="#（2）SAVE-、BGSAVE-、AOF-写入和-BGREWRITEAOF" class="headerlink" title="（2）SAVE 、BGSAVE 、AOF 写入和 BGREWRITEAOF"></a>（2）SAVE 、BGSAVE 、AOF 写入和 BGREWRITEAOF</h5><p>当<code>SAVE</code>执行时，<code>Redis</code>服务器是阻塞的，所以当<code>SAVE</code>正在执行时，新的<code>SAVE</code>、<code>BGSAVE</code>或<code>BGREWRITEAOF</code>调用都不会产生任何作用。</p>
<p>另外，因为<code>AOF</code>写入由后台线程完成，而<code>BGREWRITEAOF</code>则由子进程完成，所以在<code>SAVE</code>执行的过程中，<code>AOF</code>写入和<code>BGREWRITEAOF</code>可以同时进行。</p>
<p>在执行<code>SAVE</code>命令之前，服务器会检查<code>BGSAVE</code>是否正在执行当中，如果是的话，服务器就 不调用<code>rdbSave</code>，而是向客户端返回一个出错信息，告知在<code>BGSAVE</code>执行期间，不能执行<code>SAVE</code>。</p>
<p><code>BGREWRITEAOF</code>和<code>BGSAVE</code>两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑：并发出两个子进程，并且两个子进程都同时进行大量的磁盘写 入操作，这怎么想都不会是一个好主意。</p>
<h5 id="（3）RDB文件结构"><a href="#（3）RDB文件结构" class="headerlink" title="（3）RDB文件结构"></a>（3）RDB文件结构</h5><p>一个<code>RDB</code>文件可以分为以下几个部分：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712205121.png" style="zoom:70%;" />

<p><code>REDIS</code>：文件的最开头保存着<code>REDIS</code>五个字符，标识着一个<code>RDB</code>文件的开始。</p>
<p><code>RDB-VERSION</code>：一个四字节长的以字符表示的整数，记录了该文件所使用的<code>RDB</code>版本号。</p>
<p><code>DB-DATA</code>：这个部分在一个<code>RDB</code>文件中会出现任意多次，每个<code>DB-DATA</code>部分保存着服务器上一个非空数据库的所有数据。</p>
<p><code>SELECT-DB</code>：这域保存着跟在后面的键值对所属的数据库号码。</p>
<p><code>KEY-VALUE-PAIRS</code>：因为空的数据库不会被保存到<code>RDB</code>文件，所以这个部分至少会包含一个键值对的数据。</p>
<p><code>EOF</code>：标志着数据库内容的结尾（不是文件的结尾），值为 <code>rdb.h/EDIS_RDB_OPCODE_EOF</code>（255）。</p>
<p><code>CHECK-SUM RDB</code>：文件所有内容的校验和，一个<code>uint_64</code>类型值。</p>
<h5 id="（4）触发机制"><a href="#（4）触发机制" class="headerlink" title="（4）触发机制"></a>（4）触发机制</h5><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，呐RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。Redis默认的是RDB持久化方式。</p>
<ul>
<li>save的规则满足的情况下，会自动出发rdb规则</li>
<li>执行flushall命令，也会触发rdb规则</li>
<li>退出redis，也会产生rdb文件</li>
</ul>
<p>备份就会自动生成一个rdb文件。</p>
<p>【恢复rdb文件】：</p>
<p>只需要将rdb文件放在redis启动目录就可以，redis启动的时候会自动检查dump.rdb并恢复其中的数据。</p>
<p>适用于大规模的数据恢复，对数据的完整性要求不高。但需要一定的时间间隔进行操作，如果redis意外宕机了，最后一次修改的数据就没有了，且fork进程的时候会占用一定的内存空间。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220413221609.png" style="zoom:67%;" />

<h4 id="3、持久化之AOF"><a href="#3、持久化之AOF" class="headerlink" title="3、持久化之AOF"></a>3、持久化之AOF</h4><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF保存的文件是<code>appendonly.aof</code>。</p>
<p>只需要在配置文件中开启aof配置即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes   <span class="comment"># 改为yes即为开启aof模式</span></span><br></pre></td></tr></table></figure>

<p>aof是以日志的形式保存的，如果aof文件有错误（比如恶意破坏等），redis是启动失败的，需要通过工具<strong>redis-check-aof</strong>进行修复。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-check-aof --fix appendonly.aof </span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点：</p>
<ul>
<li>每一次修改数据都会同步，文件的完整性会更好；</li>
<li>每秒同步一次，可能会丢失一秒的数据；</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>相对于数据文件来说，aof远大于rdb，修复的速度也比rdb慢；</li>
<li>aof运行效率也要比rdb慢</li>
</ul>
</li>
</ul>
<p><code>AOF</code>则以协议文本的方式，将所有<strong>对数据库进行过写入的命令</strong>（及其参数）记录到<code>AOF</code>文件，以此达到记录数据库状态的目的。</p>
<p>同步命令到<code>AOF</code>文件的整个过程可以分为三个阶段：</p>
<ul>
<li>命令传播：<code>Redis</code>将执行完的命令、命令的参数、命令的参数个数等信息发送到<code>AOF</code>程序中。</li>
<li>缓存追加：<code>AOF</code>程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的<code>AOF</code>缓存中。</li>
<li>文件写入和保存：<code>AOF</code>缓存中的内容被写入到<code>AOF</code>文件末尾，如果设定的 <code>AOF</code>保存 条件被满足的话，<code>fsync</code>函数或者<code>fdatasync</code>函数会被调用，将写入的内容真正地保存到磁盘中。</li>
</ul>
<p><code>Redis</code>目前支持三种<code>AOF</code>保存模式：</p>
<ul>
<li><p><code>AOF_FSYNC_NO</code>：不保存。在这种模式下，每次调用<code>flushAppendOnlyFile</code>函数，<code>WRITE</code>都会被执行，但<code>SAVE</code>会被略过。在这种模式下，<code>SAVE</code>只会在以下任意一种情况中被执行：<code>Redis</code>被关闭；<code>AOF</code>功能被关闭；系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行） 这三种情况下的<code>SAVE</code>操作都会引起<code>Redis</code>主进程阻塞。</p>
</li>
<li><p><code>AOF_FSYNC_EVERYSEC</code>：每一秒钟保存一次。在这种模式中，<code>SAVE</code>原则上每隔一秒钟就会执行一次（但在实际运行中，程序在这种模式下对<code>fsync</code>或 <code>fdatasync</code>的调用并不是每秒一次，它和调用<code>flushAppendOnlyFile</code>函数时 <code>Redis</code>所处的状态有关。），因为<code>SAVE</code>操作是由后台子线程调用 的，所以它不会引起服务器主进程阻塞。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712210643.png" style="zoom:67%;" /></li>
<li><p><code>AOF_FSYNC_ALWAYS</code>：每执行一个命令保存一次。在这种模式下，每次执行完一个命令之后，<code>WRITE</code>和<code>SAVE</code>都会被执行。 另外，因为<code>SAVE</code>是由<code>Redis</code>主进程执行的，所以在<code>SAVE</code>执行期间，主进程会被阻塞，不能接受命令请求。</p>
</li>
</ul>
<h5 id="（1）AOF重写和AOF后台重写"><a href="#（1）AOF重写和AOF后台重写" class="headerlink" title="（1）AOF重写和AOF后台重写"></a>（1）AOF重写和AOF后台重写</h5><p>根据键的类型，使用适当的写入命令来重现键的当前值，这就是<code>AOF</code>重写的实现原理。例如，如果服务器对键<code>list</code>执行了以下四条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list 1 2 3 4 &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">RPOP list &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">LPOP list &#x2F;&#x2F; [2, 3]</span><br><span class="line">LPUSH list 1 &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>如果要保存这个列表的当前状态，并且尽量减少所使用的命令数，那么最简单的方式不是去<code>AOF</code>文件上分析前面执行的四条命令，而是直接读取<code>list</code>键在数据库的当前值，然后用一 条<code>RPUSH 1 2 3</code>命令来代替前面的四条命令。</p>
<p><code>Redis</code>不希望<code>AOF</code>重写造成调用线程阻塞，导致服务器无法处理请求，所以<code>Redis</code>决定将<code>AOF</code>重写程序放到（后台）子进程里执行，不过，使用子进程也有一个问题需要解决：因为子进程在进行<code>AOF</code>重写期间，主进程还需要继续处理命令，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的<code>AOF</code>文件中的数据不一致。</p>
<p>为了解决这个问题，<code>Redis</code>增加了一个<code>AOF</code>重写缓存，这个缓存在<code>fork</code>出子进程之后开始启用，<code>Redis</code>主进程在接到新的写命令之后，除了会将这个写命令的协议内容追加到现有的<code>AOF</code>文件之外，还会追加到这个缓存中。</p>
<p>换言之，当子进程在执行<code>AOF</code>重写时，主进程需要执行以下三个工作：</p>
<ul>
<li>处理命令请求。</li>
<li>将写命令追加到现有的<code>AOF</code>文件中。</li>
<li>将写命令追加到<code>AOF</code>重写缓存中。</li>
</ul>
<p>当子进程完成<code>AOF</code>重写之后，它会向父进程发送一个完成信号，父进程在接到完成信号之后， 会调用一个信号处理函数，并完成以下工作：</p>
<ul>
<li>将<code>AOF</code>重写缓存中的内容全部写入到新<code>AOF</code>文件中。</li>
<li>对新的<code>AOF</code>文件进行改名，覆盖原有的<code>AOF</code>文件。</li>
</ul>
<p><code>AOF</code>重写可以由用户通过调用<code>BGREWRITEAOF</code>手动触发。</p>
<h4 id="4、RDB和AOF扩展"><a href="#4、RDB和AOF扩展" class="headerlink" title="4、RDB和AOF扩展"></a>4、RDB和AOF扩展</h4><p>1、RDB持久化方式能够在指定的时间间隔内对数据进行快照存储；</p>
<p>2、AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大；</p>
<p>3、只做缓存，如果只希望数据在服务器运行的时候存在，也可以不使用任何持久化；</p>
<p>4、同时开启两种持久化方式</p>
<ul>
<li>在这种情况下，当redis重启的时候会有限载入AOF文件来恢复原始的数据，因为在通常情况下，AOF文件保存的数据要比RDB文件保存的数据要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，但不建议只使用AOF，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug。</li>
</ul>
<p>5、性能建议</p>
<ul>
<li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 9000 1这条规则；</li>
<li>如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒的数据，启动脚本较简单，只需要加载自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的，只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设置到5G以上，默认超过原大小100%大小重写可以改到适当的数值。</li>
<li>如果不Enable AOF，仅靠Master-Slave Replication实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时宕掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个，微博就是这种架构。</li>
</ul>
<h4 id="5、事件"><a href="#5、事件" class="headerlink" title="5、事件"></a>5、事件</h4><h5 id="（1）文件事件"><a href="#（1）文件事件" class="headerlink" title="（1）文件事件"></a>（1）文件事件</h5><p><code>Redis</code>将这类因为对套接字进行多路复用而产生的事件称为文件事件，文件事件可 以分为读事件和写事件两类。</p>
<ul>
<li><p>读事件</p>
<p>当一个新的客户端连接到服务器时，服务器会给为该客户端绑定读事件，直到客户端断开连接之后，这个读事件才会被移除。 读事件在整个网络连接的生命期内，都会在等待和就绪两种状态之间切换：</p>
<ul>
<li>当客户端只是连接到服务器，但并没有向服务器发送命令时，该客户端的读事件就处于<strong>等待</strong>状态。</li>
<li>当客户端给服务器发送命令请求，并且请求已到达时（相应的套接字可以无阻塞地执行读操作），该客户端的读事件处于<strong>就绪</strong>状态。</li>
</ul>
</li>
<li><p>写事件</p>
<p>服务器只会在有命令结果要传回给客户端时，才会为客户端关联写事件，并且在命令结果传送完毕之后，客户端和写事件的关联就会被移除。 一个写事件会在两种状态之间切换：</p>
<ul>
<li>当服务器有命令结果需要返回给客户端，但客户端还未能执行无阻塞写，那么写事件处于<strong>等待</strong>状态。</li>
<li>当服务器有命令结果需要返回给客户端，并且客户端可以进行无阻塞写，那么写事件处于<strong>就绪</strong>状态。</li>
</ul>
</li>
</ul>
<p>在同一次文件事件处理器的调用中，单个客户端只能执行其中一种事件（要么读，要么写， 但不能又读又写），当出现读事件和写事件同时就绪的情况时，事件处理器优先处理读事件。 这也就是说，当服务器有命令结果要返回客户端，而客户端又有新命令请求进入时，服务器先处理新命令请求。</p>
<h5 id="（2）时间事件"><a href="#（2）时间事件" class="headerlink" title="（2）时间事件"></a>（2）时间事件</h5><p>时间事件记录着那些要在指定时间点运行的事件，多个时间事件以无序链表的形式保存在服务器状态中。 每个时间事件主要由三个属性组成：</p>
<ul>
<li><code>when</code>：以毫秒格式的<code>UNIX</code>时间戳为单位，记录了应该在什么时间点执行事件处理函数。</li>
<li><code>timeProc</code>：事件处理函数。根据<code>timeProc</code>函数的返回值，可以将时间事件划分为两类：<ul>
<li>如果事件处理函数返回<code>ae.h/AE_NOMORE</code>，那么这个事件为单次执行事件，该事件会在指 定的时间被处理一次，之后该事件就会被删除，不再执行。</li>
<li>如果事件处理函数返回一个非<code>AE_NOMORE</code>的整数值，那么这个事件为循环执行事件，该事件会在指定的时间被处理，之后它会按照事件处理函数的返回值，更新事件的<code>when</code>属 性，让这个事件在之后的某个时间点再次运行，并以这种方式一直更新并运行下去。</li>
</ul>
</li>
<li><code>next</code>指向下一个时间事件，形成链表。</li>
</ul>
<p>一种事件会等待另一种事件执行完毕之后，才开始执行，事件之间不会出现抢占。事件处理器先处理文件事件（处理命令请求），再执行时间事件（调用 <code>serverCron</code>）。文件事件的等待时间（类<code>poll</code>函数的最大阻塞时间），由距离到达时间最短的时间事件决定。</p>
<h4 id="6、主从复制"><a href="#6、主从复制" class="headerlink" title="6、主从复制"></a>6、主从复制</h4><h5 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h5><p>主从复制是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（master/leader）。后者称为从节点（slave/follower），<strong>数据的复制是单向的，只能由主节点到从节点。</strong>master以写为主，slave以读为主。</p>
<p><strong>默认情况下，每台Redis服务器都是主节点</strong>，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p>
<p>主从复制的作用主要包括：</p>
<p>1）数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式；</p>
<p>2）故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余；</p>
<p>3）负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量；</p>
<p>4）高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<h5 id="6-2-集群环境模拟测试"><a href="#6-2-集群环境模拟测试" class="headerlink" title="6.2 集群环境模拟测试"></a>6.2 集群环境模拟测试</h5><p>复制3个配置文件，然后修改对应的信息，模拟3个不同的redis服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 6381    <span class="comment"># 修改端口号</span></span><br><span class="line">pidfile /var/run/redis_6381.pid   <span class="comment"># 修改pid名字</span></span><br><span class="line">logfile <span class="string">&quot;6381.log&quot;</span>         <span class="comment"># 修改log文件名</span></span><br><span class="line">dbfilename dump6381.rdb    <span class="comment"># 修改dump.rdb文件名</span></span><br></pre></td></tr></table></figure>

<p>修改完毕之后启动3个redis服务器，可以通过进程查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./redis-server redis79.conf</span><br><span class="line">./redis-server redis80.conf</span><br><span class="line">./redis-server redis81.conf</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220415140801.png" style="zoom:67%;" />

<p>也可通过redis客户端查看信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220415141010.png" style="zoom:67%;" />

<p>默认情况下，每台redis服务器都是主节点，一般情况下只用配置机就好了。假设设置6379端口的服务器为主机，6380和6381端口的服务器为从机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6381&gt; slaveof 127.0.0.1 6379   <span class="comment"># 设置6379位主机</span></span><br></pre></td></tr></table></figure>

<p>此时在主机上可以看到两个连接的从机：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220415142011.png" style="zoom:67%;" />

<p>主机可以写，从机不能写只能读。主机中的所有信息和数据都会被从机保存。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220415142337.png" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220415142416.png" style="zoom:67%;" />

<ul>
<li><p>如果主机断开连接，从机依旧连接着主机，在此过程中主机没有写操作，这个时候，如果主机恢复了，从机依旧可以直接获取到主机写的信息。</p>
</li>
<li><p>如果使用命令行进行主从机配置的，这个时候如果从机重启了，从机就会变回主机的状态（默认没有手动设置的情况下都是主机）。但只要设置一下变回从机，就能立马从主机中获取数据。</p>
</li>
</ul>
<h5 id="6-3-主从复制的复制原理"><a href="#6-3-主从复制的复制原理" class="headerlink" title="6.3 主从复制的复制原理"></a>6.3 主从复制的复制原理</h5><p>Slave启动成功连接到master后会发送一个sync同步命令，master接到命令，七佛那个后台的存盘进程，同时收集所有接收到的用于修改数据集的命令，在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave，并完成一次完全同步</strong>。</p>
<p><strong>全量复制</strong>：slave服务在接收到数据库文件数据之后，将其存盘并加载到内存中；</p>
<p><strong>增量复制</strong>：master继续将新的所有收集到的修改命令依次传给slave，完成同步；</p>
<p>但是只要重新连接master，一次完全同步（全量复制）将被自动执行。数据一定可以在从机中看到。</p>
<p>如果主机断开了连接，可以使用<code>slaveod no one</code>命令让自己变成主机，其他的节点就可以手动连接到最新的这个主节点（手动）。</p>
<h5 id="6-4-哨兵模式"><a href="#6-4-哨兵模式" class="headerlink" title="6.4 哨兵模式"></a>6.4 哨兵模式</h5><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这种情况下，推荐使用哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。</p>
<p>哨兵模式是一种特殊的模式，手电redis提供了哨兵的命令，哨兵是一个独立的进程。其原理是：哨兵通过发送命令，等待redis服务器响应，从而监控运行多个redis实例。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220415225249.png" style="zoom:67%;" />

<p>这里哨兵有两个作用：</p>
<ul>
<li>通过发送命令，让redis服务器但会监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对redis服务器进行监控，可能会出现问题，为此，可以使用多个哨兵进行监控，各个哨兵之间还会进行监控，这就形成了多哨兵模式。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220416104241.png" style="zoom:67%;" />

<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观地认为主服务器不可用，这个现象称为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover【故障转移】操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<p>【测试】目前的状态是一主二从。</p>
<p>1、哨兵配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1,1代表如果主机挂了，slave投票决定下一个主机</span></span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>

<p>2、启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220416110012.png" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220416110139.png" style="zoom:67%;" />

<p>如果此时原来的主机恢复了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则。</p>
<p>优点：</p>
<ul>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点他都有</li>
<li>主从可以切换，故障可以转移，系统的可用性更好</li>
<li>哨兵模式就是主从复制的升级，手动到自动，更加健壮</li>
</ul>
<p>缺点：</p>
<ul>
<li>redis不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ul>
<h4 id="7、Redis缓存穿透和雪崩"><a href="#7、Redis缓存穿透和雪崩" class="headerlink" title="7、Redis缓存穿透和雪崩"></a>7、Redis缓存穿透和雪崩</h4><h5 id="7-1-缓存穿透"><a href="#7-1-缓存穿透" class="headerlink" title="7.1 缓存穿透"></a>7.1 缓存穿透</h5><p>当用户想要查询一个数据，发现redis内存数据库内有，也就是缓存没有命中，于是向持久层数据库查询，发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<p><strong>【解决方案】：</strong></p>
<p><strong>1、布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220416134715.png" style="zoom:67%;" />

<p><strong>2、缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据会从缓存中获取，保护了后端数据。但是这种方法会存在两个问题：</p>
<ul>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220416134854.png" style="zoom:67%;" />

<h5 id="7-2-缓存击穿"><a href="#7-2-缓存击穿" class="headerlink" title="7.2 缓存击穿"></a>7.2 缓存击穿</h5><p>缓存击穿是指一个key非常热点，在不停地扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就能穿破缓存，直接请求数据库。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新的申诉局，并且回写缓存，会导致数据库瞬间压力过大。</p>
<p><strong>【解决方案】：</strong></p>
<p><strong>1、设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p>
<p><strong>2、加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h5 id="7-3-缓存雪崩"><a href="#7-3-缓存雪崩" class="headerlink" title="7.3 缓存雪崩"></a>7.3 缓存雪崩</h5><p>缓存雪崩是指在某一个时间段，缓存集中过期失效，或redis宕机导致缓存雪崩。</p>
<p>产生雪崩的原因之一，比如马上要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中地放入了缓存，假设缓存一个小时，那么到了凌晨一点的时候，这批商品的缓存就都过期了。而对于这批商品的访问查询，都落到了数据库中，对于数据库而言，就会产生周期性的压力波峰，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网，因为自然形成的缓存雪崩一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已，而缓存服务节点宕机，对数据库服务器造成的压力是不可预知的，很可能瞬间就把数据库压垮。</p>
<p><strong>【解决方案】：</strong></p>
<p><strong>1、redis高可用</strong></p>
<p>核心思想是：既然redis有可能挂掉，那么就多增设几台redis，这样一台挂掉之后其他的还可以工作，其实就是搭建集群。</p>
<p><strong>2、限流降级</strong></p>
<p>在缓存失效后，通过加锁或队列来控制读数据库写缓存的线程数量，比如对某个key只允许一个线程查询数据和写缓存，其他的线程需要等待。</p>
<p><strong>3、数据预热</strong></p>
<p>在正式部署之前，先把可能的数据线预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中，在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<h3 id="六、使用Redis"><a href="#六、使用Redis" class="headerlink" title="六、使用Redis"></a>六、使用Redis</h3><h4 id="1、安装配置Redis以及常用命令"><a href="#1、安装配置Redis以及常用命令" class="headerlink" title="1、安装配置Redis以及常用命令"></a>1、安装配置Redis以及常用命令</h4><h5 id="1）安装和配置"><a href="#1）安装和配置" class="headerlink" title="1）安装和配置"></a>1）安装和配置</h5><p>官网下载压缩包，解压后在linux下进行安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make -p /usr/<span class="built_in">local</span>/redis     <span class="comment"># 创建安装目录</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis install    <span class="comment"># 在创建的目录中进行安装</span></span><br></pre></td></tr></table></figure>

<p>修改配置redis.conf：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改为后台启动</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解除保护模式，任何ip地址均可连接redis</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1 -::1    # 注释绑定的ip地址</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">no</span>   <span class="comment"># 将保护模式改为no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置登录密码为root</span></span><br><span class="line"><span class="string">requirepass</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>改为后台启动后，启动<code>redis-server</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server</span><br></pre></td></tr></table></figure>

<p>启动<code>redis-cli</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -p指定连接的端口号，-a指定连接的密码</span></span><br><span class="line">./redis-cli <span class="comment"># -p 6379 -a root </span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220408215416.png" style="zoom:67%;" />

<h5 id="2）常用命令"><a href="#2）常用命令" class="headerlink" title="2）常用命令"></a>2）常用命令</h5><ul>
<li>关闭redis服务：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在客户端执行命令</span></span><br><span class="line">shutdown</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>并发测试：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;redis-benchmark -h localhost -p 6379 -c 100 -n 100000 -a root</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410160937.png" style="zoom:67%;" />

<ul>
<li>Redis默认有16个数据库，默认使用第0个数据库。使用<code>select</code>命令进行切换。<code>dbsize</code>命令获取数据库的大小。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 3    <span class="comment"># 获取第3号数据库</span></span><br><span class="line">dbsize      <span class="comment"># 获取数据库大小</span></span><br><span class="line">flushdb     <span class="comment"># 清空当前数据库的内容</span></span><br><span class="line">flushall    <span class="comment"># 清空全部数据库的内容</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410162500.png" style="zoom:67%;" />

<ul>
<li>判断键是否存在：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists name    <span class="comment"># 返回1表示存在，返回0表示不存在</span></span><br></pre></td></tr></table></figure>

<ul>
<li>移除键：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move name 1    <span class="comment"># 移除当前数据库中的键name，1代表当前数据库</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看键的类型：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> name    <span class="comment"># 查看当期键的数据类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除键：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name    <span class="comment"># 删除键name</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以层级关系和目录形式存储数据：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> cart:user01:item01 apple</span><br><span class="line">get cart:user01:item01 apple</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置key的失效时间：</p>
<p>Redis 有四个不同的命令可以用于设置键的生存时间(键可以存在多久)或过期时间(键什么时候会被删除)：</p>
<ul>
<li><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code>：用于将键<code>key</code>的生存时间设置为<code>tt1</code>秒；</li>
<li><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>：用于将键<code>key</code>的生存时间设置为 <code>tt1</code>毫秒；</li>
<li><code>EXPIREAT &lt;key&gt; &lt;timestamp&gt;</code> ：用于将键<code>key</code>的过期时间设置为<code>timestamp</code>所指定的秒数时间戳；</li>
<li><code>PEXPIREAT &lt;key&gt; &lt; timestamp&gt;</code>: 用于将键<code>key</code>的过期时间设置为<code>timestamp</code>所指定的毫秒数时问戳；</li>
<li><code>TTL</code>获取的值为<code>-1</code>说明此<code>key</code>没有设置有效期，当值为<code>-2</code>时证明过了有效期。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name lisi</span><br><span class="line">expire name 10    <span class="comment"># 设置当前key的失效时间为10秒</span></span><br><span class="line">ttl name          <span class="comment"># 查看当前key的剩余失效时间</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410164453.png" style="zoom:67%;" />

<h4 id="2、使用Redis"><a href="#2、使用Redis" class="headerlink" title="2、使用Redis"></a>2、使用Redis</h4><h5 id="1、String类型"><a href="#1、String类型" class="headerlink" title="1、String类型"></a>1、String类型</h5><ul>
<li><code>set</code>和<code>get</code>默认将值保存为字符串。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> name zhangsan</span><br><span class="line">get name</span><br><span class="line">keys *  <span class="comment"># 获取所有的值</span></span><br><span class="line">append name lisi    <span class="comment"># 在String之后追加字符，如果当前key不存在，相当于set key</span></span><br><span class="line">strlen name    <span class="comment"># 获取字符串长度</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410220102.png" style="zoom:67%;" />

<ul>
<li>可以设置步长，指定增量：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> views 0</span><br><span class="line">incr views     <span class="comment"># 自增1</span></span><br><span class="line">decr views     <span class="comment"># 自减1</span></span><br><span class="line">incrby views 10  <span class="comment"># 自增10</span></span><br><span class="line">decrby views 10  <span class="comment"># 自减10</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410220539.png" style="zoom:67%;" />

<ul>
<li>提取某范围内的字符串：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key1 hello,world</span><br><span class="line">getrange 0 3     <span class="comment"># 获取[0, 3]下标范围内的字符串</span></span><br><span class="line">getrannge 0 -11  <span class="comment"># 获取整个字符串的内容</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将指定位置开始的字符串进行替换：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key2 abcdefg</span><br><span class="line">setrange key2 1 xx    <span class="comment"># 将下标1位置的字符替换为xx</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410221103.png" style="zoom:67%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################</span></span><br><span class="line"><span class="comment"># setex(set with expire)   # 设置过期时间</span></span><br><span class="line"><span class="comment"># setnx(set if not expire)  # 不存在设置（在分布式锁中会经常使用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################################################</span></span><br><span class="line">setex key3 30 hello    <span class="comment"># 将key的值设置过期时间为30秒</span></span><br><span class="line">ttl key3</span><br><span class="line"></span><br><span class="line">setnx key4 hhhhhh      <span class="comment"># 如果key4不存在，则设置为hhhhhh，成功返回1</span></span><br><span class="line">setnx key4 mmmmmm      <span class="comment"># 此时设置返回0，设置失败</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410221721.png" style="zoom:67%;" />

<ul>
<li>批量设置和获取k-v值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mset k1 v1 k2 v2 k3 v3   <span class="comment"># 同时设置多个值</span></span><br><span class="line">mget k1 k2 k3            <span class="comment"># 同时获取多个值</span></span><br><span class="line">msetnx k1 v1 k4 v4       <span class="comment"># 如果不存在则设置，存在则设置失败；msetnx是一个原子操作，要么一起成功，要么一起失败</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象方式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mset user:1:name zhangsan user:1:age 18</span><br><span class="line">mget user:1:name user:1:age</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410222754.png" style="zoom:67%;" />

<ul>
<li>先<code>get</code>后<code>set</code>，如果值不存在返回<code>nil</code>，存在则返回原来的值，并设置修改后的值：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getset db redis      <span class="comment"># 返回nil</span></span><br><span class="line">get db</span><br><span class="line">getset db monngodb   <span class="comment"># 返回redis</span></span><br><span class="line">get db</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410223005.png" style="zoom:67%;" />

<h5 id="2、Hash类型"><a href="#2、Hash类型" class="headerlink" title="2、Hash类型"></a>2、Hash类型</h5><p>用法和String类似，相当于是<code>key-map</code>集合。</p>
<ul>
<li>获取、添加和删除元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hset user name lisi      <span class="comment"># user是redis的key，name是hash的key，lisi是hash的value</span></span><br><span class="line">hget user name </span><br><span class="line">hmset user age 18 sex 1  <span class="comment"># 设置多个值</span></span><br><span class="line">hmget user name age sex  <span class="comment"># 获取多个值</span></span><br><span class="line">hgetall user             <span class="comment"># 获取user的所有的值</span></span><br><span class="line">hdel user name age       <span class="comment"># 删除user的name和age两个属性</span></span><br><span class="line">hlen user                <span class="comment"># 获取哈希表的字段数量</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411112332.png" style="zoom:67%;" />

<ul>
<li>判断某个key对应的value是否存在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists user sex     <span class="comment"># 返回1则存在，0则不存在</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取所有的key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys user </span><br></pre></td></tr></table></figure>

<ul>
<li>获取所有的value</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals user</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411112637.png" style="zoom:67%;" />

<ul>
<li>自增和自减</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hincrby user age 1      <span class="comment"># user的age字段加1</span></span><br><span class="line">hincrby user age -1     <span class="comment"># user的age字段减1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不存在则设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx user name zhangsan   <span class="comment"># 如果不存你在这个字段，则设置；；如果存在则不能设置</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411115241.png" style="zoom:67%;" />

<p>应用场景：hash变更的数据，尤其是与用户有关等的经常变动的信息，hash更适合于对象的存储，String更适合字符串存储。</p>
<h5 id="3、List类型"><a href="#3、List类型" class="headerlink" title="3、List类型"></a>3、List类型</h5><p>元素是可以重复的，两端均可添加元素。<code>lpush</code>为从左往右添加，<code>rpush</code>为从右往左添加。</p>
<ul>
<li>通过下标获取值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex list 1     <span class="comment"># 下标1位置的元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取列表的长度</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen list        <span class="comment"># 返回列表的长度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>左右插入和弹出</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lpush list one        <span class="comment"># 从左边插入</span></span><br><span class="line">lpush list two</span><br><span class="line">lpush list three</span><br><span class="line"> </span><br><span class="line">rpush list right      <span class="comment"># 从右边插入</span></span><br><span class="line">lrange list 0 -1</span><br><span class="line"></span><br><span class="line">lpop list             <span class="comment"># 从左边弹出</span></span><br><span class="line">rpop list             <span class="comment"># 从右边弹出</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410225017.png" style="zoom:67%;" />

<ul>
<li>移除列表中指定个数的value。<code>lrem</code>为删除，可以指定删除的元素的数目，如果删除多个同名元素，则从左往右删除。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpush students zhangsan lisi  <span class="comment"># 左添加两条数据</span></span><br><span class="line">rpush students wangwu zhaoliu <span class="comment"># 右添加两条数据</span></span><br><span class="line">lrange students 0 3           <span class="comment"># 查看所有数据</span></span><br><span class="line">llen students                 <span class="comment"># 获取数据条数</span></span><br><span class="line">lrem students 2 lisi        <span class="comment"># 删除2值为lisi的数据。从左往右开始删除</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220408223519.png" style="zoom:67%;" />

<ul>
<li>通过下标截取列表指定长度的元素，截取之后只剩下截取到的元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpush mylist hello0</span><br><span class="line">rpush mylist hello1</span><br><span class="line">rpush mylist hello2</span><br><span class="line">rpush mylist hello3</span><br><span class="line"></span><br><span class="line">ltrim mylist 1 2    <span class="comment"># 截取列表下标[1, 2]范围内的与元素</span></span><br><span class="line">lrange mylist 0 -1</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410230117.png" style="zoom:67%;" />

<ul>
<li>组合命令：移除列表的最后一个元素，并保存到新的列表中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpush list1 hello0</span><br><span class="line">rpush list1 hello1</span><br><span class="line">rpush list1 hello2</span><br><span class="line"></span><br><span class="line">rpoplpush list1 list2  <span class="comment"># 将list1中最右边的元素移动到list2中</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410230726.png" style="zoom:67%;" />

<ul>
<li>判断列表是否存在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists list1</span><br></pre></td></tr></table></figure>

<ul>
<li>将列表中指定下标的值替换为另外一个值，相当于更新操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset list1 0 item    <span class="comment"># 如果列表和下标存在，则会更新当前列表中当前下标的值，如果列表或下标不存在则会报错                     </span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410231124.png" style="zoom:67%;" />

<ul>
<li>在列表中某个元素的前面或后面插入元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpush list hello</span><br><span class="line">rpush list world</span><br><span class="line">linsert list before world my   <span class="comment"># 在world之前插入my</span></span><br><span class="line">linsert list after world haha  <span class="comment"># 在world之后插入haha</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220410231513.png" style="zoom:67%;" />

<h5 id="4、Set类型"><a href="#4、Set类型" class="headerlink" title="4、Set类型"></a>4、Set类型</h5><p>set是无序不重复集合。set中的值是不能重读的。</p>
<ul>
<li>查看元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smembers letters             <span class="comment"># 查看数据（每次查看元素的顺序不变）</span></span><br><span class="line">sismember letters aa         <span class="comment"># 判断元素是否存在</span></span><br><span class="line">scard letters                <span class="comment"># 获取数据条数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加和删除元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sadd letters aa bb cc dd     <span class="comment"># 添加数据</span></span><br><span class="line">srem letters aa dd           <span class="comment"># 删除单个或多个元素</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411110006.png" style="zoom:67%;" />

<ul>
<li>随机选择和删除元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srandmember letters          <span class="comment"># 随机挑选一个元素</span></span><br><span class="line">srandmember letters 2        <span class="comment"># 随机挑选2个元素</span></span><br><span class="line">spop letters                 <span class="comment"># 随机删除一个元素</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411110444.png" style="zoom:67%;" />

<ul>
<li>将一个指定的值，从源集合移动到指定的集合中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove myset1 myset2 hello    <span class="comment"># 将myset1中的hello元素移动到myset2中</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411110716.png" style="zoom:67%;" />

<ul>
<li>差集、交集和并集</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdiff key1 key2     <span class="comment"># 获取key1和key2集合的差集</span></span><br><span class="line">sinter key1 key2    <span class="comment"># 获取key1和key2集合的差集</span></span><br><span class="line">sunion key1 key2    <span class="comment"># 获取key1和key2集合的并集</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411111201.png" style="zoom:67%;" />

<p>场景：共同关注、共同好友、推荐好友等。</p>
<h5 id="5、Zset类型（有序集合）"><a href="#5、Zset类型（有序集合）" class="headerlink" title="5、Zset类型（有序集合）"></a>5、Zset类型（有序集合）</h5><p>相当于在set的基础上增加了每个值的分数用于排序。元素按要求进行排序。给出每个元素的分数，按照分数从低到高进行排序。</p>
<ul>
<li>查看、添加和删除元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zadd score 7 zhangsan 3 lisi 6 wangwu 10 zhaoliu 1 tianqi     <span class="comment"># 给每个元素赋予一个分数值</span></span><br><span class="line">zrange score 0 4    <span class="comment"># 查看每个元素</span></span><br><span class="line">zcard score         <span class="comment"># 查看元素个数</span></span><br><span class="line">zrem score zhangsan lisi  <span class="comment"># 删除一个或多个元素</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220408224554.png" style="zoom:67%;" />

<ul>
<li>对元素进行排序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore score -inf +inf   <span class="comment"># 升序</span></span><br><span class="line">zrangebyscore score -inf +inf withscore  <span class="comment"># 升序，并打印具体信息</span></span><br><span class="line">zrangebyscore score -inf 5 withscore  <span class="comment"># 升序，并打印满足(-inf, 5)的元素的具体信息</span></span><br><span class="line"></span><br><span class="line">zrevrangebyscore score +inf -inf  <span class="comment"># 降序</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220411121612.png" style="zoom:67%;" />

<ul>
<li>获取指定区间的成员数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount score 1 5    <span class="comment"># 获取[1,5]之间的成员数量</span></span><br></pre></td></tr></table></figure>

<h5 id="6、Geospatial地理位置"><a href="#6、Geospatial地理位置" class="headerlink" title="6、Geospatial地理位置"></a>6、Geospatial地理位置</h5><ul>
<li>添加、移除和查看城市的地理位置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geoadd china:city 116.40 39.90 beijing   <span class="comment"># geoadd设置经度和纬度</span></span><br><span class="line">zrange china:city 0 -1    <span class="comment"># 查看所有的城市信息</span></span><br><span class="line">zrem china:city beijing    <span class="comment"># 在集合中移除北京</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定的地理位置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos china:city beijing withcoord     <span class="comment"># geopos</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取城市之间的直线距离</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geodist china:city beijing shanghai km    <span class="comment"># geodist获取城市之间的距离，按km为单位</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在集合中找出某一范围内的元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadius china:city 110 30 1000 km count 2   <span class="comment"># 精度 维度 范围，查询个数限制为2个</span></span><br></pre></td></tr></table></figure>

<ul>
<li>找出位于指定范围内的元素，中心点是由给定的位置元素决定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">georadiusbymember china:city shanghai 500 km </span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220412133218.png" style="zoom:67%;" />

<p>应用场景：附近的人等。</p>
<h5 id="7、Hyperloglog"><a href="#7、Hyperloglog" class="headerlink" title="7、Hyperloglog"></a>7、Hyperloglog</h5><p>计算集合的基数，即不重复的元素。但是有一定的错误率，如果允许容错，那么可以使用Hyperloglog；如果不允许容错，那么只能使用set或自己的数据类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd mykey a b c d e f g h i j   <span class="comment"># 创建一组元素</span></span><br><span class="line">pfcount mykey     <span class="comment"># 统计集合中的基数数量</span></span><br><span class="line">pfmerge mykey3 mykey mykey2  <span class="comment"># 计算两组元素的并集</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220412134547.png" style="zoom:67%;" />

<p>应用场景：网页的UV（一个人访问一个网站多次，但还是算作一个人）</p>
<h5 id="8、Bitmaps"><a href="#8、Bitmaps" class="headerlink" title="8、Bitmaps"></a>8、Bitmaps</h5><p>位存储。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以每天打卡为例</span></span><br><span class="line">setbit sign 0 1</span><br><span class="line">setbit sign 1 0</span><br><span class="line">setbit sign 2 0</span><br><span class="line">setbit sign 3 1</span><br><span class="line">setbit sign 4 1</span><br><span class="line">setbit sign 5 1</span><br><span class="line">setbit sign 6 0</span><br><span class="line"></span><br><span class="line">getbit sign 3   <span class="comment"># 查看某一天是否打卡</span></span><br><span class="line">bitcount sign   <span class="comment"># 统计打卡记录</span></span><br></pre></td></tr></table></figure>

<p>应用场景：统计用户信息，活跃或不活跃，登录或未登录，打卡等，涉及到两个状态的都可以使用bitmaps，使用二进制进行记录，只有0和1两种状态。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220412135715.png" style="zoom:67%;" />

<h5 id="9、Jedis"><a href="#9、Jedis" class="headerlink" title="9、Jedis"></a>9、Jedis</h5><ul>
<li>导入对应的依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        redis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            1.x的版本默认采用的连接池技术是Jedis</span></span><br><span class="line"><span class="comment">            2.0以上版本默认连接池是Lettuce</span></span><br><span class="line"><span class="comment">            如果采用Jedis，需要排除Lettuce的依赖：</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        Jedis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        Json依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>测试常用API</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个Jedis对象</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jedis所有的方法就是redis的指令</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        System.out.println(jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span> + jedis.exists(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;新增键值对：&quot;</span> + jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;新增键值对：&quot;</span> + jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;111&quot;</span>));</span><br><span class="line">        System.out.print(<span class="string">&quot;查看所有的键值对：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(keys);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除键：&quot;</span> + jedis.del(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;查看键name所存储的值的类型&quot;</span> + jedis.type(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;随即返回key空间的一个： &quot;</span> + jedis.randomKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;重命名key：&quot;</span> + jedis.rename(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;取出改名后的name：&quot;</span> + jedis.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;按索引查询：&quot;</span> + jedis.select(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;删除当前选择的数据库中的所有key：&quot;</span> + jedis.flushDB());</span><br><span class="line">        System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span> + jedis.dbSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;删除所有数据库中的所有的key：&quot;</span> + jedis.flushAll());</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 事务</span></span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Transaction multi = jedis.multi();   <span class="comment">// 开启事务</span></span><br><span class="line">        String result = jsonObject.toJSONString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        jedis.watch(result);    // 乐观锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>, result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>, result);</span><br><span class="line"><span class="comment">//            int i = 1 / 0;     // 代码抛出异常，事务执行失败</span></span><br><span class="line">            multi.exec();      <span class="comment">// 执行事务</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            multi.discard();   <span class="comment">// 放弃事务</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close();    <span class="comment">// 关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、SpringBoot整合Redis"><a href="#10、SpringBoot整合Redis" class="headerlink" title="10、SpringBoot整合Redis"></a>10、SpringBoot整合Redis</h5><p>SpringBoot1.x的版本默认采用的连接池技术是Jedis，采用的是直连，jedis中多线程操作是不安全的，使用jedis pool连接池，更像BIO模式；</p>
<p>SpringBoot2.0以上版本默认连接池是Lettuce，采用netty实现，实例可以在多个线程中进行共享，不存在线程不安全的情况，可以减少线程数据，更像NIO（异步）模式；</p>
<ul>
<li>1）导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2）配置redis</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3）测试</li>
</ul>
<p><code>private RedisTemplate redisTemplate;</code>常用的方法都可以直接通过<code>redisTemplate</code>进行操作。默认的<code>RedisTemplate</code>没有过多的设置，redis对象都是需要序列化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User.java</span></span><br><span class="line"><span class="comment"> * 在实际开发场景中，pojo是需要序列化的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">// 真实开发场景中一般都是使用json来传递对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">//        String jsonUser = new ObjectMapper().writeValueAsString(user);</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行test后，此时在redis-cli客户端查看keys，会出现乱码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220413120803.png"></p>
<p>解决方法：自定义<code>RedisTemplate</code>类，设置序列化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编写自己的RedisTemplate，固定模板如下</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 为了开发方便，一般直接使用&lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        template.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value的序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value的序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行test后，在redis-cli客户端查看keys，能正常查看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20220413121204.png"></p>
<h5 id="11、Redis-conf配置文件"><a href="#11、Redis-conf配置文件" class="headerlink" title="11、Redis.conf配置文件"></a>11、Redis.conf配置文件</h5><ul>
<li>配置文件对大小写不敏感。</li>
<li>可以包含其他配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include .\path\to\local.conf</span><br><span class="line">include c:\path\to\other.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>网络</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1      <span class="comment"># 绑定的端口</span></span><br><span class="line">protected-mode yes  <span class="comment"># 保护模式</span></span><br><span class="line">port 6379           <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通用GENERAL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes      <span class="comment"># 以守护进程的方式运行，默认是no，需要手动开启</span></span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid  <span class="comment"># 如果以后台的方式运行，就需要指定一个pid文件</span></span><br><span class="line"></span><br><span class="line">loglevel notice    <span class="comment"># 日志</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span>         <span class="comment"># 日志的位置</span></span><br><span class="line">databases 16       <span class="comment"># 默认的数据库数目</span></span><br><span class="line"></span><br><span class="line">always-show-logo no  <span class="comment"># 是否总是显示redis的logo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>持久化：在规定的时间内，执行了多少次操作，则会持久化到文件.rdb或.aof</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果3600s内，至少有一个key进行了修改，则进行持久化操作</span></span><br><span class="line">save 3600 1</span><br><span class="line"><span class="comment"># 如果在300s内，至少有100个key进行了修改，则进行持久化操作</span></span><br><span class="line">save 300 100</span><br><span class="line"><span class="comment"># 如果在60s内，至少有10000个key进行了修改，则进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes  <span class="comment"># 如果持久化从出错，是否还需要继续工作</span></span><br><span class="line"></span><br><span class="line">rdbcompression yes    <span class="comment"># 是否压缩rdb文件，会消耗cpu资源</span></span><br><span class="line">rdbchecksum yes       <span class="comment"># 保存rdb文件的时候，进行错误的检查校验</span></span><br><span class="line"></span><br><span class="line">dir ./                <span class="comment"># rdb文件保存的路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SECURITY安全</li>
</ul>
<p>可以在这里设置redis的密码， 默认是没有密码的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;config get requirepass     <span class="comment"># 获取redis的密码</span></span><br><span class="line">127.0.0.1:6379&gt;config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span>    <span class="comment"># 设置redis的密码</span></span><br></pre></td></tr></table></figure>

<ul>
<li>限制客户端CLIENTS</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000     <span class="comment"># 设置能连接上redis的最大客户端数目</span></span><br><span class="line">maxmemory &lt;bytes&gt;    <span class="comment"># redis配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction  <span class="comment"># 内存到达上限之后的处理策略</span></span><br></pre></td></tr></table></figure>

<ul>
<li>AOF配置（APPEND ONLY MODE模式）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no   <span class="comment"># 默认不开启aof模式，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>   <span class="comment"># aof持久化文件的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always    # 每次修改都会sync，消耗性能</span></span><br><span class="line">appendfsync everysec    <span class="comment"># 每秒执行一次sync，可能丢失这1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no        # 不执行sync，这个时候操作系统自己同步数据，速度最快</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2022/04/20/%E7%AC%94%E8%AE%B0-redis/">https://varrella.github.io/2022/04/20/%E7%AC%94%E8%AE%B0-redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/20/%E7%AC%94%E8%AE%B0-SpringBoot2/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureuyfdb3840x2160-bg-2b185ed.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">SpringBoot2学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/20/%E9%9D%A2%E8%AF%95-%E5%89%91%E6%8C%87Offer/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-3965109.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">刷题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">0、关系型数据库和非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">1、关系型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">2、非关系型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.</span> <span class="toc-text">3、比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Redis%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.</span> <span class="toc-text">4、Redis概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Redis%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5、Redis单线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">一、内部数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Sds%EF%BC%8CSimple-Dynamic-String%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1、简单动态字符串（Sds，Simple Dynamic String）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Sds%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">（1）Sds在Redis中的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89sds%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">（2）sds的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2、双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">（1）双端链表的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">（2）双端链表的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E5%85%B8"><span class="toc-number">2.3.</span> <span class="toc-text">3、字典</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AD%97%E5%85%B8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">（1）字典的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">（2）字典的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.3.</span> <span class="toc-text">（3）哈希表的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">（4）哈希算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.5.</span> <span class="toc-text">（5）添加新元素操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89rehash%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.6.</span> <span class="toc-text">（6）rehash的执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%AD%97%E5%85%B8%E7%9A%84%E6%94%B6%E7%BC%A9"><span class="toc-number">2.3.7.</span> <span class="toc-text">（7）字典的收缩</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">4、跳跃表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">二、内存映射数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%EF%BC%88intset%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1、整数集合（intset）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">3.1.1.</span> <span class="toc-text">（1）整数集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">（2）数据结构和主要操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%EF%BC%88Ziplist%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">2、压缩列表（Ziplist）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">（1）压缩列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89ziplist%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">3.2.2.</span> <span class="toc-text">（2）ziplist的构成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">三、Redis 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81redisObject-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BB%A5%E5%8F%8A-Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1、redisObject 数据结构，以及 Redis 的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%91%BD%E4%BB%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">4.2.</span> <span class="toc-text">2、命令的类型检查和多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">4.3.</span> <span class="toc-text">3、对象共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">4.4.</span> <span class="toc-text">4、 引用计数以及对象的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.5.</span> <span class="toc-text">5、五大数据类型——字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.6.</span> <span class="toc-text">6、五大数据类型——哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8"><span class="toc-number">4.7.</span> <span class="toc-text">7、五大数据类型——列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E9%9B%86%E5%90%88"><span class="toc-number">4.8.</span> <span class="toc-text">8、五大数据类型——集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%9C%89%E5%BA%8F%E9%9B%86"><span class="toc-number">4.9.</span> <span class="toc-text">9、五大数据类型——有序集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">四、功能与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">1、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%80%E5%A7%8B%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.1.1.</span> <span class="toc-text">（1）开始事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%91%BD%E4%BB%A4%E5%85%A5%E9%98%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">（2）命令入队</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.1.3.</span> <span class="toc-text">（3）执行事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84-DISCARD-%E3%80%81MULTI-%E5%92%8C-WATCH-%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.4.</span> <span class="toc-text">（4）事务状态下的 DISCARD 、MULTI 和 WATCH 命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID-%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.5.</span> <span class="toc-text">（5）事务的 ACID 性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.6.</span> <span class="toc-text">（7）示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-number">5.2.</span> <span class="toc-text">2、订阅与发布</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E5%88%B0%E9%A2%91%E9%81%93%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 订阅&#x2F;发布到频道：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A2%91%E9%81%93%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">（1）频道的订阅与信息发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A2%E9%98%85%E9%A2%91%E9%81%93-SUBSCRIBE"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">（2）订阅频道 SUBSCRIBE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E5%88%B0%E9%A2%91%E9%81%93-PUBLISH"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">（3）发送信息到频道 PUBLISH</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E9%80%80%E8%AE%A2%E9%A2%91%E9%81%93-UNSUBSCRIBE"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">（4） 退订频道 UNSUBSCRIBE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.1.5.</span> <span class="toc-text">（5）测试</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E5%88%B0%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 订阅&#x2F;发布到模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">（1） 模式的订阅与信息发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">（2）订阅模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E5%88%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">（3）发送信息到模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%80%80%E8%AE%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">（4）退订模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Lua%E8%84%9A%E6%9C%AC"><span class="toc-number">5.3.</span> <span class="toc-text">3、Lua脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">5.4.</span> <span class="toc-text">4、 慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.</span> <span class="toc-text">（1）相关数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E9%83%A8%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">五、内部运作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">6.1.</span> <span class="toc-text">1、数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">（1）数据库的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4"><span class="toc-number">6.1.2.</span> <span class="toc-text">（2）数据库键空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.1.3.</span> <span class="toc-text">（3）数据库键空间的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4"><span class="toc-number">6.1.4.</span> <span class="toc-text">（4）键的过期时间和生存时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="toc-number">6.1.5.</span> <span class="toc-text">（5）过期时间的保存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">6.1.6.</span> <span class="toc-text">（6）过期键的判定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E6%B8%85%E9%99%A4"><span class="toc-number">6.1.7.</span> <span class="toc-text">（7）过期键的清除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB"><span class="toc-number">6.2.</span> <span class="toc-text">2、持久化之RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89rdbSave-%E5%92%8C-rdbLoad"><span class="toc-number">6.2.1.</span> <span class="toc-text">（1）rdbSave 和 rdbLoad</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89SAVE-%E3%80%81BGSAVE-%E3%80%81AOF-%E5%86%99%E5%85%A5%E5%92%8C-BGREWRITEAOF"><span class="toc-number">6.2.2.</span> <span class="toc-text">（2）SAVE 、BGSAVE 、AOF 写入和 BGREWRITEAOF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.3.</span> <span class="toc-text">（3）RDB文件结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.4.</span> <span class="toc-text">（4）触发机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF"><span class="toc-number">6.3.</span> <span class="toc-text">3、持久化之AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89AOF%E9%87%8D%E5%86%99%E5%92%8CAOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99"><span class="toc-number">6.3.1.</span> <span class="toc-text">（1）AOF重写和AOF后台重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81RDB%E5%92%8CAOF%E6%89%A9%E5%B1%95"><span class="toc-number">6.4.</span> <span class="toc-text">4、RDB和AOF扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">5、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.1.</span> <span class="toc-text">（1）文件事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">6.5.2.</span> <span class="toc-text">（2）时间事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">6.6.</span> <span class="toc-text">6、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.1 概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">6.2 集群环境模拟测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">6.6.3.</span> <span class="toc-text">6.3 主从复制的复制原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.4.</span> <span class="toc-text">6.4 哨兵模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.7.</span> <span class="toc-text">7、Redis缓存穿透和雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.7.1.</span> <span class="toc-text">7.1 缓存穿透</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.7.2.</span> <span class="toc-text">7.2 缓存击穿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.7.3.</span> <span class="toc-text">7.3 缓存雪崩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">7.</span> <span class="toc-text">六、使用Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AERedis%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">1、安装配置Redis以及常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">7.1.1.</span> <span class="toc-text">1）安装和配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.1.2.</span> <span class="toc-text">2）常用命令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">7.2.</span> <span class="toc-text">2、使用Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81String%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">1、String类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">2、Hash类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81List%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.3.</span> <span class="toc-text">3、List类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.4.</span> <span class="toc-text">4、Set类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81Zset%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">7.2.5.</span> <span class="toc-text">5、Zset类型（有序集合）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81Geospatial%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">7.2.6.</span> <span class="toc-text">6、Geospatial地理位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81Hyperloglog"><span class="toc-number">7.2.7.</span> <span class="toc-text">7、Hyperloglog</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81Bitmaps"><span class="toc-number">7.2.8.</span> <span class="toc-text">8、Bitmaps</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81Jedis"><span class="toc-number">7.2.9.</span> <span class="toc-text">9、Jedis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81SpringBoot%E6%95%B4%E5%90%88Redis"><span class="toc-number">7.2.10.</span> <span class="toc-text">10、SpringBoot整合Redis</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81Redis-conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">7.2.11.</span> <span class="toc-text">11、Redis.conf配置文件</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>