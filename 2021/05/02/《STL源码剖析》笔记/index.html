<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《STL源码剖析》笔记 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、容器概述1、容器的分类序列式容器、关联式容器   标准的STL关联式容器分为set（集合）和map（哈希表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器底层机制均以RB-Tree完成。此外，STL还提供了一个不在标准规格之列的关联式容器：hash table（散列表）、以及以此hash table为底层机制而完成的hash_set（散列集合">
<meta property="og:type" content="article">
<meta property="og:title" content="《STL源码剖析》笔记">
<meta property="og:url" content="https://varrella.github.io/2021/05/02/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="一、容器概述1、容器的分类序列式容器、关联式容器   标准的STL关联式容器分为set（集合）和map（哈希表）两大类，以及这两大类的衍生体multiset（多键集合）和multimap（多键映射表）。这些容器底层机制均以RB-Tree完成。此外，STL还提供了一个不在标准规格之列的关联式容器：hash table（散列表）、以及以此hash table为底层机制而完成的hash_set（散列集合">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___-33ZZ-YflN8___0___.jpg">
<meta property="article:published_time" content="2021-05-02T14:16:07.000Z">
<meta property="article:modified_time" content="2021-06-10T12:57:44.578Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___-33ZZ-YflN8___0___.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/05/02/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-10 20:57:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___-33ZZ-YflN8___0___.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《STL源码剖析》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-02T14:16:07.000Z" title="Created 2021-05-02 22:16:07">2021-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-10T12:57:44.578Z" title="Updated 2021-06-10 20:57:44">2021-06-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《STL源码剖析》笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="一、容器概述"><a href="#一、容器概述" class="headerlink" title="一、容器概述"></a>一、容器概述</h4><h5 id="1、容器的分类"><a href="#1、容器的分类" class="headerlink" title="1、容器的分类"></a>1、容器的分类</h5><p>序列式容器、关联式容器</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502223359.png" style="zoom:67%;" />

<p>标准的<code>STL</code>关联式容器分为<code>set</code>（集合）和<code>map</code>（哈希表）两大类，以及这两大类的衍生体<code>multiset</code>（多键集合）和<code>multimap</code>（多键映射表）。这些容器底层机制均以<code>RB-Tree</code>完成。此外，<code>STL</code>还提供了一个不在标准规格之列的关联式容器：<code>hash table</code>（散列表）、以及以此<code>hash table</code>为底层机制而完成的<code>hash_set</code>（散列集合）、<code>hash_map</code>（散列映射表）、<code>hash_multiset</code>（散列多键集合）、<code>hash_multimap</code>（散列多键映射表）。</p>
<h4 id="二、vector"><a href="#二、vector" class="headerlink" title="二、vector"></a>二、vector</h4><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><p><code>vector</code>的数据安排以及操作方式与<code>array</code>非常相似，两者的唯一差别在于空间运用的灵活性。<code>array</code>是静态空间，一旦配置了就不能改变，如果需要更大的空间，则需要首先配置一块新空间，然后将元素从旧地址复制到新地址中，然后释放原来的空间。<code>vector</code>是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。</p>
<p>动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。</p>
<p><code>vector</code>容器对象的大小在32位机器中是12字节，即<code>vector</code>中三个指针的大小。</p>
<p><code>public</code>继承是一种<code>is a</code>的关系</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502225130.png" style="zoom:67%;" />

<h5 id="2、vector-的数据结构"><a href="#2、vector-的数据结构" class="headerlink" title="2、vector 的数据结构"></a>2、vector 的数据结构</h5><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210503223933.png" style="zoom: 60%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数,允许指定vector大小和初始值value</span></span><br><span class="line">    <span class="built_in">vector</span>() :<span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">vector</span>() &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">        <span class="built_in">deallocate</span>();  <span class="comment">// vector成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 第一个元素</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="comment">// 最后一个元素</span></span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; <span class="comment">// 将元素插入至最尾端</span></span><br><span class="line">        <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish, x);</span><br><span class="line">            ++finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">// vector的成员函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; <span class="comment">// 将最尾端元素取出</span></span><br><span class="line">        --finish;</span><br><span class="line">        <span class="built_in">destroy</span>(finish);  <span class="comment">//全局函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除某个位置上的元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) &#123; <span class="comment">// 后续元素前移</span></span><br><span class="line">            <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position); <span class="comment">// 全局函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        --finish;</span><br><span class="line">        <span class="built_in">destroy</span>(finish);</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除[first, last)中的所有元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">        iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">        <span class="built_in">destroy</span>(i, finish);</span><br><span class="line">        finish = finish - (last - first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">// 从position开始插入n个元素，初始值为x</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator position, size_type n, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start) &#123;</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 填充并初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">        finish = start + n;</span><br><span class="line">        end_of_storage = finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置空间并填满内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        iterator result = data_allocator::<span class="built_in">allocate</span>(n); <span class="comment">// 配置n个元素空间</span></span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(result, n, x);  <span class="comment">// 全局函数</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123; <span class="comment">// 如果还有备用空间</span></span><br><span class="line">        <span class="comment">// 在备用空间起始处构造一个元素，并以vector最后一个元素值为其初值</span></span><br><span class="line">        <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *position = x_copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 已无备用空间</span></span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 配置规则：如果原大小为0，则配置为1</span></span><br><span class="line">        <span class="comment">// 如果原大小不为0，则2倍扩容，前半段用来放原始数据，后半段用来放新数据</span></span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">        iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将原vector的内容拷贝到新vector</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">            <span class="comment">// 为新元素设定初始值</span></span><br><span class="line">            <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">            ++new_finish;</span><br><span class="line">            <span class="comment">// 将原vector的备用空间中的内容也拷贝过来</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">            <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">            data_allocator::<span class="built_in">allocate</span>(new_start, len);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 析构并释放原vector</span></span><br><span class="line">        <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">        <span class="comment">// 调整迭代器，指向新vector</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果备用空间大于等于新增元素的个数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) &#123;</span><br><span class="line">            T x_copy = x;</span><br><span class="line">            <span class="comment">// 以下计算插入点之后的现有元素个数</span></span><br><span class="line">            <span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">            iterator old_finish = finish;</span><br><span class="line">            <span class="comment">// 插入点之后的现有元素个数大于新增元素的个数</span></span><br><span class="line">            <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">                <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);</span><br><span class="line">                finish += n;</span><br><span class="line">                <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);</span><br><span class="line">                <span class="built_in">fill</span>(position, position + n, x_copy); <span class="comment">// 从插入点开始填入新值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x_copy);</span><br><span class="line">                finish += n - elems_after;</span><br><span class="line">                <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">                finish += elems_after;</span><br><span class="line">                <span class="built_in">fill</span>(position, old_finish, x_copy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果备用空间小于新增元素的个数，则必须配置额外的内存</span></span><br><span class="line">        <span class="comment">// 首先决定新长度：旧长度的两倍，或旧长度+新增元素的个数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">            <span class="comment">// 配置新的vector空间</span></span><br><span class="line">            iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">            iterator new_finish = new_start;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                 <span class="comment">// 将vector的插入点之前的元素拷贝到新空间</span></span><br><span class="line">                new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">                 <span class="comment">// 将新增的元素（初始值皆为n），填入新空间</span></span><br><span class="line">                new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x);</span><br><span class="line">                 <span class="comment">// 将vector的插入点之后的元素拷贝到新空间</span></span><br><span class="line">                new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">            &#125;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">            <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">                <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">                data_allocator::<span class="built_in">allocate</span>(new_start, len);</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>        </span></span><br><span class="line">            <span class="comment">// 析构并释放原vector</span></span><br><span class="line">            <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">            <span class="built_in">deallocate</span>();</span><br><span class="line">            <span class="comment">// 调整迭代器，指向新vector</span></span><br><span class="line">            start = new_start;</span><br><span class="line">            finish = new_finish;</span><br><span class="line">            end_of_storage = new_start + len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、list"><a href="#三、list" class="headerlink" title="三、list"></a>三、list</h4><p><code>list</code>是一个双向链表，插入操作和接合操作都不会改变原有的<code>list</code>迭代器，甚至list的元素的删除操作也只有“指向被删除的元素”的那个迭代器失效，其他迭代器不受影响。</p>
<h5 id="1、List-的节点（node）"><a href="#1、List-的节点（node）" class="headerlink" title="1、List 的节点（node）"></a>1、List 的节点（node）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;   <span class="comment">//指向前驱节点</span></span><br><span class="line">    void_pointer next;   <span class="comment">//指向后继节点</span></span><br><span class="line">    T data;              <span class="comment">//数据域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、List-迭代器"><a href="#2、List-迭代器" class="headerlink" title="2、List 迭代器"></a>2、List 迭代器</h5><p>让指针<code>node</code>指向刻意置于尾端的一个空白节点，<code>node</code>便能轻易完成几个常用的函数。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210503203004.png" style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line"></span><br><span class="line">    link_type node;   <span class="comment">// 迭代器内部一个普通指针，4字节大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    __list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">    __list_iterator() &#123;&#125;</span><br><span class="line">    __list_iterator(<span class="keyword">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运算符重载</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node == x.node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node != x.node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对迭代器取值，取的是节点的数据值</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> (*node).data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对迭代器取值，取的是成员</span></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对迭代器加1，就是前进一个节点</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        node = (link_type)(*(node).next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++* <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对迭代器减1，就是后退一个节点</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        node = (link_type)(*(node).prev);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --* <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他函数操作</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type)(*(node).next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;next == node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(--<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入一个节点，作为头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">begin</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入一个节点，作为尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除尾节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iterator tmp = <span class="built_in">end</span>();</span><br><span class="line">        <span class="built_in">erase</span>(--tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除迭代器position所指向的节点</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        link_type next_node = (link_type)(position.node-&gt;next);</span><br><span class="line">        link_type prev_node = (link_type)(position.node-&gt;prev);</span><br><span class="line">        prev_node-&gt;next = next_node;</span><br><span class="line">        next_node-&gt;prev = prev_node;</span><br><span class="line">        <span class="built_in">destroy_node</span>(position.node);  <span class="comment">// 其中调用destroy全局函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将[first, last)内的素有元素移动到position之前，transfer为非公开接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position != last) &#123;</span><br><span class="line">            (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node;</span><br><span class="line">            (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node;</span><br><span class="line">            (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node;</span><br><span class="line">            link_type tmp = <span class="built_in">link_type</span>((*position.node).prev);</span><br><span class="line">            (*position.node).prev = (*last.node).prev</span><br><span class="line">            (*last.node).prev = (*first.node).prev;</span><br><span class="line">            (*first.node).prev = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公开的接口为splice，将x接合于position所指的位置之前</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iteration position, list&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、List-的数据结构"><a href="#3、List-的数据结构" class="headerlink" title="3、List 的数据结构"></a>3、List 的数据结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc&gt; <span class="comment">// 缺省使用alloc为配置器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;   <span class="comment">// 代表整个class大小即为4字节</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;     <span class="comment">// 清除所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>; <span class="comment">// 将数值是value的所有元素移除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>; <span class="comment">// 移除数值相同的连续元素至只剩一个</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(list&lt;T, Alloc&gt;&amp; x)</span></span>;<span class="comment">// 将x合并到this身上，两个list的内容必须先经过递增顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;   <span class="comment">// 将*this的内容逆置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;      <span class="comment">// list不能使用stl算法sort()，必须使用自己的成员函数sort()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T, Alloc&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    link_type cur = (link_type)(*(node).next);</span><br><span class="line">    <span class="keyword">while</span> (cur != node) &#123;</span><br><span class="line">        link_type tmp = cur;</span><br><span class="line">        cur = (link_type)cur-&gt;next;</span><br><span class="line">        <span class="built_in">destroy_node</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复node原始状态</span></span><br><span class="line">    node-&gt;prev = node;</span><br><span class="line">    node-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        iterator next = first; <span class="comment">// 记录下一个迭代器</span></span><br><span class="line">        ++next;</span><br><span class="line">        <span class="keyword">if</span> (*first == value) &#123; <span class="comment">//找到就移除</span></span><br><span class="line">            <span class="built_in">erase</span>(first);</span><br><span class="line">        &#125;</span><br><span class="line">        first = next;   <span class="comment">// first指向下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">if</span> (first == end) <span class="keyword">return</span>;</span><br><span class="line">    iterator next = first;</span><br><span class="line">    <span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first == *next) &#123; <span class="comment">//后一个元素和前一个相同，则移除</span></span><br><span class="line">            <span class="built_in">erase</span>(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 否则往后移一个</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125;</span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">    iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">    iterator last2 = x.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">// 这一步的前提是两个list都已经是递增有序的</span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">            iterator next = first2;</span><br><span class="line">            <span class="built_in">transfer</span>(first1, first2, ++next);</span><br><span class="line">            first2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++first1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first2 != last2) &#123;  <span class="comment">// 如果该链表还有剩余</span></span><br><span class="line">        <span class="built_in">transfer</span>(last1, first2, last2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果是空链表或仅有一个元素则不进行任何操作，也可用size()==1来判断，但速度较慢</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>()) &#123;</span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++first;</span><br><span class="line">        <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="comment">// 如果是空链表或仅有一个元素则不进行任何操作，也可用size()==1来判断，但速度较慢</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;T, Alloc&gt; carry;</span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);</span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == fill) &#123;</span><br><span class="line">            ++fill;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) &#123;</span><br><span class="line">        counter[i].<span class="built_in">merge</span>(counter[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(counter[fill - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、deque"><a href="#四、deque" class="headerlink" title="四、deque"></a>四、deque</h4><h5 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h5><p><code>deque</code>是一种双向开口的连续线性空间，可以再头尾两端进行元素的插入和删除操作。<code>deque</code>和<code>vector</code>的最大差异在于的确允许在常熟时间内对起头端进行元素的插入和删除操作，且<code>deque</code>没有容量（<code>capacity</code>）的概念，因为它是动态分段连续空间组合而成，随时可以增加一段新的空间并链接起来。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504183444.png" style="zoom:67%;" />

<h5 id="2、deque-的中控器"><a href="#2、deque-的中控器" class="headerlink" title="2、deque 的中控器"></a>2、deque 的中控器</h5><p><code>deque</code>采用一块所谓的<code>map</code>（即一块连续空间）最为主控，其中每个元素（节点，<code>node</code>）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区，缓冲区才是<code>deque</code>的储存空间主体，允许指定缓冲区的大小，默认值 0 表示将使用 512 字节缓冲区。也就是说，<code>map</code>其实是一个<code>T**</code>，即它是一个指针，所指向的又是一个指针，指向类型为<code>T</code>的一块空间。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504183942.png" style="zoom:67%;" />

<h5 id="3、deque-的迭代器"><a href="#3、deque-的迭代器" class="headerlink" title="3、deque 的迭代器"></a>3、deque 的迭代器</h5><p>deque迭代器本身的大小是16字节，有四个指针</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504203726.png" style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T,<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 决定缓冲区的大小，调用全局函数</span></span><br><span class="line">		<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in"><span class="keyword">sizeof</span></span>(T));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四个迭代器指针16字节	</span></span><br><span class="line">	T* cur;   <span class="comment">// 指向缓冲区中的现行（current）元素</span></span><br><span class="line">	T* first; <span class="comment">// 指向缓冲区中的头</span></span><br><span class="line">	T* last;  <span class="comment">// 指向缓冲区中的尾</span></span><br><span class="line">	map_pointer node;  <span class="comment">// 指向管控中心</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 跳一个缓冲区</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">		node = new_node;</span><br><span class="line">		first = *new_noded;</span><br><span class="line">		last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">	difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		++cur;   <span class="comment">// 切换至下一个元素</span></span><br><span class="line">		<span class="keyword">if</span> (cur == last) &#123; <span class="comment">// 如果已经到达缓冲区的尾端</span></span><br><span class="line">			<span class="built_in">set_node</span>(node + <span class="number">1</span>);  <span class="comment">// 切换至下一个节点（亦即缓冲区的第一个元素）</span></span><br><span class="line">			cur = first;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		++* <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur == first) &#123;  <span class="comment">// 如果已经到达缓冲区的头端</span></span><br><span class="line">			<span class="built_in">set_node</span>(node - <span class="number">1</span>);  <span class="comment">// 切换至前一个节点（亦即缓冲区的最后一个元素）</span></span><br><span class="line">			cur = last;</span><br><span class="line">		&#125;</span><br><span class="line">		--cur;   <span class="comment">// 切换至前一个元素</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		--* <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实现随机存取，迭代器可以直接跳跃n个距离</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">		difference_type offset = n + (cur - first);   <span class="comment">// 计算目标位置</span></span><br><span class="line">		<span class="comment">// 如果目标位置在同一个缓冲区中</span></span><br><span class="line">		<span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buff_size</span>())) &#123;</span><br><span class="line">			cur += n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果目标位置不在同一个缓冲区中</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buff_size</span>())</span><br><span class="line">				: -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buff_size</span>()) - <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">set_node</span>(node + node_offset); <span class="comment">// 切换至正确的节点（即缓冲区）</span></span><br><span class="line">			cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buff_size</span>()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span> += -n;  <span class="comment">// 调用 operator+=完成operator-=</span></span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp += n;     <span class="comment">// 调用 operator+=</span></span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> tmp -= n;     <span class="comment">// 调用 operator-=</span></span><br><span class="line">	&#125;</span><br><span class="line">	reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *(*<span class="keyword">this</span> + n);  <span class="comment">// 调用operator*、operator+</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	<span class="comment">// n不为0，传回n，标示buffer_size由用户自定义</span></span><br><span class="line">	<span class="comment">// 如果n不为0，标示buffer_size使用默认值，那么：</span></span><br><span class="line">	<span class="comment">// 如果sz不小于512，传回1；否则，传回512/sz</span></span><br><span class="line">	<span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、deque-的数据结构"><a href="#4、deque-的数据结构" class="headerlink" title="4、deque 的数据结构"></a>4、deque 的数据结构</h5><p><code>deque</code> 除了维护一个指向<code>map</code>的指针外，也维护<code>start</code>、<code>finish</code>两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一个位置）。它当然也必须记住<code>map</code>的大小，一旦<code>map</code>所提供的的节点不足，就必须重新配置更大的一块<code>map</code>。当创建一个<code>deque</code>的时候，对象本身占<code>40</code>个字节大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line">class deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;  <span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">typedef</span> pointer* map_pointer;  <span class="comment">// 元素的指针的指针</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// deque对象一共占40个字节</span></span><br><span class="line">	iterator start;     <span class="comment">// 指向第一个节点的迭代器，占16字节</span></span><br><span class="line">	iterator finish;    <span class="comment">// 指向最后一个节点，占16字节</span></span><br><span class="line">	map_pointer map;    <span class="comment">// 指向map，map是块连续的空间，其每个元素都是指针，指向一个节点（缓冲区），占4字节</span></span><br><span class="line">	size_type map_size; <span class="comment">// map内有多少指针，占4字节</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">		<span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">// 调用__deque_iterator::operator[]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;  <span class="comment">// 调用__deque_iterator::operator*</span></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		iterator tmp = finish;   <span class="comment">// 调用__deque_iterator::operator--</span></span><br><span class="line">		--tmp; <span class="keyword">return</span> *tmp;       <span class="comment">// 调用__deque_iterator::operator*</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">	<span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 的确定义了两个专属的空间配置器</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br><span class="line">	<span class="comment">// 产生并安排好deque的结构，并将元素的初始值设置妥当</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">create_map_and_nodes</span><span class="params">(size_type num_elements)</span></span>;</span><br><span class="line">	<span class="built_in">deque</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back_aux</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 最后缓冲区尚有一个以上的备用空间</span></span><br><span class="line">		<span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">construct</span>(finish.cur, t); <span class="comment">// 直接在备用空间上构造元素</span></span><br><span class="line">			++finish.cur; <span class="comment">// 调整最后缓冲区的使用状态</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最后缓冲区已无（或只剩一个）元素备用空间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">push_back_aux</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front_aux</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 第一缓冲区尚有一个以上的备用空间</span></span><br><span class="line">		<span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">			<span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t); <span class="comment">// 直接在备用空间上构造元素</span></span><br><span class="line">			--start.cur; <span class="comment">// 调整第一缓冲区的使用状态</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第一缓冲区已无元素备用空间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">push_front_aux</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front_aux</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//第一缓冲区有一个(或更多)元素</span></span><br><span class="line">			<span class="built_in">destroy</span>(start.cur);  <span class="comment">//将第一元素析构</span></span><br><span class="line">			++start.cur;         <span class="comment">//调整指针，相当于排除了第一元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//第一缓冲区仅有一个元素</span></span><br><span class="line">			<span class="built_in">pop_front_aux</span>();   <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back_aux</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">			<span class="comment">//最后缓冲区有一个(或更多)元素			</span></span><br><span class="line">			--finish.cur;         <span class="comment">//调整指针，相当于排除了最后元素</span></span><br><span class="line">			<span class="built_in">destroy</span>(finish.cur);  <span class="comment">//将最后元素析构</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//最后缓冲区仅有一个元素</span></span><br><span class="line">			<span class="built_in">pop_back_aux</span>();   <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清除整个deque，deque的最初状态保有一个缓冲区，clear完成之后回复最初状态</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// erase用来清除[first, last)区间内的所有元素</span></span><br><span class="line">	<span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">	<span class="comment">// erase用来清除某个元素，pos为清除点</span></span><br><span class="line">	<span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">		iterator next = pos;</span><br><span class="line">		++next;</span><br><span class="line">		difference_type index = pos - start; <span class="comment">// 清除点之前的元素个数</span></span><br><span class="line">		<span class="comment">//如果清除点之前的元素比较少，就移动清除点之前的元素</span></span><br><span class="line">		<span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;  </span><br><span class="line">			<span class="built_in">copy_backward</span>(start, pos, next);</span><br><span class="line">			<span class="built_in">pop_front</span>();  <span class="comment">//移动完毕，最前一个元素冗余，去除之</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果清除点之后的元素比较少，就移动清除点之后的元素</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">copy</span>(next, finish, pos);</span><br><span class="line">			<span class="built_in">pop_back</span>();		<span class="comment">//移动完毕，最后一个元素冗余，去除之</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start + index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 允许在某个点之前插入某个元素并设定其值</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert_aux</span><span class="params">(iterator pos, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">	<span class="comment">// 允许在某个点之前插入某个元素并设定其值</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果插入点是deque的最前端</span></span><br><span class="line">		<span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">			<span class="built_in">push_front</span>(x);</span><br><span class="line">			<span class="keyword">return</span> start;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果插入点是deque的最尾端</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">			<span class="built_in">push_back</span>(x);</span><br><span class="line">			iterator tmp = finish;</span><br><span class="line">			--tmp;</span><br><span class="line">			<span class="keyword">return</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断何时map需要重新整治	</span></span><br><span class="line">	<span class="built_in">reserve_map_at_back</span>(size_type nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map)) &#123;</span><br><span class="line">			<span class="comment">// 如果map尾端的节点备用空间不足，符合以上条件必须重换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">			<span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reserve_map_at_front</span>(size_type nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes_to_add &gt; start, node - map) &#123;</span><br><span class="line">			<span class="comment">// 如果map前端的节点备用空间不足，符合以上条件必须重换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">			<span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reallocate_map</span><span class="params">(size_type nodes_to_add, <span class="keyword">bool</span> add_at_front)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="keyword">const</span> value_type&amp; value) &#123;</span><br><span class="line">	<span class="built_in">create_map_and_nodes</span>(n);</span><br><span class="line">	map_pointer cur;</span><br><span class="line">	__STL_TRY&#123;</span><br><span class="line">		<span class="comment">// 为每个节点的缓冲区设置初始值</span></span><br><span class="line">		<span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur) &#123;</span><br><span class="line">			<span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最后一个节点的设定稍有不同，因为尾端可能有备用空间，不必设置初始值</span></span><br><span class="line">		<span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) &#123;</span><br><span class="line">	<span class="comment">// 需要的节点数 = （元素个数 、 每个缓冲区可容纳的元素个数） + 1</span></span><br><span class="line">	<span class="comment">// 如果刚好整除，会多分配一个节点</span></span><br><span class="line">	size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 一个map要管理最少8个节点，最多“所需的节点数+2”个节点（前后各预留一个，扩充时可用）</span></span><br><span class="line">	map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">	map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line">	<span class="comment">// 以上分配出一个“具有map_size个节点“的map</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 令nstart和nfinish指向map所拥有的全部节点的最中央区段</span></span><br><span class="line">	<span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大，每个节点可对应一个缓冲区</span></span><br><span class="line">	map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">	map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	map_pointer cur;</span><br><span class="line">	__STL_TRY&#123;</span><br><span class="line">		<span class="comment">// 为map中的每个节点配置缓冲区，所有缓冲区加起来就是deque的可用空间（最后一个缓冲区可能留有富余）</span></span><br><span class="line">		<span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur) &#123;</span><br><span class="line">			*cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 最后一个节点的设定稍有不同，因为尾端可能有备用空间，不必设置初始值</span></span><br><span class="line">	<span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为deque内的两个迭代器start和finish设定正确内容</span></span><br><span class="line">	start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">	finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">	start.cur = start.first;</span><br><span class="line">	finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add, <span class="keyword">bool</span> add_at_front) &#123;</span><br><span class="line">	size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">	size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">	map_pointer new_nstart;</span><br><span class="line">	<span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">		new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span> +</span><br><span class="line">			(add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (new_nstart &lt; start.node) &#123;</span><br><span class="line">			<span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">		&#125;</span><br><span class="line">		e1se&#123;</span><br><span class="line">			<span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//配置一块空间，准备给新map使用</span></span><br><span class="line">		map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">		new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> +</span><br><span class="line">			(add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//把原map内容拷贝过来</span></span><br><span class="line">		<span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">		<span class="comment">//释放原map</span></span><br><span class="line">		map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">		<span class="comment">//设定新map的起始地址与大小</span></span><br><span class="line">		map = new_map;</span><br><span class="line">		map_size = new_map_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重新设定迭代器start和finish </span></span><br><span class="line">	start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">	finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">	value_type t_vopy = t;</span><br><span class="line">	<span class="built_in">reserve_map_at_back</span>();</span><br><span class="line">	*(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>();  <span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">	__STL_TRY&#123;</span><br><span class="line">		<span class="built_in">construct</span>(finish.cur, t_copy);     <span class="comment">// 针对标的元素设置</span></span><br><span class="line">		finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>);  <span class="comment">// 改变finish，令其指向新节点</span></span><br><span class="line">		finish.cur = finish.first;         <span class="comment">// 设定finish的状态</span></span><br><span class="line">	&#125;</span><br><span class="line">	__STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + !)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">	value_type t_vopy = t;</span><br><span class="line">	<span class="built_in">reserve_map_at_front</span>();</span><br><span class="line">	*(start.node - <span class="number">1</span>) = <span class="built_in">allocate_node</span>(); <span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">	__STL_TRY&#123;</span><br><span class="line">		start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>);  <span class="comment">// 改变start，令其指向新节点</span></span><br><span class="line">		start.cur = start.last - <span class="number">1</span>;      <span class="comment">// 设定start的状态</span></span><br><span class="line">		<span class="built_in">construct</span>(start.cur, t_copy);    <span class="comment">// 针对标的元素设置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">		start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);  </span><br><span class="line">		start.cur = start.first;      </span><br><span class="line">		<span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">throw</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>() &#123;</span><br><span class="line">	<span class="built_in">destroy</span>(start.cur);               <span class="comment">//将第一缓冲区的第一个元素析构</span></span><br><span class="line">	<span class="built_in">deallocate_node</span>(start.first);     <span class="comment">//释放第一缓冲区</span></span><br><span class="line">	start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);   <span class="comment">//调整start的状态，使指向</span></span><br><span class="line">	start.cur = start.first;          <span class="comment">//下一个缓冲区的第一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_back_aux</span>() &#123;</span><br><span class="line">	<span class="built_in">deallocate_node</span>(finish.first);     <span class="comment">//释放最后一个缓冲区</span></span><br><span class="line">	finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);  <span class="comment">//调整finish的状态，使指向</span></span><br><span class="line">	finish.cur = finish.last <span class="number">-1</span>;       <span class="comment">//上一个缓冲区的最后一个元素</span></span><br><span class="line">	<span class="built_in">destroy</span>(finish.cur);               <span class="comment">//将该元素析构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">	<span class="comment">//以下针对头尾以外的每一个缓冲区(它们一定都是饱满的)</span></span><br><span class="line">	<span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">		<span class="comment">//将缓冲区内的所有元素析构 </span></span><br><span class="line">		<span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line">		<span class="comment">//释放缓冲区内存</span></span><br><span class="line">		data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (start.node != finish.node) &#123; <span class="comment">// 至少有头尾两个缓冲区</span></span><br><span class="line">		<span class="built_in">destroy</span>(start.cur, start.last); <span class="comment">// 将头缓冲区的目前所有元素析构 </span></span><br><span class="line">		<span class="built_in">destroy</span>(finish.first, finish.cur); <span class="comment">// 将尾缓冲区的目前所有元素析构</span></span><br><span class="line">		<span class="comment">//以下释放尾缓冲区。注意，头缓冲区保留</span></span><br><span class="line">		data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//只有一个缓冲区</span></span><br><span class="line">		<span class="built_in">destroy</span>(start.cur, finish.cur); <span class="comment">// 将此唯一缓冲区内的所有元素析构</span></span><br><span class="line">	    <span class="comment">//注意，并不释放缓冲区空间。这唯一的缓冲区将保留</span></span><br><span class="line">	&#125;</span><br><span class="line">	finish = start; <span class="comment">//调整状态</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last)&#123;</span><br><span class="line">	<span class="comment">// 如果清除区间就是整个deque，直接调用clear()即可</span></span><br><span class="line">	<span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;</span><br><span class="line">		<span class="built_in">c1ear</span>();</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		difference_type n = last - first;   <span class="comment">//清除区间的长度</span></span><br><span class="line">		difference_type elems_before = first - start;  <span class="comment">//清除区间前方的元素个数</span></span><br><span class="line">		<span class="comment">//如果前方的元素比较少</span></span><br><span class="line">		<span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">copy_backward</span>(start, first, last);  <span class="comment">//向后移动前方元素(覆盖清除区间)</span></span><br><span class="line">			iterator new_start = start + n;     <span class="comment">//标记deque的新起点</span></span><br><span class="line">			<span class="built_in">destroy</span>(start, new_start);  <span class="comment">//移动完毕，将冗余的元素析构</span></span><br><span class="line">			<span class="comment">// 以下将冗余 的缓冲区释放</span></span><br><span class="line">			<span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) &#123;</span><br><span class="line">				data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">			&#125;		</span><br><span class="line">			start = new_start;  <span class="comment">//设定deque的新起点</span></span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">//如果清除区间后方的元素比较少</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">copy</span>(last, finish, first);        <span class="comment">//向前移动后方元素(覆盖清除区间)</span></span><br><span class="line">			iterator new_finish = finish - n; <span class="comment">//标记deque的新尾点</span></span><br><span class="line">			<span class="built_in">destroy</span>(new_finish, finish);      <span class="comment">//移动完毕，将冗余的元素析构</span></span><br><span class="line">			<span class="comment">//以下将冗余的缓冲区释放</span></span><br><span class="line">			<span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur) &#123;</span><br><span class="line">				data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">			&#125;</span><br><span class="line">			finish = new_finish;<span class="comment">//设定deque的新尾点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> start + e1ems_before;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">	difference_type index = pos - start; <span class="comment">//插人点之前的元素个数</span></span><br><span class="line">	value_type x_copy = x;</span><br><span class="line">	<span class="comment">// 如果插人点之前的元素个数比较少</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="function">push_ <span class="title">front</span><span class="params">(front())</span></span>;     <span class="comment">//在最前端加人与第一元素同値的元素</span></span><br><span class="line">		iterator front1 = start;  <span class="comment">//以下示示記号，然后迸行元素移幼</span></span><br><span class="line">		++front1;</span><br><span class="line">		iterator front2 = front1;</span><br><span class="line">		++front2;</span><br><span class="line">		pos = start + index;</span><br><span class="line">		iterator pos1 = pos;</span><br><span class="line">		++pos1;</span><br><span class="line">		<span class="built_in">copy</span>(front2, pos1, front1);  <span class="comment">//元素移幼</span></span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="comment">// 插人点之后的元素个数比较少</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		push_ <span class="built_in">back</span>(<span class="built_in">back</span>());   <span class="comment">//在最尾端加人与最后元素同値的元素</span></span><br><span class="line">		iterator back1 = finish;  <span class="comment">//以下柝示己号，然后迸行元素移劫</span></span><br><span class="line">		--back1;</span><br><span class="line">		iterator back2 = back1;</span><br><span class="line">		--back2;</span><br><span class="line">		pos = start + index;</span><br><span class="line">		<span class="built_in">copy_backward</span>(pos, back2, back1);   <span class="comment">//元素移幼</span></span><br><span class="line">	&#125;</span><br><span class="line">	*pos = x_copy; <span class="comment">// 在插人点上没定新値 </span></span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="五、stack（配接器）"><a href="#五、stack（配接器）" class="headerlink" title="五、stack（配接器）"></a>五、stack（配接器）</h4><p><code>stack</code>是一种先进后出（<code>FILO</code>）的数据结构，允许新增元素、移除元素、取得最顶端元素，但没办法存取<code>stack</code>其他元素，即<code>stack</code>不允许有遍历行为，因此<code>stack</code>没有迭代器。</p>
<p>【注】除了<code>deque</code>之外，list也是双向开口的数据结构，若以<code>list</code>作为底层容器也能实现一个<code>stack</code>。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504104227.png" style="zoom:67%;" />

<h5 id="1、以-deque-作为底层容器"><a href="#1、以-deque-作为底层容器" class="headerlink" title="1、以 deque 作为底层容器"></a>1、以 deque 作为底层容器</h5><p><code>deque</code>是双向开口的数据结构，若以<code>deque</code>为底部结构并封闭其头端开口，便形成了一个<code>stack</code>。</p>
<p>【注】除了<code>deque</code>之外，<code>list</code>也是双向开口的数据结构，若以list作为底层容器也能实现一个<code>stack</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> stack&amp; x, <span class="keyword">const</span> stack&amp; y);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> stack&amp; x, <span class="keyword">const</span> stack&amp; y);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;   <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">// 以下完全利用Sequence c的操作，完成stack的操作</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> valut_type&amp; x)</span> </span>&#123;</span><br><span class="line">		c.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		c.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="六、queue（配接器）"><a href="#六、queue（配接器）" class="headerlink" title="六、queue（配接器）"></a>六、queue（配接器）</h4><p><code>queue</code>是一种先进先出（<code>FIFO</code>）的数据结构，允许新增元素、移除元素、从最底端加入元素、取得最顶端的元素，除此之外没有其他办法可以存取<code>queue</code>的其他元素，即<code>queue</code>不允许有遍历行为，因此<code>queue</code>没有迭代器。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504104207.png" style="zoom:67%;" />

<h5 id="1、以-deque-作为底层容器-1"><a href="#1、以-deque-作为底层容器-1" class="headerlink" title="1、以 deque 作为底层容器"></a>1、以 deque 作为底层容器</h5><p><code>deque</code>是双向开口的数据结构，若以<code>deque</code>为底部结构并封闭其底端的出口和前端的入口，便形成了一个<code>queue</code>。</p>
<p>【注】除了<code>deque</code>之外，<code>list</code>也是双向开口的数据结构，若以<code>list</code>作为底层容器也能实现一个<code>queue</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> queue&amp; x, <span class="keyword">const</span> queue&amp; y);</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> queue&amp; x, <span class="keyword">const</span> queue&amp; y);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;   <span class="comment">// 底层容器</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">// 以下完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// queue是末端进，前端出</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> valut_type&amp; x)</span> </span>&#123;</span><br><span class="line">		c.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		c.<span class="built_in">pop_front</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、heap"><a href="#七、heap" class="headerlink" title="七、heap"></a>七、heap</h4><p><code>heap</code>并不属于STL容器组件，它是<code>priority queue</code>的助手。<code>priority queue</code>允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先权最高的元素开始取，<code>binary max heap</code>正式具有这样的特性，适合作为<code>priority queue</code>的底层机制。</p>
<p>若使用<code>list</code>作为<code>priority queue</code>的底层机制，那么元素插入可以是常数时间，但是要找到list中的极值，需要对整个<code>list</code>进行线性扫描；若使用<code>binary search tree</code>（如<code>RB-tree</code>）作为<code>priority queue</code>的底层机制，那么元素的插入和极值的取得均为<code>O(logN)</code>的表现，但<code>binary search tree</code>的输入需要足够的随机性，且<code>binary search tree</code>并不容易实现。</p>
<p><code>priority queue</code>的复杂度最好介于<code>queue</code>和<code>binary search tree</code>之间，因此采用<code>binary heap</code>，<code>binary heap</code>就是一种<code>complete binary tree</code>（完全二叉树）。可以利用<code>vector</code>来存储所有节点，保留 0 位置的元素来保证下标一致，假设某个节点位于<code>i</code> 处，其左子节点必然处于 <code>2i</code> 处，右子节点必然处于 <code>2i+1</code> 处，其父节点必然处于 <code>i/2</code> 处。</p>
<p>根据元素的排列方式，<code>heap</code>可以分为<code>max-heap</code>和<code>min-heap</code>，前者每个节点的键值都大于等于其子节点的键值，最大值在根节点；后者每个节点的键值都小于等于其子节点的键值，最小值在根节点。</p>
<h5 id="1、heap-算法"><a href="#1、heap-算法" class="headerlink" title="1、heap 算法"></a>1、heap 算法</h5><h6 id="（1）push-heap-算法"><a href="#（1）push-heap-算法" class="headerlink" title="（1）push_heap 算法"></a>（1）push_heap 算法</h6><p>为了满足完全二叉树的条件，新加入的元素一定要放在最下一层作为叶节点，也就是把新元素插入到<code>vector</code>的<code>end()</code>处，为了让新元素满足<code>max-heap</code>的条件，执行<code>percolate up</code>（上溯）操作，将新节点和父节点进行比较，如果其键值比父节点大，就交换两个节点的位置，如此一直上溯，直到不需要对换或直到根节点为止。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504121642.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 此函数被调用时，新元素应已置于底部容器的最尾端</span></span><br><span class="line">	__push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) &#123;</span><br><span class="line">	<span class="comment">// 容器最尾端，此即第一个洞号：(last - first) - 1)</span></span><br><span class="line">	__push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value) &#123;</span><br><span class="line">	Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 找出父节点</span></span><br><span class="line">	<span class="comment">// 当尚未到达顶端，且父节点小于新值，进行上溯</span></span><br><span class="line">	<span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">		*(first + holeIndex) = *(frist + parent); <span class="comment">// 令洞值为父值</span></span><br><span class="line">		holeIndex = parent;           <span class="comment">// 上溯，调整洞号，向上提升至父节点</span></span><br><span class="line">		parent= (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 新洞的父节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	*(first + holeIndex) = value;     <span class="comment">// 令洞值为新值，完成插入操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="（2）pop-heap-算法"><a href="#（2）pop-heap-算法" class="headerlink" title="（2）pop_heap 算法"></a>（2）pop_heap 算法</h6><p><code>pop</code>操作取走根节点（其实是移至容器<code>vector</code>的最后一个元素）之后，为了满足完全二叉树的条件，必须将最下一层最右边的叶节点拿掉，执行下溯操作，将根节点（最大值被取走后，形成一个“洞”）填入叶节点值，再将它拿来和其两个子节点比较键值，并与较大子节点对调位置，如此一直下溯，直到这个“洞”的键值大于左右两个子节点，或直接下溯到叶节点为止。</p>
<p><code>pop_heap</code>之后，最大元素只是被置于底部容器的最尾端，尚未被取走，如果要取其值，可使用底部容器<code>vector</code>的<code>back()</code>操作函数，如果要移除它，可使用<code>vector</code>所提供的的<code>pop_back()</code>操作函数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504122107.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	__pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*) &#123;</span><br><span class="line">	__pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator result, T value, Distance*) &#123;</span><br><span class="line">	*result = *first; <span class="comment">// 设定尾值为首值，于是尾值即为要求的结果</span></span><br><span class="line">	<span class="comment">// 重新调整heap，洞号为0（即树根处），要调整的值为value</span></span><br><span class="line">	__adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value) &#123;</span><br><span class="line">	Distance topIndex = holeIndex;</span><br><span class="line">	Distance secondChild = <span class="number">2</span> * holdIndex + <span class="number">2</span>;  <span class="comment">// 洞节点的右子节点</span></span><br><span class="line">	<span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line">		<span class="comment">// 比较洞节点的左右两个子节点，secondChild指向值较大的一个子节点</span></span><br><span class="line">		<span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>))) &#123;</span><br><span class="line">			secondChild--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 下溯，令较大值为洞值，再令洞号下移到较大子节点处</span></span><br><span class="line">		*(first + holeIndex) = *(first + secondChild);</span><br><span class="line">		holeIndex = secondIndex;</span><br><span class="line">		<span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line">		secondChild = <span class="number">2</span> * secondChild + <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (secondChild == len) &#123; <span class="comment">// 没有右子节点，只有左子节点</span></span><br><span class="line">		*(first + holdIndex) = *(first + (secondChild - <span class="number">1</span>));</span><br><span class="line">		holdIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 也可以是 *(first + holdIndex) = value，将要调整的值填入洞内</span></span><br><span class="line">	__push_heap(first, holdIndex, topIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="（3）sort-heap-算法"><a href="#（3）sort-heap-算法" class="headerlink" title="（3）sort_heap 算法"></a>（3）sort_heap 算法</h6><p>既然每次<code>pop_heap</code>可获得<code>heap</code>中键值最大的元素，如果持续对整个<code>heap</code>做<code>pop_heap</code>操作，每次将操作范围从后向前缩减一个元素（因为<code>pop_heap</code>会把键值最大的元素放在底部容器的最尾端），当整个程序执行完成时，便有了一个递增序列。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504122255.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504122305.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 每次执行pop_heap()，极值都被放在尾端，一直下去最后即得排序结果</span></span><br><span class="line">	<span class="keyword">while</span> (last - firts &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">pop_heap</span>(first, last--);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="（4）make-heap-算法"><a href="#（4）make-heap-算法" class="headerlink" title="（4）make_heap 算法"></a>（4）make_heap 算法</h6><p>用来将一段现有的数据转化为一个<code>heap</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">	__make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*) &#123;</span><br><span class="line">	<span class="comment">// 如果长度为0或1，不必重新排列</span></span><br><span class="line">	<span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Distance len = last - first;</span><br><span class="line">	<span class="comment">// 找出第一个需要重排的子树头部，以parent标示出</span></span><br><span class="line">	Diatance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">// 重排为parent为首的子树，len是为了让__adjust_heap判断操作范围</span></span><br><span class="line">		__adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">		<span class="keyword">if</span> (parent == <span class="number">0</span>) &#123; <span class="comment">// 走完根节点，则结束</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		parent--;  <span class="comment">// （即将重排子树的）头部向前一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、priority-queue（配接器）"><a href="#八、priority-queue（配接器）" class="headerlink" title="八、priority_queue（配接器）"></a>八、priority_queue（配接器）</h4><p>只允许在底端加入元素，并从顶端取出元素，除此之外别无其他存取元素的途径。其内的元素并非按照被推入的次序排列，而是自动依照元素的权值排列，权值最高的排在最前面。缺省情况下的<code>priority_queue</code>是利用一个<code>max_heap</code>完成，<code>max_heap</code>是一个以<code>vector</code>表现的完全二叉树。<code>priority_queue</code>不提供遍历功能，即没有迭代器。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504162050.png" style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> vector&lt;T&gt;, </span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> Sequence::value_type&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;   <span class="comment">// 底层容器</span></span><br><span class="line">	Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	<span class="built_in">priority_queue</span>() :<span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="keyword">const</span> Compare&amp; x)</span> :c(), comp(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">	<span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="keyword">const</span> Compare&amp; x) : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123;</span><br><span class="line">		<span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">	<span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) : <span class="built_in">c</span>(first, last) &#123;</span><br><span class="line">		<span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 操作函数</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> valut_type&amp; x)</span> </span>&#123;</span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			<span class="comment">// push_heap是泛型算法，先利用底层容器的push_back()将元素推入末端，再重排heap</span></span><br><span class="line">			c.<span class="built_in">push_back</span>(x);</span><br><span class="line">			<span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">const</span> valut_type&amp; x)</span> </span>&#123;</span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			<span class="comment">// pop_heap是泛型算法，从heap内取出一个元素并不是真正将元素弹出，而是重排heap</span></span><br><span class="line">			<span class="comment">// 然后再以底层容器的pop_back()取得被弹出的元素			</span></span><br><span class="line">			<span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">			c.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="九、slist"><a href="#九、slist" class="headerlink" title="九、slist"></a>九、slist</h4><p><code>slist（single linked list）</code>是一种单向链表。<code>slist</code>和<code>list</code>的主要差别在于前者的迭代器属于单向的<code>Forward Iterator</code>，后者的迭代器属于双向的<code>Bidirectional Iterator</code>。<code>slist</code>相较于<code>list</code>的最大缺点就是<code>slist</code>没有任何方便的办法可以回头定出前一个位置，因此它必须从头找起，基于效率考虑，<code>slist</code>不提供<code>push_back()</code>，只提供<code>push_front()</code>，因此<code>slist</code>的元素次序会和元素插入进来的次序相反。</p>
<h5 id="1、slist的节点"><a href="#1、slist的节点" class="headerlink" title="1、slist的节点"></a>1、slist的节点</h5><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504164943.png" style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表的节点的基本结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_node_base</span> &#123;</span></span><br><span class="line">	__slist_node_base* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表的节点的结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_node</span> :</span> <span class="keyword">public</span> __slist_node_base &#123;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数：已知某一节点，插入新节点于其后</span></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link(__slist_node_base * prev_node, __slist_node_base* new_node) &#123;</span><br><span class="line">	new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">	prev_node-&gt;next = new_node;</span><br><span class="line">	<span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数：单向链表的大小</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __slist_size(__slist_node_base* node) &#123;</span><br><span class="line">	<span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; node != <span class="number">0</span>; node = node-&gt;next) &#123;</span><br><span class="line">		++result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、slist的迭代器"><a href="#2、slist的迭代器" class="headerlink" title="2、slist的迭代器"></a>2、slist的迭代器</h5><p>比较两个<code>slist</code>迭代器是否等同时（例如我们常在循环中比较某个迭代器是否等同于<code>slist.end()</code>，由于<code>__slist_iterator</code>并未对<code>operator==</code>实施重载，所以会调用<code>__slist_iterator_base::operator==</code>。根据其中的定义，两个<code>slist</code>是否等同，视其<code>__slist_node_base* node</code>是否等同而定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表的迭代器的基本结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_iterator_base</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">	__slist_node_base* node;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	__slist_iterator_base(__slist_node_base* x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">	<span class="comment">// 前进一个节点</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> __slist_iterator_base&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node == x.node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> __slist_iterator_base&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> node != x.node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表的迭代器的结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_iterator</span> :</span> <span class="keyword">public</span> __slist_iterator_base &#123;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line"></span><br><span class="line">	__slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125;</span><br><span class="line">	__slist_iterator() : __slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	__slist_iterator(<span class="keyword">const</span> iterator&amp; x) : __slist_iterator_base(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ((list_node*)node)-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		<span class="built_in">incr</span>();  <span class="comment">// 前进一个节点</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		self tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="built_in">incr</span>();    <span class="comment">// 前进一个节点</span></span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//没有实现operator--，因为这是一个forward iterator</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、slist的数据结构"><a href="#3、slist的数据结构" class="headerlink" title="3、slist的数据结构"></a>3、slist的数据结构</h5><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210504172854.png" style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">slist</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_node_base list_node_base;</span><br><span class="line">	<span class="keyword">typedef</span> __slist_iterator_base iterator_base;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> list_node* <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		list_node* node = list_node_allocator::<span class="built_in">allocate</span>(); <span class="comment">// 配置空间</span></span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			<span class="built_in">construct</span>(&amp;node-&gt;data,<span class="number">0</span>);</span><br><span class="line">			node-&gt;next = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(list_node_allocator::<span class="built_in">deallocate</span>(node));</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">destroy</span>(&amp;node-&gt;data);</span><br><span class="line">		list_node_allocator::<span class="built_in">deallocate</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	list_node_base head;   <span class="comment">// 头部，不是指针，是实物</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">slist</span>() &#123; head.next = <span class="number">0</span>; &#125;</span><br><span class="line">	~<span class="built_in">slist</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __slist_size(head.next);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head.next = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 两个slist互换，只要将head交换互指即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span> </span>&#123;</span><br><span class="line">		list_node_base* tmp = head.next;</span><br><span class="line">		head.next = L.head.next;</span><br><span class="line">		L.head.next = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取头部元素</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ((list_node*)head.next)-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从头部插入元素，新元素成为slist的第一个元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">		__slist_make_link(&amp;head, <span class="built_in">create_node</span>(x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从头部取走元素（并删除）</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		list_node* node = (list_node*)head.next;</span><br><span class="line">		head.next = node-&gt;next;</span><br><span class="line">		<span class="built_in">deatroy_node</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="十、树"><a href="#十、树" class="headerlink" title="十、树"></a>十、树</h4><h5 id="二叉搜索树（BST）的插入和删除："><a href="#二叉搜索树（BST）的插入和删除：" class="headerlink" title="二叉搜索树（BST）的插入和删除："></a>二叉搜索树（BST）的插入和删除：</h5><p>插入新元素时，可从根节点开始，插入元素比根节点小就向左递归，比根节点大就向右递归。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210506155013.png" style="zoom:67%;" />

<p>删除元素A时，如果A只有一个子节点，则直接将A的子节点连接到A的父节点，并将A删除；如果A有两个子节点，则就以右子树内的最小节点取代A。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210506155046.png" style="zoom: 80%;" />

<h5 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h5><p>平衡条件的建立是为了确保整棵树的深度为O(logN)。AVL Tree要求任何节点的左右子树高度相差最多1.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/05/02/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0/">https://varrella.github.io/2021/05/02/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___-33ZZ-YflN8___0___.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/03/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturedn-3840x2400-bg-d459300.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">web服务器项目整理</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">常见面试题整理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、容器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1、容器的分类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81vector"><span class="toc-number">2.</span> <span class="toc-text">二、vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81vector-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2、vector 的数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81list"><span class="toc-number">3.</span> <span class="toc-text">三、list</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81List-%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88node%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1、List 的节点（node）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81List-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2、List 迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81List-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">3、List 的数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81deque"><span class="toc-number">4.</span> <span class="toc-text">四、deque</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81deque-%E7%9A%84%E4%B8%AD%E6%8E%A7%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2、deque 的中控器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81deque-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">3、deque 的迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81deque-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">4、deque 的数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81stack%EF%BC%88%E9%85%8D%E6%8E%A5%E5%99%A8%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">五、stack（配接器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%A5-deque-%E4%BD%9C%E4%B8%BA%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">1、以 deque 作为底层容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81queue%EF%BC%88%E9%85%8D%E6%8E%A5%E5%99%A8%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">六、queue（配接器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%A5-deque-%E4%BD%9C%E4%B8%BA%E5%BA%95%E5%B1%82%E5%AE%B9%E5%99%A8-1"><span class="toc-number">6.1.</span> <span class="toc-text">1、以 deque 作为底层容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81heap"><span class="toc-number">7.</span> <span class="toc-text">七、heap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81heap-%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">1、heap 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89push-heap-%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.1.</span> <span class="toc-text">（1）push_heap 算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89pop-heap-%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">（2）pop_heap 算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89sort-heap-%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">（3）sort_heap 算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89make-heap-%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.4.</span> <span class="toc-text">（4）make_heap 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E3%80%81priority-queue%EF%BC%88%E9%85%8D%E6%8E%A5%E5%99%A8%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">八、priority_queue（配接器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9D%E3%80%81slist"><span class="toc-number">9.</span> <span class="toc-text">九、slist</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81slist%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">9.1.</span> <span class="toc-text">1、slist的节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81slist%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">9.2.</span> <span class="toc-text">2、slist的迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81slist%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.</span> <span class="toc-text">3、slist的数据结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">十、树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">二叉搜索树（BST）的插入和删除：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL-Tree%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">平衡二叉树（AVL Tree）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___-33ZZ-YflN8___0___.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>