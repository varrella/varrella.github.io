<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常见面试题整理 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、C++0、指针和引用的区别 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作 指针可以有多级，引用只有一级 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 指针可以为空，引用不可以。  1、在函数参数传递的">
<meta property="og:type" content="article">
<meta property="og:title" content="常见面试题整理">
<meta property="og:url" content="https://varrella.github.io/2021/05/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="一、C++0、指针和引用的区别 指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作 指针可以有多级，引用只有一级 传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改 指针的大小一般是4个字节，引用的大小取决于被引用对象的大小 指针可以为空，引用不可以。  1、在函数参数传递的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg">
<meta property="article:published_time" content="2021-05-02T14:16:07.000Z">
<meta property="article:modified_time" content="2021-09-10T10:41:28.387Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/05/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-10 18:41:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常见面试题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-02T14:16:07.000Z" title="Created 2021-05-02 22:16:07">2021-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-10T10:41:28.387Z" title="Updated 2021-09-10 18:41:28">2021-09-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常见面试题整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、C"><a href="#一、C" class="headerlink" title="一、C++"></a>一、C++</h1><h4 id="0、指针和引用的区别"><a href="#0、指针和引用的区别" class="headerlink" title="0、指针和引用的区别"></a>0、指针和引用的区别</h4><ul>
<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li>
<li>指针可以有多级，引用只有一级</li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li>
<li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li>
<li>指针可以为空，引用不可以。</li>
</ul>
<h4 id="1、在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#1、在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="1、在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>1、在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h4 id="2、堆和栈有什么区别"><a href="#2、堆和栈有什么区别" class="headerlink" title="2、堆和栈有什么区别"></a>2、堆和栈有什么区别</h4><ul>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li>
</ul>
<h4 id="3、堆快一点还是栈快一点？（字节提前批一面）"><a href="#3、堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="3、堆快一点还是栈快一点？（字节提前批一面）"></a>3、堆快一点还是栈快一点？（字节提前批一面）</h4><p>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h4 id="4、-new和delete是如何实现的，new-与-malloc的异同处"><a href="#4、-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="4、 new和delete是如何实现的，new 与 malloc的异同处"></a>4、 new和delete是如何实现的，new 与 malloc的异同处</h4><p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p>
<p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p>
<h4 id="5、既然有了malloc-free，C-中为什么还需要new-delete呢？"><a href="#5、既然有了malloc-free，C-中为什么还需要new-delete呢？" class="headerlink" title="5、既然有了malloc/free，C++中为什么还需要new/delete呢？"></a>5、既然有了malloc/free，C++中为什么还需要new/delete呢？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p>
<ul>
<li>malloc/free和new/delete都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。</li>
</ul>
<h4 id="6、-C和C-的区别"><a href="#6、-C和C-的区别" class="headerlink" title="6、 C和C++的区别"></a>6、 C和C++的区别</h4><p>包括但不限于：</p>
<ul>
<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</li>
<li>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</li>
<li>C++中还有函数重载和引用等概念，C中没有</li>
</ul>
<h4 id="7、delete和delete-的区别"><a href="#7、delete和delete-的区别" class="headerlink" title="7、delete和delete[]的区别"></a>7、delete和delete[]的区别</h4><ul>
<li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p>
</li>
<li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
</li>
</ul>
<h4 id="8、-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#8、-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="8、 C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>8、 C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于：</p>
<ul>
<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li>
<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>
<li>C++有指针，Java没有指针，只有引用</li>
<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>
</ul>
<h4 id="9、C-和python的区别"><a href="#9、C-和python的区别" class="headerlink" title="9、C++和python的区别"></a>9、C++和python的区别</h4><p>包括但不限于：</p>
<ol>
<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>python的库函数比C++的多，调用起来很方便</li>
</ol>
<h4 id="10、Struct和class的区别"><a href="#10、Struct和class的区别" class="headerlink" title="10、Struct和class的区别"></a>10、Struct和class的区别</h4><ul>
<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>
<li>struct的继承默认是public继承，而class的继承默认是private继承</li>
<li>class可以用作模板，而struct不能</li>
</ul>
<h4 id="11、define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#11、define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="11、define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>11、define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4><p>  联系：它们都是定义常量的一种方法。</p>
<p>  区别：</p>
<ul>
<li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li>
<li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li>
<li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li>
<li>const可以定义函数而define不可以。</li>
</ul>
<h4 id="12、在C-中const的用法（定义，用途）"><a href="#12、在C-中const的用法（定义，用途）" class="headerlink" title="12、在C++中const的用法（定义，用途）"></a>12、在C++中const的用法（定义，用途）</h4><ul>
<li>const修饰类的成员变量时，表示常量不能被修改</li>
<li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li>
</ul>
<h4 id="13、C-中的static用法和意义"><a href="#13、C-中的static用法和意义" class="headerlink" title="13、C++中的static用法和意义"></a>13、C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p>
<ul>
<li><p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p>
</li>
<li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p>
</li>
<li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p>
</li>
</ul>
<p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p>
<p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p>
<h4 id="14、计算下面几个类的大小："><a href="#14、计算下面几个类的大小：" class="headerlink" title="14、计算下面几个类的大小："></a>14、计算下面几个类的大小：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> a; <span class="keyword">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h4 id="15、C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#15、C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="15、C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>15、C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h4 id="16、STL源码中的hash表的实现"><a href="#16、STL源码中的hash表的实现" class="headerlink" title="16、STL源码中的hash表的实现"></a>16、STL源码中的hash表的实现</h4><p>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</p>
<p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p>
<h4 id="17、解决哈希冲突的方式？"><a href="#17、解决哈希冲突的方式？" class="headerlink" title="17、解决哈希冲突的方式？"></a>17、解决哈希冲突的方式？</h4><ol>
<li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li>
<li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li>
<li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li>
<li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li>
<li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li>
</ol>
<h4 id="18、STL中unordered-map和map的区别"><a href="#18、STL中unordered-map和map的区别" class="headerlink" title="18、STL中unordered_map和map的区别"></a>18、STL中unordered_map和map的区别</h4><ul>
<li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。</li>
<li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li>
</ul>
<h4 id="19、STL中vector的实现"><a href="#19、STL中vector的实现" class="headerlink" title="19、STL中vector的实现"></a>19、STL中vector的实现</h4><p>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p>
<p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p>
<h4 id="20、-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#20、-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="20、 vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>20、 vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p>
<h4 id="21、C-中vector和list的区别"><a href="#21、C-中vector和list的区别" class="headerlink" title="21、C++中vector和list的区别"></a>21、C++中vector和list的区别</h4><p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>
<p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“&lt;”等操作符。</p>
<p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“&lt;”等</p>
<p>vector::iterator和list::iterator都重载了“++”运算符。</p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h4 id="22、C-中的重载和重写的区别："><a href="#22、C-中的重载和重写的区别：" class="headerlink" title="22、C++中的重载和重写的区别："></a>22、C++中的重载和重写的区别：</h4><ul>
<li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li>
<li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p>
<h4 id="23、C-内存管理（热门问题）"><a href="#23、C-内存管理（热门问题）" class="headerlink" title="23、C ++内存管理（热门问题）"></a>23、C ++内存管理（热门问题）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。</p>
<ul>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li>
<li>代码区，存放程序的二进制代码</li>
</ul>
<p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p>
<h4 id="24、介绍面向对象的三大特性，并且举例说明每一个。"><a href="#24、介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="24、介绍面向对象的三大特性，并且举例说明每一个。"></a>24、介绍面向对象的三大特性，并且举例说明每一个。</h4><p>面向对象的三大特性是：封装，继承和多态。</p>
<ul>
<li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li>
<li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li>
<li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</li>
</ul>
<h4 id="25、多态的实现（和下个问题一起回答）"><a href="#25、多态的实现（和下个问题一起回答）" class="headerlink" title="25、多态的实现（和下个问题一起回答）"></a>25、多态的实现（和下个问题一起回答）</h4><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p>
<ul>
<li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li>
</ul>
<h4 id="26、C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#26、C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="26、C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>26、C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4><p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p>
<ul>
<li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></li>
</ul>
<h4 id="27、实现编译器处理虚函数表应该如何处理"><a href="#27、实现编译器处理虚函数表应该如何处理" class="headerlink" title="27、实现编译器处理虚函数表应该如何处理"></a>27、实现编译器处理虚函数表应该如何处理</h4><p>编译器处理虚函数的方法是：<br>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/iFuMI/article/details/51088091">虚函数的作用及其底层实现机制</a></p>
<h4 id="28、基类的析构函数一般写成虚函数的原因"><a href="#28、基类的析构函数一般写成虚函数的原因" class="headerlink" title="28、基类的析构函数一般写成虚函数的原因"></a>28、基类的析构函数一般写成虚函数的原因</h4><p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>
<h4 id="29、构造函数为什么一般不定义为虚函数"><a href="#29、构造函数为什么一般不定义为虚函数" class="headerlink" title="29、构造函数为什么一般不定义为虚函数"></a>29、构造函数为什么一般不定义为虚函数</h4><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<h4 id="30、构造函数或者析构函数中调用虚函数会怎样"><a href="#30、构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="30、构造函数或者析构函数中调用虚函数会怎样"></a>30、构造函数或者析构函数中调用虚函数会怎样</h4><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p>
<p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p>
<h4 id="31、纯虚函数"><a href="#31、纯虚函数" class="headerlink" title="31、纯虚函数"></a>31、纯虚函数</h4><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p>
<p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p>
<p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>
<h4 id="32、-静态绑定和动态绑定的介绍"><a href="#32、-静态绑定和动态绑定的介绍" class="headerlink" title="32、 静态绑定和动态绑定的介绍"></a>32、 静态绑定和动态绑定的介绍</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>
<p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>
<h4 id="33、深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#33、深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="33、深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>33、深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p>
<p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p>
<p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>
<h4 id="34、对象复用的了解，零拷贝的了解"><a href="#34、对象复用的了解，零拷贝的了解" class="headerlink" title="34、对象复用的了解，零拷贝的了解"></a>34、对象复用的了解，零拷贝的了解</h4><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p>
<p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p>
<blockquote>
<p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
</blockquote>
<h4 id="35、介绍C-所有的构造函数"><a href="#35、介绍C-所有的构造函数" class="headerlink" title="35、介绍C++所有的构造函数"></a>35、介绍C++所有的构造函数</h4><p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p>
<ul>
<li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li>
<li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li>
<li>拷贝构造函数是在发生对象复制的时候调用的。 </li>
</ul>
<h4 id="36、什么情况下会调用拷贝构造函数（三种情况）"><a href="#36、什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="36、什么情况下会调用拷贝构造函数（三种情况）"></a>36、什么情况下会调用拷贝构造函数（三种情况）</h4><ul>
<li><p>对象以值传递的方式传入函数参数 </p>
<blockquote>
<p>如 <code> void func(Dog dog)&#123;&#125;;</code></p>
</blockquote>
</li>
<li><p>对象以值传递的方式从函数返回</p>
<blockquote>
<p>如 <code> Dog func()&#123; Dog d; return d;&#125;</code></p>
</blockquote>
</li>
<li><p>对象需要通过另外一个对象进行初始化</p>
</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p>
<h4 id="37、结构体内存对齐方式和为什么要进行内存对齐？"><a href="#37、结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="37、结构体内存对齐方式和为什么要进行内存对齐？"></a>37、结构体内存对齐方式和为什么要进行内存对齐？</h4><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>
<p>对齐规则：</p>
<ul>
<li>第一个成员在与结构体变量偏移量为0的地址</li>
<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li>
<li>对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</li>
<li>linux 中默认为4</li>
<li>vs 中的默认值为8<br>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li>
</ul>
<h4 id="38、内存泄露的定义，如何检测与避免？"><a href="#38、内存泄露的定义，如何检测与避免？" class="headerlink" title="38、内存泄露的定义，如何检测与避免？"></a>38、内存泄露的定义，如何检测与避免？</h4><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p>
<p>造成内存泄漏的几种原因：</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
<p>避免方法：</p>
<ol>
<li>malloc/free要配套</li>
<li>使用智能指针；</li>
<li>将基类的析构函数设为虚函数；</li>
</ol>
<h4 id="39、C-的智能指针有哪些"><a href="#39、C-的智能指针有哪些" class="headerlink" title="39、C++的智能指针有哪些"></a>39、C++的智能指针有哪些</h4><p>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</p>
<ul>
<li>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</li>
<li>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</li>
<li>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li>
<li>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</li>
</ul>
<h4 id="40、调试程序的方法"><a href="#40、调试程序的方法" class="headerlink" title="40、调试程序的方法"></a>40、调试程序的方法</h4><ul>
<li>通过设置断点进行调试</li>
<li>打印log进行调试</li>
<li>打印中间结果进行调试</li>
</ul>
<h4 id="41、遇到coredump要怎么调试"><a href="#41、遇到coredump要怎么调试" class="headerlink" title="41、遇到coredump要怎么调试"></a>41、遇到coredump要怎么调试</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<ul>
<li>使用gdb命令对core文件进行调试</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></table></figure>

<p>在编辑器内键入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    scanf(&quot;%d&quot;,i);&#x2F;&#x2F;正确的应该是&amp;i,这里使用i会导致segment fault</span><br><span class="line">    printf(&quot;%d\n&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;coredumpTest</span><br></pre></td></tr></table></figure>

<p>使用gdb调试coredump</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br></pre></td></tr></table></figure>

<h4 id="42、inline关键字说一下-和宏定义有什么区别"><a href="#42、inline关键字说一下-和宏定义有什么区别" class="headerlink" title="42、inline关键字说一下 和宏定义有什么区别"></a>42、inline关键字说一下 和宏定义有什么区别</h4><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>
<p>1、内联函数在编译时展开，而宏在预编译时展开</p>
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p>
<p>4、宏不是函数，而inline是函数</p>
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p>
<p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p>
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<h4 id="43、模板的用法与适用场景-实现原理"><a href="#43、模板的用法与适用场景-实现原理" class="headerlink" title="43、模板的用法与适用场景 实现原理"></a>43、模板的用法与适用场景 实现原理</h4><p>用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p>
<p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p>
<h4 id="44、成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#44、成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="44、成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>44、成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;int id;string name;FaceImage face;A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace)&#123;&#125; &#x2F;&#x2F; 成员初始化列表&#125;;</span><br></pre></td></tr></table></figure>

<p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>另外，有三种情况是必须使用成员初始化列表进行初始化的：</p>
<ul>
<li>常量成员的初始化，因为常量成员只能初始化不能赋值</li>
<li>引用类型</li>
<li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li>
</ul>
<p>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<h4 id="45、用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#45、用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="45、用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>45、用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4><ul>
<li><p>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p>
</li>
<li><p>nullptr<br>：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p>
</li>
<li><p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p>
</li>
<li><p>thread类和mutex类</p>
</li>
<li><p>新的智能指针 unique_ptr和shared_ptr</p>
</li>
</ul>
<ul>
<li>更多详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></li>
</ul>
<h4 id="46、C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#46、C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="46、C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>46、C++的调用惯例（简单一点C++函数调用的压栈过程）</h4><p>函数的调用过程：</p>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p>
<h4 id="47、C-的四种强制转换"><a href="#47、C-的四种强制转换" class="headerlink" title="47、C++的四种强制转换"></a>47、C++的四种强制转换</h4><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<ul>
<li><p>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</p>
<blockquote>
<p>特性与要点：</p>
<ol>
<li>它没有运行时类型检查，所以是有安全隐患的。</li>
<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>
<li>static_cast不能转换const，volatile等属性</li>
</ol>
</blockquote>
</li>
<li><p>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>dynamic_cast如果不能转换返回NULL。</p>
</li>
<li><p>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>
</li>
<li><p>4）reinterpret_cast<br>几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。</p>
</li>
</ul>
<h4 id="48、string的底层实现"><a href="#48、string的底层实现" class="headerlink" title="48、string的底层实现"></a>48、string的底层实现</h4><p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h4 id="49、一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#49、一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="49、一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>49、一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><p>预处理，编译，汇编，链接</p>
<ul>
<li>预处理： 对预处理命令进行替换等预处理操作</li>
<li>编译：代码优化和生成汇编代码</li>
<li>汇编：将汇编代码转化为机器语言</li>
<li>链接：将目标文件彼此链接起来</li>
</ul>
<h4 id="50、set，map和vector的插入复杂度"><a href="#50、set，map和vector的插入复杂度" class="headerlink" title="50、set，map和vector的插入复杂度"></a>50、set，map和vector的插入复杂度</h4><p><code>set</code>，<code>map</code>的插入复杂度就是红黑树的插入复杂度，是<code>log(N)</code>。</p>
<p><code>unordered_set</code>，<code>unordered_map</code>的插入复杂度是常数，最坏是<code>O(N)</code>。</p>
<p><code>vector</code>的插入复杂度是<code>O(N)</code>,最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p>
<h4 id="51、定义和声明的区别"><a href="#51、定义和声明的区别" class="headerlink" title="51、定义和声明的区别"></a>51、定义和声明的区别</h4><ul>
<li><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p>
</li>
<li><p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p>
</li>
</ul>
<h4 id="52、typdef和define区别"><a href="#52、typdef和define区别" class="headerlink" title="52、typdef和define区别"></a>52、typdef和define区别</h4><p><code>#define</code>是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p><code>typedef</code>是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<h4 id="53、被free回收的内存是立即返还给操作系统吗？为什么"><a href="#53、被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="53、被free回收的内存是立即返还给操作系统吗？为什么"></a>53、被free回收的内存是立即返还给操作系统吗？为什么</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p>
<p>不是的，被<code>free</code>回收的内存会首先被<code>ptmalloc</code>使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时<code>ptmalloc</code>也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h4 id="54、引用作为函数参数以及返回值的好处"><a href="#54、引用作为函数参数以及返回值的好处" class="headerlink" title="54、引用作为函数参数以及返回值的好处"></a>54、引用作为函数参数以及返回值的好处</h4><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p>
<h4 id="55、友元函数和友元类"><a href="#55、友元函数和友元类" class="headerlink" title="55、友元函数和友元类"></a>55、友元函数和友元类</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;using namespace std;class A&#123;public:    friend void set_show(int x, A &amp;a);      &#x2F;&#x2F;该函数是友元函数的声明private:    int data;&#125;;void set_show(int x, A &amp;a)  &#x2F;&#x2F;友元函数定义，为了访问类A中的成员&#123;    a.data &#x3D; x;    cout &lt;&lt; a.data &lt;&lt; endl;&#125;int main(void)&#123;    class A a;    set_show(1, a);    return 0;&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;using namespace std;class A&#123;public:    friend class C;                         &#x2F;&#x2F;这是友元类的声明private:    int data;&#125;;class C             &#x2F;&#x2F;友元类定义，为了访问类A中的成员&#123;public:    void set_show(int x, A &amp;a) &#123; a.data &#x3D; x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;&#125;;int main(void)&#123;    class A a;    class C c;    c.set_show(1, a);    return 0;&#125;</span><br></pre></td></tr></table></figure>

<p>使用友元类时注意： </p>
<p>(1) 友元关系不能被继承。 </p>
<p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p>
<p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h4 id="56、说一下volatile关键字的作用"><a href="#56、说一下volatile关键字的作用" class="headerlink" title="56、说一下volatile关键字的作用"></a>56、说一下volatile关键字的作用</h4><p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p>
<h4 id="57、STL中的sort-算法是用什么实现的，stable-sort-呢"><a href="#57、STL中的sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="57、STL中的sort()算法是用什么实现的，stable_sort()呢"></a>57、STL中的sort()算法是用什么实现的，stable_sort()呢</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>
<h4 id="58、vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#58、vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="58、vector会迭代器失效吗？什么情况下会迭代器失效？"></a>58、vector会迭代器失效吗？什么情况下会迭代器失效？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p>
<ul>
<li>会</li>
<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li>
<li>当vector在插入的时候，end迭代器肯定会失效</li>
<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>
</ul>
<h4 id="58、为什么C-没有实现垃圾回收？"><a href="#58、为什么C-没有实现垃圾回收？" class="headerlink" title="58、为什么C++没有实现垃圾回收？"></a>58、为什么C++没有实现垃圾回收？</h4><ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h1 id="二、计算机网络"><a href="#二、计算机网络" class="headerlink" title="二、计算机网络"></a>二、计算机网络</h1><h4 id="（1）-建立TCP服务器的各个系统调用"><a href="#（1）-建立TCP服务器的各个系统调用" class="headerlink" title="（1） 建立TCP服务器的各个系统调用"></a>（1） 建立TCP服务器的各个系统调用</h4><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p>
<h4 id="（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><pre><code>socket()    创建套接字   bind()      绑定本机端口    connect()   建立连接     （TCP三次握手在调用这个函数时进行）listen()    监听端口accept()    接受连接recv(), read(), recvfrom()  数据接收send(), write(), sendto()   数据发送close(), shutdown() 关闭套接字
</code></pre>
<p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close/shutdown详解</a></p>
<p>TCP连接与断开详解： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p>
<h4 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP."></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4><ul>
<li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p>
</li>
<li><p>OSPF：详见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p>
</li>
</ul>
<h4 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h4><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。</p>
<p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<p>作者：姚冬<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h4><ul>
<li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li>
<li>TCP提供流量控制和拥塞控制，而UDP没有。</li>
<li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li>
<li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li>
<li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li>
</ul>
<p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p>
<h4 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h4><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p>
<h4 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p>
<p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p>
<p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p>
<h4 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h4><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p>
<ul>
<li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li>
<li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li>
<li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li>
<li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。</li>
</ul>
<h4 id="（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）"><a href="#（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）" class="headerlink" title="（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）"></a>（9）    在浏览器中输入URL后执行的全部过程（如<a target="_blank" rel="noopener" href="http://www.baidu.com)/">www.baidu.com）</a></h4><ol>
<li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li>
<li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li>
<li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li>
<li>服务器对客户端发来的http请求进行处理，并返回响应；</li>
<li>客户端接收到http响应，将结果渲染展示给用户。</li>
</ol>
<h4 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h4><p>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</p>
<p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p>
<h4 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4><ul>
<li>三次握手</li>
</ul>
<p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN=1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p>
<p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p>
<p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK=1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="D:/hexo/ztblog/source/_posts/fig/三次握手.png" alt="三次握手.png"></p>
<ul>
<li>四次挥手断开连接：</li>
</ul>
<p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p>
<p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack=seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p>
<p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p>
<p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="D:/hexo/ztblog/source/_posts/fig/四次挥手.png" alt="fig/四次挥手.png"></p>
<h4 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4><p>见上</p>
<h4 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h4><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p>
<p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p>
<h4 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h4><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h4><h4 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h4><p><strong>（校序重流拥）</strong></p>
<ul>
<li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p>
</li>
<li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p>
</li>
<li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
</li>
</ul>
<p>慢启动、拥塞避免、快速重传、快速恢复 </p>
<h4 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h4 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h4><p>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p>
<p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p>
<p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p>
<h4 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p>
<h4 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h4><p><img src="D:/hexo/ztblog/source/_posts/fig/拥塞控制.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p>
<p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p>
<p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p>
<h4 id="（21）-http协议与TCP的区别与联系"><a href="#（21）-http协议与TCP的区别与联系" class="headerlink" title="（21） http协议与TCP的区别与联系"></a>（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p>
<h4 id="（22）-http-1-0和http-1-1的区别"><a href="#（22）-http-1-0和http-1-1的区别" class="headerlink" title="（22） http/1.0和http/1.1的区别"></a>（22） http/1.0和http/1.1的区别</h4><p>HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。<br>HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<h4 id="（23）-http的请求方法有哪些？get和post的区别。"><a href="#（23）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（23） http的请求方法有哪些？get和post的区别。"></a>（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p>
<p>get和post的区别：</p>
<ol>
<li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li>
<li>get可以保存为书签，可以用缓存来优化，而post不可以</li>
<li>get把请求附在url上，而post把参数附在http包的包体中</li>
<li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li>
<li>post可以传输二进制编码的信息，get的参数一般只支持ASCII</li>
</ol>
<h4 id="（24）-http的状态码-403-201等等是什么意思"><a href="#（24）-http的状态码-403-201等等是什么意思" class="headerlink" title="（24） http的状态码 403 201等等是什么意思"></a>（24） http的状态码 403 201等等是什么意思</h4><p>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></p>
<p>常见的状态码有：</p>
<blockquote>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
<li>400 - 请求无效 </li>
<li>403 - 禁止访问 </li>
</ul>
</blockquote>
<h4 id="（25）-http和https的区别，由http升级为https需要做哪些操作"><a href="#（25）-http和https的区别，由http升级为https需要做哪些操作" class="headerlink" title="（25） http和https的区别，由http升级为https需要做哪些操作"></a>（25） http和https的区别，由http升级为https需要做哪些操作</h4><p>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p>
<h4 id="（26）-https的具体实现，怎么确保安全性"><a href="#（26）-https的具体实现，怎么确保安全性" class="headerlink" title="（26） https的具体实现，怎么确保安全性"></a>（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p>
<p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>
<li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li>
<li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li>
</ol>
<p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p>
<p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p>
<h4 id="（27）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（27）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（27） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p>
<h4 id="（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h4 id="（29）-对称密码和非对称密码体系"><a href="#（29）-对称密码和非对称密码体系" class="headerlink" title="（29） 对称密码和非对称密码体系"></a>（29） 对称密码和非对称密码体系</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个<ul>
<li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul>
</li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul>
<li>优点：安全，不怕泄漏  缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA</li>
</ul>
</li>
</ul>
<h4 id="（30）-数字证书的了解（高频）"><a href="#（30）-数字证书的了解（高频）" class="headerlink" title="（30） 数字证书的了解（高频）"></a>（30） 数字证书的了解（高频）</h4><p><img src="D:/hexo/ztblog/source/_posts/fig/数字证书.jpg" alt="fig/数字证书.jpg"></p>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p>
<h4 id="（31）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（31）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（31） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug</li>
</ul>
<h4 id="（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4><ul>
<li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
</li>
<li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p>
</li>
</ul>
<ol>
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p>
<ul>
<li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p>
</li>
<li><p>加强安全性：加盐（加随机数）</p>
</li>
</ul>
<h4 id="（33）-单条记录高并发访问的优化"><a href="#（33）-单条记录高并发访问的优化" class="headerlink" title="（33） 单条记录高并发访问的优化"></a>（33） 单条记录高并发访问的优化</h4><p>服务器端：</p>
<ul>
<li>使用缓存，如redis等</li>
<li>使用分布式架构进行处理</li>
<li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li>
<li>将静态资源尽可能在客户端进行缓存</li>
<li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</li>
</ul>
<p>数据库端：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施</li>
<li>建立适当的索引</li>
<li>分库分表</li>
</ul>
<h4 id="（34）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（34）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（34） 介绍一下ping的过程，分别用到了哪些协议"></a>（34） 介绍一下ping的过程，分别用到了哪些协议</h4><p>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p>
<h4 id="（35）-TCP-IP的粘包与避免介绍一下"><a href="#（35）-TCP-IP的粘包与避免介绍一下" class="headerlink" title="（35） TCP/IP的粘包与避免介绍一下"></a>（35） TCP/IP的粘包与避免介绍一下</h4><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面：</p>
<ul>
<li>发送端等待缓冲区满才进行发送，造成粘包</li>
<li>接收方来不及接收缓冲区内的数据，造成粘包</li>
<li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li>
</ul>
<p>避免粘包的措施：</p>
<ul>
<li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li>
<li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li>
<li>设置固定长度的报文或者设置报文头部指示报文的长度。</li>
</ul>
<h4 id="（36）-说一下TCP的封包和拆包"><a href="#（36）-说一下TCP的封包和拆包" class="headerlink" title="（36） 说一下TCP的封包和拆包"></a>（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<h4 id="（37）-一个ip配置多个域名，靠什么识别？"><a href="#（37）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（37） 一个ip配置多个域名，靠什么识别？"></a>（37） 一个ip配置多个域名，靠什么识别？</h4><ul>
<li>靠host主机名区分</li>
<li>靠端口号区分</li>
</ul>
<h4 id="（38）-服务器攻击（DDos攻击）"><a href="#（38）-服务器攻击（DDos攻击）" class="headerlink" title="（38） 服务器攻击（DDos攻击）"></a>（38） 服务器攻击（DDos攻击）</h4><h4 id="（39）DNS的工作过程和原理"><a href="#（39）DNS的工作过程和原理" class="headerlink" title="（39）DNS的工作过程和原理"></a>（39）DNS的工作过程和原理</h4><p><img src="D:/hexo/ztblog/source/_posts/fig/DNS查询图解.png"><br>DNS解析有两种方式：递归查询和迭代查询</p>
<ul>
<li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li>
<li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果</li>
</ul>
<h4 id="（41）OSA七层协议和五层协议，分别有哪些"><a href="#（41）OSA七层协议和五层协议，分别有哪些" class="headerlink" title="（41）OSA七层协议和五层协议，分别有哪些"></a>（41）OSA七层协议和五层协议，分别有哪些</h4><p>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<p><img src="D:/hexo/ztblog/source/_posts/fig/网络协议层.png" alt="(fig/网络协议层.png"></p>
<h4 id="（42）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（42）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（42）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6388.html">http://c.biancheng.net/view/6388.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxy_nick/article/details/9190693">https://blog.csdn.net/wxy_nick/article/details/9190693</a></p>
<p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p>
<h5 id="1、网络模型和各个层的协议"><a href="#1、网络模型和各个层的协议" class="headerlink" title="1、网络模型和各个层的协议"></a>1、网络模型和各个层的协议</h5><h6 id="（1）网络模型"><a href="#（1）网络模型" class="headerlink" title="（1）网络模型"></a>（1）网络模型</h6><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br> TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br> 五层协议 （5层）：物理层、数据链路层、网络层、传输层、 应用层。</p>
<h6 id="（2）每一层的协议"><a href="#（2）每一层的协议" class="headerlink" title="（2）每一层的协议"></a>（2）每一层的协议</h6><p> 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）<br> 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br> 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br> 传输层：TCP、UDP、SPX<br> 会话层：NFS、SQL、NETBIOS、RPC<br> 表示层：JPEG、MPEG、ASII<br> 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
<h6 id="（3）每一层的作用"><a href="#（3）每一层的作用" class="headerlink" title="（3）每一层的作用"></a>（3）每一层的作用</h6><p> 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br> 数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br> 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br> 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br> 会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br> 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br> 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<h5 id="2、TCP和UDP的区别"><a href="#2、TCP和UDP的区别" class="headerlink" title="2、TCP和UDP的区别"></a>2、TCP和UDP的区别</h5><ul>
<li>TCP面向连接，UDP无连接（发送数据前不需要建立链接）</li>
<li>TCP面向字节流（文件传输），UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对IP电话，实时视频会议等）</li>
<li>TCP首部开销20字节，UDP的首部开销小，只有8个字节</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，数据传输慢，UDP则是不可靠信道，数据传输快。</li>
</ul>
<h5 id="3、TCP如何保证数据的可靠传输的"><a href="#3、TCP如何保证数据的可靠传输的" class="headerlink" title="3、TCP如何保证数据的可靠传输的"></a>3、TCP如何保证数据的可靠传输的</h5><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>4种拥塞控制算法：慢启动，拥塞避免，快速重传和快速恢复。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114428.png"></p>
<ul>
<li>针对发送端发出的数据包的确认应答信号ACK、通常将推迟几分之一秒(可能是要对包做完整校验)</li>
<li>针对数据包丢失或者出现定时器超时的重发机制</li>
<li>针对数据包到达接收端主机顺序乱掉的顺序控制、对失序数据进行重新排序，然后才交给应用层</li>
<li>针对高效传输数据包的流动窗口控制</li>
<li>针对避免网络拥堵时候的流量控制</li>
<li>针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的慢启动算法和拥塞控制。</li>
</ul>
<p>（1）确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</p>
<p>（2）数据校验</p>
<p>（3）数据合理分片和排序：</p>
<p>UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。</p>
<p>（4）流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
<p>（5）拥塞控制：当网络拥塞时，减少数据的发送。</p>
<h5 id="4、TCP三次握手的过程"><a href="#4、TCP三次握手的过程" class="headerlink" title="4、TCP三次握手的过程"></a>4、TCP三次握手的过程</h5><p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114556.png"></p>
<p>ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段<br> SYN：同步序号，用于建立连接过程<br> FIN： finish标志，用于释放连接</p>
<ul>
<li>客户端发送确认序号SYN=1，初始序号seq=X的包，连接的服务器的端口</li>
<li>服务端返回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号设置为x+1。并发送一个自己的序列号 y</li>
<li>客户端发送确认包(ACK) SYN标志位为0，ACK标志位为1，并且把服务器发来的 y ，+1 作为确认号发送给对方，且序列号设置为第二次的确认号x+1</li>
</ul>
<h5 id="5、TCP四次挥手"><a href="#5、TCP四次挥手" class="headerlink" title="5、TCP四次挥手"></a>5、TCP四次挥手</h5><p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114648.png"></p>
<p>TCP连接是全双工的，因此每个方向都必须单独进行关闭。</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送，并发送一个自己的ISN（u）</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（u+1）。同时发送一个自己的ISN(v)</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN、ACK给客户端A，确认号为收到的序号加1（u+1），与上一次不变。同时发送一个自己的ISN（w）</li>
<li>客户端A发送ACK报文确认，并将确认序号设置为收到序号加1（w+1），序列号就是上一次的确认号（u+1）</li>
</ul>
<h5 id="6、DNS域名系统工作原理"><a href="#6、DNS域名系统工作原理" class="headerlink" title="6、DNS域名系统工作原理"></a>6、DNS域名系统工作原理</h5><ul>
<li>查询 浏览器、操作系统 缓存</li>
<li>请求 <strong>本地域名服务器</strong></li>
<li>本地域名服务器未命中缓存，其请求 <strong>根域名服务器</strong></li>
<li>根域名服务器返回所查询域的<strong>主域名服务器</strong>。（主域名、顶级域名，如com、cn）</li>
<li>本地域名服务器请求主域名服务器，获取该域名的 <strong>名称服务器</strong>（域名注册商的服务器）</li>
<li>本地域名服务器向 名称服务器 请求 域名-IP 映射</li>
<li>缓存解析结果</li>
</ul>
<h5 id="7、ARP地址解析协议工作原理"><a href="#7、ARP地址解析协议工作原理" class="headerlink" title="7、ARP地址解析协议工作原理"></a>7、ARP地址解析协议工作原理</h5><p>每台主机都有一个ARP列表，存放IP地址和MAC地址的对应关系。<br> 当源主机向目标主机发送数据时，首先查看ARP列表中IP地址对应的目标主机的MAC地址，如果找到则直接发送数据；如果找不到，就向该网段中的所有主机发送ARP请求包，里面存放源IP地址，源MAC地址，目标IP地址。<br> 当该网段中的所有主机收到该ARP响应包之后，首先查看目标ip地址是否与自己相匹配，如果不是则忽略，如果是，就将源ip地址和源MAC地址存放到自己的ARP列表中，然后将自己的MAC地址存放到ARP响应包中发送给源主机；<br> 目标主机收到ARP响应包，则取出对应的IP和MAC地址存放到ARP列表中，并发送数据。若未收到则ARP查询失败。<br> 广播ARP请求，单播ARP响应。</p>
<h5 id="8、连续ARQ和滑动窗口协议"><a href="#8、连续ARQ和滑动窗口协议" class="headerlink" title="8、连续ARQ和滑动窗口协议"></a>8、连续ARQ和滑动窗口协议</h5><p>连续ARQ协议：所谓连续就是在发送完一个数据帧后，不是停下来等待确认帧，而是可以连续再发若干帧，边发可以边等待确认帧，如果收到了确认帧，又可以继续发送数据帧， 由于减少了等待的时间，利用率就提高了。<br> 但是连续ARQ在收到一个否认帧或超时后，所有该帧后面的帧都要重发而不管该帧后面的帧是否正确传送，于是便有了选择重传ARQ协议。</p>
<p>滑动窗口协议：允许发送方发送多个分组而不需等待确认。（滑动窗口协议是TCP使用的一种流量控制方法，此协议能够加速数据的传输）</p>
<h5 id="9、HTTP和HTTPS的区别"><a href="#9、HTTP和HTTPS的区别" class="headerlink" title="9、HTTP和HTTPS的区别"></a>9、HTTP和HTTPS的区别</h5><p>HTTP协议时超文本传输协议。<br> HTTPS是安全的超文本传输协议，是安全版的HTTP协议，使用安全套接字层(SSL)进行信息交换。<br> HTTPS协议主要针对解决HTTP协议以下不足：<br> 1.通信使用明文（不加密），内容可能会被窃听<br> 2.不验证通信方身份，应此可能遭遇伪装<br> 3.无法证明报文的完整性（即准确性），所以可能已遭篡改<br> HTTP+加密+认证+完整性保护=HTTPS</p>
<p>HTTP端口 80<br> HTTPS端口443<br> HTTPS采用对称加密、<br> SSL位于应用层于传输层TCP之间，原本数据由应用层直接交由传输层处理，现在会经过SSL加密再进行传输。<br> HTTPS也不是绝对安全的，针对SSL的中间人攻击方式主要有两类，分别是SSL劫持攻击和SSL剥离攻击。<br> SSL劫持攻击就是 SSL证书欺骗攻击，将自己接入到客户端和目标网站之间； 在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥。</p>
<h5 id="10、在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#10、在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="10、在浏览器中输入url地址-&gt;&gt;显示主页的过程"></a>10、在浏览器中输入url地址-&gt;&gt;显示主页的过程</h5><ul>
<li>浏览器解析域名</li>
<li>TCP建立连接</li>
<li>浏览器向服务器发送HTTP请求</li>
<li>服务器解析请求并返回HTTP报文</li>
<li>浏览器解析并渲染页面</li>
<li>断开连接</li>
</ul>
<p>​     <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114841.png"> </p>
<h5 id="11、HTTP常见状态码"><a href="#11、HTTP常见状态码" class="headerlink" title="11、HTTP常见状态码"></a>11、HTTP常见状态码</h5><p>200 ：请求成功，成功返回网页<br> 301 ：资源（网页等）被永久转移到其它URL<br> 302 ：资源（网页等）被临时转移到其它URL<br> 304 ：请求未修改、命中缓存<br> 401 ：未授权<br> 403 ：服务器拒绝请求<br> 404 ：请求的网页或资源不存在<br> 500 ：内部服务器错误，无法完成请求<br> 502 ：错误网关<br> 503 ：请求未完成，服务器临时过载或宕机<br> 504 ：网关超时</p>
<h5 id="12、HTTP的请求和响应"><a href="#12、HTTP的请求和响应" class="headerlink" title="12、HTTP的请求和响应"></a>12、HTTP的请求和响应</h5><p>HTTP请求信息由3部分组成：</p>
<ul>
<li>请求方法（GET/POST）、URI、协议/版本</li>
<li>请求头(Request Header)：Content-Type、端口号Host、Cookie</li>
<li>请求正文：包含客户提交的查询字符串信息</li>
<li>请求头和请求正文之间是一个空行</li>
</ul>
<p> HTTP响应也由3个部分构成：</p>
<ul>
<li>状态行：状态代码及描述 如404、500</li>
<li>响应头(Response Header)：Content-Type 、Server、Date</li>
<li>响应正文：html代码</li>
</ul>
<h5 id="13、HTTP请求方法有哪些"><a href="#13、HTTP请求方法有哪些" class="headerlink" title="13、HTTP请求方法有哪些"></a>13、HTTP请求方法有哪些</h5><p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115113.png"></p>
<h5 id="14、简述HTTP中GET和POST的区别"><a href="#14、简述HTTP中GET和POST的区别" class="headerlink" title="14、简述HTTP中GET和POST的区别"></a>14、简述HTTP中GET和POST的区别</h5><p>从原理性看：</p>
<p>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的（对同一URL的多个请求应该返回同样的结果）</p>
<p>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</p>
<p>从表面上看：</p>
<p>GET请求的数据会附在URL后面（（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连），POST的数据放在HTTP包体</p>
<p>POST安全性比GET安全性高</p>
<h5 id="15、IP地址的分类"><a href="#15、IP地址的分类" class="headerlink" title="15、IP地址的分类"></a>15、IP地址的分类</h5><p>A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。</p>
<p>B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。</p>
<p>C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。</p>
<p>D类地址(224~239)：以1110开头，保留位多播地址。</p>
<p>E类地址(240~255)：以1111开头，保留位今后使用。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115155.png"></p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115239.png"></p>
<h5 id="16、交换机、路由器、网关的概念，并知道各自的用途"><a href="#16、交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="16、交换机、路由器、网关的概念，并知道各自的用途"></a>16、交换机、路由器、网关的概念，并知道各自的用途</h5><p>交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。用途:人工交换 电路程控 集线比较</p>
<p>路由器:路由器就是连接两个以上个别网络的设备。用途:连通不同的网络信息传输。</p>
<p>网关:又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备。用途:用于两个高层协议不同的网络互连。</p>
<h5 id="17、常见端口号及对应的服务"><a href="#17、常见端口号及对应的服务" class="headerlink" title="17、常见端口号及对应的服务"></a>17、常见端口号及对应的服务</h5><p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115314.png"></p>
<h1 id="三、-数据库"><a href="#三、-数据库" class="headerlink" title="三、 数据库"></a>三、 数据库</h1><h4 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h4><ul>
<li>关系型数据库的优点<ol>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol>
</li>
<li>非关系型数据库的优点<ol>
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
</ol>
</li>
</ul>
<h4 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h4><p>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</p>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用</li>
</ul>
<h4 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4><ul>
<li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li>
<li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li>
</ul>
<h4 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h4><p>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</p>
<ul>
<li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li>
<li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li>
<li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li>
<li>全文索引 可以加快模糊查询，不常用</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li>
<li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。</li>
</ul>
<h4 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h4 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引alter table table_name add index (column_list)      #添加一个普通索引alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure>

<p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure>

<h4 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p>
<ul>
<li>经常搜索的列上建索引</li>
<li>作为主键的列上要建索引</li>
<li>经常需要连接（where子句）的列上</li>
<li>经常需要排序的列</li>
<li>经常需要范围查找的列</li>
</ul>
<p>哪些列不适合建索引？</p>
<ul>
<li>很少查询的列</li>
<li>更新很频繁的列</li>
<li>数据值的取值比较少的列（比如性别）</li>
</ul>
<h4 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h4><p>数据库的索引是使用B+树来实现的。</p>
<p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h4 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h4><p><img src="D:/hexo/ztblog/source/_posts/fig/Bptree.png" alt="./fig/Bptree.png"></p>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ol>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ol>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p>
<h4 id="（10）-索引最左前缀-最左匹配"><a href="#（10）-索引最左前缀-最左匹配" class="headerlink" title="（10） 索引最左前缀/最左匹配"></a>（10） 索引最左前缀/最左匹配</h4><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p>
<h4 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h4><p>高频访问：</p>
<ul>
<li>分表分库：将数据库表进行水平拆分，减少表的长度</li>
<li>增加缓存： 在web和DB之间加上一层缓存层</li>
<li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只在主服务器上写，从服务器上读</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力</li>
</ul>
<h4 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4><ul>
<li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li>
<li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li>
<li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li>
<li>CSV</li>
<li>blackhole</li>
</ul>
<h4 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4><p>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p>
<p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p>
<h4 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p>
<ul>
<li><p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p>
<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p>
</blockquote>
</li>
<li><p>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。</p>
<blockquote>
<p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p>
</blockquote>
</li>
<li><p>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。</p>
<blockquote>
<p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
</li>
</ul>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h4 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p>
<ul>
<li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li>
<li>读已提交 Read committed:   可以避免脏读的发生 </li>
<li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li>
<li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li>
</ul>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p>
<h4 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h4><h4 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h4><ul>
<li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </li>
<li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</li>
</ul>
<h4 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h4><h4 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p>
<ul>
<li><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li>
</ul>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式</p>
</blockquote>
<ul>
<li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。 </li>
</ul>
<blockquote>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p>
</blockquote>
<ul>
<li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p>
</blockquote>
<ul>
<li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</li>
</ul>
<h4 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h4><p>以MYSQL为例，</p>
<ul>
<li>按照类型来分有乐观锁和悲观锁</li>
<li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li>
<li>根据作用来分有共享锁（读锁）和排他锁（写锁）。</li>
</ul>
<h4 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h4><ul>
<li><p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p>
</li>
<li><p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p>
</li>
</ul>
<h4 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h4><h4 id="（23）"><a href="#（23）" class="headerlink" title="（23）"></a>（23）</h4><h4 id="（24）数据库高并发的解决方案"><a href="#（24）数据库高并发的解决方案" class="headerlink" title="（24）数据库高并发的解决方案"></a>（24）数据库高并发的解决方案</h4><ol>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ol>
<h4 id="（25）乐观锁与悲观锁解释一下"><a href="#（25）乐观锁与悲观锁解释一下" class="headerlink" title="（25）乐观锁与悲观锁解释一下"></a>（25）乐观锁与悲观锁解释一下</h4><p>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p>
<h4 id="（26）乐观锁与悲观锁是怎么实现的"><a href="#（26）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（26）乐观锁与悲观锁是怎么实现的"></a>（26）乐观锁与悲观锁是怎么实现的</h4><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式：</p>
<ul>
<li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li>
<li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li>
<li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li>
</ul>
<h4 id="（27）对数据库目前最新技术有什么了解吗"><a href="#（27）对数据库目前最新技术有什么了解吗" class="headerlink" title="（27）对数据库目前最新技术有什么了解吗"></a>（27）对数据库目前最新技术有什么了解吗</h4><h5 id="1、什么是索引？为什么要用索引？"><a href="#1、什么是索引？为什么要用索引？" class="headerlink" title="1、什么是索引？为什么要用索引？"></a>1、什么是索引？为什么要用索引？</h5><ul>
<li>什么是索引？</li>
</ul>
<p>数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库中表的数据。索引的实现通常使用B树和变种的B+树(mysql常用的索引就是B+树)。除了数据之外，数据库系统还维护为满足特定查找算法的数据结构，这些数据结构以某种方式引用数据。这种数据结构就是索引。</p>
<p>简言之，索引就类似于书本、字典的目录！</p>
<ul>
<li>为什么要用索引？</li>
</ul>
<p>打个比方，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。</p>
<p>一言以蔽之，合理使用索引，可以加快数据库的查询效率和提升程序性能。</p>
<h5 id="2、索引的作用与缺点"><a href="#2、索引的作用与缺点" class="headerlink" title="2、索引的作用与缺点"></a>2、索引的作用与缺点</h5><ul>
<li><p>作用</p>
<p>通过创建索引，可以在查询的过程中，提高系统的性能</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</p>
<p>在使用分组和排序子句进行数据检索时，可以减少查询中分组和排序的时间</p>
</li>
<li><p>缺点</p>
<p>创建索引和维护索引要耗费时间，而且时间随着数据量的增加而增大</p>
<p>索引需要占用物理空间，如果要建立聚簇索引，所需要的空间会更大</p>
<p>在对表中的数据进行增加删除和修改时需要耗费较多的时间，因为索引也要动态地维护</p>
</li>
</ul>
<h5 id="3、创建索引的场景"><a href="#3、创建索引的场景" class="headerlink" title="3、创建索引的场景"></a>3、创建索引的场景</h5><p>  ① 经常需要搜索的列上</p>
<p>  ② 作为主键的列上</p>
<p>  ③ 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</p>
<p>  ④ 经常需要根据范围进行搜索的列上</p>
<p>  ⑤ 经常需要排序的列上</p>
<p>  ⑥ 经常使用在where子句上面的列上</p>
<h5 id="4、不应创建索引的场景"><a href="#4、不应创建索引的场景" class="headerlink" title="4、不应创建索引的场景"></a>4、不应创建索引的场景</h5><p>  ① 查询中很少用到的列</p>
<p>  ② 对于那些具有很少数据值的列，比如数据表中的性别列，bit数据类型的列</p>
<p>  ③ 对于那些定义为text、image的列，因为这些列的数据量相当大</p>
<p>  ④ 当对修改性能的要求远远大于搜索性能时，因为当增加索引时，会提高搜索性能，但是会降低修改性能</p>
<h5 id="5、索引的分类"><a href="#5、索引的分类" class="headerlink" title="5、索引的分类"></a>5、索引的分类</h5><ul>
<li><p>主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
</li>
<li><p>单列索引：一个索引只包含单个列，一个表可以有多个单列索引</p>
</li>
<li><p>唯一索引： 索引列的值必须唯一，但允许有空值</p>
</li>
<li><p>复合索引：一个索引包含多个列，在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)。如果一个表中的数据在查询时有多个字段总是同时出现则这些字段就可以作为复合索引，形成索引覆盖可以提高查询的效率。</p>
</li>
<li><p>聚集索引</p>
<p>指索引项的排序方式和表中数据记录排序方式一致的索引。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。</p>
<p>比如字典中，用‘拼音’查汉字，就是聚集索引。因为正文中字都是按照拼音排序的。而用‘偏旁部首’查汉字，就是非聚集索引，因为正文中的字并不是按照偏旁部首排序的，我们通过检字表得到正文中的字在索引中的映射，然后通过映射找到所需要的字。</p>
<p>聚集索引的使用场合为： </p>
<p>a、查询命令的回传结果是以该字段为排序依据的；<br>b、查询的结果返回一个区间的值；<br>c、查询的结果返回某值相同的大量结果集。<br>聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。</p>
</li>
<li><p>非聚集索引</p>
<p>与聚集索引相反， 索引顺序与物理存储顺序不一致。</p>
<p>非聚集索引的使用场合为： </p>
<p>a、查询所获数据量较少时； </p>
<p>b、某字段中的数据的唯一性比较高时；</p>
<p>非聚集索引必须是稠密索引</p>
</li>
<li><p>聚簇索引<br>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。</p>
<p>聚簇索引的特点：</p>
<p>① 聚簇索引具有唯一性，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p>
<p>② 表中行的物理顺序和索引中行的物理顺序是相同的，在创建任何非聚簇索引之前创建聚簇索引，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p>
<p>③ 聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键（类似oracle中的RowId）来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。</p>
</li>
<li><p>非聚簇索引</p>
<p>不是聚簇索引的二级索引，也叫辅助索引，都称为非聚簇索引。将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。</p>
</li>
<li><p>稠密索引</p>
<p>在稠密索引中，文件中的每个搜索码值都对应一个索引值。也就是说，稠密索引为数据记录文件的每一条记录都设一个键-指针对。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421124925.png"></p>
</li>
<li><p>稀疏索引</p>
<p>在稀疏索引中，只为搜索码的某些值建立索引项。也就是说，稀疏索引为数据记录文件的每个存储块设一个键-指针对，存储块意味着块内存储单元连续。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421130635.png"></p>
</li>
</ul>
<h5 id="6、聚集索引和非聚集索引的区别及优缺点"><a href="#6、聚集索引和非聚集索引的区别及优缺点" class="headerlink" title="6、聚集索引和非聚集索引的区别及优缺点"></a>6、聚集索引和非聚集索引的区别及优缺点</h5><p>区别：</p>
<p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个<br>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续<br>聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。<br>非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。<br>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>
<p>优势与缺点：</p>
<p>聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入），查询数据比非聚集数据的速度快。</p>
<h5 id="7、索引的底层原理，为什么用B-树而不用B树？"><a href="#7、索引的底层原理，为什么用B-树而不用B树？" class="headerlink" title="7、索引的底层原理，为什么用B+树而不用B树？"></a>7、索引的底层原理，为什么用B+树而不用B树？</h5><h6 id="（1）B-树和B-树"><a href="#（1）B-树和B-树" class="headerlink" title="（1）B+树和B-树"></a>（1）B+树和B-树</h6><ul>
<li><p>优势</p>
<p>B+树每个节点可以包含更多的节点，这样做有两个原因，一个是降低树的高度，另外一个是将数据范围变为多个区间，区间越多，数据检索越快</p>
<p>所有查询都要查找到叶子节点，查询性能稳定</p>
<p>所有叶子节点形成有序链表，便于范围查询</p>
</li>
<li><p>区别</p>
<p>B+树内节点不存储数据，所有数据存储在叶节点导致查询时间复杂度固定为 log n<br>B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)<br>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等<br>B+树更适合外部存储(存储磁盘数据)。由于内节点无 data 域，每个节点能索引的范围更大更精确</p>
</li>
</ul>
<h6 id="（2）问题1：MySQL中存储索引用到的数据结构是B-树，B-树的查询时间跟树的高度有关，是log-n-，如果用hash存储，那么查询时间是O-1-。既然hash比B-树更快，为什么mysql用B-树来存储索引呢？"><a href="#（2）问题1：MySQL中存储索引用到的数据结构是B-树，B-树的查询时间跟树的高度有关，是log-n-，如果用hash存储，那么查询时间是O-1-。既然hash比B-树更快，为什么mysql用B-树来存储索引呢？" class="headerlink" title="（2）问题1：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？"></a>（2）问题1：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？</h6><p>从内存角度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p>
<p>从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</p>
<h6 id="（3）问题2：为什么不用红黑树或者二叉排序树？"><a href="#（3）问题2：为什么不用红黑树或者二叉排序树？" class="headerlink" title="（3）问题2：为什么不用红黑树或者二叉排序树？"></a>（3）问题2：为什么不用红黑树或者二叉排序树？</h6><p>树的查询时间跟树的高度有关，B+树是一棵多路搜索树可以降低树的高度，提高查找效率</p>
<h6 id="（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？"><a href="#（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？" class="headerlink" title="（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？"></a>（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？</h6><p>这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找，</p>
<h6 id="（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B-树吗？"><a href="#（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B-树吗？" class="headerlink" title="（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？"></a>（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？</h6><p>B+树是在B树的基础上进行改造，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表。</p>
<p>下面是一个4路B+树，它的数据都在叶子结点，并且有链表相连。<br><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421125451.png"></p>
<h6 id="（6）为什么B-树要这样设计？"><a href="#（6）为什么B-树要这样设计？" class="headerlink" title="（6）为什么B+树要这样设计？"></a>（6）为什么B+树要这样设计？</h6><p>这个跟它的使用场景有关，B+树在数据库的索引中用得比较多，数据库中select数据，不一定只选一条，很多时候会选中多条，比如按照id进行排序后选100条。如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>
<p>比如选出7到19只需要在叶子结点中就能找到。<br><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421125531.png"></p>
<h1 id="四、Linux"><a href="#四、Linux" class="headerlink" title="四、Linux"></a>四、Linux</h1><h4 id="（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</li>
<li>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</li>
<li>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</li>
</ul>
<ul>
<li>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</li>
<li>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。</li>
</ul>
<h4 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4><h4 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p>
</li>
<li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p>
</li>
<li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p>
</li>
</ul>
<h4 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="D:/hexo/ztblog/source/_posts/fig/select.png" alt="select"><br>（2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="D:/hexo/ztblog/source/_posts/fig/epoll.png" alt="epoll"><br>详见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p>
<h4 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li>
</ul>
<h4 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4><p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p>
<ol>
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载</li>
</ol>
<h4 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h4><h4 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h4><h4 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h4><h4 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h4><h4 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4><h4 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4><h4 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h4><h4 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h4><p>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</p>
<h4 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h4><p>详见： <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></p>
<ol>
<li>cat 与 tac</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。tac语法：tac 文件名。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>more和less（常用）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | moremore的语法：more 文件名Enter 向下n行，需要定义，默认为1行； Ctrl f 向下滚动一屏； 空格键 向下滚动一屏； Ctrl b 返回上一屏； &#x3D; 输出当前行的行号； :f 输出文件名和当前行的行号； v 调用vi编辑器； ! 命令 调用Shell，并执行命令； q 退出moreless的功能和more相似，但是使用more无法向前翻页，只能向后翻。less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。less的语法：less 文件名</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>head和tail</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容head的语法：head [n number] 文件名 (number 显示行数)tail的功能恰好和head相反，只显示最后几行内容tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>nl</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来nl的语法：nl 文件名</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h4 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h4><h4 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h4><h4 id="（18）coredump是什么-怎么才能coredump"><a href="#（18）coredump是什么-怎么才能coredump" class="headerlink" title="（18）coredump是什么 怎么才能coredump"></a>（18）coredump是什么 怎么才能coredump</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>coredump产生的条件</p>
<ol>
<li>shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li>
<li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li>
<li>使用了线程不安全的函数，读写未加锁保护</li>
<li>错误使用指针转换</li>
<li>堆栈溢出</li>
</ol>
<h4 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h4><p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　</p>
<h4 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h4><p>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li>crontab命令用来对crontab文件进行管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：crontab [-u user] filecrontab [-u user] [ -e | -l | -r ]2．命令功能：通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。3．命令参数：-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：从&#x2F;var&#x2F;spool&#x2F;cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>

<ul>
<li>crontab文件内容</li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command其中：minute： 表示分钟，可以是从0到59之间的任何整数。hour：表示小时，可以是从0到23之间的任何整数。day：表示日期，可以是从1到31之间的任何整数。month：表示月份，可以是从1到12之间的任何整数。week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。在以上各个字段中，还可以使用以下特殊字符：星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*&#x2F;10，如果用在minute字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure>

<h4 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h4><ul>
<li>jobs</li>
</ul>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h5 id="1、软链接和硬链接的区别？"><a href="#1、软链接和硬链接的区别？" class="headerlink" title="1、软链接和硬链接的区别？"></a>1、软链接和硬链接的区别？</h5><p>1、语法上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软链接：ln -s 源文件 目标文件硬链接：ln 源文件 目标文件源文件：即你要对谁建立链接</span><br></pre></td></tr></table></figure>

<p>2、原理上</p>
<ul>
<li>硬链接(hard link)：文件A是文件B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。</li>
</ul>
<ul>
<li>软链接(soft link)：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</li>
</ul>
<p>3、使用限制上</p>
<ul>
<li><p>硬链接：<br>不能对目录创建硬链接，原因有几种，最重要的是：文件系统不能存在链接环（目录创建时的”..”除外，这个系统可以识别出来），存在环的后果会导致例如文件遍历等操作的混乱(du，pwd等命令的运作原理就是基于文件硬链接，顺便一提，ls -l 结果的第二列也是文件的硬链接数，即inode节点的链接数)</p>
<p>不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下。</p>
<p>不能对不存在的文件创建硬链接，由原理即可知原因。</p>
</li>
<li><p>软链接：<br>可以对目录创建软链接，遍历操作会忽略目录的软链接。</p>
<p>可以跨文件系统</p>
<p>可以对不存在的文件创建软链接，因为放的只是一个字符串，至于这个字符串是不是对于一个实际的文件，就是另外一回事了</p>
</li>
</ul>
<p>4、作用上</p>
<ul>
<li>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。只删除一个连接并不影响节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li>
<li>软链接又称之为符号连接（Symbolic Link）。软链接文件类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</li>
</ul>
<h1 id="五、操作系统"><a href="#五、操作系统" class="headerlink" title="五、操作系统"></a>五、操作系统</h1><h4 id="1、进程与线程的区别和联系（重点）"><a href="#1、进程与线程的区别和联系（重点）" class="headerlink" title="1、进程与线程的区别和联系（重点）"></a>1、进程与线程的区别和联系（重点）</h4><ul>
<li>区别</li>
</ul>
<ol>
<li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li>
<li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li>
<li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li>
<li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li>
</ol>
<ul>
<li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。</li>
</ul>
<h4 id="2、Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#2、Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="2、Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>2、Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4><p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p>
<h4 id="3、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#3、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="3、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>3、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h4><ul>
<li>存储器：内存</li>
<li>控制器：南桥北桥</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li>输出设备：显示器、网卡</li>
</ul>
<h4 id="4、进程之间的通信方法有哪几种-（重点）"><a href="#4、进程之间的通信方法有哪几种-（重点）" class="headerlink" title="4、进程之间的通信方法有哪几种 （重点）"></a>4、进程之间的通信方法有哪几种 （重点）</h4><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
<ul>
<li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="D:/hexo/ztblog/source/_posts/fig/管道通信.png" alt="fig/管道通信.png"></p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p>
</li>
<li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p>
</li>
<li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
</li>
<li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
</li>
</ul>
<h4 id="5、进程调度方法详细介绍"><a href="#5、进程调度方法详细介绍" class="headerlink" title="5、进程调度方法详细介绍"></a>5、进程调度方法详细介绍</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p>
<ul>
<li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。</li>
<li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li>
<li>多级反馈队列(Multilevel Feedback Queue) </li>
</ul>
<h4 id="6、进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#6、进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="6、进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>6、进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4><p>进程的执行需要经过三大步骤：编译，链接和装入。</p>
<ul>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：将模块装入内存运行</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h4 id="7、操作系统的内存管理说一下"><a href="#7、操作系统的内存管理说一下" class="headerlink" title="7、操作系统的内存管理说一下"></a>7、操作系统的内存管理说一下</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p>
<ul>
<li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li>
<li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li>
</ul>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p>
<h4 id="8、-实现一个LRU算法"><a href="#8、-实现一个LRU算法" class="headerlink" title="8、 实现一个LRU算法"></a>8、 实现一个LRU算法</h4><p>用到两个数据结构：哈希+双向链表 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,list&lt;pair&lt;int,int&gt; &gt; &gt; cache ;&#x2F;&#x2F; 存放键，迭代器list&lt;pair&lt;int,int&gt;&gt; auxlist; &#x2F;&#x2F; 存放 &lt;键，值&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;    int cap;    list&lt;pair&lt;int,int&gt;&gt; l;&#x2F;&#x2F; front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器    map&lt;int,list&lt;pair&lt;int,int&gt; &gt;::iterator &gt; cache;&#x2F;&#x2F; 存放键，迭代器public:    LRUCache(int capacity) &#123;        cap&#x3D;capacity;    &#125;        int get(int key) &#123;        auto mapitera &#x3D; cache.find(key);        if(mapitera&#x3D;&#x3D;cache.end())&#123;            return -1;        &#125;else&#123;&#x2F;&#x2F; found            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera &#x3D; mapitera-&gt;second;            int value &#x3D; (*listItera).second;            l.erase(listItera);            l.push_front(&#123;key,value&#125;);            cache[key]&#x3D;l.begin();            return value;        &#125;    &#125;        void put(int key, int value) &#123;        auto itera &#x3D; cache.find(key);        if(itera!&#x3D;cache.end())&#123;&#x2F;&#x2F; exist            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera &#x3D; itera-&gt;second;            l.erase(listItera);            l.push_front(&#123;key,value&#125;);            cache[key]&#x3D;l.begin();        &#125;else&#123;&#x2F;&#x2F; not exist            if(cache.size()&gt;&#x3D;cap)&#123;                pair&lt;int,int&gt; oldpair &#x3D; l.back();                l.pop_back();                cache.erase(oldpair.first);            &#125;            l.push_front(&#123;key,value&#125;);            cache[key]&#x3D;l.begin();        &#125;    &#125;&#125;;&#x2F;** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj &#x3D; new LRUCache(capacity); * int param_1 &#x3D; obj-&gt;get(key); * obj-&gt;put(key,value); *&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="9、死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#9、死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="9、死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>9、死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h4><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p>
<p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p>
<h4 id="10、死锁的恢复"><a href="#10、死锁的恢复" class="headerlink" title="10、死锁的恢复"></a>10、死锁的恢复</h4><ol>
<li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li>
<li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br>(1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li>
<li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br>(1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br>(2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li>
<li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br>(1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br>(2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li>
</ol>
<h4 id="11、什么是饥饿"><a href="#11、什么是饥饿" class="headerlink" title="11、什么是饥饿"></a>11、什么是饥饿</h4><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p>
<h4 id="12、-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#12、-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="12、 如果要你实现一个mutex互斥锁你要怎么实现？"></a>12、 如果要你实现一个mutex互斥锁你要怎么实现？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>); </span><br><span class="line">    flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123; </span><br><span class="line">    flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为while有可能被重入，所以可以用TestandSet()方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> old = *ptr;   </span><br><span class="line">    *ptr = <span class="keyword">new</span>;   </span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13、线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#13、线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="13、线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>13、线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4><p>线程之间通信：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<p>进程之间同步：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p>
<ul>
<li>信号量</li>
<li>管程</li>
</ul>
<h4 id="14、什么时候用多进程，什么时候用多线程"><a href="#14、什么时候用多进程，什么时候用多线程" class="headerlink" title="14、什么时候用多进程，什么时候用多线程"></a>14、什么时候用多进程，什么时候用多线程</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p>
<ul>
<li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h4 id="15、孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#15、孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="15、孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>15、孤儿进程和僵尸进程分别是什么，怎么形成的？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。</li>
</ul>
<h4 id="16、说一下PCB-说一下进程地址空间"><a href="#16、说一下PCB-说一下进程地址空间" class="headerlink" title="16、说一下PCB/说一下进程地址空间/"></a>16、说一下PCB/说一下进程地址空间/</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></p>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></p>
<p>进程地址空间内有：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据Data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>栈</li>
<li>堆</li>
</ul>
<h4 id="17、内核空间和用户空间是怎样区分的"><a href="#17、内核空间和用户空间是怎样区分的" class="headerlink" title="17、内核空间和用户空间是怎样区分的"></a>17、内核空间和用户空间是怎样区分的</h4><p>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p>
<h4 id="18、多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#18、多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="18、多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>18、多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量</li>
</ul>
<h4 id="19、同一个进程内的线程会共享什么资源？"><a href="#19、同一个进程内的线程会共享什么资源？" class="headerlink" title="19、同一个进程内的线程会共享什么资源？"></a>19、同一个进程内的线程会共享什么资源？</h4><ul>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的</p>
<h4 id="20、异常和中断的区别"><a href="#20、异常和中断的区别" class="headerlink" title="20、异常和中断的区别"></a>20、异常和中断的区别</h4><h4 id="21、一般情况下在Linux-windows平台下栈空间的大小"><a href="#21、一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="21、一般情况下在Linux/windows平台下栈空间的大小"></a>21、一般情况下在Linux/windows平台下栈空间的大小</h4><p>在Linux下栈空间通常是8M，Windows下是1M</p>
<h4 id="22、虚拟内存的了解"><a href="#22、虚拟内存的了解" class="headerlink" title="22、虚拟内存的了解"></a>22、虚拟内存的了解</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p>
<h4 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h4><ol>
<li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
</li>
</ol>
<h4 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h4><p>协程和微线程是一个东西。</p>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p>
<h4 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h4 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h4><ul>
<li><p>三态模型<br>三态模型包括三种状态：</p>
<ol>
<li>执行：进程分到CPU时间片，可以执行</li>
<li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li>
<li>阻塞：有IO事件或者等待其他资源<br><img src="D:/hexo/ztblog/source/_posts/fig/三态模型.png"></li>
</ol>
</li>
<li><p>五态模型</p>
<ol>
<li>新建态：进程刚刚创建。</li>
<li>就绪态：</li>
<li>运行态：</li>
<li>等待态：出现等待事件</li>
<li>终止态：进程结束<br><img src="D:/hexo/ztblog/source/_posts/fig/五态模型.png"></li>
</ol>
</li>
<li><p>七态模型</p>
<ol>
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态<br><img src="D:/hexo/ztblog/source/_posts/fig/七态模型.png"></li>
</ol>
</li>
</ul>
<h4 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h4 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span>  <span class="keyword">short</span> s;  <span class="keyword">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;&#125;un;un.s=0x0102;if(un.c[0]==1 and un.c[1]==2) cout&lt;&lt;&quot;大端&quot;;if(un.c[0]==2 and un.c[1]==1) cout&lt;&lt;&quot;小端&quot;;</span></span><br></pre></td></tr></table></figure>

<p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h5 id="1、进程和线程以及它们的区别："><a href="#1、进程和线程以及它们的区别：" class="headerlink" title="1、进程和线程以及它们的区别："></a>1、进程和线程以及它们的区别：</h5><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</p>
<p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
<p>一个进程可以有多个线程，多个线程也可以并发执行</p>
<h5 id="2、线程同步的方式有哪些？"><a href="#2、线程同步的方式有哪些？" class="headerlink" title="2、线程同步的方式有哪些？"></a>2、线程同步的方式有哪些？</h5><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p>
<p>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>
<p>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p>
<h5 id="3、进程的通信方式有哪些？"><a href="#3、进程的通信方式有哪些？" class="headerlink" title="3、进程的通信方式有哪些？"></a>3、进程的通信方式有哪些？</h5><p>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</p>
<p>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</p>
<p>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</p>
<p>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</p>
<p>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</p>
<p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。 </p>
<h5 id="4、什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#4、什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="4、什么是缓冲区溢出？有什么危害？其原因是什么？"></a>4、什么是缓冲区溢出？有什么危害？其原因是什么？</h5><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝额服务</li>
<li>跳转并且执行一段恶意代码</li>
<li>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</li>
</ul>
<h5 id="5、什么是死锁？死锁产生的条件？"><a href="#5、什么是死锁？死锁产生的条件？" class="headerlink" title="5、什么是死锁？死锁产生的条件？"></a>5、什么是死锁？死锁产生的条件？</h5><p> 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<p> 死锁产生的四个条件（有一个条件不成立，则不会产生死锁）：</p>
<ul>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
<li>如果对死锁还不是太熟悉，建议阅读：死锁产生的原因和解锁的方法</li>
</ul>
<h5 id="6、进程有哪几种状态？"><a href="#6、进程有哪几种状态？" class="headerlink" title="6、进程有哪几种状态？"></a>6、进程有哪几种状态？</h5><p> 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</p>
<p>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</p>
<p>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</p>
<h5 id="7、分页和分段有什么区别？"><a href="#7、分页和分段有什么区别？" class="headerlink" title="7、分页和分段有什么区别？"></a>7、分页和分段有什么区别？</h5><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</p>
<p>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</p>
<p>段向用户提供二维地址空间；页向用户提供的是一维地址空间</p>
<p>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</p>
<h5 id="8、操作系统中进程调度策略有哪几种？"><a href="#8、操作系统中进程调度策略有哪几种？" class="headerlink" title="8、操作系统中进程调度策略有哪几种？"></a>8、操作系统中进程调度策略有哪几种？</h5><p> FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p>
<h5 id="9、进程同步有哪几种机制"><a href="#9、进程同步有哪几种机制" class="headerlink" title="9、进程同步有哪几种机制"></a>9、进程同步有哪几种机制</h5><p> 原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>
<h5 id="10、死锁的处理基本策略和常用方法"><a href="#10、死锁的处理基本策略和常用方法" class="headerlink" title="10、死锁的处理基本策略和常用方法"></a>10、死锁的处理基本策略和常用方法</h5><p>解决死锁的基本方法如下： </p>
<p>预防死锁、避免死锁、检测死锁、解除死锁</p>
<p>解决四多的常用策略如下：</p>
<p>鸵鸟策略、预防策略、避免策略、检测与解除死锁</p>
<h1 id="六、场景题-算法题"><a href="#六、场景题-算法题" class="headerlink" title="六、场景题/算法题"></a>六、场景题/算法题</h1><h4 id="（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p>
<h4 id="（1）-介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）-介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1） 介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4><h4 id="（2）-写单例模式，线程安全版本"><a href="#（2）-写单例模式，线程安全版本" class="headerlink" title="（2） 写单例模式，线程安全版本"></a>（2） 写单例模式，线程安全版本</h4><figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span>  <span class="keyword">private</span>:    <span class="keyword">static</span> Singleton* instance;    <span class="built_in">Singleton</span>()&#123;      <span class="comment">// initialize    &#125;  public:    static Singleton* getInstance()&#123;      if(instance==nullptr) instance=new Singleton();      return instance;    &#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="（3）-写三个线程交替打印ABC"><a href="#（3）-写三个线程交替打印ABC" class="headerlink" title="（3） 写三个线程交替打印ABC"></a>（3） 写三个线程交替打印ABC</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span>using namespace std;mutex mymutex;condition_variable cv;int flag=0;void printa()&#123;    unique_lock<span class="meta-string">&lt;mutex&gt;</span> lk(mymutex);    int count=0;    while(count<span class="meta-string">&lt;10)&#123;        while(flag!=0) cv.wait(lk);        cout&lt;&lt;&quot;thread 1: a&quot;&lt;&lt;endl;        flag=1;        cv.notify_all();        count++;    &#125;    cout&lt;&lt;&quot;my thread 1 finish&quot;&lt;&lt;endl;&#125;void printb()&#123;    unique_lock&lt;mutex&gt;</span> lk(mymutex);    for(int i=0;i<span class="meta-string">&lt;10;i++)&#123;        while(flag!=1) cv.wait(lk);        cout&lt;&lt;&quot;thread 2: b&quot;&lt;&lt;endl;        flag=2;        cv.notify_all();    &#125;    cout&lt;&lt;&quot;my thread 2 finish&quot;&lt;&lt;endl;&#125;void printc()&#123;    unique_lock&lt;mutex&gt;</span> lk(mymutex);    for(int i=0;i&lt;10;i++)&#123;        while(flag!=2) cv.wait(lk);        cout&lt;&lt;<span class="meta-string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;        flag=0;        cv.notify_all();    &#125;    cout&lt;&lt;<span class="meta-string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;&#125;int main()&#123;    thread th2(printa);    thread th1(printb);    thread th3(printc);    th1.join();    th2.join();    th3.join();    cout&lt;&lt;<span class="meta-string">&quot; main thread &quot;</span>&lt;&lt;endl;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="（4）-二维码登录的实现过程-场景题"><a href="#（4）-二维码登录的实现过程-场景题" class="headerlink" title="（4） 二维码登录的实现过程 场景题"></a>（4） 二维码登录的实现过程 场景题</h4><p><img src="D:/hexo/ztblog/source/_posts/fig/二维码登录流程.png"></p>
<h4 id="（5）-不使用临时变量实现swap函数"><a href="#（5）-不使用临时变量实现swap函数" class="headerlink" title="（5） 不使用临时变量实现swap函数"></a>（5） 不使用临时变量实现swap函数</h4><ul>
<li>使用异或/加减等方式，下面给出使用异或的实现方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span>&#123;  a=a^b;  b=a^b;  a=a^b;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4><h4 id="（7）-实现快排"><a href="#（7）-实现快排" class="headerlink" title="（7） 实现快排"></a>（7） 实现快排</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    vec[a]=vec[a]^vec[b];    vec[b]=vec[a]^vec[b];    vec[a]=vec[a]^vec[b];&#125;<span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;    <span class="keyword">int</span> pivot=vec[start+(end-start)/<span class="number">2</span>];    <span class="keyword">while</span>(start&lt;end)&#123;        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[start]&lt;pivot) start++;        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[end]&gt;pivot) end--;        <span class="keyword">if</span>(start&lt;end) <span class="built_in">swap</span>(vec,start,end);    &#125;    <span class="keyword">return</span> start;&#125;<span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;    <span class="keyword">int</span> pivot=<span class="built_in">partition</span>(vec,start,end);    <span class="built_in">quickSort</span>(vec,start,pivot<span class="number">-1</span>);    <span class="built_in">quickSort</span>(vec,pivot+<span class="number">1</span>,end);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（8）-实现一个堆排序"><a href="#（8）-实现一个堆排序" class="headerlink" title="（8） 实现一个堆排序"></a>（8） 实现一个堆排序</h4><p>堆排序的基本过程：</p>
<ul>
<li>将n个元素的序列构建一个大顶堆或小顶堆</li>
<li>将堆顶的元素放到序列末尾</li>
<li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li>
</ul>
<p>整体时间复杂度为nlogn</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>using namespace std;void swap(vector<span class="meta-string">&lt;int&gt;</span>&amp; arr, int a,int b)&#123;    arr[a]=arr[a]^arr[b];    arr[b]=arr[a]^arr[b];    arr[a]=arr[a]^arr[b];&#125;void adjust(vector<span class="meta-string">&lt;int&gt;</span>&amp; arr,int len,int index)&#123;    int maxid=index;    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2    int left=2*index+1,right=2*index+2;    // 寻找当前以index为根的子树中最大/最小的元素的下标    if(left&lt;len and arr[left]&lt;arr[maxid]) maxid=left;    if(right&lt;len and arr[right]&lt;arr[maxid]) maxid=right;    // 进行交换，记得要递归进行adjust,传入的index是maxid    if(maxid!=index)&#123;        swap(arr,maxid,index);        adjust(arr,len,maxid);    &#125;&#125;void heapsort(vector&lt;int&gt;&amp;arr,int len)&#123;    // 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号    for(int i=(len-1-1)/2;i&gt;=0;i--)&#123;        adjust(arr,len,i);    &#125;    // 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust    for(int i=len-1;i&gt;0;i--)&#123;        swap(arr,0,i);        adjust(arr,i,0);// 注意每次adjust是从根往下调整，所以这里index是0！    &#125;&#125;int main()&#123;    vector&lt;int&gt; arr=&#123;3,4,2,1,5,8,7,6&#125;;    cout&lt;&lt;&quot;before: &quot;&lt;&lt;endl;    for(int item:arr) cout&lt;&lt;item&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;    heapsort(arr,arr.size());    cout&lt;&lt;&quot;after: &quot;&lt;&lt;endl;    for(int item:arr)cout&lt;&lt;item&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="（8）-实现一个插入排序"><a href="#（8）-实现一个插入排序" class="headerlink" title="（8） 实现一个插入排序"></a>（8） 实现一个插入排序</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;  <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;    <span class="keyword">int</span> key=nums[i];    <span class="keyword">int</span> j=i<span class="number">-1</span>;    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j]&gt;key)&#123;      nums[j+<span class="number">1</span>]=nums[j];      j--;    &#125;    nums[j+<span class="number">1</span>]=key;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（9）-快排存在的问题，如何优化"><a href="#（9）-快排存在的问题，如何优化" class="headerlink" title="（9） 快排存在的问题，如何优化"></a>（9） 快排存在的问题，如何优化</h4><ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列</p>
<h4 id="（10）-反转一个链表（招银网络二面）"><a href="#（10）-反转一个链表（招银网络二面）" class="headerlink" title="（10） 反转一个链表（招银网络二面）"></a>（10） 反转一个链表（招银网络二面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span></span>&#123;  ListNode* pre=<span class="literal">nullptr</span>,cur=root,nxt;  <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;    nxt=cur-&gt;next;    cur-&gt;next=pre;    pre=cur;cur=nxt;  &#125;  <span class="keyword">return</span> pre;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4><p><em>Top K 问题的常见形式：</em></p>
<blockquote>
<p>给定10000个整数，找第K大（第K小）的数<br><br>给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p>
</blockquote>
<p><em>解决Top K问题若干种方法</em></p>
<ul>
<li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li>
<li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li>
<li>使用排序方法，排序后再寻找top K元素。</li>
<li>使用选择排序的思想，对前K个元素部分排序。</li>
<li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li>
</ul>
<ol>
<li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li>
</ol>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>    <span class="keyword">int</span> value;    <span class="keyword">int</span> idx;    <span class="built_in">Node</span> (<span class="keyword">int</span> v, <span class="keyword">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) ; &#125;;<span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) &#123;    <span class="keyword">return</span> n1.value &lt; n2.value;&#125;priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li>
</ol>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此为Java实现public int findKthLargest(int[] nums, int k) &#123;  return quickSelect(nums, k, 0, nums.length - 1);&#125;&#x2F;&#x2F; quick select to find the kth-largest elementpublic int quickSelect(int[] arr, int k, int left, int right) &#123;  if (left &#x3D;&#x3D; right) return arr[right];  int index &#x3D; partition(arr, left, right);  if (index - left + 1 &gt; k)    return quickSelect(arr, k, left, index - 1);  else if (index - left + 1 &#x3D;&#x3D; k)    return arr[index];  else    return quickSelect(arr, k - (index - left + 1), index + 1, right);&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li>
</ol>
<h4 id="（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4><p>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p>
<h4 id="（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span>using namespace std;struct treeNode&#123;    string val;    treeNode* left,*right;    treeNode(string val):val(val)&#123;        left=nullptr;        right=nullptr;    &#125;&#125;;treeNode* vec2tree(vector<span class="meta-string">&lt;string&gt;</span>&amp; vec,int&amp; start)&#123;    treeNode* root;    <span class="meta-keyword">if</span>(vec[start]==<span class="meta-string">&quot;null&quot;</span>)&#123;        start+=1;        root=nullptr;    &#125;<span class="meta-keyword">else</span>&#123;        root=new treeNode(vec[start]);        start+=1;        root-&gt;left=vec2tree(vec,start);        root-&gt;right=vec2tree(vec,start);    &#125;    return root;&#125;void tree2vec(treeNode *root,vector<span class="meta-string">&lt;string&gt;</span>&amp; vec)&#123;    <span class="meta-keyword">if</span>(root==nullptr)&#123;        vec.push_back(<span class="meta-string">&quot;null&quot;</span>);    &#125;<span class="meta-keyword">else</span>&#123;        vec.push_back(root-&gt;val);        tree2vec(root-&gt;left,vec);        tree2vec(root-&gt;right,vec);    &#125;&#125;int main()&#123;    vector<span class="meta-string">&lt;string&gt;</span> vec=&#123;<span class="meta-string">&quot;2&quot;</span>,<span class="meta-string">&quot;4&quot;</span>,<span class="meta-string">&quot;5&quot;</span>,<span class="meta-string">&quot;7&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;3&quot;</span>,<span class="meta-string">&quot;6&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;2&quot;</span>,<span class="meta-string">&quot;null&quot;</span>,<span class="meta-string">&quot;null&quot;</span>&#125;;    int index=0,&amp;start=index;    treeNode* root=vec2tree(vec,start);    <span class="comment">//displaytree(root);    vector&lt;string&gt; mvec;    tree2vec(root,mvec);    for(string item:mvec) cout&lt;&lt;item&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;    return 0;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="（14）-介绍一下b树和它的应用场景有哪些"><a href="#（14）-介绍一下b树和它的应用场景有哪些" class="headerlink" title="（14） 介绍一下b树和它的应用场景有哪些"></a>（14） 介绍一下b树和它的应用场景有哪些</h4><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m/2 &lt;= k &lt;= m）</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li>
</ol>
<p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p>
<p>查询时间复杂度是logN</p>
<h4 id="（15）-介绍一下b-树和它的应用场景有哪些"><a href="#（15）-介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（15） 介绍一下b+树和它的应用场景有哪些"></a>（15） 介绍一下b+树和它的应用场景有哪些</h4><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p>
<p>应用场景主要是数据库的索引</p>
<p>查询时间复杂度也是logN<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p>
<h4 id="（16）-介绍一下红黑树和它的应用场景有哪些"><a href="#（16）-介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（16） 介绍一下红黑树和它的应用场景有哪些"></a>（16） 介绍一下红黑树和它的应用场景有哪些</h4><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶节点的空节点是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li>
<li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li>
</ol>
<p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p>
<p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p>
<h4 id="（17）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（17）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（17） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> limit <span class="number">1000</span> <span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure>

<h4 id="（18）-N个骰子出现和为m的概率"><a href="#（18）-N个骰子出现和为m的概率" class="headerlink" title="（18） N个骰子出现和为m的概率"></a>（18） N个骰子出现和为m的概率</h4><h4 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h4><h4 id="（20）-一致性哈希"><a href="#（20）-一致性哈希" class="headerlink" title="（20） 一致性哈希"></a>（20） 一致性哈希</h4><h4 id="（21）希尔排序说一下-手撕"><a href="#（21）希尔排序说一下-手撕" class="headerlink" title="（21）希尔排序说一下/手撕"></a>（21）希尔排序说一下/手撕</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="（22）Dijkstra算法说一下"><a href="#（22）Dijkstra算法说一下" class="headerlink" title="（22）Dijkstra算法说一下"></a>（22）Dijkstra算法说一下</h4><h4 id="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4><p>模拟STL中vector的实现即可，去看一下vector的源码。</p>
<h4 id="（24）最小生成树算法说一下"><a href="#（24）最小生成树算法说一下" class="headerlink" title="（24）最小生成树算法说一下"></a>（24）最小生成树算法说一下</h4><h4 id="（25）-海量数据的bitmap使用原理"><a href="#（25）-海量数据的bitmap使用原理" class="headerlink" title="（25） 海量数据的bitmap使用原理"></a>（25） 海量数据的bitmap使用原理</h4><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p>
<p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int = 4字节  =4*8比特 = 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max/32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="D:/hexo/ztblog/source/_posts/fig/bitmap1.png"></p>
<p><strong>移位计算公式：</strong><br>N/32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F = 00011111)<br><br>模32然后相应位置置为1： a[i] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p>所以总的公式为： a[ N&gt;&gt;5 ] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p><strong>BitMap算法评价</strong></p>
<ul>
<li>优点：<ol>
<li>运算效率高，不进行比较和移位；</li>
<li>占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。</li>
</ol>
</li>
<li>缺点：<ol>
<li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li>
<li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li>
</ol>
</li>
</ul>
<h4 id="（26）-布隆过滤器原理与优点"><a href="#（26）-布隆过滤器原理与优点" class="headerlink" title="（26） 布隆过滤器原理与优点"></a>（26） 布隆过滤器原理与优点</h4><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p>
<p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p>
<p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p>
<p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p>
<p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p>
<p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="D:/hexo/ztblog/source/_posts/fig/布隆过滤器.png"></p>
<h4 id="（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4><h4 id="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评测题目: class FIFOQueue&#123;vector&lt;int&gt; vec(initCap,0);int start=0,end=0;condition_variable cv;mutex m;bool flag=false;// isFull  bool enqueue(int v) &#123;  	unique_lock&lt;mutex&gt;&lt;/mutex&gt; lk(m);    while(flag==true) cv.wait(lk);        end=(end+1)%initCap;        vec[end]=v;        cv.notifyall();        return true;    &#125;  &#125;  int dequeue() &#123;  unique_lock&lt;mutex&gt;&lt;/mutex&gt; lk(m);  	if(start!=end)&#123;    	int val = vec[start];    	start=(start+1)%initCap;        flag=false;    	cv.notifyall();        return val;    &#125;else&#123;    	flag=false;    	cv.notifyall();    	return -1;  	&#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p>
<h1 id="七、智力题"><a href="#七、智力题" class="headerlink" title="七、智力题"></a>七、智力题</h1><h4 id="（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"><a href="#（1）-100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）" class="headerlink" title="（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）"></a>（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h4><ul>
<li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100/2=50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50/2=25楼扔起，重复。</li>
<li>动态规划</li>
</ul>
<h4 id="（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"><a href="#（2）-毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠" class="headerlink" title="（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠"></a>（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h4><p>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。</p>
<h4 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h4><h4 id="（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"><a href="#（4）-先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿" class="headerlink" title="（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿"></a>（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h4><p>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。</p>
<h4 id="（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"><a href="#（5）-放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。" class="headerlink" title="（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。"></a>（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h4><p>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。</p>
<h4 id="（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"><a href="#（6）-瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶" class="headerlink" title="（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶"></a>（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h4><p>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。</p>
<h4 id="（7）在24小时里面时针分针秒针可以重合几次"><a href="#（7）在24小时里面时针分针秒针可以重合几次" class="headerlink" title="（7）在24小时里面时针分针秒针可以重合几次"></a>（7）在24小时里面时针分针秒针可以重合几次</h4><p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p>
<h4 id="（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"><a href="#（8）-有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？" class="headerlink" title="（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？"></a>（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h4><p>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；</p>
<h4 id="（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"><a href="#（9）-有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？" class="headerlink" title="（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？"></a>（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h4><p>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组</p>
<h4 id="（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？"><a href="#（10）生成随机数问题：给定生成1到5的随机数Rand5-，如何得到生成1到7的随机数函数Rand7-？" class="headerlink" title="（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？"></a>（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h4><p>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>记住下面这个式子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RandNN&#x3D; N( RandN()-1 ) + RandN() ;&#x2F;&#x2F; 生成1到N^2之间的随机数可以看作是在数轴上撒豆子。N是跨度&#x2F;步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙</span><br></pre></td></tr></table></figure>

<p>比如<code> Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rand7()&#123;  int x&#x3D;INT_MAX;  while(x&gt;21)&#123;    x&#x3D;5*(rand5()-1)+rand5();  &#125;  return x%7+1;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"><a href="#赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？" class="headerlink" title="赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？"></a>赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h4><ul>
<li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。 </li>
<li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li>
<li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li>
<li>所以一共是5+3+1=9场。</li>
</ul>
<h4 id="烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"><a href="#烧-香-绳子-其他-确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？" class="headerlink" title="烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？"></a>烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h4><p>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p>
<h4 id="掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"><a href="#掰巧克力问题-NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）" class="headerlink" title="掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）"></a>掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p>
<p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。</p>
<h1 id="八、-大数据"><a href="#八、-大数据" class="headerlink" title="八、 大数据"></a>八、 大数据</h1><h4 id="1-介绍一下Hadoop"><a href="#1-介绍一下Hadoop" class="headerlink" title="1. 介绍一下Hadoop"></a>1. 介绍一下Hadoop</h4><p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p>
<ul>
<li>HDFS提供分布式的数据存储</li>
<li>MapReduce负责进行数据运算 </li>
<li>YARN负责任务调度</li>
</ul>
<p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p>
<h4 id="2-说一下MapReduce的运行机制"><a href="#2-说一下MapReduce的运行机制" class="headerlink" title="2. 说一下MapReduce的运行机制"></a>2. 说一下MapReduce的运行机制</h4><p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p>
<ul>
<li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li>
<li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li>
<li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li>
<li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  <a target="_blank" rel="noopener" href="https://blog.csdn.net/ASN_forever/article/details/81233547">https://blog.csdn.net/ASN_forever/article/details/81233547</a></li>
<li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li>
</ul>
<h4 id="3-介绍一下kafka"><a href="#3-介绍一下kafka" class="headerlink" title="3. 介绍一下kafka"></a>3. 介绍一下kafka</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29186199/article/details/80827085">https://blog.csdn.net/qq_29186199/article/details/80827085</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/student__software/article/details/81486431">https://blog.csdn.net/student__software/article/details/81486431</a></p>
<p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。 </p>
<p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p>
<h4 id="4-为什么kafka吞吐量高？-介绍一下零拷贝"><a href="#4-为什么kafka吞吐量高？-介绍一下零拷贝" class="headerlink" title="4. 为什么kafka吞吐量高？/介绍一下零拷贝"></a>4. 为什么kafka吞吐量高？/介绍一下零拷贝</h4><p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p>
<p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p>
<h4 id="5-介绍一下spark"><a href="#5-介绍一下spark" class="headerlink" title="5. 介绍一下spark"></a>5. 介绍一下spark</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011204847/article/details/51010205">https://blog.csdn.net/u011204847/article/details/51010205</a></p>
<p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p>
<h4 id="6-介绍一下spark-streaming"><a href="#6-介绍一下spark-streaming" class="headerlink" title="6. 介绍一下spark-streaming"></a>6. 介绍一下spark-streaming</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu0_zhang0/article/details/80569946">https://blog.csdn.net/yu0_zhang0/article/details/80569946</a></p>
<p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p>
<p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。 </p>
<h4 id="7-spark的transformation和action有什么区别"><a href="#7-spark的transformation和action有什么区别" class="headerlink" title="7. spark的transformation和action有什么区别"></a>7. spark的transformation和action有什么区别</h4><p>spark的算子分成transformation和action两类</p>
<ul>
<li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 </li>
<li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark</li>
</ul>
<h4 id="8-spark常用的算子说几个"><a href="#8-spark常用的算子说几个" class="headerlink" title="8. spark常用的算子说几个"></a>8. spark常用的算子说几个</h4><p>spark的算子分为两类：transformation和action</p>
<p>常用的transformation算子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 求并集val rdd8 = rdd6.union(rdd7)// intersection 求交集 val rdd9 = rdd6.intersection(rdd7)// join 将rdd进行聚合连接，类似数据库的join val rdd3 = rdd1.join(rdd2)// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 val arr1 = Array(1,2,3,4,5)val arr2 = rdd1.map(_+1)// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span></span><br></pre></td></tr></table></figure>

<p>常用的action算子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 按照一定的方法将元素进行合并 val rdd2 = rdd1.reduce(_+_)// collect 将RDD转换为数组rdd1.collect// top 返回最大的k个元素rdd1.top(2)</span></span><br></pre></td></tr></table></figure>

<h4 id="9-如何保证kafka的消息不丢失"><a href="#9-如何保证kafka的消息不丢失" class="headerlink" title="9. 如何保证kafka的消息不丢失"></a>9. 如何保证kafka的消息不丢失</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liudashuang2017/article/details/88576274">https://blog.csdn.net/liudashuang2017/article/details/88576274</a></p>
<p>我们可以从三个方面保证kafka不丢失消息</p>
<ul>
<li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li>
<li>在consumer消费者方面，关闭自动提交；</li>
<li>在broker集群方面，设置复制系数replica.factor为大于等于3</li>
</ul>
<h4 id="10-kafka如何选举leader"><a href="#10-kafka如何选举leader" class="headerlink" title="10. kafka如何选举leader"></a>10. kafka如何选举leader</h4><p>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p>
<h4 id="11-说下spark中的宽依赖和窄依赖"><a href="#11-说下spark中的宽依赖和窄依赖" class="headerlink" title="11. 说下spark中的宽依赖和窄依赖"></a>11. 说下spark中的宽依赖和窄依赖</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1043498776/article/details/54889922">https://blog.csdn.net/a1043498776/article/details/54889922</a></p>
<ul>
<li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li>
<li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br><img src="https://img-blog.csdn.net/20170206221148299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEwNDM0OTg3NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></li>
</ul>
<h4 id="12-说下spark中stage是依照什么划分的"><a href="#12-说下spark中stage是依照什么划分的" class="headerlink" title="12. 说下spark中stage是依照什么划分的"></a>12. 说下spark中stage是依照什么划分的</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57124273">https://zhuanlan.zhihu.com/p/57124273</a></p>
<p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p>
<h4 id="13-spark的内存管理是怎样的"><a href="#13-spark的内存管理是怎样的" class="headerlink" title="13. spark的内存管理是怎样的"></a>13. spark的内存管理是怎样的</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f1e551553ae">https://www.jianshu.com/p/4f1e551553ae</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wzj4858/p/8204282.html">https://www.cnblogs.com/wzj4858/p/8204282.html</a></p>
<p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p>
<ul>
<li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li>
</ul>
<p><img src="D:/hexo/ztblog/source/_posts/fig/spark内存一.png"></p>
<ul>
<li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br><img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li>
</ul>
<h4 id="14-spark的容错机制是什么样的"><a href="#14-spark的容错机制是什么样的" class="headerlink" title="14. spark的容错机制是什么样的"></a>14. spark的容错机制是什么样的</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dengxing1234/article/details/73613484">https://blog.csdn.net/dengxing1234/article/details/73613484</a></p>
<p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p>
<ul>
<li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li>
<li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li>
</ul>
<h1 id="九、HR面"><a href="#九、HR面" class="headerlink" title="九、HR面"></a>九、HR面</h1><h4 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h4><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p>
<h4 id="2-项目中遇到的最大难点"><a href="#2-项目中遇到的最大难点" class="headerlink" title="2. 项目中遇到的最大难点"></a>2. 项目中遇到的最大难点</h4><ul>
<li><p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p>
</li>
<li><p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p>
</li>
</ul>
<h4 id="3-项目中的收获"><a href="#3-项目中的收获" class="headerlink" title="3. 项目中的收获"></a>3. 项目中的收获</h4><p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p>
<p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p>
<h4 id="4-可以实习的时间，实习时长"><a href="#4-可以实习的时间，实习时长" class="headerlink" title="4. 可以实习的时间，实习时长"></a>4. 可以实习的时间，实习时长</h4><p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p>
<h4 id="5-哪里人"><a href="#5-哪里人" class="headerlink" title="5. 哪里人"></a>5. 哪里人</h4><h4 id="6-说一下自己的性格"><a href="#6-说一下自己的性格" class="headerlink" title="6. 说一下自己的性格"></a>6. 说一下自己的性格</h4><p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p>
<h4 id="7-你的优缺点是什么"><a href="#7-你的优缺点是什么" class="headerlink" title="7. 你的优缺点是什么"></a>7. 你的优缺点是什么</h4><p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p>
<p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p>
<h4 id="8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样"><a href="#8-有什么兴趣爱好，画的怎么样-球打的如何-游戏打的怎么样" class="headerlink" title="8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样"></a>8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样</h4><p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p>
<h4 id="9-看过最好的一本书是什么"><a href="#9-看过最好的一本书是什么" class="headerlink" title="9. 看过最好的一本书是什么"></a>9. 看过最好的一本书是什么</h4><p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p>
<p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p>
<h4 id="10-学习技术中有什么难点"><a href="#10-学习技术中有什么难点" class="headerlink" title="10. 学习技术中有什么难点"></a>10. 学习技术中有什么难点</h4><h4 id="11-怎么看待加班"><a href="#11-怎么看待加班" class="headerlink" title="11. 怎么看待加班"></a>11. 怎么看待加班</h4><p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p>
<h4 id="12-觉得深圳怎么样（或者其他地点）"><a href="#12-觉得深圳怎么样（或者其他地点）" class="headerlink" title="12. 觉得深圳怎么样（或者其他地点）"></a>12. 觉得深圳怎么样（或者其他地点）</h4><h4 id="13-遇见过最大的挫折是什么，怎么解决的"><a href="#13-遇见过最大的挫折是什么，怎么解决的" class="headerlink" title="13. 遇见过最大的挫折是什么，怎么解决的"></a>13. 遇见过最大的挫折是什么，怎么解决的</h4><h4 id="14-职业规划"><a href="#14-职业规划" class="headerlink" title="14. 职业规划"></a>14. 职业规划</h4><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p>
<p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p>
<h4 id="15-目前的offer情况"><a href="#15-目前的offer情况" class="headerlink" title="15. 目前的offer情况"></a>15. 目前的offer情况</h4><p>可以如实说</p>
<h4 id="16-你最大的优势和劣势是什么"><a href="#16-你最大的优势和劣势是什么" class="headerlink" title="16. 你最大的优势和劣势是什么"></a>16. 你最大的优势和劣势是什么</h4><ul>
<li>优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。</li>
<li>劣势：有时候做事情比较急躁，容易导致粗心。</li>
</ul>
<h4 id="17-介绍在项目里面充当的角色"><a href="#17-介绍在项目里面充当的角色" class="headerlink" title="17. 介绍在项目里面充当的角色"></a>17. 介绍在项目里面充当的角色</h4><h4 id="18-介绍一下本科获得的全国赛奖项的情况"><a href="#18-介绍一下本科获得的全国赛奖项的情况" class="headerlink" title="18. 介绍一下本科获得的全国赛奖项的情况"></a>18. 介绍一下本科获得的全国赛奖项的情况</h4><h4 id="19-最有成就感的事情-最骄傲的一件事情"><a href="#19-最有成就感的事情-最骄傲的一件事情" class="headerlink" title="19. 最有成就感的事情/最骄傲的一件事情"></a>19. 最有成就感的事情/最骄傲的一件事情</h4><ul>
<li>本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩</li>
<li>保研夏令营拿到了四个学校的offer</li>
</ul>
<h4 id="20-在实验室中担任什么角色，参加的XXX能聊聊吗"><a href="#20-在实验室中担任什么角色，参加的XXX能聊聊吗" class="headerlink" title="20. 在实验室中担任什么角色，参加的XXX能聊聊吗"></a>20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h4><h4 id="22-用两个词来形容自己"><a href="#22-用两个词来形容自己" class="headerlink" title="22. 用两个词来形容自己"></a>22. 用两个词来形容自己</h4><p>踏实 认真</p>
<h1 id="十、其他面经整理"><a href="#十、其他面经整理" class="headerlink" title="十、其他面经整理"></a>十、其他面经整理</h1><h4 id="1、c-构造函数可以是私有的吗？析构函数呢？拷贝构造？赋值操作符？"><a href="#1、c-构造函数可以是私有的吗？析构函数呢？拷贝构造？赋值操作符？" class="headerlink" title="1、c++ 构造函数可以是私有的吗？析构函数呢？拷贝构造？赋值操作符？"></a>1、c++ 构造函数可以是私有的吗？析构函数呢？拷贝构造？赋值操作符？</h4><p>对于<strong>protected</strong>的函数，子类的“内部”的其他函数可以调用之。而对于<strong>private</strong>的函数，只能被本类“内部”的其他函数调用。</p>
<ul>
<li><p>构造函数定义为<code>protected</code>后，不能在类的外部构造对象，只能在外部构造该类的子类的对象；</p>
<p>构造函数定义为<code>private</code>后，不能在类的外部构造对象，也不能在外部构造该类的子类的对象，只能通过类的<code>static</code>静态函数来访问类的内部定义的对象，设计模式里面单例模式就是私有构造函数的。</p>
<p>构造函数至少要有一个是公有的，不然就不能用来生成任何对象；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> single* p;</span><br><span class="line">	<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line">	~<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">single* single::p = <span class="keyword">new</span> <span class="built_in">single</span>();</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>拷贝构造和赋值操作符可以被定义成私有</strong>。将拷贝构造函数和<code>operator=</code>(赋值操作符重载)声明成<code>private</code>，但是没有实现体。这个的目的是禁止一个类的外部用户对这个类的对象进行复制动作。</p>
</li>
<li><p>对于堆中的对象，通常都是用<code>new/delete</code>来创建/销毁，当调用<code>new</code>时，它会自动调用相应类的构造函数，当调用<code>delete</code>时，它会自动调用相应类的析构函数。而在栈中产生对象时，对象的创建/销毁是自动完成的，也就是在创建时自动调用构造函数，在销毁时自动调用析构函数，即不需要显示调<code>new/delete</code>，但有个前提是类的构造/析构函数都必须是<code>public</code>的。</p>
</li>
<li><p><strong>析构函数无论是<code>protected</code>还是<code>priavte</code>，其共同作用都是禁止在栈中产生对象</strong>，因为无法自动完成析构函数的调用，自然就不能在栈中创建对象了；当然如果在堆上创建对象时，也不能直接<code>delete</code>对象了，因为这样也会在外部析构该对象，但是可以间接完成堆对象的析构，比如为拥有私有或保护析构函数的类创建一个公有的<code>Destroy</code>函数来销毁对象即可。</p>
</li>
</ul>
<p>  <code>protected</code>和<code>priavte</code>析构函数的区别在于<code>private</code>的析构函数不仅禁止了栈中产生对象，而且同时也禁止了继承。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;<span class="keyword">delete</span> <span class="keyword">this</span>;&#125;                </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2、静态成员函数是什么？可以是const的吗？"><a href="#2、静态成员函数是什么？可以是const的吗？" class="headerlink" title="2、静态成员函数是什么？可以是const的吗？"></a>2、静态成员函数是什么？可以是const的吗？</h4><p>静态成员函数是用<code>static</code>修饰的，不能访问非静态数据成员的类成员函数。类的静态成员可以是所属类的类型，而普通成员则不可以，普通成员只能声明为所属类类型的指针或引用。</p>
<p><strong>静态成员函数不能用<code>const</code>。</strong><code>const</code>修饰符用于表示函数不能修改成员变量的值，该函数必须是含有<code>this</code>指针的类成员函数，函数调用方式为<code>thiscall</code>，而类中的<code>static</code>函数本质上是全局函数，调用规约是<code>__cdecl</code>或<code>__stdcall</code>，因此不能用<code>const</code>来修饰它。</p>
<p>一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字<code>const</code>是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用<code>const</code>了。</p>
<p>【static五种含义】 </p>
<p><code>static</code>的第一种含义：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。</p>
<p><code>static</code>的第二种含义：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。</p>
<p><code>static</code>的第三种含义：修饰函数时，表明该函数只在同一文件中调用。</p>
<p><code>static</code>的第四种含义：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。</p>
<p><code>static</code>的第五种含义：修饰类成员函数，用<code>static</code>修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量。</p>
<h4 id="3、线程A-B-C循环顺序打印10次"><a href="#3、线程A-B-C循环顺序打印10次" class="headerlink" title="3、线程A, B, C循环顺序打印10次"></a>3、线程A, B, C循环顺序打印10次</h4><p>该问题为三线程间的同步唤醒操作，主要的目的就是<code>ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA</code>循环执行三个线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用条件变量控制输出的字符，用ready来标记哪个线程来输出，当ready==0时，func1线程打印A，如果不是1的话则阻塞在条件变量上等待，当func1线程打印完成后，给ready+1，让另一个线程打印B，以此类推*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> ready = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ready != <span class="number">0</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(ul);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ready = <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ready != <span class="number">1</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(ul);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        ready = <span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (ready != <span class="number">2</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(ul);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ready = <span class="number">0</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(func3)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Linux下：</strong>循环打印A、B、C、D共10次。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> condPrintA = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> condPrintB = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> condPrintC = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> condPrintD = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印a的标志位，注意每个现成函数中ready的变化</span></span><br><span class="line"><span class="keyword">int</span> ready = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadPrintA</span><span class="params">(<span class="keyword">void</span>* pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (ready != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;condPrintA, &amp;mtx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line">		ready = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;condPrintB);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadPrintB</span><span class="params">(<span class="keyword">void</span>* pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (ready != <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;condPrintB, &amp;mtx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>);</span><br><span class="line">		ready = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;condPrintC);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadPrintC</span><span class="params">(<span class="keyword">void</span>* pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (ready != <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;condPrintC, &amp;mtx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;C\n&quot;</span>);</span><br><span class="line">		ready = <span class="number">3</span>;</span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;condPrintD);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadPrintD</span><span class="params">(<span class="keyword">void</span>* pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (ready != <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">pthread_cond_wait</span>(&amp;condPrintD, &amp;mtx);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;D\n&quot;</span>);</span><br><span class="line">		ready = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">pthread_cond_signal</span>(&amp;condPrintA);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//线程测试Demo</span></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> pt[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;pt[<span class="number">0</span>], <span class="literal">NULL</span>, &amp;ThreadPrintA, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create return -1, process return&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;pt[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;ThreadPrintB, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create return -1, process return&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;pt[<span class="number">2</span>], <span class="literal">NULL</span>, &amp;ThreadPrintC, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create return -1, process return&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;pt[<span class="number">3</span>], <span class="literal">NULL</span>, &amp;ThreadPrintD, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create return -1, process return&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//线程返回值</span></span><br><span class="line">	<span class="keyword">void</span>* pThreadRet;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="built_in">pthread_join</span>(pt[i], &amp;pThreadRet);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pthread_join return -1, process return&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、实现一个死锁"><a href="#4、实现一个死锁" class="headerlink" title="4、实现一个死锁"></a>4、实现一个死锁</h4><p>【方法1】单线程对一个资源重复申请上锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line">mutex mt1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	data = data * data;</span><br><span class="line">	mt1.<span class="built_in">lock</span>();  <span class="comment">// 第二次申请对mt1上锁，但是上不上去</span></span><br><span class="line">	cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	mt1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mt1.<span class="built_in">lock</span>();  <span class="comment">// 第一次对mt1上锁</span></span><br><span class="line">	data = data + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">a2</span>();</span><br><span class="line">	cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	mt1.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(a1)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main here&quot;</span> &lt;&lt; endl;  <span class="comment">// 线程结束才会执行</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【方法二】两个线程对两个资源申请上锁，形成环路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mtx1 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mtx2 = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun1</span><span class="params">(<span class="keyword">void</span>* pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx1);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	data = data + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx2);  <span class="comment">// 此时fun2已经对mt1上锁，所以要等待</span></span><br><span class="line">	cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx2);</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx1);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fun2</span><span class="params">(<span class="keyword">void</span>* pParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx2);</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">	data = data * data;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;mtx1);  <span class="comment">// 此时fun1已经对mt1上锁，所以要等待</span></span><br><span class="line">	cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx1);</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;mtx2);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> pt[<span class="number">2</span>];</span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;pt[<span class="number">0</span>], <span class="literal">NULL</span>, &amp;fun1, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create return -1, process return&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">pthread_create</span>(&amp;pt[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;fun2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pthread_create return -1, process return&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span>* pThreadRet;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = <span class="built_in">pthread_join</span>(pt[i], &amp;pThreadRet);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;pthread_join return -1, process return&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main here&quot;</span> &lt;&lt; endl;  <span class="comment">//要t1线程、t2线程都执行完毕后才会执行</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、shared-ptr-底层实现？"><a href="#5、shared-ptr-底层实现？" class="headerlink" title="5、shared_ptr 底层实现？"></a>5、shared_ptr 底层实现？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line">	<span class="comment">// 初始化构造函数，计数器的值置1</span></span><br><span class="line">	<span class="built_in">SharedPtr</span>(T* ptr = <span class="literal">nullptr</span>) :_ptr(<span class="literal">nullptr</span>), _pcount(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">	<span class="comment">// 拷贝构造函数，计数器加1</span></span><br><span class="line">	<span class="built_in">SharedPtr</span>(<span class="keyword">const</span> SharedPtr&amp; s) :_ptr(s._ptr), _pcount(s._pcount) &#123;</span><br><span class="line">		(*_pcount)++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 赋值运算符，原对象引用计数减1，若为0则释放，后来指向的对象计数加1</span></span><br><span class="line">    <span class="comment">// 赋值运算符需要检查源对象和新建对象是否相同</span></span><br><span class="line">	SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&amp; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s) &#123;</span><br><span class="line">			<span class="keyword">if</span> (--(*(<span class="keyword">this</span>-&gt;_pcount)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_pcount;</span><br><span class="line">			&#125;</span><br><span class="line">			_ptr = s._ptr;</span><br><span class="line">			_count = s._pcount;</span><br><span class="line">			(*_pcount)++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// *运算符重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// -&gt;运算符重载</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 析构函数，计数器减1</span></span><br><span class="line">	~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">		--(*(<span class="keyword">this</span>-&gt;_pcount));</span><br><span class="line">		<span class="keyword">if</span> (*(<span class="keyword">this</span>-&gt;_pcount) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">			_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_pcount;</span><br><span class="line">			_pcount = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* _ptr;</span><br><span class="line">	<span class="keyword">int</span>* _pcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6、shared-ptr-是线程安全的吗？"><a href="#6、shared-ptr-是线程安全的吗？" class="headerlink" title="6、shared_ptr 是线程安全的吗？"></a>6、shared_ptr 是线程安全的吗？</h4><p>虽然我们借<code>shared_ptr</code>来实现线程安全的对象释放，但是<code>shared_ptr </code>本身不是100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是，因为<code>shared_ptr</code>有两个数据成员（指向的对象的指针，引用计数，其中引用计数是原子的），读和写操作不能原子化。<code>shared_ptr</code>的引用次数加减操作内部自动加锁解锁，是线程安全的。但是指向对象的指针不是线程安全的。</p>
<ul>
<li>一个<code>shared_ptr</code>对象实体可被多个线程同时读取；</li>
<li>两个<code>shared_ptr</code>对象实体可以被两个线程同时写入，“析构”算写操作。多线程环境下，调用不同的<code>shared_ptr</code>实例的成员函数是不需要额外的同步手段的；</li>
<li>多个线程同时读同一个<code>shared_ptr</code>对象是线程安全的；</li>
<li>如果要从多个线程读写同一个<code>shared_ptr</code>对象，那么需要加锁；</li>
</ul>
<p>以上是<code>shared_ptr</code>对象本身的线程安全级别，不是它管理的对象的线程安全级别。</p>
<p>要在多个线程中同时访问同一个<code>shared_ptr</code>，正确的做法是用<code>mutex</code> 保护：</p>
<h4 id="7、shared-ptr-可以指向数组吗？unique-ptr？"><a href="#7、shared-ptr-可以指向数组吗？unique-ptr？" class="headerlink" title="7、shared_ptr 可以指向数组吗？unique_ptr？"></a>7、shared_ptr 可以指向数组吗？unique_ptr？</h4><p>可以。在创建指向普通类型的动态数组时，需指定对应的删除函数。因为如果不指定的话，默认调用的析构方法是 <code>delete</code>, 而我们析构数组时，需要调用 <code>delete[]</code> ，在析构数组的地方使用<code>delete</code> 会引起内存泄漏。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_deleter</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T <span class="keyword">const</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], array_deleter&lt;<span class="keyword">int</span>&gt;())</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//使用 std 的删除函数</span></span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="keyword">int</span>[]&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 lambda 表达式</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 vector 无需提供 delete 函数</span></span><br><span class="line">std::shared_ptr&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">sp</span>(<span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 unique_ptr 无需显示调用 delete[]</span></span><br><span class="line">std::unique_ptr&lt;int[]&gt; up(new int[10]);</span><br></pre></td></tr></table></figure>

<h4 id="8、实现单例模式"><a href="#8、实现单例模式" class="headerlink" title="8、实现单例模式"></a>8、实现单例模式</h4><p>单例思路：</p>
<ul>
<li>静态成员建议在类外进行初始化，但在类内也可以初始化，只是通过类名访问静态成员的属性时，访问不到</li>
<li>构造函数声明为<code>private</code>或<code>protected</code>防止被外部函数实例化</li>
<li>内部保存一个<code>private static</code>的类指针保存唯一的实例</li>
<li>实例的动作由一个<code>public</code>的类方法代劳</li>
<li>懒汉模式：在<code>getinstance()</code>中实例化</li>
<li>饿汉模式：在单例类定义时实例化</li>
</ul>
<p>【饿汉模式】：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************************************************************</span></span><br><span class="line"><span class="comment">// ------------------- 饿汉模式 -----------------------</span></span><br><span class="line"><span class="comment">// 饿汉模式，在定义单例类最初就实例化，此后返回的就一个，感觉相当于全局变量</span></span><br><span class="line"><span class="comment">// 在饿汉模式下，在单例类定义的时候就已经定义了一个对象，对类进行了初始化。</span></span><br><span class="line"><span class="comment">// 后面不管哪个线程调用成员函数 getinstance()，都只不过是返回一个对象的指针而已。</span></span><br><span class="line"><span class="comment">// 所以是线程安全的，不需要在成员函数 getinstance() 中加锁。</span></span><br><span class="line"><span class="comment">//************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line">	~<span class="built_in">single</span>() &#123;&#125;</span><br><span class="line">	<span class="keyword">static</span> single* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意和懒汉模式实例化的区别，饿汉模式在单例类定义时实例化</span></span><br><span class="line">single* single::p = <span class="keyword">new</span> <span class="built_in">single</span>();</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;      <span class="comment">// 结果：输出“same”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【懒汉模式 经典实现】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************************************************************</span></span><br><span class="line"><span class="comment">// ------------------- 懒汉模式 经典实现 -----------------------</span></span><br><span class="line"><span class="comment">//************************************************************</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">single</span>() &#123;&#125;;</span><br><span class="line">	~<span class="built_in">single</span>() &#123;&#125;;</span><br><span class="line">	<span class="keyword">static</span> single* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意和饿汉模式实例化的区别，懒汉模式在 getinstance() 中实例化</span></span><br><span class="line">single* single::p = <span class="literal">nullptr</span>;     </span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		p = <span class="keyword">new</span> single;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;      <span class="comment">// 结果：输出“same”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【懒汉模式 线程安全 经典实现】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************************************************************</span></span><br><span class="line"><span class="comment">// ------------------- 懒汉模式 线程安全 -----------------------</span></span><br><span class="line"><span class="comment">//************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> single* p;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">	<span class="built_in">single</span>() &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> single::lock;</span><br><span class="line">single* single::p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			p = <span class="keyword">new</span> single;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;      <span class="comment">// 结果：输出“same”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【懒汉模式 线程安全 内部静态变量实现】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="comment">// 懒汉模式线程安全内部静态变量实现</span></span><br><span class="line"><span class="comment">// 将经典实现中的私有唯一实例删掉</span></span><br><span class="line"><span class="comment">// 改为在 getinstance 函数里定义一个静态的实例</span></span><br><span class="line"><span class="comment">// 也可以保证拥有唯一实例，在返回时只需要返回其指针就可以</span></span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">	<span class="built_in">single</span>() &#123;</span><br><span class="line">		<span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> single::lock;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">static</span> single obj;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">	<span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	single* p1 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	single* p2 = single::<span class="built_in">getinstance</span>();</span><br><span class="line">	<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl;      <span class="comment">// 结果：输出“same”</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9、c-默认的是深拷贝还是浅拷贝？"><a href="#9、c-默认的是深拷贝还是浅拷贝？" class="headerlink" title="9、c++默认的是深拷贝还是浅拷贝？"></a>9、c++默认的是深拷贝还是浅拷贝？</h4><p>当类中没有定义拷贝构造函数时，编译器会默认提供一个拷贝构造函数，进行成员变量之间的拷贝，这个拷贝操作是<strong>浅拷贝</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCls</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span>* p;</span><br><span class="line">    <span class="built_in">TestCls</span>() &#123;  <span class="comment">//无参构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;TestCls()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TestCls</span>() &#123;     <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~TestCls()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    TestCls t1;    <span class="comment">// 这句运行不会出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这句运行时就会发生内存泄漏，原因就在于默认的拷贝构造函数实现的是浅拷贝</span></span><br><span class="line">    TestCls t2 = t1;   <span class="comment">// 效果等同于TestCls t2(t1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深拷贝，一般的赋值操作，是深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure>

<p>浅拷贝，简单的指针指向，则是浅拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【例1】</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *b;</span><br><span class="line">b = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【例2】</span></span><br><span class="line"><span class="keyword">char</span>* str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* str2 = str1;</span><br></pre></td></tr></table></figure>

<p>将拷贝改为深拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【例1】</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【例2】</span></span><br><span class="line"><span class="keyword">char</span>* str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="keyword">char</span>* str2 = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, str1, len);</span><br></pre></td></tr></table></figure>

<h4 id="10、信号量和互斥锁之间的区别？"><a href="#10、信号量和互斥锁之间的区别？" class="headerlink" title="10、信号量和互斥锁之间的区别？"></a>10、信号量和互斥锁之间的区别？</h4><ul>
<li>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</li>
<li>互斥：是指某一资源<strong>同时只允许一个访问者</strong>对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</li>
<li>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的<strong>有序访问</strong>。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</li>
<li>互斥量值只能为0/1。信号量值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
</ul>
<h4 id="11、C10K-并发连接问题"><a href="#11、C10K-并发连接问题" class="headerlink" title="11、C10K 并发连接问题"></a>11、C10K 并发连接问题</h4><ul>
<li><p><code>C10K</code>问题的本质</p>
<p>C10K问题的本质上是操作系统的问题。对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是<code>requests per second</code>。当创建的进程或线程多了，数据拷贝频繁（缓存<code>I/O</code>、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是<code>C10K</code>问题的本质。可见，解决<code>C10K</code>问题的关键就是尽可能减少这些<code>CPU</code>资源消耗。</p>
</li>
<li><p><code>C10K</code>问题的解决方案</p>
<p>（1）每个连接分配一个独立的线程/进程</p>
<p>该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以会使资源占用过多，可扩展性差</p>
<p>（2）每个进程/线程同时处理 多个连接(<code>I/O</code>多路复用)</p>
<ul>
<li><p><code>select</code>方式：使用<code>fd_set</code>结构体告诉内核同时监控哪些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时，当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回。</p>
<p>该方式有以下缺点：文件句柄数量是有上限的，逐个检查吞吐量低，每次调用都要重复初始化<code>fd_set</code>结构体。</p>
</li>
<li><p><code>poll</code>方式：该方式主要解决了<code>select</code>方式的2个缺点，文件句柄上限问题（链表方式存储）以及重复初始化问题（不同字段标注关注事件和发生事件），但是逐个去检查文件句柄是否就绪的问题仍然没有解决。</p>
</li>
<li><p><code>epoll</code>方式：该方式可以说是<code>C10K</code>问题的killer，他不去轮询监听所有文件句柄是否已经就绪。<code>epoll</code>只对发生变化的文件句柄感兴趣。其工作机制是，使用”事件”的就绪通知方式，通过<code>epoll_ctl</code>注册文件描述符<code>fd</code>，一旦该<code>fd</code>就绪，内核就会采用类似<code>callback</code>的回调机制来激活该<code>fd</code>， <code>epoll_wait</code>便可以收到通知，并通知应用程序。而且<code>epoll</code>使用一个文件描述符管理多个描述符，将用户进程的文件描述符的事件存放到内核的一个事件表中，这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且<code>epoll</code>是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高，适用于大规模的应用场景。但是依赖于特定的平台（Linux）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="12、c-的move函数？左值引用和右值引用？"><a href="#12、c-的move函数？左值引用和右值引用？" class="headerlink" title="12、c++的move函数？左值引用和右值引用？"></a>12、c++的move函数？左值引用和右值引用？</h4><ul>
<li>左值：指表达式结束后依然存在的<strong>持久对象</strong>，<strong>可以取地址</strong>，具名变量或对象 。</li>
<li>右值：表达式结束后就不再存在的<strong>临时对象</strong>，<strong>不可以取地址</strong>，没有名字。</li>
<li>左值引用：<code>type &amp;引用名 = 左值表达式;</code></li>
<li>右值引用：<code>type &amp;&amp;引用名 = 右值表达式;</code></li>
<li><code>std::move</code>语句可以将左值变为右值而<strong>避免拷贝构造</strong>。</li>
<li><code>std::move</code>是<strong>将对象的状态或者所有权从一个对象转移到另一个对象</strong>，只是转移，<strong>没有内存的搬迁或者内存拷贝。</strong></li>
</ul>
<p><code>std::move</code>并不能移动任何东西，它唯一的功能是<strong>将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义</strong>，右值引用能够完美解决临时对象效率问题。。从实现上讲，<code>std::move</code>基本等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用常规的拷贝构造函数，新建字符数组，拷贝数据</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动构造函数，掏空str，掏空后，最好不要使用str</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="number">0</span>]</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// After copy, str is &quot;Hello&quot;</span></span><br><span class="line"><span class="comment">// After move, str is &quot;&quot;</span></span><br><span class="line"><span class="comment">// The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="13、TCP-socket中的心跳机制"><a href="#13、TCP-socket中的心跳机制" class="headerlink" title="13、TCP socket中的心跳机制"></a>13、TCP socket中的心跳机制</h4><p>心跳机制是定时发送一个自定义的结构体(心跳包)，让对方知道自己还活着，以确保连接的有效性的机制。代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。</p>
<p><strong>心跳检测步骤：</strong><br>（1）客户端每隔一个时间间隔发生一个探测包给服务器<br>（2）客户端发包时启动一个超时定时器<br>（3）服务器端接收到检测包，应该回应一个包<br>（4）如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器<br>（5）如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了</p>
<p>例如在聊天软件中，一般都会有一个用户掉线检测功能。使用HeartBeat方式可以检测用户的掉线情况。采用的思路是：客户端连接上服务端以后，服务端维护一个在线用户字典，客户端每隔一段时间，向服务器发送一个心跳包，服务器接收到包以后，字典数据的值都会更新为0；一旦服务端超过规定时间没有接收到客户端发来的包，字典数据将会递增加一，当字典数据的值累计大于等于三，则视为掉线。</p>
<h4 id="14、子类有几个虚函数表？"><a href="#14、子类有几个虚函数表？" class="headerlink" title="14、子类有几个虚函数表？"></a>14、子类有几个虚函数表？</h4><p>c++多重继承的子类要使用多个虚函数表。比如：基类的虚函数表是分开2个的话，那将父类指针指向子类对象的操作，编译器只需要做一些指针偏移，就可以得到正确的结果。把基类对象在子类对象的内存布局中完全分开可以更高效地实现父子类之间的转换。</p>
<p>（1）一般继承（无虚函数覆盖）：在派生类的实例中，虚函数按照其声明顺序放于表中，父类的虚函数在子类的虚函数前面。子类实例中的虚函数表如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210602113026.png"></p>
<p>（2）一般继承（有虚函数覆盖）：覆盖的<code>f()</code>函数被放到了虚表中原来父类虚函数的位置，没有被覆盖的函数依旧。子类实例中的虚函数表如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210602113126.png"></p>
<p>这样，我们就可以看到对于下面这样的程序，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">b-&gt;<span class="built_in">f</span>();</span><br><span class="line"><span class="comment">// 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</span></span><br></pre></td></tr></table></figure>

<p>（3）多重继承（无虚函数覆盖）</p>
<p>每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）。子类实例中的虚函数表如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210602113430.png"></p>
<p>（4）多重继承（有虚函数覆盖）</p>
<p>三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。子类实例中的虚函数表如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210602113606.png"></p>
<h4 id="15、路由器和交换机的区别"><a href="#15、路由器和交换机的区别" class="headerlink" title="15、路由器和交换机的区别"></a>15、路由器和交换机的区别</h4><p>（1）路由器工作在第三层（网络层），交换机工作在第二层（链路层），目前有更加高级的三层交换机，四层交换机，甚至还有七层交换机；</p>
<p>（2）路由器（寻址、转发）：内有一份<strong>路由表</strong>，里面有它的<strong>寻址</strong>信息，它收到网络层的数据报后，会根据路由表和选路算法将数据报<strong>转发</strong>到下一站（可能是路由器、交换机、目的主机）；</p>
<p>交换机（过滤、转发）：内有一张<strong>MAC表</strong>，里面存放着和它相连的所有设备的MAC地址，它会根据收到的数据帧的首部信息内的目的MAC地址在自己的表中查找，如果有就转发，如果没有就放弃；</p>
<p>（3）交换机通常由硬件加速转发，路由器主要靠软件寻址，速度慢。</p>
<h4 id="16、Epoll-的-ET-LT-区别"><a href="#16、Epoll-的-ET-LT-区别" class="headerlink" title="16、Epoll 的 ET/LT 区别"></a>16、Epoll 的 ET/LT 区别</h4><p><strong>（1）触发模式设计上的区别</strong></p>
<p><code>LT</code>模式是电平触发（Level Trigger）：当<code>epoll_wait</code>检测到<code>fd</code>上有事件发生，并将此事件通知应用程序后，应用程序可以不立即处理该事件，这样，当应用程序下一次调用<code>epoll_wait</code>时，<code>epoll_wait</code>还会再次向应用程序通知此事件，直到此事件被处理。</p>
<p><code>ET</code>模式是边沿触发（Edge Trigger）：当<code>epoll_wait</code>检测到<code>fd</code>上有事件发生，并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的<code>epoll_wait</code>调用将不再向应用程序通知这一事件。只有消息从无到有才会触发。比如从不可读到可读，从不可写到可写， 并且只通知一次。 就是通知你一次之后，一直处于可读状态， 那么就不会通知你，只有再从不可读到可读才会再次通知你。</p>
<p>举个栗子： 当同时有套接字可读， 也就是说同时来个是个消息， 此时你处理了五个， 你就去<code>epoll_wait</code>了， 如果是<code>LT</code>模式， 会立刻返回， 返回的是你没有处理的那五个， 如果是<code>ET</code>模式呢， 不会返回没处理的那五个， 因为状态没有从不可读变为可读。</p>
<p><strong>（2）编码上的区别</strong><br>如果来了大量的请求， 我们一次能处理完的时候， <code>LT</code>模式下完全可以不管， 直接再次<code>epoll_wait</code>就可以， 因为下次他还会返回那些没有处理的事件， 因为我们没读， 所以数据依然在， 依然可读。</p>
<p><code>ET</code>模式下， 就需要把所有的可读事件全部处理完， 或者使用一个<code>ready_queue</code>的数据结构， 暂时保存一下， 稍后处理， 因为如果不保存， 你就不知道哪些是没有处理的， 或者需要处理的。 这就出现了一个差别， <code>ET</code>模式需要多一个容器去保存尚未处理的事件， 编程比<code>LT</code>更复杂，但是<code>ET</code>模式多用了内存和时间去保存和维护尚未处理的事件。</p>
<p>可见<code>ET</code>模式在很大程度上降低了同一个<code>epoll</code>事件被重复触发的次数，因此<code>ET</code>模式效率比<code>LT</code>模式高。<code>ET</code>模式下事件被触发的次数比<code>LT</code>模式下少很多。每个使用<code>ET</code>模式的文件描述符都应该是非阻塞的。 如果描述符是阻塞的，那么读或写操作将会因没有后续事件而一直处于阻塞状态 ( 饥渴状态 )。</p>
<h4 id="17、C-空类中有哪些默认的函数？"><a href="#17、C-空类中有哪些默认的函数？" class="headerlink" title="17、C++ 空类中有哪些默认的函数？"></a>17、C++ 空类中有哪些默认的函数？</h4><p>C++空类中有6个默认的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Empty</span>();             <span class="comment">// 缺省构造函数</span></span><br><span class="line">	<span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	~<span class="built_in">Empty</span>();            <span class="comment">// 析构函数</span></span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp;);  <span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">	Empty* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取地址运算符重载函数</span></span><br><span class="line">	<span class="keyword">const</span> Empty * <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;  <span class="comment">// const修饰的取地址操作符重载函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="18、虚函数能定义成-private-吗？"><a href="#18、虚函数能定义成-private-吗？" class="headerlink" title="18、虚函数能定义成 private 吗？"></a>18、虚函数能定义成 private 吗？</h4><p>用<code>private</code>声明虚函数，表示派生类对这个虚函数必需要有自己的实现，而不能调用基类的实现。C++中，虚函数可以为<code>private</code>，并且可以被子类覆盖。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">PrintClassName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived;  <span class="comment">// 最终实际调用的是Derived::PrintClassName()</span></span><br><span class="line">    ptr-&gt;<span class="built_in">print</span>();    <span class="comment">// 结果输出：Derived</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19、函数模板和类模板的区别？"><a href="#19、函数模板和类模板的区别？" class="headerlink" title="19、函数模板和类模板的区别？"></a>19、函数模板和类模板的区别？</h4><ul>
<li>类模板在模板参数列表中可以有默认参数</li>
<li>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用，而类模板只能显式调用。</li>
</ul>
<p>类模板实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NameType mName;</span><br><span class="line">	AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 必须显式调用</span></span><br><span class="line">	Person&lt;string, int&gt; p(&quot;孙悟空&quot;, 1000); </span><br><span class="line">	p.<span class="built_in">showPerson</span>();</span><br><span class="line">	</span><br><span class="line">	Person&lt;string, <span class="keyword">int</span>&gt;* a = <span class="keyword">new</span> Person&lt;string, <span class="keyword">int</span>&gt;();</span><br><span class="line">	a = &amp;p;    <span class="comment">// 或*a = p</span></span><br><span class="line">	a-&gt;<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类模板中的模板参数列表,可以指定默认参数</span></span><br><span class="line">	Person &lt;string&gt; <span class="built_in">b</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); </span><br><span class="line">	b.<span class="built_in">showPerson</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// name: 孙悟空 age : 1000</span></span><br><span class="line"><span class="comment">// name : 孙悟空 age : 1000</span></span><br><span class="line"><span class="comment">// name : 猪八戒 age : 999</span></span><br></pre></td></tr></table></figure>

<p>函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maxValue</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 隐式调用, 函数模板的实例化在程序调用时自动完成</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">100</span>, <span class="number">204</span>) &lt;&lt; endl; </span><br><span class="line">	cout &lt;&lt; <span class="built_in">maxValue</span>(<span class="number">2.5002</span>, <span class="number">30.003</span>) &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示调用</span></span><br><span class="line">	cout &lt;&lt; maxValue&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; maxValue&lt;<span class="keyword">double</span>&gt;(<span class="number">2.5002</span>, <span class="number">30.003</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 204</span></span><br><span class="line"><span class="comment">// 30.003</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 30.003</span></span><br></pre></td></tr></table></figure>

<h4 id="20、-udp-如何实现可靠传输？"><a href="#20、-udp-如何实现可靠传输？" class="headerlink" title="20、 udp 如何实现可靠传输？"></a>20、 udp 如何实现可靠传输？</h4><p>最简单的方式是在应用层模仿传输层<code>TCP</code>的可靠性传输。下面不考虑拥塞处理，可靠<code>UDP</code>的简单设计。</p>
<ul>
<li><p>添加<code>seq/ack</code>机制，确保数据发送到对端</p>
<p>发送端发送数据时，生成一个随机<code>seq=x</code>，然后每一片按照数据大小分配<code>seq</code>。</p>
</li>
<li><p>添加发送和接收缓冲区，主要是用户超时重传</p>
<p>数据到达接收端后接收端放入缓存，并发送一个<code>ack=x</code>的包，表示对方已经收到了数据。</p>
<p>发送端收到了<code>ack</code>包后，删除缓冲区对应的数据。</p>
</li>
<li><p>添加超时重传机制：</p>
<p>时间到后，发送端定时任务检查是否需要重传数据。</p>
</li>
</ul>
<p>目前有如下开源程序利用<code>udp</code>实现了可靠的数据传输。分别为<code>RUDP</code>、<code>RTP</code>、<code>UDT</code>。</p>
<h4 id="21、GET-和-POST-区别？两者的传输效率？"><a href="#21、GET-和-POST-区别？两者的传输效率？" class="headerlink" title="21、GET 和 POST 区别？两者的传输效率？"></a>21、GET 和 POST 区别？两者的传输效率？</h4><p><strong>（1）主要区别</strong></p>
<ul>
<li><p><code>get</code>是获取数据，<code>post</code>是修改数据</p>
</li>
<li><p><code>get</code>把请求的数据放在 <code>url </code>上， 以<code>?</code>分割<code>URL</code>和传输数据，参数之间以<code>&amp;</code>相连，所以<code>get</code>不太安全。而 <code>post</code>把数据放在<code>HTTP</code>的包体内（requrest body） </p>
</li>
<li><p><code>get</code>提交的数据最大是<code>2k</code>（ 限制实际上取决于浏览器），<code>post</code>理论上没有限制。</p>
</li>
<li><p><code>get</code>产生一个<code>TCP</code>数据包，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200</code>(返回数据); <code>post</code>产生两个<code>TCP</code>数据包，浏览器先发送<code>header</code>，服务器响应<code>100 continue</code>，浏览器再发送 <code>data</code>，服务器响应<code>200 ok</code>(返回数据)。 </p>
</li>
<li><p><code>get</code>请求会被浏览器主动缓存，而<code>post</code>不会，除非手动设置。</p>
</li>
<li><p><strong>本质区别</strong>：<code>get</code>是幂等的，而<code>post</code>不是幂等的 </p>
<p>【这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意 味着对同一URL的多个请求应该返回同样的结果】</p>
</li>
</ul>
<p><strong>（2）传输效率</strong></p>
<p><code>get</code> 比<code>post</code>更快，具体表现在：</p>
<ul>
<li><p><strong><code>post</code>在真正接受数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据</strong>，即<code>post</code>将请求头和数据分开发送，而<code>get</code>将两者合在一起发送；</p>
</li>
<li><p><code>post</code>请求包含更多的请求头：因为<code>post</code>需要在请求的<code>body</code>部分包含数据，所以会多了几个数据描述部分的首部字段（如content-type），但这其实是微乎其微的；</p>
</li>
<li><p><code>get</code>会将数据缓存起来，而<code>post</code>不会</p>
</li>
<li><p><strong>post不能进行管道化传输</strong>：除了持久连接之外，在<code>http/1.1</code>中，还有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去。但是这样的方式有一个问题：不安全，如果一个管道中有10个连接，在发送出9个后，突然服务器告诉你，连接关闭了，此时客户端即使收到了前9个请求的答复，也会将这9个请求的内容清空，也就是说，白忙活了……此时，客户端的这9个请求需要重新发送。这对于幂等请求还好（比如<code>get</code>，多发送几次都没关系，每次都是相同的结果），如果是<code>post</code>这样的非幂等请求（比如支付的时候，多发送几次就惨了），肯定是行不通的。</p>
</li>
</ul>
<h4 id="22、http-协议如何解决粘包问题？UDP会出现粘包问题吗？"><a href="#22、http-协议如何解决粘包问题？UDP会出现粘包问题吗？" class="headerlink" title="22、http 协议如何解决粘包问题？UDP会出现粘包问题吗？"></a>22、http 协议如何解决粘包问题？UDP会出现粘包问题吗？</h4><p>在讲粘包问题之前，首先得明白这个包是应用层的数据包。<br>当数据在传输层时，由于<code>TCP</code>是面向字节流的，所以它看到的数据是按照顺序一个个放在缓冲区中的，而对于应用层而言，看到的只是一连串的数据，那么应用层该从哪里读数据，读到哪合适呢？因此就有了粘包问题。</p>
<p>所以要避免粘包问题，就得明确两个包之间的边界：</p>
<p>对于定长的数据包，保证每次都按固定的大小读取即可；<br>对于变长的包，可在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置；<br>对于变长的包，还可以在包和包之间使用明确的分隔符（应用层协议，是我们自己写的，只要保证分隔符不和正文冲突即可）</p>
<p>若传输层是<code>UDP</code>协议，应用层会不会出现粘包问题？</p>
<p>对于<code>UDP</code>而言，报文长度是固定的，就算没有交付，长度依然在，同时，<code>UDP</code>是一个一个把数据交付给应用层的，就有很明显的边界。站在应用层的角度，每次收到的<code>UDP</code>报文，要么是一整个，要么不收，不会出现半个的情况。</p>
<h4 id="23、lambda-表达式和函数指针的区别？lambda表达式的对象捕获方式？"><a href="#23、lambda-表达式和函数指针的区别？lambda表达式的对象捕获方式？" class="headerlink" title="23、lambda 表达式和函数指针的区别？lambda表达式的对象捕获方式？"></a>23、lambda 表达式和函数指针的区别？lambda表达式的对象捕获方式？</h4><p>（1）<strong>函数指针</strong></p>
<p>无法直接捕获当前的一些状态，所有外部状态只能通过参数传递（不考虑在函数内部使用<code>static</code>变量）。使用函数指针的调用无法 <code>inline</code>（编译期无法确定这个指针会被赋上什么值）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个指向有两个整型参数，返回值为整型参数的函数指针类型</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*Plus)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通常我们用 typedef 来定义函数指针类型的别名方便使用</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Plus)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从 C++11 开始，更推荐使用 using 来定义别名</span></span><br><span class="line"><span class="keyword">using</span> Plus = <span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>（2）<strong>仿函数</strong></p>
<p>就是让一个类（<code>class/struct</code>）的对象的使用看上去像一个函数，具体实现就是在类中实现 <code>operator()</code>。相比函数指针，仿函数对象可通过成员变量来捕获/传递一些状态。缺点就是，写起来很麻烦（码字比较多）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plus</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Plus plus;</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">11</span>, <span class="number">22</span>) &lt;&lt; std::endl;   <span class="comment">// 输出 33</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>Lambda 表达式</strong></p>
<ul>
<li><p><code>Lambda</code> 表达式在表达能力上和仿函数是等价的。编译器一般也是通过自动生成类似仿函数的代码来实现 <code>Lambda</code> 表达式的。上面的例子，用 <code>Lambda </code>改写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Plus = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>一个完整的 <code>Lambda </code>表达式的组成如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ capture-list ] ( params ) <span class="built_in"><span class="keyword">mutable</span></span>(optional) <span class="built_in">exception</span>(optional) <span class="built_in">attribute</span>(optional) -&gt; <span class="built_in">ret</span>(optional) &#123; body &#125; </span><br></pre></td></tr></table></figure>

<p><code>capture-list</code>：捕获列表。前面的例子 <code>auto Plus = [](int a, int b) &#123; return a + b; &#125;; </code>没有捕获任何变量。<br><code>params</code>：和普通函数一样的参数。<br><code>mutable</code>：只有这个<code>Lambda</code>表达式是<code>mutable</code>的才允许修改按值捕获的参数。<br><code>exception</code>：异常标识。<br><code>attribute</code>：属性标识。<br><code>ret</code>：返回值类型，可以省略，让编译器通过<code> return</code> 语句自动推导。<br><code>body</code>：函数的具体逻辑。</p>
</li>
<li><p><code>Lambda </code>表达式的捕获</p>
<p>其实就是将局部自动变量保存到<code> Lambda</code>表达式内部（<code>Lambda</code>表达式不能捕获全局变量或<code>static</code>变量）。<code>Lambda</code>表达式的最基本的两种捕获方式是：<strong>按值捕获</strong>（Capture by Value）和<strong>按引用捕获</strong>（Capture by Reference）。</p>
<ul>
<li><p>按值捕获 ：<code>Lambda</code> 表达式内部会保存一份副本。</p>
</li>
<li><p>按引用捕获： <code>Lambda</code> 表达式内部不会复制多一份副本。</p>
</li>
<li><p>捕获列表初始化（Capture Initializers）：C++ 14 支持<code> lambda capture initializers</code>。<code>Lambda </code>捕获列表初始化最最最重要的一点是“支持 Capture by Move”。在 C++14 之前，<code>Lambda </code>是不支持捕获一个 Move-Only 的对象的，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现找出其中 title 包含“C++”的书本的数量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	string title;</span><br><span class="line">	<span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Book&gt; books;</span><br><span class="line">	books.<span class="built_in">push_back</span>(&#123; <span class="number">0</span>, <span class="string">&quot;C++&quot;</span>, <span class="number">2.5</span> &#125;);</span><br><span class="line">	books.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>, <span class="string">&quot;操作系统&quot;</span>, <span class="number">10.5</span> &#125;);</span><br><span class="line">	books.<span class="built_in">push_back</span>(&#123; <span class="number">2</span>, <span class="string">&quot;Linux&quot;</span>, <span class="number">6</span> &#125;);</span><br><span class="line">	books.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>, <span class="string">&quot;C++&quot;</span>, <span class="number">5.5</span> &#125;);</span><br><span class="line">	string target = <span class="string">&quot;C++&quot;</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按值捕获 target</span></span><br><span class="line">	<span class="keyword">auto</span> cnt1 = std::<span class="built_in">count_if</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(),</span><br><span class="line">		[target](<span class="keyword">const</span> Book&amp; book) &#123;</span><br><span class="line">			<span class="keyword">return</span> book.title.<span class="built_in">find</span>(target) != std::string::npos;</span><br><span class="line">		&#125;);</span><br><span class="line">	cout &lt;&lt; cnt1 &lt;&lt; endl;     <span class="comment">// 输出2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按引用捕获 target</span></span><br><span class="line">	<span class="keyword">auto</span> cnt2 = std::<span class="built_in">count_if</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(),</span><br><span class="line">		[&amp;target](<span class="keyword">const</span> Book&amp; book) &#123;</span><br><span class="line">			<span class="keyword">return</span> book.title.<span class="built_in">find</span>(target) != std::string::npos;</span><br><span class="line">		&#125;);</span><br><span class="line">	cout &lt;&lt; cnt2 &lt;&lt; endl;     <span class="comment">// 输出2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按值捕获 target，但是在 Lambda 内部的变量名叫做 v，捕获列表初始化</span></span><br><span class="line">	<span class="keyword">auto</span> cnt3 = std::<span class="built_in">count_if</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), </span><br><span class="line">		[v = target](<span class="keyword">const</span> Book&amp; book) &#123;</span><br><span class="line">			<span class="keyword">return</span> book.title.<span class="built_in">find</span>(v) != std::string::npos;</span><br><span class="line">		&#125;);</span><br><span class="line">	cout &lt;&lt; cnt3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按引用捕获 target，但是在 Lambda 内部的名字叫做 r，捕获列表初始化</span></span><br><span class="line">	<span class="keyword">auto</span> cnt4 = std::<span class="built_in">count_if</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), </span><br><span class="line">		[&amp;r = target](<span class="keyword">const</span> Book&amp; book) &#123;</span><br><span class="line">			<span class="keyword">return</span> book.title.<span class="built_in">find</span>(r) != std::string::npos;</span><br><span class="line">		&#125;);</span><br><span class="line">	cout &lt;&lt; cnt4 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>默认捕获（Default Capture）：<code>Lambda</code> 表示支持两种 <code>default capture</code> 的模式：</p>
<p><code>[=] </code>表示 <code>default capture by value</code>。按值捕获可见范围内的所有局部变量。<br><code>[&amp;] </code>表示<code> default capture by reference</code>。按引用捕获可见范围内的所有局部变量。</p>
<p>不建议直接使用 <code>[&amp;] </code>或<code>[=]</code>捕获所有参数，而是按需显示捕获。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">auto</span> default_capture_by_value = [=]() &#123;&#125;  <span class="comment">// 按值捕获了 a、s 和 v</span></span><br><span class="line">    <span class="keyword">auto</span> default_capture_by_reference = [&amp;]() &#123;&#125;  <span class="comment">// 按引用捕获了 a、s 和 v</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>按值捕获，类型是<code> const</code>的。</p>
<p>如果要修改按值捕获的参数，需要将 <code>Lambda </code>表达式声明为<code>mutable</code>的。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//auto func = [i]() &#123;i = 200;&#125;  // 编译错误：assignment of read-only variable ‘i’</span></span><br><span class="line">    <span class="keyword">auto</span> func = [i]() <span class="keyword">mutable</span> &#123;i = <span class="number">200</span>; cout &lt;&lt; i; &#125;;  <span class="comment">// 编译正确</span></span><br><span class="line">    <span class="built_in">func</span>();    <span class="comment">// 输出 200</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>捕获<code>this</code>指针 </p>
<p>在成员函数中的 <code>Lambda</code> 表达式可以捕获当前对象的<code> this</code> 指针，让 <code>Lambda</code>表达式拥有和当前类成员同样的访问权限，可以修改类的成员变量，使用类的成员函数。<code>this</code> 指针只能按值捕获 <code>[this]</code> ，不能按引用捕获 <code>[&amp;this]</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> std::string&amp; s, <span class="keyword">int</span> i) : <span class="built_in">s_</span>(s), <span class="built_in">i_</span>(i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> do_print = [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Print: &quot;</span> &lt;&lt; s_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i_ &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">do_print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> std::string&amp; s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> do_update = [<span class="keyword">this</span>, &amp;s, i]() &#123;</span><br><span class="line">            s_ = s;</span><br><span class="line">            i_ = i;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Update: &quot;</span> &lt;&lt; s_ &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i_ &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">do_update</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string s_;</span><br><span class="line">    <span class="keyword">int</span> i_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Foo *a = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    a-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    a-&gt;<span class="built_in">Update</span>(<span class="string">&quot;hahaha&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Print: hello 2</span></span><br><span class="line"><span class="comment">// Update: hahaha 100</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="24、实现-memcpy-函数"><a href="#24、实现-memcpy-函数" class="headerlink" title="24、实现 memcpy 函数"></a>24、实现 memcpy 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* psrc;</span><br><span class="line">    <span class="keyword">char</span>* pdst;</span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="keyword">char</span>*)src + size &gt; (<span class="keyword">char</span>*)dst) &#123; <span class="comment">// 自后向前拷贝</span></span><br><span class="line">        psrc = (<span class="keyword">char</span>*)src + size - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="keyword">char</span>*)dst + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            *pdst-- = *psrc--;   <span class="comment">// （*,--）优先级相同，从右向左结合，psrc--是先使用，后减减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">        pdst = (<span class="keyword">char</span>*)dst;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;abcdefghijk&quot;</span>;</span><br><span class="line">    <span class="comment">//memcpy(buf + 2, buf, 5);</span></span><br><span class="line">    <span class="comment">//printf(&quot;%s\n&quot;, buf + 2);</span></span><br><span class="line">    <span class="built_in">Memcpy</span>(buf + <span class="number">2</span>, buf, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25、GET-请求能包含-body-吗？"><a href="#25、GET-请求能包含-body-吗？" class="headerlink" title="25、GET 请求能包含 body 吗？"></a>25、GET 请求能包含 body 吗？</h4><p>回答是可以，但最好不要这么做。在<code>http1.1</code>协议中没有被明确禁止，但也没有定义语义。就算服务器不会忽略 <code>GET</code> 请求的<code>body</code>，各种代理和缓存可能也会过滤<code>body</code>。</p>
<h4 id="26、TCP-IP-协议中-TTL"><a href="#26、TCP-IP-协议中-TTL" class="headerlink" title="26、TCP/IP 协议中 TTL"></a>26、TCP/IP 协议中 TTL</h4><p><code>TTL</code>是<code>IP</code>协议包中的一个值，指定数据包被路由器丢弃之前允许通过的网段数量。<code>TTL</code> 是由发送主机设置的，以防止数据包不断在互联网络上永不终止地循环。转发<code> IP</code>数据包时，要求路由器至少将<code>TTL</code>减小 1，当此值为0则数据报将被丢弃，同时发送<code>ICMP</code>报文通知源主机。</p>
<h4 id="27、删除vector中的偶数元素，删除list中的奇数元素"><a href="#27、删除vector中的偶数元素，删除list中的奇数元素" class="headerlink" title="27、删除vector中的偶数元素，删除list中的奇数元素"></a>27、删除vector中的偶数元素，删除list中的奇数元素</h4><p>注意迭代器失效的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">21</span>,<span class="number">55</span>,<span class="number">89</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> ve = vec.<span class="built_in">begin</span>();    </span><br><span class="line">    <span class="keyword">while</span> (ve != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*ve % <span class="number">2</span>) &#123; <span class="comment">// 如果是奇数</span></span><br><span class="line">            ++ve;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 如果是偶数</span></span><br><span class="line">            ve = vec.<span class="built_in">erase</span>(ve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec)</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; li = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">21</span>,<span class="number">55</span>,<span class="number">89</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = li.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != li.<span class="built_in">end</span>()) &#123; <span class="comment">// 如果是奇数</span></span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span>) &#123;</span><br><span class="line">            it = li.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果是偶数</span></span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : li)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="28、auto关键字使用，类型是什么时候推导的？"><a href="#28、auto关键字使用，类型是什么时候推导的？" class="headerlink" title="28、auto关键字使用，类型是什么时候推导的？"></a>28、auto关键字使用，类型是什么时候推导的？</h4><p><code>auto</code>的作用是让编译器自动推断变量的类型，而不需要显式指定类型。这种隐式类型的<strong>推导发生在编译期</strong>。</p>
<p><code>auto</code>并不能代表实际的类型声明，只是一个类型声明的<strong>“占位符”</strong>。</p>
<p><code>auto</code>声明的变量<strong>必须马上初始化</strong>，以让编译器推断出它的实际类型。</p>
<h4 id="29、内核是如何管理进程的？"><a href="#29、内核是如何管理进程的？" class="headerlink" title="29、内核是如何管理进程的？"></a>29、内核是如何管理进程的？</h4><p>一个进程里至少有一个线程；线程之间由操作系统进行调度，包括进程中使用的资源也由操作系统进行调度；协程相当于线程中的语句块，由线程控制。</p>
<p>进程管理负责控制进程对 CPU 的访问，如任务的创建、调度和终止等。任务调度是进</p>
<p>程管理最核心的工作，由 Linux 内核调度器来完成。Linux 内核调度器根据进程的优先级选择最值得运行的进程。</p>
<p><strong>状态之间转换六种情况：</strong><br>　　<strong>运行 → 就绪：</strong>主要是进程占用 CPU 的时间过长，而系统分配给该进程占用 CPU 的时间是有限的；在采用抢先式优先级调度算法的系统中，当有更高优先级的进程要运行时，该进程就被迫让出 CPU，该进程便由执行状态转变为就绪状态。<br>　　<strong>就绪 → 运行：</strong>运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配 CPU。<br>　　<strong>运行 → 阻塞：</strong>正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态如发生了 I/O 请求。<br>　　<strong>阻塞 → 就绪：</strong>进程所等待的事件已经发生，就进入就绪队列。
　　</p>
<p><strong>以下两种状态是不可能发生的：</strong><br>　　<strong>阻塞 → 运行：</strong>即使给阻塞进程分配 CPU，也无法执行，操作系统在进行调度时，不会从阻塞队列进行挑选，而是从就绪队列中选取。<br>　　<strong>就绪 → 阻塞：</strong>就绪态根本就没有执行，谈不上进入阻塞态。</p>
<h4 id="30、vector-是否是线程安全的？"><a href="#30、vector-是否是线程安全的？" class="headerlink" title="30、vector 是否是线程安全的？"></a>30、vector 是否是线程安全的？</h4><h4 id="31、空类创建对象并进行拷贝会报错吗？"><a href="#31、空类创建对象并进行拷贝会报错吗？" class="headerlink" title="31、空类创建对象并进行拷贝会报错吗？"></a>31、空类创建对象并进行拷贝会报错吗？</h4><p>不会。自动生成拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	A b = a;</span><br><span class="line">	<span class="function">A <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="32、死锁如何调试？检测？死锁检测工具的实现原理？"><a href="#32、死锁如何调试？检测？死锁检测工具的实现原理？" class="headerlink" title="32、死锁如何调试？检测？死锁检测工具的实现原理？"></a>32、死锁如何调试？检测？死锁检测工具的实现原理？</h4><h4 id="33、实际项目中如何使用-Git-做分支管理？"><a href="#33、实际项目中如何使用-Git-做分支管理？" class="headerlink" title="33、实际项目中如何使用 Git 做分支管理？"></a>33、实际项目中如何使用 Git 做分支管理？</h4><p>实际开发中，一个仓库（通常只放一个项目）主要存在两条主分支：<code>master</code>与<code>develop</code>分支。这个两个分支的生命周期是整个项目周期。就是说，自创建出来就不会删除，会随着项目的不断开发不断的往里面添加代码。<code>master</code>分支是创建<code>git</code>仓库时自动生成的。</p>
<p><strong>master</strong>：这个分支最为稳定，这个分支代表项目处于可发布的状态。</p>
<p><strong>develop</strong>：作为开发的分支，平行于<code>master</code>分支。</p>
<p><strong>支持分支</strong>：这些分支都是为了程序员协同开发，以及应对项目的各种需求而存在的。这些分支都是为了解决某一个具体的问题而设立，当这个问题解决后，代码会合并回主分支<code>develop</code>或者<code>master</code>后删除，一般我们会人为分出三种分支。</p>
<ul>
<li><strong>Feature branches</strong>：这种分支和我们程序员日常开发最为密切，称作功能分支。必须从develop分支创建，完成后合并回develop分支。</li>
<li><strong>Release branches</strong>：这个分支用来分布新版本。<br>从develop分支创建，完成后合并回develop与master分支。这个分支上可以做一些非常小的bug修复，当然，你也可以禁止在这个分支做任何bug的修复工作，而只做版本发布的相关操作，例如设置版本号等操作，那样的话那些发现的小bug就必须放到下一个版本修复了。如果在这个分支上发现了大bug，那么也绝对不能在这个分支上改，需要Featrue分支上改，走正常的流程。</li>
<li><strong>Hotfix branches</strong>：这个分支主要为修复线上特别紧急的bug准备的。<br>必须从master分支创建，完成后合并回develop与master分支。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210602171234.png" style="zoom:60%;" />

<h4 id="34、既然已经有了进程，为什么要有线程？协程？"><a href="#34、既然已经有了进程，为什么要有线程？协程？" class="headerlink" title="34、既然已经有了进程，为什么要有线程？协程？"></a>34、既然已经有了进程，为什么要有线程？协程？</h4><ul>
<li><p>进程的缺点</p>
<p>在操作系统中，每个进程的内存空间都是独立的，这样用多进程实现并发就有两个缺点：一是内核的管理成本高，二是无法简单地通过内存同步数据，很不方便。于是，多线程模式就出现了。</p>
</li>
<li><p>线程调度的缺点</p>
<p>在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。因此，线程也被称为轻量级进程。与进程调度类似，<code>CPU</code>在线程之间快速切换，制造了线程并行运行的假象。由于各个线程都可以访问进程地址空间的每一个内存地址，所以一个线程可以读、写，甚至清除另一个线程的堆栈。也就是说，线程之间是没有保护的。但要注意的是，每个线程都有自己的堆栈、程序计数器、寄存器等信息，这些不是共享的。</p>
<p>共享地址空间虽然可以方便地共享对象，但这也导致一个问题，那就是任何一个线程出错时，进程中的所有线程会跟着一起崩溃。这也是如<code>Nginx</code>等强调稳定性的服务坚持使用多进程模式的原因。事实上，无论基于多进程还是多线程，都难以实现高并发，这由三个原因所致：</p>
<ul>
<li>线程占用：单个线程消耗的内存过多，比如<code>64</code>位的<code>Linux</code>为每个线程的栈分配了<code>8MB</code>的内存，通过<code>ulimit -s</code>可以查看线程的默认分配的内存。单位<code>kb</code>。</li>
<li>线程竞争：为了解决线程申请堆内存时，互相竞争的问题。每个线程预先在这个空间内申请堆空间还预分配了<code>64MB</code>的内存作为堆内存池。所以，我们没有足够的内存去开启几万个线程实现并发。</li>
<li>线程切换耗时：线程的切换是由内核控制的，什么时候会切换线程呢？不只时间片用尽，当调用阻塞方法时，内核为了<code>CPU</code> 充分工作，也会切换到其他线程执行。一次上下文切换的成本在几十纳秒到几微秒间，当线程繁忙且数量众多时，这些切换会消耗绝大部分的<code>CPU</code>运算能力。</li>
</ul>
</li>
<li><p>协程</p>
<p>协程就是用户态的线程。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。线程的栈有<code>8MB</code>，而协程栈的大小通常只有几十<code> KB</code>。而且，C库内存池也不会为协程预分配内存，它感知不到协程的存在。这样，更低的内存占用空间为高并发提供了保证，毕竟十万并发请求，就意味着10万个协程。</p>
<ul>
<li><p>协程的调度</p>
<p>每个协程有独立的栈，而栈既保留了变量的值，也保留了函数的调用关系、参数和返回值，CPU中的栈寄存器SP指向了当前协程的栈，而指令寄存器IP保存着下一条要执行的指令地址。因此，从协程1切换到协程2时，首先要把SP、IP寄存器的值为线程1保存下来，再从内存中找出协程2上一次切换前保存好的寄存器值，写入CPU的寄存器，这样就完成了协程切换。</p>
</li>
<li><p><strong>为什么要有协程？</strong></p>
<ul>
<li>节省CPU，避免系统内核级的线程频繁切换，造成的CPU资源浪费。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。            </li>
<li>节约内存，在64位的Linux中，一个线程需要分配8MB栈内存和64MB堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。</li>
<li>稳定性，前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。</li>
<li>开发效率，使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时IO请求等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="35、如果电脑是2G的，能写出4G的数组吗？"><a href="#35、如果电脑是2G的，能写出4G的数组吗？" class="headerlink" title="35、如果电脑是2G的，能写出4G的数组吗？"></a>35、如果电脑是2G的，能写出4G的数组吗？</h4><p>把数据存入文本文件中，分批加载到内存中，C++文件输入输出流读写。</p>
<p>取决于内存+硬盘还有你的操作系统是多少位，如果是32位的肯定不行，因为32为的linux虚拟空间为4g，1g是内核空间，用户空间只有3g，3g中有2.9g供堆使用。</p>
<p>不讲虚拟内存的话内存的大小一般是会影响运行效率，因为内存不足时有个换页机制，可以把内存中某些暂时用不到的数据换到磁盘中保存，所以正常的存储空间应该是内存加外存，内存大的话换页发生的就少，速度就会快一些，内存小的话换页频繁，效率比较慢。</p>
<h4 id="36、异地的两个ip，怎样查看一个ip到另一个ip之间经过的路由信息？"><a href="#36、异地的两个ip，怎样查看一个ip到另一个ip之间经过的路由信息？" class="headerlink" title="36、异地的两个ip，怎样查看一个ip到另一个ip之间经过的路由信息？"></a>36、异地的两个ip，怎样查看一个ip到另一个ip之间经过的路由信息？</h4><p><code>Tracert </code>命令用<code>IP 生存时间 (TTL)</code>字段和<code> ICMP 错误消息</code>来确定从一个主机到网络上其他主机的路由。</p>
<p><code>Tracert</code>是利用<code>ICMP</code>和<code>TTL</code>进行工作的。首先<code>tracert</code>会发出<code>TTL</code>值为<code>1</code>的<code>ICMP</code>数据报（包含40个字节，包括源地址、目标地址和发出的时间标签，一般会连续发3个包）。当到达路径上的第一个路由器时，路由器会将<code>TTL</code>值减<code>1</code>，此时<code>TTL</code>值变成<code>0</code>，该路由器会将此数据报丢弃，并返回一个超时回应数据报（包括数据报的源地址、内容和路由器的<code>IP</code>地址）。当<code>tracert</code>收到该数据报时，它便获得了这个路径上的第一个路由器的地址。接着，<code>tracert</code>再发送另一个<code>TTL</code>为<code>2</code>的数据报，第一个路由器会将此数据报转发给第二个路由器，而第二个路由器收到数据报时，<code>TTL</code>为<code>0</code>。第二个路由器便会返回一个超时回应数据报，从而<code>tracert</code>便获得了第二个路由器的地址。</p>
<p><code>Tracert</code>每次发出数据报时便会将<code>TTL</code>加<code>1</code>（一般每次都是发3个数据报），来发现下一个路由器。这个动作一直重复，直到到达目的地或者确定目标主机不可到达为止。当数据报到达目的地后，目标主机并不返回超时回应数据报。<code>Tracert</code>在发送数据报时，会选择一个一般应用程序不会使用的号码（30000以上）来作为接收端口号，所以当到达目的地后，目标主机会返回一个<code>ICMP port unreachable（端口不可达）</code>的消息。当<code>tracert</code>收到这个消息后，就知道目的地已经到达了。</p>
<p><code>Tracert</code>会提取<code>ICMP</code>的超时回应数据报中的<code>IP</code>地址并作主机名解析（用-d参数表示不解析主机名，解析主机名会耽误一些时间），然后将所经过的路由器的主机名及<code>IP</code>地址、数据报每次往返花费的时间显示出来。<code>Tracert</code>有一个固定的等待响应时间，如果这个时间过了，<code>tracert</code>就会输出<code>“*”</code>来表示某个设备没有在规定的时间内作出响应，然后<code>tracert</code>会将<code>TTL</code>值加<code>1</code>，继续进行检测。</p>
<h4 id="37、模板如何推导返回值类型？"><a href="#37、模板如何推导返回值类型？" class="headerlink" title="37、模板如何推导返回值类型？"></a>37、模板如何推导返回值类型？</h4><p>通过<code>auto</code> 和 <code>decltype</code>结合起来，来实现返回值类型的推导。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(U a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">getMax</span><span class="params">(U a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">10.5</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = add&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;   <span class="comment">// 输出 14.5</span></span><br><span class="line">    <span class="keyword">auto</span> d = <span class="built_in">getMax</span>(a, b);</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;   <span class="comment">// 输出 10.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="38、线程池线程数与-CPU密集型任务和I-O密集型任务-的关系？与CPU的核心数的关系？"><a href="#38、线程池线程数与-CPU密集型任务和I-O密集型任务-的关系？与CPU的核心数的关系？" class="headerlink" title="38、线程池线程数与(CPU密集型任务和I/O密集型任务)的关系？与CPU的核心数的关系？"></a>38、线程池线程数与(CPU密集型任务和I/O密集型任务)的关系？与CPU的核心数的关系？</h4><p>（1）<code>CPU</code>密集型的任务</p>
<p>比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。应该设置数目较小的线程数，比如<code>CPU </code>核心数<code>加1</code>，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是<code>CPU</code>核心数的 2 倍以上，因为计算任务非常重，会占用大量的 <code>CPU </code>资源，所以这时<code>CPU</code>的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 <code>CPU </code>资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</p>
<p>（2）<code>IO</code>密集型的任务</p>
<p>比如数据库、文件的读写，网络通信等任务。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。当然，如果线程数目太多，那么线程切换所带来的开销又会对系统的响应时间带来影响。</p>
<p>（3）如何合理设置线程池大小？公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最佳线程数目 &#x3D; （（线程等待时间 + 线程CPU时间）&#x2F; 线程CPU时间 ）* CPU数目</span><br><span class="line">进一步转化为：</span><br><span class="line">最佳线程数目 &#x3D; （线程等待时间 &#x2F; 线程CPU时间 + 1）* CPU数目</span><br></pre></td></tr></table></figure>

<p>得出结论：<strong>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程</strong>。</p>
<h4 id="39、TCP连接建立后，出现服务器崩溃、断电、网线被拔（即没有机会发出断开的-FIN-数据报文）会发生什么情况"><a href="#39、TCP连接建立后，出现服务器崩溃、断电、网线被拔（即没有机会发出断开的-FIN-数据报文）会发生什么情况" class="headerlink" title="39、TCP连接建立后，出现服务器崩溃、断电、网线被拔（即没有机会发出断开的 FIN 数据报文）会发生什么情况?"></a>39、TCP连接建立后，出现服务器崩溃、断电、网线被拔（即没有机会发出断开的 FIN 数据报文）会发生什么情况?</h4><p>如果A断开了，和 A 直连的路由设备虽然知道 A 设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知 B 端 A 端的断开。而 B 端没有收到断开的数据报文就会依然保持连接。<strong>所以 A 端拔掉网线或者断掉电源后 B 端是没办法收到断开连接的通知的</strong>。</p>
<p>（1）服务器崩溃：服务器会发送<code>RST</code>包让客户端关闭连接</p>
<p>发送<code>RST</code>包的情况：</p>
<ul>
<li>服务器没有打开对应的端口</li>
<li>服务器想主动关闭连接（非优雅关闭）</li>
<li>在一个已关闭的<code>socket</code>中收到数据(一般是半打开连接，一方关闭了另一方却不知道)</li>
</ul>
<p>（2）服务器断电、网线被拔</p>
<p>包不能被接收，需要客户端开启<code>keep-alive</code>，长期未收到响应就主动关闭连接。<code>TCP</code>协议本身就提供了一种这样的机制来探测对端的存活。<code>TCP</code>协议有一个<code>KEEP_LIVE</code>开关，只要打开这个开关就会定时发送一些数据长度为零的探测心跳包，发送的频率和次数都可以设置。<br>一般心跳包的机制是：客户端主动发送，服务器定时接收。若客户端没有收到响应就判定服务器断连，若服务器没有到收到心跳包就判定客户端断连接。</p>
<p>那么是否只是一端向另一端发送心跳就行了呢？显然不行。因为两端都有可能发生异常断开的情况。所以<code>TCP</code>连接的两端必须都向对端发送心跳。</p>
<h4 id="40、QQ可以打开多个，为什么微信只能打开一个？"><a href="#40、QQ可以打开多个，为什么微信只能打开一个？" class="headerlink" title="40、QQ可以打开多个，为什么微信只能打开一个？"></a>40、QQ可以打开多个，为什么微信只能打开一个？</h4><p>首先打开微信是打开一个进程，那么为什么后面打开微信进程的时候会失败呢？</p>
<p>主要是使用共享互斥锁。当创建一个进程的时候，互享互斥锁会检查是否已经创建，若没有，则打开成功。若已经有了，则不可以创建。       </p>
<h4 id="41、Linux-如何查看文件描述符？"><a href="#41、Linux-如何查看文件描述符？" class="headerlink" title="41、Linux 如何查看文件描述符？"></a>41、Linux 如何查看文件描述符？</h4><p>文件描述符是内核为了高效管理已被打开的文件所创建的索引，用于指向被打开的文件，所有执行<code>I/O</code>操作的系统调用都通过文件描述符。</p>
<p>（1）文件描述符总量与使用量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr </span><br><span class="line"><span class="comment">#第一列：为已分配的FD数量</span></span><br><span class="line"><span class="comment">#第二列：为已分配但尚未使用的FD数量</span></span><br><span class="line"><span class="comment">#第三列：为系统可用的最大FD数量</span></span><br></pre></td></tr></table></figure>

<p>（2）获取进程打开的文件描述符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/3253/fd</span><br><span class="line"><span class="comment"># 统计数量用 ll /proc/3253/fd | wc -l</span></span><br></pre></td></tr></table></figure>

<p>（3）查看文件描述符总量限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n</span><br></pre></td></tr></table></figure>

<p>（4）临时更改文件描述符总量限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 10240</span><br></pre></td></tr></table></figure>

<p>（5）永久更改文件描述符总量限制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/security/limits.conf </span><br><span class="line"><span class="comment"># 增加以下语句</span></span><br><span class="line"><span class="built_in">test</span> hard nofile 10240</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ulimit -n 10240&quot;</span> &gt;&gt; /home/abc/ .bash_profile</span><br></pre></td></tr></table></figure>

<h4 id="42、http1-0、http1-1、http2-的区别？"><a href="#42、http1-0、http1-1、http2-的区别？" class="headerlink" title="42、http1.0、http1.1、http2 的区别？"></a>42、http1.0、http1.1、http2 的区别？</h4><h4 id="43、不考虑性能、内存等因素，理想条件下，一台主机最多可以建立10万个连接嘛？"><a href="#43、不考虑性能、内存等因素，理想条件下，一台主机最多可以建立10万个连接嘛？" class="headerlink" title="43、不考虑性能、内存等因素，理想条件下，一台主机最多可以建立10万个连接嘛？"></a>43、不考虑性能、内存等因素，理想条件下，一台主机最多可以建立10万个连接嘛？</h4><p><code>TCP</code>连接中使用<strong>四元组（源IP，源端口，目标IP，目标端口）</strong>来标识一个<code>TCP</code>连接。这个问题要分两个方面考虑：</p>
<p><strong>（1）主机是客户端</strong></p>
<ul>
<li><p><strong>端口号限制</strong></p>
<ul>
<li>若是单网卡，即只有一个<code>IP</code>地址，并且向一个目标<code>IP</code>发送<code>TCP</code>请求，一个端口对应一个连接，端口号是短整型变量，受端口号限制（1 ~ 65535），因此最多只能建立<code>65535</code>个连接，此时不能建立10万个连接。可增加一个<code>ip</code>，支持的连接数就可以翻倍。 </li>
<li>若是单网卡，即只有一个<code>IP</code>地址，并且向<code>n</code>个目标<code>IP</code>发送<code>TCP</code>请求，那么最多可以建立<code> n * 65535</code>，<strong>受端口号和所连接的目标<code>IP</code>数量限制</strong>；</li>
<li>若是<code>m</code>网卡，即有多个<code>IP</code>地址，并向一个目标<code>IP</code>发送<code>TCP</code>请求，那么最多可以建立 <code>m * 65536</code>个连接，<strong>受端口号和网卡数量限制</strong>；</li>
</ul>
</li>
<li><p><strong>文件描述符限制</strong></p>
<p>每建立一个<code>TCP</code>连接，就得分配给一个文件描述符，<code>linux </code>对可打开的文件描述符的数量分别作了三个方面的限制：</p>
<p>系统级：当前系统可打开的最大数量，通过  <code>cat /proc/sys/fs/file-max </code>查看</p>
<p>用户级：指定用户可打开的最大数量，通过  <code>cat /etc/security/limits.conf </code>查看</p>
<p>进程级：单个进程可打开的最大数量，通过 <code> cat /proc/sys/fs/nr_open</code> 查看</p>
</li>
<li><p><strong>线程限制</strong></p>
<p>若是传统多线程并发模式，每建立一个<code>TCP</code>连接便创建一个线程，那么<code>TCP</code>连接数量还要受到线程限制。但是可以使用<code>IO多路复用</code>的方式来创建更多连接，即一个线程可以管理多个 <code>TCP</code> 连接。</p>
</li>
<li><p><strong>内存</strong></p>
<p>每个<code>TCP</code>连接本身，以及这个连接所用到的缓冲区，都是需要占用一定内存。所以还受到了内存限制。</p>
</li>
<li><p><strong>CPU</strong></p>
<p>创建和维持<code>TCP</code>连接需要消耗<code>CPU</code>资源，所以还受到<code>CPU</code>资源限制。</p>
</li>
</ul>
<p><strong>（2）主机是服务器端</strong></p>
<ul>
<li>服务器端主要是监听固定端口的<code>TCP</code>请求，那么根据 <strong>四元组（源IP，源端口，目标IP，目标端口）</strong>的定义，服务器端的目标<code>IP</code>，目标端口固定，所能接受的<code>TCP</code>连接数受到源<code>IP</code>和源端口的限制，那么最多可维持的<code>TCP</code>连接数为 <strong>2的32次方 (IP数)* 2 的16次方(port数)</strong> 个连接（当然这是一个模糊值，因为特殊<code>IP</code>地址需要排除在外，例如广播地址，本机地址啥的）。</li>
<li>除此之外，服务器端的连接还受到了 <strong>内存、文件描述符的、内存资源和CPU资源</strong>限制。</li>
</ul>
<h4 id="44、单核-CPU-运行多个线程可能出现的情况？"><a href="#44、单核-CPU-运行多个线程可能出现的情况？" class="headerlink" title="44、单核 CPU 运行多个线程可能出现的情况？"></a>44、单核 CPU 运行多个线程可能出现的情况？</h4><p><code>单核CPU</code>上运行的多线程程序, 同一时间只能一个线程在跑, 系统帮你切换线程而已, 系统给每个线程分配时间片来执行，每个时间片大概<code>10ms</code>左右，看起来像是同时跑，但实际上是每个线程跑一点点就换到其它线程继续跑。</p>
<p>可能会出现执行顺序不一致的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210602214330.png"></p>
<h4 id="45、http-如何传输大文件？"><a href="#45、http-如何传输大文件？" class="headerlink" title="45、http 如何传输大文件？"></a>45、http 如何传输大文件？</h4><p><strong>（1）数据压缩</strong></p>
<p>浏览器在发送请求时都会带着<code>Accept-Encoding</code>头字段，里面是浏览器支持的压缩格式列表，例如<code>gzip、deflate、br</code>等，这样服务器就可以从中选择一种压缩算法，放进<code>Content-Encoding</code> 响应头里，再把原数据压缩后发给浏览器。</p>
<p><strong>（2）分块传输</strong></p>
<p>分块传输会把一个大文件切成很多小块，把这些小块依次发给浏览器，浏览器收到之后再组装复原。这样浏览器和服务器都不用在内存中保存全部文件，每次只收发一小部分，网络也不会被大文件长时间占用，内存、带宽等资源也就节省下来了。</p>
<p>具体实现是在 <code>response</code> 响应报文里用头字段 <code>Transfer-Encoding: chunked</code> 来表示，表示报文里的<code> body</code> 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。当 <code>chunk </code>为 <code>0</code> 时说明是最后一个，传输结束。</p>
<p><code>Transfer-Encoding</code> 和<code>Content-Length</code>两个字段是互斥的，不能同时出现。一个响应报文的长度要么是已知的，要么是未知的。</p>
<h4 id="46、fork之后子进程会继承父进程的锁吗？子进程会如何处理父进程的未决信号？"><a href="#46、fork之后子进程会继承父进程的锁吗？子进程会如何处理父进程的未决信号？" class="headerlink" title="46、fork之后子进程会继承父进程的锁吗？子进程会如何处理父进程的未决信号？"></a>46、fork之后子进程会继承父进程的锁吗？子进程会如何处理父进程的未决信号？</h4><p><code>fork</code>函数调用会创建子进程，子进程的地址空间是在调用<code>fork</code>时父进程地址空间的拷贝。因为子进程地址空间跟父进程一样，所以调用<code>fork</code>时，<strong>子进程继承了父进程中的所有互斥锁、读写锁和条件变量（包括它们的状态）</strong>。</p>
<p>  但在多线程环境中，调用<code>fork</code>时，子进程中只有一个线程存在，这个线程是调用<code>fork</code>函数的那个线程，其他线程都没有被拷贝。</p>
<p> 根据上述两点，子进程中的锁可能被不存在的线程所拥有，这样子进程将没法获取或释放这些锁。针对这个问题有一个解决办法，即在调用<code>fork</code>之前，线程先获取进程中所有锁，在调用<code>fork</code>后分别在父子进程中释放这些锁，从而可以重新利用这些资源。因为<code>fork</code>之前，当前线程拥有所有的锁，所以<code>fork</code>之后，当前线程继续存在，子进程可以安全的释放这些锁。</p>
<p> 当然，在调用<code>fork</code>后，子进程马上调用<code>exec</code>，就无需考虑这些问题了，因为子进程地址空间被完全更换了。</p>
<p> 子进程只会继承父进程的信号处理方式。并不是说父进程后面应该收到的信号，子进程也该收到。所以你这里子进程不退出是因为没有<code>SIGALM</code>信号发送到子进程。</p>
<h4 id="47、数据库索引越多越好吗？"><a href="#47、数据库索引越多越好吗？" class="headerlink" title="47、数据库索引越多越好吗？"></a>47、数据库索引越多越好吗？</h4><p>索引并不是建立越多越好，把索引比作目录，相当于，一本100页的书，如果有50页目录，书本这么厚，实际内容就那么少，谁还会去翻看，若在面试中被问到，可以根据以下三点来回答：</p>
<ul>
<li>数据量小的表不需要建立索引，建立会增加额外的索引开销；</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本；</li>
<li>更多的索引意味着也需要更多的空间（索引也是需要空间来存放的）；</li>
</ul>
<h4 id="48、d为单例模式的动态链接库，如果a-b-c三个进程，同时访问，会如何，是否会产生多个对象？为什么？如何访问？"><a href="#48、d为单例模式的动态链接库，如果a-b-c三个进程，同时访问，会如何，是否会产生多个对象？为什么？如何访问？" class="headerlink" title="48、d为单例模式的动态链接库，如果a,b,c三个进程，同时访问，会如何，是否会产生多个对象？为什么？如何访问？"></a>48、d为单例模式的动态链接库，如果a,b,c三个进程，同时访问，会如何，是否会产生多个对象？为什么？如何访问？</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="49、设计一个应用层协议可以断点续传的文件传输协议，整体流程？"><a href="#49、设计一个应用层协议可以断点续传的文件传输协议，整体流程？" class="headerlink" title="49、设计一个应用层协议可以断点续传的文件传输协议，整体流程？"></a>49、设计一个应用层协议可以断点续传的文件传输协议，整体流程？</h4><h4 id="50、传值-传指针-传引用，指针和引用？"><a href="#50、传值-传指针-传引用，指针和引用？" class="headerlink" title="50、传值 / 传指针 / 传引用，指针和引用？"></a>50、传值 / 传指针 / 传引用，指针和引用？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test0</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">	p = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;传值后 p = &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针作为参数进行传递，函数运行结束之后，不影响实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;传指针后，p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用作为参数进行传递，函数运行结束之后，影响实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	p = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;传引用后 p = &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">666</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始值 x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test0</span>(x);  <span class="comment">// 传值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;传值函数运行完 x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始值 p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test1</span>(p);  <span class="comment">// 传指针</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;传指针函数运行完 p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始值 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">test2</span>(b);   <span class="comment">// 传引用</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;传引用函数运行完 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 原始值 x = 666</span></span><br><span class="line"><span class="comment">// 传值后 p = 200</span></span><br><span class="line"><span class="comment">// 传值函数运行完 x = 666</span></span><br><span class="line"><span class="comment">// 原始值 p = 100</span></span><br><span class="line"><span class="comment">// 传指针后，p = 1</span></span><br><span class="line"><span class="comment">// 传指针函数运行完 p = 100</span></span><br><span class="line"><span class="comment">// 原始值 b = 200</span></span><br><span class="line"><span class="comment">// 传引用后 p = 2</span></span><br><span class="line"><span class="comment">// 传引用函数运行完 b = 2</span></span><br></pre></td></tr></table></figure>

<h4 id="51、数组和指针的区别？"><a href="#51、数组和指针的区别？" class="headerlink" title="51、数组和指针的区别？"></a>51、数组和指针的区别？</h4><p>数组名相当于常指针，没有自增、自减的操作，数组作为参数传递的时候，会退化为一般指针，<code>sizeof</code>得到的不再是数组的大小，而是指针的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">char</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p[2]=%d, *(p+2)=%d\n&quot;</span>, p[<span class="number">2</span>], *(p + <span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a[2]=%c, *(a+2)=%c\n&quot;</span>, a[<span class="number">2</span>], *(a + <span class="number">2</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">5</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">9</span>] = &#123; <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(p));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">	<span class="built_in">f</span>(p, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// sizeof(p) = 20</span></span><br><span class="line"><span class="comment">// sizeof(a) = 9</span></span><br><span class="line"><span class="comment">// p[2] = 2, *(p + 2) = 2</span></span><br><span class="line"><span class="comment">// a[2] = 2, *(a + 2) = 2</span></span><br><span class="line"><span class="comment">// sizeof(p) = 8</span></span><br><span class="line"><span class="comment">// sizeof(a) = 8</span></span><br></pre></td></tr></table></figure>

<h4 id="52、weak-ptr-如何打破循环指向的问题？"><a href="#52、weak-ptr-如何打破循环指向的问题？" class="headerlink" title="52、weak_ptr 如何打破循环指向的问题？"></a>52、weak_ptr 如何打破循环指向的问题？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;destroying A\n&quot;</span>; &#125;</span><br><span class="line">	shared_ptr&lt;B&gt; pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;destroying B\n&quot;</span>; &#125;</span><br><span class="line">	shared_ptr&lt;A&gt; pa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">	a-&gt;pb = b;</span><br><span class="line">	b-&gt;pa = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;begin test...\n&quot;</span>;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end test\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：并没有释放对象</span></span><br><span class="line"><span class="comment">// begin test...</span></span><br><span class="line"><span class="comment">// end test    </span></span><br></pre></td></tr></table></figure>

<p>在函数<code>test()</code>中，<code>A</code>、<code>B</code>的对象分别被彼此的<code>shared_ptr</code>所引用，离开<code>test()</code>作用域后，<code>A</code>、<code>B</code>对象再也不能被用户访问，因为智能指针<code>a</code>、<code>b</code>被销毁了，但是各自引用计数为1，两个对象的内存再也不会被释放，可怕的内存泄漏就此产生。</p>
<p>考虑如果将B中的智能指针换成<code>weak_ptr&lt;A&gt;</code>，回过头看<code>test()</code>里发生了什么？</p>
<p>首先<code>shared_ptr</code>版本的<code>a</code>、<code>b</code>初始化，引用计数各自为1，然后将<code>b</code>赋值给<code>A</code>中的<code>shared_ptr</code>，B对象引用计数变为2，将<code>a</code>赋值给<code>B</code>中的<code>weak_ptr</code>，此操作不改变<code>shared_ptr&lt;A&gt;</code>的引用计数，依旧为1。退出<code>test</code>作用域，<code>a</code>、<code>b</code>析构，<code>B</code>引用计数变为1，<code>A</code>的引用计数为0。<code>A</code>的析构函数被调用，<code>A</code>中的<code>shared_ptr&lt;B&gt;</code>也被销毁，即<code>B</code>的引用计数再次减1变为0，调用<code>B</code>的析构函数。此时，内存已经被全部回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;destroying A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;B&gt; pb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;destroying B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	weak_ptr&lt;A&gt; pa;  <span class="comment">// 将B中的智能指针转换成弱引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">b</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">	a-&gt;pb = b;</span><br><span class="line">	b-&gt;pa = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;begin test...\n&quot;</span>;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end test\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：已经释放对象了</span></span><br><span class="line"><span class="comment">// begin test...</span></span><br><span class="line"><span class="comment">// destroying A</span></span><br><span class="line"><span class="comment">// destroying B</span></span><br><span class="line"><span class="comment">// end test</span></span><br></pre></td></tr></table></figure>

<h4 id="53、为什么-hashtable-中桶的数目都是用质数表示"><a href="#53、为什么-hashtable-中桶的数目都是用质数表示" class="headerlink" title="53、为什么 hashtable 中桶的数目都是用质数表示"></a>53、为什么 hashtable 中桶的数目都是用质数表示</h4><p>哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。</p>
<p>假设我们使用合数作为桶数，那么桶数<code>n</code>除了<code>1</code>和<code>n</code>之外还会有其他的约数<code>a1,a2….</code>，那么假设我们的关键字和桶数有相同的约数<code>a</code>，那么哈希计算：<code>k % n = (k’ *a) % (n’ *a) = (k’ % n’) *a 其中，k = k’ * a, n = n’ *a</code>，说明计算得到的桶号肯定是<code>a</code>的倍数，而这些和桶数有约数的元素永远不会被放到<code>非a倍数</code>的桶号中，那么这时候<code>hashtable</code>的性能将取决于到底有多少元素能够和桶数有公约数，这对<code>hashtable</code>尽量使各个桶之间的元素数近似相等的原则违背。</p>
<p>另外，<code>hashtable</code>相比于<code>RB-tree</code>的一个优势就在于<code>RB-tree</code>虽然平均查找时间是对数时间，但是这是在假设数据均匀分布的基础之上的，而<code>hashtable</code>也有平均对数时间上的性能，且这种表现是以统计为基础，不需依赖元素输入的随机性。而且如果合数作为桶数，那么如果输入的数列为某种规律数列的话，很容易导致极端情况出现。</p>
<h4 id="54、C-中-union-和-struct-的区别"><a href="#54、C-中-union-和-struct-的区别" class="headerlink" title="54、C++ 中 union 和 struct 的区别"></a>54、C++ 中 union 和 struct 的区别</h4><p>union：有时需要使几种不同类型的变量存放在同一段内存单元中。虽然在同一段内存中不同数据类型所占字节数不同，但都从同一地址开始存放，也就是使用了覆盖技术，几个变量互相覆盖。这种使几个不同的变量共占一段内存的结构，称为共同体类型的结构（也称为联合类型），采用重叠式存储。能够访问的是共用体变量中最后一次被赋值的成员，在对一个新的成员赋值后原有的成员就失去作用。</p>
<p>区别：结构体变量所占内存长度是各成员占的内存长度之和。每个成员分别占有其自己的内存单元。</p>
<p>共用体变量所占的内存空间等于字节长度最大的成员的长度。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/05/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">https://varrella.github.io/2021/05/02/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/02/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___-33ZZ-YflN8___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《STL源码剖析》笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___3jcRnpA38Ac___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">github + hexo + PicGo</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81C"><span class="toc-number">1.</span> <span class="toc-text">一、C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">0、指针和引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9C%A8%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">1、在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">2、堆和栈有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%EF%BC%9F%EF%BC%88%E5%AD%97%E8%8A%82%E6%8F%90%E5%89%8D%E6%89%B9%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">3、堆快一点还是栈快一点？（字节提前批一面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81-new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Cnew-%E4%B8%8E-malloc%E7%9A%84%E5%BC%82%E5%90%8C%E5%A4%84"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">4、 new和delete是如何实现的，new 与 malloc的异同处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86malloc-free%EF%BC%8CC-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81new-delete%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">5、既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81-C%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">6、 C和C++的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">7、delete和delete[]的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81-C-%E3%80%81Java%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%AD%89%EF%BC%88java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">8、 C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81C-%E5%92%8Cpython%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">9、C++和python的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81Struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">10、Struct和class的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81define-%E5%92%8Cconst%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%AD%89%EF%BC%89"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">11、define 和const的联系与区别（编译阶段、安全性、内存占用等）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E5%9C%A8C-%E4%B8%ADconst%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%94%A8%E9%80%94%EF%BC%89"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">12、在C++中const的用法（定义，用途）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81C-%E4%B8%AD%E7%9A%84static%E7%94%A8%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-number">1.0.0.14.</span> <span class="toc-text">13、C++中的static用法和意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E8%AE%A1%E7%AE%97%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9A"><span class="toc-number">1.0.0.15.</span> <span class="toc-text">14、计算下面几个类的大小：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81C-%E7%9A%84STL%E4%BB%8B%E7%BB%8D%EF%BC%88%E8%BF%99%E4%B8%AA%E7%B3%BB%E5%88%97%E4%B9%9F%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%BE%AF%E6%8D%B7%E8%80%81%E5%B8%88%E7%9A%84%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E4%B9%A6%E7%B1%8D%E4%B8%8E%E8%A7%86%E9%A2%91%EF%BC%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86allocator%EF%BC%8C%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%AD%89"><span class="toc-number">1.0.0.16.</span> <span class="toc-text">15、C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81STL%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84hash%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.0.17.</span> <span class="toc-text">16、STL源码中的hash表的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.0.0.18.</span> <span class="toc-text">17、解决哈希冲突的方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81STL%E4%B8%ADunordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.19.</span> <span class="toc-text">18、STL中unordered_map和map的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81STL%E4%B8%ADvector%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.0.20.</span> <span class="toc-text">19、STL中vector的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81-vector%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%E5%8F%8A%E5%85%B6%E5%8E%9F%E5%9B%A0%EF%BC%8C%E9%A2%91%E7%B9%81%E5%AF%B9vector%E8%B0%83%E7%94%A8push-back-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%92%8C%E5%8E%9F%E5%9B%A0%E3%80%82"><span class="toc-number">1.0.0.21.</span> <span class="toc-text">20、 vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81C-%E4%B8%ADvector%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.22.</span> <span class="toc-text">21、C++中vector和list的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.0.0.23.</span> <span class="toc-text">22、C++中的重载和重写的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.0.0.24.</span> <span class="toc-text">23、C ++内存管理（热门问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%AF%8F%E4%B8%80%E4%B8%AA%E3%80%82"><span class="toc-number">1.0.0.25.</span> <span class="toc-text">24、介绍面向对象的三大特性，并且举例说明每一个。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%92%8C%E4%B8%8B%E4%B8%AA%E9%97%AE%E9%A2%98%E4%B8%80%E8%B5%B7%E5%9B%9E%E7%AD%94%EF%BC%89"><span class="toc-number">1.0.0.26.</span> <span class="toc-text">25、多态的实现（和下个问题一起回答）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E7%83%AD%E9%97%A8%EF%BC%8C%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.0.0.27.</span> <span class="toc-text">26、C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%84%E7%90%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">1.0.0.28.</span> <span class="toc-text">27、实现编译器处理虚函数表应该如何处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.0.0.29.</span> <span class="toc-text">28、基类的析构函数一般写成虚函数的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.0.30.</span> <span class="toc-text">29、构造函数为什么一般不定义为虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">1.0.0.31.</span> <span class="toc-text">30、构造函数或者析构函数中调用虚函数会怎样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.0.32.</span> <span class="toc-text">31、纯虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.0.33.</span> <span class="toc-text">32、 静态绑定和动态绑定的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="toc-number">1.0.0.34.</span> <span class="toc-text">33、深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">1.0.0.35.</span> <span class="toc-text">34、对象复用的了解，零拷贝的了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81%E4%BB%8B%E7%BB%8DC-%E6%89%80%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.0.36.</span> <span class="toc-text">35、介绍C++所有的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%89"><span class="toc-number">1.0.0.37.</span> <span class="toc-text">36、什么情况下会调用拷贝构造函数（三种情况）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E5%92%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="toc-number">1.0.0.38.</span> <span class="toc-text">37、结构体内存对齐方式和为什么要进行内存对齐？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">1.0.0.39.</span> <span class="toc-text">38、内存泄露的定义，如何检测与避免？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39%E3%80%81C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.0.0.40.</span> <span class="toc-text">39、C++的智能指针有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40%E3%80%81%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.0.41.</span> <span class="toc-text">40、调试程序的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E3%80%81%E9%81%87%E5%88%B0coredump%E8%A6%81%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95"><span class="toc-number">1.0.0.42.</span> <span class="toc-text">41、遇到coredump要怎么调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E3%80%81inline%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%B4%E4%B8%80%E4%B8%8B-%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.43.</span> <span class="toc-text">42、inline关键字说一下 和宏定义有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E3%80%81%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.0.44.</span> <span class="toc-text">43、模板的用法与适用场景 实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF%EF%BC%89%EF%BC%9F"><span class="toc-number">1.0.0.45.</span> <span class="toc-text">44、成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45%E3%80%81%E7%94%A8%E8%BF%87C11%E5%90%97%EF%BC%8C%E7%9F%A5%E9%81%93C11%E6%96%B0%E7%89%B9%E6%80%A7%E5%90%97%EF%BC%9F%EF%BC%88%E6%9C%89%E9%9D%A2%E8%AF%95%E5%AE%98%E5%BB%BA%E8%AE%AE%E7%86%9F%E6%82%89C11%EF%BC%89"><span class="toc-number">1.0.0.46.</span> <span class="toc-text">45、用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46%E3%80%81C-%E7%9A%84%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B%EF%BC%88%E7%AE%80%E5%8D%95%E4%B8%80%E7%82%B9C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B%EF%BC%89"><span class="toc-number">1.0.0.47.</span> <span class="toc-text">46、C++的调用惯例（简单一点C++函数调用的压栈过程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47%E3%80%81C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.0.0.48.</span> <span class="toc-text">47、C++的四种强制转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48%E3%80%81string%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.0.49.</span> <span class="toc-text">48、string的底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49%E3%80%81%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B%E6%88%96%E8%80%85%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">1.0.0.50.</span> <span class="toc-text">49、一个函数或者可执行文件的生成过程或者编译过程是怎样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50%E3%80%81set%EF%BC%8Cmap%E5%92%8Cvector%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.0.0.51.</span> <span class="toc-text">50、set，map和vector的插入复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E3%80%81%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.52.</span> <span class="toc-text">51、定义和声明的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E3%80%81typdef%E5%92%8Cdefine%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.0.53.</span> <span class="toc-text">52、typdef和define区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E3%80%81%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.0.54.</span> <span class="toc-text">53、被free回收的内存是立即返还给操作系统吗？为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54%E3%80%81%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.0.0.55.</span> <span class="toc-text">54、引用作为函数参数以及返回值的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">1.0.0.56.</span> <span class="toc-text">55、友元函数和友元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.0.57.</span> <span class="toc-text">56、说一下volatile关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57%E3%80%81STL%E4%B8%AD%E7%9A%84sort-%E7%AE%97%E6%B3%95%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Cstable-sort-%E5%91%A2"><span class="toc-number">1.0.0.58.</span> <span class="toc-text">57、STL中的sort()算法是用什么实现的，stable_sort()呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58%E3%80%81vector%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">1.0.0.59.</span> <span class="toc-text">58、vector会迭代器失效吗？什么情况下会迭代器失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.0.0.60.</span> <span class="toc-text">58、为什么C++没有实现垃圾回收？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">二、计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E5%BB%BA%E7%AB%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">（1） 建立TCP服务器的各个系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E7%BB%A7%E4%B8%8A%E4%B8%80%E9%A2%98%EF%BC%8C%E8%AF%B4%E6%98%8Esocket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F%E5%85%B6%E4%B8%ADclose%E6%98%AF%E4%B8%80%E6%AC%A1%E5%B0%B1%E8%83%BD%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%AD%E7%9A%84%E5%90%97%EF%BC%8C%E5%8D%8A%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E5%AF%B9%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E4%BB%8B%E7%BB%8D%E3%80%82%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEIGP%E5%8C%85%E6%8B%ACRIP%EF%BC%8COSPF%EF%BC%8C%E5%92%8C%E5%A4%96%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEEGP%E5%92%8CBGP"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">（4） UDP如何实现可靠传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">（5） TCP和UDP的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-TCP%E5%92%8CUDP%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">（6） TCP和UDP相关的协议与端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-TCP%EF%BC%88UDP%EF%BC%8CIP%EF%BC%89%E7%AD%89%E9%A6%96%E9%83%A8%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%88http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%9E%84%E6%88%90%EF%BC%89"><span class="toc-number">2.0.0.7.</span> <span class="toc-text">（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E7%BD%91%E9%A1%B5%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.0.8.</span> <span class="toc-text">（8） 网页解析的过程与实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E5%A6%82www-baidu-com%EF%BC%89"><span class="toc-number">2.0.0.9.</span> <span class="toc-text">（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%88%86%E7%89%87%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.0.0.10.</span> <span class="toc-text">（10） 网络层分片的原因与具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%88TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80%E6%98%AF%E7%83%AD%E9%97%A8%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">2.0.0.11.</span> <span class="toc-text">（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-TCP%E6%8F%A1%E6%89%8B%E4%BB%A5%E5%8F%8A%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E4%BA%8E%E5%93%AA%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">2.0.0.12.</span> <span class="toc-text">（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-number">2.0.0.13.</span> <span class="toc-text">（13） 为什么使用三次握手，两次握手可不可以？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89-TIME-WAIT%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E4%BA%8E2MSL%EF%BC%89"><span class="toc-number">2.0.0.14.</span> <span class="toc-text">（14） TIME_WAIT的意义（为什么要等于2MSL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8D%E5%A4%AA%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.0.0.15.</span> <span class="toc-text">（15） 超时重传机制（不太高频）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-TCP%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-number">2.0.0.16.</span> <span class="toc-text">（16） TCP怎么保证可靠性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D%EF%BC%8C%E9%87%87%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%88%E6%AD%BB%E9%94%81%E5%8F%AF%E8%83%BD%EF%BC%8C%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.0.17.</span> <span class="toc-text">（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-tcp%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.0.0.18.</span> <span class="toc-text">（18） tcp滑动窗口协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.0.19.</span> <span class="toc-text">（19） 拥塞控制和流量控制的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%8C%E7%AE%97%E6%B3%95%E5%90%8D%E5%AD%97%EF%BC%9F%EF%BC%88%E6%9E%81%E5%85%B6%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">2.0.0.20.</span> <span class="toc-text">（20） TCP拥塞控制，算法名字？（极其重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-http%E5%8D%8F%E8%AE%AE%E4%B8%8ETCP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">2.0.0.21.</span> <span class="toc-text">（21） http协议与TCP的区别与联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-http-1-0%E5%92%8Chttp-1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.0.22.</span> <span class="toc-text">（22） http&#x2F;1.0和http&#x2F;1.1的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89-http%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fget%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">2.0.0.23.</span> <span class="toc-text">（23） http的请求方法有哪些？get和post的区别。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89-http%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81-403-201%E7%AD%89%E7%AD%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">2.0.0.24.</span> <span class="toc-text">（24） http的状态码 403 201等等是什么意思</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89-http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%94%B1http%E5%8D%87%E7%BA%A7%E4%B8%BAhttps%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.0.25.</span> <span class="toc-text">（25） http和https的区别，由http升级为https需要做哪些操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89-https%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.0.0.26.</span> <span class="toc-text">（26） https的具体实现，怎么确保安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8827%EF%BC%89-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9A%84seq%E5%BA%8F%E5%8F%B7%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="toc-number">2.0.0.27.</span> <span class="toc-text">（27） TCP三次握手时的第一次的seq序号是怎样产生的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8828%EF%BC%89-%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8A%E9%99%90%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97%EF%BC%9F%E9%82%A3%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%B6%85%E8%BF%87%E8%BF%99%E4%B8%AA%E9%99%90%E5%88%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.0.0.28.</span> <span class="toc-text">（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8829%EF%BC%89-%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E4%BD%93%E7%B3%BB"><span class="toc-number">2.0.0.29.</span> <span class="toc-text">（29） 对称密码和非对称密码体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8830%EF%BC%89-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.0.0.30.</span> <span class="toc-text">（30） 数字证书的了解（高频）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8831%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.0.31.</span> <span class="toc-text">（31） 服务器出现大量close_wait的连接的原因以及解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8832%EF%BC%89-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%BB%8B%E7%BB%8DMD5%E7%AE%97%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88MD5%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%80%86%E7%9A%84%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BC%BA%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A9%E5%AE%83%E4%B8%8D%E9%82%A3%E4%B9%88%E5%AE%B9%E6%98%93%E8%A2%AB%E7%A0%B4%E8%A7%A3%E5%91%A2%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">2.0.0.32.</span> <span class="toc-text">（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8833%EF%BC%89-%E5%8D%95%E6%9D%A1%E8%AE%B0%E5%BD%95%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">2.0.0.33.</span> <span class="toc-text">（33） 单条记录高并发访问的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8834%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bping%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.0.0.34.</span> <span class="toc-text">（34） 介绍一下ping的过程，分别用到了哪些协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8835%EF%BC%89-TCP-IP%E7%9A%84%E7%B2%98%E5%8C%85%E4%B8%8E%E9%81%BF%E5%85%8D%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="toc-number">2.0.0.35.</span> <span class="toc-text">（35） TCP&#x2F;IP的粘包与避免介绍一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8836%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E5%B0%81%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85"><span class="toc-number">2.0.0.36.</span> <span class="toc-text">（36） 说一下TCP的封包和拆包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8837%EF%BC%89-%E4%B8%80%E4%B8%AAip%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%9D%A0%E4%BB%80%E4%B9%88%E8%AF%86%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.0.37.</span> <span class="toc-text">（37） 一个ip配置多个域名，靠什么识别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8838%EF%BC%89-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%BB%E5%87%BB%EF%BC%88DDos%E6%94%BB%E5%87%BB%EF%BC%89"><span class="toc-number">2.0.0.38.</span> <span class="toc-text">（38） 服务器攻击（DDos攻击）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8839%EF%BC%89DNS%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.0.39.</span> <span class="toc-text">（39）DNS的工作过程和原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8841%EF%BC%89OSA%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.0.0.40.</span> <span class="toc-text">（41）OSA七层协议和五层协议，分别有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8842%EF%BC%89IP%E5%AF%BB%E5%9D%80%E5%92%8CMAC%E5%AF%BB%E5%9D%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">2.0.0.41.</span> <span class="toc-text">（42）IP寻址和MAC寻址有什么不同，怎么实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%84%E4%B8%AA%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.0.0.41.1.</span> <span class="toc-text">1、网络模型和各个层的协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.0.0.41.1.1.</span> <span class="toc-text">（1）网络模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.0.0.41.1.2.</span> <span class="toc-text">（2）每一层的协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.0.0.41.1.3.</span> <span class="toc-text">（3）每一层的作用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.0.41.2.</span> <span class="toc-text">2、TCP和UDP的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="toc-number">2.0.0.41.3.</span> <span class="toc-text">3、TCP如何保证数据的可靠传输的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.0.0.41.4.</span> <span class="toc-text">4、TCP三次握手的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.0.0.41.5.</span> <span class="toc-text">5、TCP四次挥手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.0.41.6.</span> <span class="toc-text">6、DNS域名系统工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81ARP%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.0.41.7.</span> <span class="toc-text">7、ARP地址解析协议工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E8%BF%9E%E7%BB%ADARQ%E5%92%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.0.0.41.8.</span> <span class="toc-text">8、连续ARQ和滑动窗口协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.0.41.9.</span> <span class="toc-text">9、HTTP和HTTPS的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80-gt-gt-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.0.0.41.10.</span> <span class="toc-text">10、在浏览器中输入url地址-&gt;&gt;显示主页的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.0.0.41.11.</span> <span class="toc-text">11、HTTP常见状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">2.0.0.41.12.</span> <span class="toc-text">12、HTTP的请求和响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.0.0.41.13.</span> <span class="toc-text">13、HTTP请求方法有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E8%BF%B0HTTP%E4%B8%ADGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.0.41.14.</span> <span class="toc-text">14、简述HTTP中GET和POST的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.0.0.41.15.</span> <span class="toc-text">15、IP地址的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E3%80%81%E7%BD%91%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%B9%B6%E7%9F%A5%E9%81%93%E5%90%84%E8%87%AA%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">2.0.0.41.16.</span> <span class="toc-text">16、交换机、路由器、网关的概念，并知道各自的用途</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.0.0.41.17.</span> <span class="toc-text">17、常见端口号及对应的服务</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">三、 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BD%8E%E9%A2%91%EF%BC%89"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">（1） 关系型和非关系型数据库的区别（低频）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BD%8E%E9%A2%91%EF%BC%89"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">（2） 什么是非关系型数据库（低频）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B-MySQL-%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%86%85%E9%83%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">（4） 数据库的索引类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.0.0.5.</span> <span class="toc-text">（5） 说一下事务是怎么实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-MySQL%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">3.0.0.6.</span> <span class="toc-text">（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.0.0.7.</span> <span class="toc-text">（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.0.0.8.</span> <span class="toc-text">（8） 索引的底层实现（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.0.0.9.</span> <span class="toc-text">（9） B树和B+树的区别（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80-%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">3.0.0.10.</span> <span class="toc-text">（10） 索引最左前缀&#x2F;最左匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-Mysql%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%8C%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">3.0.0.11.</span> <span class="toc-text">（11） Mysql的优化（高频，索引优化，性能优化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D%EF%BC%8Cinnodb%E5%92%8Cmyisam%E7%9A%84%E7%89%B9%E7%82%B9%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.0.12.</span> <span class="toc-text">（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%EF%BC%88%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E9%83%BD%E8%A6%81%E8%83%BD%E5%A4%9F%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%8C%E7%90%86%E8%A7%A3%E9%80%8F%E5%BD%BB%EF%BC%8C%E6%AF%94%E5%A6%82%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%8C%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8D%E5%A5%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">3.0.0.13.</span> <span class="toc-text">（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">3.0.0.14.</span> <span class="toc-text">（14）什么是脏读，不可重复读和幻读？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8Cmysql%E5%92%8COracle%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.0.0.15.</span> <span class="toc-text">（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.0.0.16.</span> <span class="toc-text">（16） 数据库连接池的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-Mysql%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%90%84%E8%87%AA%E7%89%B9%E7%82%B9"><span class="toc-number">3.0.0.17.</span> <span class="toc-text">（17） Mysql的表空间方式，各自特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.0.0.18.</span> <span class="toc-text">（18） 分布式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F"><span class="toc-number">3.0.0.19.</span> <span class="toc-text">（19） 数据库的范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-%E6%95%B0%E6%8D%AE%E7%9A%84%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%8C%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.0.20.</span> <span class="toc-text">（20） 数据的锁的种类，加锁的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">3.0.0.21.</span> <span class="toc-text">（21） 什么是共享锁和排他锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E7%AE%80%E4%BB%8B"><span class="toc-number">3.0.0.22.</span> <span class="toc-text">（22） 分库分表的理解和简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89"><span class="toc-number">3.0.0.23.</span> <span class="toc-text">（23）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.0.0.24.</span> <span class="toc-text">（24）数据库高并发的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="toc-number">3.0.0.25.</span> <span class="toc-text">（25）乐观锁与悲观锁解释一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.0.0.26.</span> <span class="toc-text">（26）乐观锁与悲观锁是怎么实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8827%EF%BC%89%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E6%8A%80%E6%9C%AF%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">3.0.0.27.</span> <span class="toc-text">（27）对数据库目前最新技术有什么了解吗</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">3.0.0.27.1.</span> <span class="toc-text">1、什么是索引？为什么要用索引？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">3.0.0.27.2.</span> <span class="toc-text">2、索引的作用与缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.0.0.27.3.</span> <span class="toc-text">3、创建索引的场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%B8%8D%E5%BA%94%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.0.0.27.4.</span> <span class="toc-text">4、不应创建索引的场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.0.0.27.5.</span> <span class="toc-text">5、索引的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.0.0.27.6.</span> <span class="toc-text">6、聚集索引和非聚集索引的区别及优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8B%E6%A0%91%EF%BC%9F"><span class="toc-number">3.0.0.27.7.</span> <span class="toc-text">7、索引的底层原理，为什么用B+树而不用B树？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89B-%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">3.0.0.27.7.1.</span> <span class="toc-text">（1）B+树和B-树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%97%AE%E9%A2%981%EF%BC%9AMySQL%E4%B8%AD%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AFB-%E6%A0%91%EF%BC%8CB-%E6%A0%91%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E8%B7%9F%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%9C%89%E5%85%B3%EF%BC%8C%E6%98%AFlog-n-%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8hash%E5%AD%98%E5%82%A8%EF%BC%8C%E9%82%A3%E4%B9%88%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E6%98%AFO-1-%E3%80%82%E6%97%A2%E7%84%B6hash%E6%AF%94B-%E6%A0%91%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%94%A8B-%E6%A0%91%E6%9D%A5%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="toc-number">3.0.0.27.7.2.</span> <span class="toc-text">（2）问题1：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%97%AE%E9%A2%982%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E6%88%96%E8%80%85%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%9F"><span class="toc-number">3.0.0.27.7.3.</span> <span class="toc-text">（3）问题2：为什么不用红黑树或者二叉排序树？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%97%A2%E7%84%B6%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%8C%E9%82%A3%E4%B9%88%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9C%80%E4%BC%98%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">3.0.0.27.7.4.</span> <span class="toc-text">（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E6%AF%94B%E6%A0%91%E6%9B%B4%E4%BC%98%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B6%89%E5%8F%8A%E5%88%B0%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9CB%E6%A0%91%E5%B0%B1%E6%9B%B4%E4%BC%98%E4%BA%86%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%A0%E8%83%BD%E8%AE%B2%E8%AE%B2B-%E6%A0%91%E5%90%97%EF%BC%9F"><span class="toc-number">3.0.0.27.7.5.</span> <span class="toc-text">（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88B-%E6%A0%91%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">3.0.0.27.7.6.</span> <span class="toc-text">（6）为什么B+树要这样设计？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Linux"><span class="toc-number">4.</span> <span class="toc-text">四、Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-Linux%E7%9A%84I-O%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E8%B6%85%E7%BA%A7%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">（1） Linux的I&#x2F;O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88EXT4%EF%BC%8CXFS%EF%BC%8CBTRFS%EF%BC%89"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">（2） 文件系统的理解（EXT4，XFS，BTRFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-EPOLL%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BA%86%E8%A7%A3"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">（3） EPOLL的介绍和了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-IO%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%88select-poll-epoll%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-Epoll%E7%9A%84ET%E6%A8%A1%E5%BC%8F%E5%92%8CLT%E6%A8%A1%E5%BC%8F%EF%BC%88ET%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-number">4.0.0.5.</span> <span class="toc-text">（5） Epoll的ET模式和LT模式（ET的非阻塞）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E6%9F%A5%E8%AF%A2%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8CPU%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%88%E6%B3%A8%E6%84%8F%E8%A6%81%E4%BA%86%E8%A7%A3%E5%88%B0used%EF%BC%8Cbuf%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%84%8F%E4%B9%89%EF%BC%89"><span class="toc-number">4.0.0.6.</span> <span class="toc-text">（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-linux%E7%9A%84%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%EF%BC%88kill%EF%BC%8Cfind%EF%BC%8Ccp%E7%AD%89%E7%AD%89%EF%BC%89"><span class="toc-number">4.0.0.7.</span> <span class="toc-text">（7） linux的其他常见命令（kill，find，cp等等）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-shell%E8%84%9A%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.0.0.8.</span> <span class="toc-text">（8） shell脚本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E7%A1%AC%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.0.9.</span> <span class="toc-text">（9） 硬连接和软连接的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%88rwx%EF%BC%89"><span class="toc-number">4.0.0.10.</span> <span class="toc-text">（10） 文件权限怎么看（rwx）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4%EF%BC%88mtime-atime%EF%BC%8Cctime%EF%BC%89%EF%BC%8C%E5%88%86%E5%88%AB%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%94%B9%E5%8F%98"><span class="toc-number">4.0.0.11.</span> <span class="toc-text">（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-Linux%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8D%A0%E7%94%A8%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E6%83%85%E5%86%B5%E5%91%BD%E4%BB%A4"><span class="toc-number">4.0.0.12.</span> <span class="toc-text">（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89Linux%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.0.0.13.</span> <span class="toc-text">（13）Linux中线程的同步方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">4.0.0.14.</span> <span class="toc-text">（14）怎么修改一个文件的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.0.0.15.</span> <span class="toc-text">（15）查看文件内容常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89%E6%80%8E%E4%B9%88%E6%89%BE%E5%87%BA%E5%90%AB%E6%9C%89%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%89%8D%E5%90%8E4%E8%A1%8C"><span class="toc-number">4.0.0.16.</span> <span class="toc-text">（16）怎么找出含有关键字的前后4行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89Linux%E7%9A%84GDB%E8%B0%83%E8%AF%95"><span class="toc-number">4.0.0.17.</span> <span class="toc-text">（17）Linux的GDB调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89coredump%E6%98%AF%E4%BB%80%E4%B9%88-%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BDcoredump"><span class="toc-number">4.0.0.18.</span> <span class="toc-text">（18）coredump是什么 怎么才能coredump</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89tcpdump%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.0.0.19.</span> <span class="toc-text">（19）tcpdump常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-crontab%E5%91%BD%E4%BB%A4"><span class="toc-number">4.0.0.20.</span> <span class="toc-text">（20） crontab命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89-%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.0.21.</span> <span class="toc-text">（21） 查看后台进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.0.0.21.1.</span> <span class="toc-text">1、软链接和硬链接的区别？</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">五、操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">1、进程与线程的区别和联系（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Linux%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">2、Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F%EF%BC%88%E7%99%BE%E5%BA%A6%E5%AE%89%E5%85%A8%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">5.0.0.3.</span> <span class="toc-text">3、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D-%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.0.0.4.</span> <span class="toc-text">4、进程之间的通信方法有哪几种 （重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.0.0.5.</span> <span class="toc-text">5、进程调度方法详细介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">5.0.0.6.</span> <span class="toc-text">6、进程的执行过程是什么样的，执行一个进程需要做哪些工作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">5.0.0.7.</span> <span class="toc-text">7、操作系统的内存管理说一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU%E7%AE%97%E6%B3%95"><span class="toc-number">5.0.0.8.</span> <span class="toc-text">8、 实现一个LRU算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%88%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">5.0.0.9.</span> <span class="toc-text">9、死锁产生的必要条件（怎么检测死锁，解决死锁问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="toc-number">5.0.0.10.</span> <span class="toc-text">10、死锁的恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%A5%A5%E9%A5%BF"><span class="toc-number">5.0.0.11.</span> <span class="toc-text">11、什么是饥饿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAmutex%E4%BA%92%E6%96%A5%E9%94%81%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">5.0.0.12.</span> <span class="toc-text">12、 如果要你实现一个mutex互斥锁你要怎么实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%88%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.0.0.13.</span> <span class="toc-text">13、线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.0.0.14.</span> <span class="toc-text">14、什么时候用多进程，什么时候用多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%BD%A2%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">5.0.0.15.</span> <span class="toc-text">15、孤儿进程和僵尸进程分别是什么，怎么形成的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BPCB-%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">5.0.0.16.</span> <span class="toc-text">16、说一下PCB&#x2F;说一下进程地址空间&#x2F;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E5%8C%BA%E5%88%86%E7%9A%84"><span class="toc-number">5.0.0.17.</span> <span class="toc-text">17、内核空间和用户空间是怎样区分的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%88%E5%B0%A4%E5%85%B6%E6%98%AF%E5%A6%82%E6%9E%9C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%BE%88%E5%A4%A7%E5%8F%AF%E8%83%BD%E4%BC%9A%E7%BB%93%E5%90%88%E8%AE%A8%E8%AE%BA%EF%BC%89"><span class="toc-number">5.0.0.18.</span> <span class="toc-text">18、多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%9A%E5%85%B1%E4%BA%AB%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">5.0.0.19.</span> <span class="toc-text">19、同一个进程内的线程会共享什么资源？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.0.0.20.</span> <span class="toc-text">20、异常和中断的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.0.0.21.</span> <span class="toc-text">21、一般情况下在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">5.0.0.22.</span> <span class="toc-text">22、虚拟内存的了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.0.0.23.</span> <span class="toc-text">（23）服务器高并发的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E5%8D%8F%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">5.0.0.24.</span> <span class="toc-text">（24）协程了解吗（高频）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E9%82%A3%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.0.0.25.</span> <span class="toc-text">（25）那协程的底层是怎么实现的，怎么使用协程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">5.0.0.26.</span> <span class="toc-text">（23）进程的状态以及转换图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%B4%E4%B8%80%E4%B8%8B-malloc%E5%87%BD%E6%95%B0%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F-%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="toc-number">5.0.0.27.</span> <span class="toc-text">（24）在执行malloc申请内存的时候，操作系统是怎么做的？&#x2F;内存分配的原理说一下&#x2F;malloc函数底层是怎么实现的？&#x2F;进程是怎么分配内存的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E6%98%AF%E5%A4%A7%E7%AB%AF%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.0.0.28.</span> <span class="toc-text">（25）什么是字节序？怎么判断是大端还是小端？有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">5.0.0.28.1.</span> <span class="toc-text">1、进程和线程以及它们的区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.0.0.28.2.</span> <span class="toc-text">2、线程同步的方式有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.0.0.28.3.</span> <span class="toc-text">3、进程的通信方式有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F%E5%85%B6%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.0.28.4.</span> <span class="toc-text">4、什么是缓冲区溢出？有什么危害？其原因是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">5.0.0.28.5.</span> <span class="toc-text">5、什么是死锁？死锁产生的条件？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">5.0.0.28.6.</span> <span class="toc-text">6、进程有哪几种状态？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.0.0.28.7.</span> <span class="toc-text">7、分页和分段有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">5.0.0.28.8.</span> <span class="toc-text">8、操作系统中进程调度策略有哪几种？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.0.28.9.</span> <span class="toc-text">9、进程同步有哪几种机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.0.28.10.</span> <span class="toc-text">10、死锁的处理基本策略和常用方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%9C%BA%E6%99%AF%E9%A2%98-%E7%AE%97%E6%B3%95%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">六、场景题&#x2F;算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%880%EF%BC%89-leetcode-hot100%E8%87%B3%E5%B0%91%E5%88%B7%E4%B8%A4%E9%81%8D%EF%BC%8C%E5%89%91%E6%8C%87offer%E8%87%B3%E5%B0%91%E5%88%B7%E4%B8%A4%E9%81%8D-%E9%87%8D%E4%B8%AD%E4%B9%8B%E9%87%8D%EF%BC%81%EF%BC%81"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E4%BB%8B%E7%BB%8D%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%95%E4%BE%8B%EF%BC%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">（1） 介绍熟悉的设计模式（单例，简单工厂模式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E5%86%99%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%88%E6%9C%AC"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">（2） 写单例模式，线程安全版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89-%E5%86%99%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ABC"><span class="toc-number">6.0.0.4.</span> <span class="toc-text">（3） 写三个线程交替打印ABC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B-%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">6.0.0.5.</span> <span class="toc-text">（4） 二维码登录的实现过程 场景题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0swap%E5%87%BD%E6%95%B0"><span class="toc-number">6.0.0.6.</span> <span class="toc-text">（5） 不使用临时变量实现swap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstrcpy%E5%87%BD%E6%95%B0%EF%BC%88%E6%88%96%E8%80%85memcpy%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%85%E5%AD%98%E5%8F%AF%E8%83%BD%E9%87%8D%E5%8F%A0%E5%91%A2"><span class="toc-number">6.0.0.7.</span> <span class="toc-text">（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89-%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8E%92"><span class="toc-number">6.0.0.8.</span> <span class="toc-text">（7） 实现快排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">6.0.0.9.</span> <span class="toc-text">（8） 实现一个堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.0.0.10.</span> <span class="toc-text">（8） 实现一个插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E5%BF%AB%E6%8E%92%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">6.0.0.11.</span> <span class="toc-text">（9） 快排存在的问题，如何优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89-%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%EF%BC%88%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2%EF%BC%89"><span class="toc-number">6.0.0.12.</span> <span class="toc-text">（10） 反转一个链表（招银网络二面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89-Top-K%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AF%E4%BB%A5%E9%87%87%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E7%82%B9%EF%BC%9F%EF%BC%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">6.0.0.13.</span> <span class="toc-text">（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8812%EF%BC%89-8G%E7%9A%84int%E5%9E%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AA%E6%9C%892G%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AF%B9%E5%AE%83%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%9F%EF%BC%88%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%EF%BC%89%EF%BC%88%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">6.0.0.14.</span> <span class="toc-text">（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8813%EF%BC%89-%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%B8%A6%E6%9C%89null%E6%A0%87%E8%AE%B0%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">6.0.0.15.</span> <span class="toc-text">（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8814%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bb%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.0.0.16.</span> <span class="toc-text">（14） 介绍一下b树和它的应用场景有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8815%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bb-%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.0.0.17.</span> <span class="toc-text">（15） 介绍一下b+树和它的应用场景有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8816%EF%BC%89-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E5%AE%83%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.0.0.18.</span> <span class="toc-text">（16） 介绍一下红黑树和它的应用场景有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8817%EF%BC%89-%E6%80%8E%E4%B9%88%E5%86%99sql%E5%8F%96%E8%A1%A8%E7%9A%84%E5%89%8D1000%E8%A1%8C%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E4%BA%8C%E9%9D%A2%EF%BC%89"><span class="toc-number">6.0.0.19.</span> <span class="toc-text">（17） 怎么写sql取表的前1000行数据（招银网络二面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8818%EF%BC%89-N%E4%B8%AA%E9%AA%B0%E5%AD%90%E5%87%BA%E7%8E%B0%E5%92%8C%E4%B8%BAm%E7%9A%84%E6%A6%82%E7%8E%87"><span class="toc-number">6.0.0.20.</span> <span class="toc-text">（18） N个骰子出现和为m的概率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8819%EF%BC%89-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98%EF%BC%88%E5%8F%AF%E5%8F%82%E8%80%83%E5%B7%A6%E7%A5%9E%E7%9A%84%E4%B9%A6%EF%BC%89"><span class="toc-number">6.0.0.21.</span> <span class="toc-text">（19） 海量数据问题（可参考左神的书）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8820%EF%BC%89-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">6.0.0.22.</span> <span class="toc-text">（20） 一致性哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8821%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%AF%B4%E4%B8%80%E4%B8%8B-%E6%89%8B%E6%92%95"><span class="toc-number">6.0.0.23.</span> <span class="toc-text">（21）希尔排序说一下&#x2F;手撕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8822%EF%BC%89Dijkstra%E7%AE%97%E6%B3%95%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">6.0.0.24.</span> <span class="toc-text">（22）Dijkstra算法说一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8823%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%AF%B4%E6%80%9D%E8%B7%AF%EF%BC%88%E8%85%BE%E8%AE%AFteg%E4%B8%80%E9%9D%A2%EF%BC%89"><span class="toc-number">6.0.0.25.</span> <span class="toc-text">（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8824%EF%BC%89%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">6.0.0.26.</span> <span class="toc-text">（24）最小生成树算法说一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8825%EF%BC%89-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E7%9A%84bitmap%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">6.0.0.27.</span> <span class="toc-text">（25） 海量数据的bitmap使用原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8826%EF%BC%89-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E7%82%B9"><span class="toc-number">6.0.0.28.</span> <span class="toc-text">（26） 布隆过滤器原理与优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8827%EF%BC%89-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%A4%84%E7%90%86%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%8F%97%E9%99%90%E3%80%81%E7%A3%81%E7%9B%98%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">6.0.0.29.</span> <span class="toc-text">（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8828%EF%BC%89%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E5%AE%83%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E9%98%BF%E9%87%8C%E4%B8%89%E9%9D%A2%EF%BC%89"><span class="toc-number">6.0.0.30.</span> <span class="toc-text">（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%99%BA%E5%8A%9B%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">七、智力题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-100%E5%B1%82%E6%A5%BC%EF%BC%8C%E5%8F%AA%E6%9C%892%E4%B8%AA%E9%B8%A1%E8%9B%8B%EF%BC%8C%E6%83%B3%E8%A6%81%E5%88%A4%E6%96%AD%E5%87%BA%E9%82%A3%E4%B8%80%E5%B1%82%E5%88%9A%E5%A5%BD%E8%AE%A9%E9%B8%A1%E8%9B%8B%E7%A2%8E%E6%8E%89%EF%BC%8C%E7%BB%99%E5%87%BA%E7%AD%96%E7%95%A5%EF%BC%88%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95%E4%B8%AD%E4%B8%A4%E4%B8%AA%E9%93%81%E7%90%83%E8%B7%9F%E8%BF%99%E4%B8%AA%E6%98%AF%E4%B8%80%E7%B1%BB%E9%A2%98%EF%BC%89"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-%E6%AF%92%E8%8D%AF%E9%97%AE%E9%A2%98%EF%BC%8C1000%E7%93%B6%E6%B0%B4%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E7%93%B6%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E7%A8%80%E9%87%8A%E7%9A%84%E6%AF%92%E8%8D%AF%EF%BC%8C%E8%A6%81%E5%BF%AB%E9%80%9F%E6%89%BE%E5%87%BA%E5%93%AA%E4%B8%80%E7%93%B6%E6%9C%89%E6%AF%92%EF%BC%8C%E9%9C%80%E8%A6%81%E5%87%A0%E5%8F%AA%E5%B0%8F%E7%99%BD%E9%BC%A0"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">（3）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E5%85%88%E6%89%8B%E5%BF%85%E8%83%9C%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98%EF%BC%9A100%E6%9C%AC%E4%B9%A6%EF%BC%8C%E6%AF%8F%E6%AC%A1%E8%83%BD%E5%A4%9F%E6%8B%BF1-5%E6%9C%AC%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8B%BF%E8%83%BD%E4%BF%9D%E8%AF%81%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%98%AF%E4%BD%A0%E6%8B%BF"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89-%E6%94%BEn%E5%8F%AA%E8%9A%82%E8%9A%81%E5%9C%A8%E4%B8%80%E6%9D%A1%E6%A0%91%E6%9E%9D%E4%B8%8A%EF%BC%8C%E8%9A%82%E8%9A%81%E4%B8%8E%E8%9A%82%E8%9A%81%E4%B9%8B%E9%97%B4%E7%A2%B0%E5%88%B0%E5%B0%B1%E5%90%84%E8%87%AA%E5%BE%80%E5%8F%8D%E6%96%B9%E5%90%91%E8%B5%B0%EF%BC%8C%E9%97%AE%E6%80%BB%E8%B7%9D%E7%A6%BB%E6%88%96%E8%80%85%E6%97%B6%E9%97%B4%E3%80%82"><span class="toc-number">7.0.0.5.</span> <span class="toc-text">（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89-%E7%93%B6%E5%AD%90%E6%8D%A2%E9%A5%AE%E6%96%99%E9%97%AE%E9%A2%98%EF%BC%9A1000%E7%93%B6%E9%A5%AE%E6%96%99%EF%BC%8C3%E4%B8%AA%E7%A9%BA%E7%93%B6%E5%AD%90%E8%83%BD%E5%A4%9F%E6%8D%A21%E7%93%B6%E9%A5%AE%E6%96%99%EF%BC%8C%E9%97%AE%E6%9C%80%E5%A4%9A%E8%83%BD%E5%96%9D%E5%87%A0%E7%93%B6"><span class="toc-number">7.0.0.6.</span> <span class="toc-text">（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%9C%A824%E5%B0%8F%E6%97%B6%E9%87%8C%E9%9D%A2%E6%97%B6%E9%92%88%E5%88%86%E9%92%88%E7%A7%92%E9%92%88%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%88%E5%87%A0%E6%AC%A1"><span class="toc-number">7.0.0.7.</span> <span class="toc-text">（7）在24小时里面时针分针秒针可以重合几次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%888%EF%BC%89-%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%B9%B3%EF%BC%8C%E4%B9%9D%E4%B8%AA%E7%A0%9D%E7%A0%81%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%BD%BB%E4%B8%80%E4%BA%9B%EF%BC%8C%E7%94%A8%E5%A4%A9%E5%B9%B3%E8%87%B3%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E6%89%BE%E5%88%B0%E8%BD%BB%E7%9A%84%EF%BC%9F"><span class="toc-number">7.0.0.8.</span> <span class="toc-text">（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%889%EF%BC%89-%E6%9C%89%E5%8D%81%E7%BB%84%E7%A0%9D%E7%A0%81%E6%AF%8F%E7%BB%84%E5%8D%81%E4%B8%AA%EF%BC%8C%E6%AF%8F%E4%B8%AA%E7%A0%9D%E7%A0%81%E9%87%8D10g%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E7%BB%84%E6%AF%8F%E4%B8%AA%E5%8F%AA%E6%9C%899g%EF%BC%8C%E6%9C%89%E8%83%BD%E6%98%BE%E7%A4%BA%E5%85%8B%E6%95%B0%E7%9A%84%E7%A7%A4%E6%9C%80%E5%B0%91%E5%87%A0%E6%AC%A1%E8%83%BD%E6%89%BE%E5%88%B0%E8%BD%BB%E7%9A%84%E9%82%A3%E4%B8%80%E7%BB%84%E7%A0%9D%E7%A0%81%EF%BC%9F"><span class="toc-number">7.0.0.9.</span> <span class="toc-text">（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%9A%E7%BB%99%E5%AE%9A%E7%94%9F%E6%88%901%E5%88%B05%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0Rand5-%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E7%94%9F%E6%88%901%E5%88%B07%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0Rand7-%EF%BC%9F"><span class="toc-number">7.0.0.10.</span> <span class="toc-text">（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%9B%E9%A9%AC%EF%BC%9A%E6%9C%8925%E5%8C%B9%E9%A9%AC%EF%BC%8C%E6%AF%8F%E5%9C%BA%E6%AF%94%E8%B5%9B%E5%8F%AA%E8%83%BD%E8%B5%9B5%E5%8C%B9%EF%BC%8C%E8%87%B3%E5%B0%91%E8%A6%81%E8%B5%9B%E5%A4%9A%E5%B0%91%E5%9C%BA%E6%89%8D%E8%83%BD%E6%89%BE%E5%88%B0%E6%9C%80%E5%BF%AB%E7%9A%843%E5%8C%B9%E9%A9%AC%EF%BC%9F"><span class="toc-number">7.0.0.11.</span> <span class="toc-text">赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%A7-%E9%A6%99-%E7%BB%B3%E5%AD%90-%E5%85%B6%E4%BB%96-%E7%A1%AE%E5%AE%9A%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%9A%E6%9C%89%E4%B8%A4%E6%A0%B9%E4%B8%8D%E5%9D%87%E5%8C%80%E7%9A%84%E9%A6%99%EF%BC%8C%E7%87%83%E7%83%A7%E5%AE%8C%E9%83%BD%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E9%97%AE%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A15%E5%88%86%E9%92%9F%E7%9A%84%E6%97%B6%E9%95%BF%EF%BC%9F"><span class="toc-number">7.0.0.12.</span> <span class="toc-text">烧 香&#x2F;绳子&#x2F;其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%B0%E5%B7%A7%E5%85%8B%E5%8A%9B%E9%97%AE%E9%A2%98-NM%E5%9D%97%E5%B7%A7%E5%85%8B%E5%8A%9B%EF%BC%8C%E6%AF%8F%E6%AC%A1%E6%8E%B0%E4%B8%80%E5%9D%97%E7%9A%84%E4%B8%80%E8%A1%8C%E6%88%96%E4%B8%80%E5%88%97%EF%BC%8C%E6%8E%B0%E6%88%9011%E7%9A%84%E5%B7%A7%E5%85%8B%E5%8A%9B%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%AC%A1%EF%BC%9F%EF%BC%881000%E4%B8%AA%E4%BA%BA%E5%8F%82%E5%8A%A0%E8%BE%A9%E8%AE%BA%E8%B5%9B%EF%BC%8C1V1%EF%BC%8C%E8%BE%93%E4%BA%86%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AE%89%E6%8E%92%E5%A4%9A%E5%B0%91%E5%9C%BA%E6%AF%94%E8%B5%9B%EF%BC%89"><span class="toc-number">7.0.0.13.</span> <span class="toc-text">掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81-%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">8.</span> <span class="toc-text">八、 大数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BHadoop"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">1. 介绍一下Hadoop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%B4%E4%B8%80%E4%B8%8BMapReduce%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">8.0.0.2.</span> <span class="toc-text">2. 说一下MapReduce的运行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bkafka"><span class="toc-number">8.0.0.3.</span> <span class="toc-text">3. 介绍一下kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88kafka%E5%90%9E%E5%90%90%E9%87%8F%E9%AB%98%EF%BC%9F-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.0.0.4.</span> <span class="toc-text">4. 为什么kafka吞吐量高？&#x2F;介绍一下零拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bspark"><span class="toc-number">8.0.0.5.</span> <span class="toc-text">5. 介绍一下spark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bspark-streaming"><span class="toc-number">8.0.0.6.</span> <span class="toc-text">6. 介绍一下spark-streaming</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-spark%E7%9A%84transformation%E5%92%8Caction%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.0.0.7.</span> <span class="toc-text">7. spark的transformation和action有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-spark%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E5%AD%90%E8%AF%B4%E5%87%A0%E4%B8%AA"><span class="toc-number">8.0.0.8.</span> <span class="toc-text">8. spark常用的算子说几个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81kafka%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">8.0.0.9.</span> <span class="toc-text">9. 如何保证kafka的消息不丢失</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-kafka%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BEleader"><span class="toc-number">8.0.0.10.</span> <span class="toc-text">10. kafka如何选举leader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%AF%B4%E4%B8%8Bspark%E4%B8%AD%E7%9A%84%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96"><span class="toc-number">8.0.0.11.</span> <span class="toc-text">11. 说下spark中的宽依赖和窄依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E8%AF%B4%E4%B8%8Bspark%E4%B8%ADstage%E6%98%AF%E4%BE%9D%E7%85%A7%E4%BB%80%E4%B9%88%E5%88%92%E5%88%86%E7%9A%84"><span class="toc-number">8.0.0.12.</span> <span class="toc-text">12. 说下spark中stage是依照什么划分的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-spark%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">8.0.0.13.</span> <span class="toc-text">13. spark的内存管理是怎样的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-spark%E7%9A%84%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">8.0.0.14.</span> <span class="toc-text">14. spark的容错机制是什么样的</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81HR%E9%9D%A2"><span class="toc-number">9.</span> <span class="toc-text">九、HR面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">1. 自我介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9A%BE%E7%82%B9"><span class="toc-number">9.0.0.2.</span> <span class="toc-text">2. 项目中遇到的最大难点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%94%B6%E8%8E%B7"><span class="toc-number">9.0.0.3.</span> <span class="toc-text">3. 项目中的收获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%B9%A0%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E5%AE%9E%E4%B9%A0%E6%97%B6%E9%95%BF"><span class="toc-number">9.0.0.4.</span> <span class="toc-text">4. 可以实习的时间，实习时长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%93%AA%E9%87%8C%E4%BA%BA"><span class="toc-number">9.0.0.5.</span> <span class="toc-text">5. 哪里人</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%A7%E6%A0%BC"><span class="toc-number">9.0.0.6.</span> <span class="toc-text">6. 说一下自己的性格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BD%A0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.0.0.7.</span> <span class="toc-text">7. 你的优缺点是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD%EF%BC%8C%E7%94%BB%E7%9A%84%E6%80%8E%E4%B9%88%E6%A0%B7-%E7%90%83%E6%89%93%E7%9A%84%E5%A6%82%E4%BD%95-%E6%B8%B8%E6%88%8F%E6%89%93%E7%9A%84%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">9.0.0.8.</span> <span class="toc-text">8. 有什么兴趣爱好，画的怎么样&#x2F;球打的如何&#x2F;游戏打的怎么样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%9C%8B%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84%E4%B8%80%E6%9C%AC%E4%B9%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.0.0.9.</span> <span class="toc-text">9. 看过最好的一本书是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E9%9A%BE%E7%82%B9"><span class="toc-number">9.0.0.10.</span> <span class="toc-text">10. 学习技术中有什么难点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%8A%A0%E7%8F%AD"><span class="toc-number">9.0.0.11.</span> <span class="toc-text">11. 怎么看待加班</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E8%A7%89%E5%BE%97%E6%B7%B1%E5%9C%B3%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%88%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E5%9C%B0%E7%82%B9%EF%BC%89"><span class="toc-number">9.0.0.12.</span> <span class="toc-text">12. 觉得深圳怎么样（或者其他地点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%81%87%E8%A7%81%E8%BF%87%E6%9C%80%E5%A4%A7%E7%9A%84%E6%8C%AB%E6%8A%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">9.0.0.13.</span> <span class="toc-text">13. 遇见过最大的挫折是什么，怎么解决的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="toc-number">9.0.0.14.</span> <span class="toc-text">14. 职业规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E7%9B%AE%E5%89%8D%E7%9A%84offer%E6%83%85%E5%86%B5"><span class="toc-number">9.0.0.15.</span> <span class="toc-text">15. 目前的offer情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E4%BD%A0%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.0.0.16.</span> <span class="toc-text">16. 你最大的优势和劣势是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E4%BB%8B%E7%BB%8D%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E5%85%85%E5%BD%93%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">9.0.0.17.</span> <span class="toc-text">17. 介绍在项目里面充当的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%9C%AC%E7%A7%91%E8%8E%B7%E5%BE%97%E7%9A%84%E5%85%A8%E5%9B%BD%E8%B5%9B%E5%A5%96%E9%A1%B9%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">9.0.0.18.</span> <span class="toc-text">18. 介绍一下本科获得的全国赛奖项的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E6%9C%80%E6%9C%89%E6%88%90%E5%B0%B1%E6%84%9F%E7%9A%84%E4%BA%8B%E6%83%85-%E6%9C%80%E9%AA%84%E5%82%B2%E7%9A%84%E4%B8%80%E4%BB%B6%E4%BA%8B%E6%83%85"><span class="toc-number">9.0.0.19.</span> <span class="toc-text">19. 最有成就感的事情&#x2F;最骄傲的一件事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E5%9C%A8%E5%AE%9E%E9%AA%8C%E5%AE%A4%E4%B8%AD%E6%8B%85%E4%BB%BB%E4%BB%80%E4%B9%88%E8%A7%92%E8%89%B2%EF%BC%8C%E5%8F%82%E5%8A%A0%E7%9A%84XXX%E8%83%BD%E8%81%8A%E8%81%8A%E5%90%97"><span class="toc-number">9.0.0.20.</span> <span class="toc-text">20. 在实验室中担任什么角色，参加的XXX能聊聊吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E7%94%A8%E4%B8%A4%E4%B8%AA%E8%AF%8D%E6%9D%A5%E5%BD%A2%E5%AE%B9%E8%87%AA%E5%B7%B1"><span class="toc-number">9.0.0.21.</span> <span class="toc-text">22. 用两个词来形容自己</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%85%B6%E4%BB%96%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">十、其他面经整理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%E5%90%97%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%EF%BC%9F%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9F"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">1、c++ 构造函数可以是私有的吗？析构函数呢？拷贝构造？赋值操作符？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%98%AFconst%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">2、静态成员函数是什么？可以是const的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8BA-B-C%E5%BE%AA%E7%8E%AF%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B010%E6%AC%A1"><span class="toc-number">10.0.0.3.</span> <span class="toc-text">3、线程A, B, C循环顺序打印10次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81"><span class="toc-number">10.0.0.4.</span> <span class="toc-text">4、实现一个死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81shared-ptr-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">10.0.0.5.</span> <span class="toc-text">5、shared_ptr 底层实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81shared-ptr-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.6.</span> <span class="toc-text">6、shared_ptr 是线程安全的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81shared-ptr-%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%90%97%EF%BC%9Funique-ptr%EF%BC%9F"><span class="toc-number">10.0.0.7.</span> <span class="toc-text">7、shared_ptr 可以指向数组吗？unique_ptr？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.0.0.8.</span> <span class="toc-text">8、实现单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81c-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">10.0.0.9.</span> <span class="toc-text">9、c++默认的是深拷贝还是浅拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.0.0.10.</span> <span class="toc-text">10、信号量和互斥锁之间的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81C10K-%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.0.11.</span> <span class="toc-text">11、C10K 并发连接问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81c-%E7%9A%84move%E5%87%BD%E6%95%B0%EF%BC%9F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">10.0.0.12.</span> <span class="toc-text">12、c++的move函数？左值引用和右值引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81TCP-socket%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="toc-number">10.0.0.13.</span> <span class="toc-text">13、TCP socket中的心跳机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E5%AD%90%E7%B1%BB%E6%9C%89%E5%87%A0%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%9F"><span class="toc-number">10.0.0.14.</span> <span class="toc-text">14、子类有几个虚函数表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.0.15.</span> <span class="toc-text">15、路由器和交换机的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81Epoll-%E7%9A%84-ET-LT-%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.0.16.</span> <span class="toc-text">16、Epoll 的 ET&#x2F;LT 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81C-%E7%A9%BA%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">10.0.0.17.</span> <span class="toc-text">17、C++ 空类中有哪些默认的函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9A%E4%B9%89%E6%88%90-private-%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.18.</span> <span class="toc-text">18、虚函数能定义成 private 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.0.0.19.</span> <span class="toc-text">19、函数模板和类模板的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81-udp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">10.0.0.20.</span> <span class="toc-text">20、 udp 如何实现可靠传输？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81GET-%E5%92%8C-POST-%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%A4%E8%80%85%E7%9A%84%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">10.0.0.21.</span> <span class="toc-text">21、GET 和 POST 区别？两者的传输效率？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81http-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9FUDP%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.22.</span> <span class="toc-text">22、http 协议如何解决粘包问题？UDP会出现粘包问题吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Flambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8D%95%E8%8E%B7%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">10.0.0.23.</span> <span class="toc-text">23、lambda 表达式和函数指针的区别？lambda表达式的对象捕获方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E5%AE%9E%E7%8E%B0-memcpy-%E5%87%BD%E6%95%B0"><span class="toc-number">10.0.0.24.</span> <span class="toc-text">24、实现 memcpy 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81GET-%E8%AF%B7%E6%B1%82%E8%83%BD%E5%8C%85%E5%90%AB-body-%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.25.</span> <span class="toc-text">25、GET 请求能包含 body 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81TCP-IP-%E5%8D%8F%E8%AE%AE%E4%B8%AD-TTL"><span class="toc-number">10.0.0.26.</span> <span class="toc-text">26、TCP&#x2F;IP 协议中 TTL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81%E5%88%A0%E9%99%A4vector%E4%B8%AD%E7%9A%84%E5%81%B6%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%8C%E5%88%A0%E9%99%A4list%E4%B8%AD%E7%9A%84%E5%A5%87%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">10.0.0.27.</span> <span class="toc-text">27、删除vector中的偶数元素，删除list中的奇数元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81auto%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%EF%BC%8C%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8E%A8%E5%AF%BC%E7%9A%84%EF%BC%9F"><span class="toc-number">10.0.0.28.</span> <span class="toc-text">28、auto关键字使用，类型是什么时候推导的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">10.0.0.29.</span> <span class="toc-text">29、内核是如何管理进程的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81vector-%E6%98%AF%E5%90%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">10.0.0.30.</span> <span class="toc-text">30、vector 是否是线程安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E7%A9%BA%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%8B%B7%E8%B4%9D%E4%BC%9A%E6%8A%A5%E9%94%99%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.31.</span> <span class="toc-text">31、空类创建对象并进行拷贝会报错吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%EF%BC%9F%E6%A3%80%E6%B5%8B%EF%BC%9F%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">10.0.0.32.</span> <span class="toc-text">32、死锁如何调试？检测？死锁检测工具的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Git-%E5%81%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%EF%BC%9F"><span class="toc-number">10.0.0.33.</span> <span class="toc-text">33、实际项目中如何使用 Git 做分支管理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81%E6%97%A2%E7%84%B6%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86%E8%BF%9B%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="toc-number">10.0.0.34.</span> <span class="toc-text">34、既然已经有了进程，为什么要有线程？协程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81%E5%A6%82%E6%9E%9C%E7%94%B5%E8%84%91%E6%98%AF2G%E7%9A%84%EF%BC%8C%E8%83%BD%E5%86%99%E5%87%BA4G%E7%9A%84%E6%95%B0%E7%BB%84%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.35.</span> <span class="toc-text">35、如果电脑是2G的，能写出4G的数组吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E5%BC%82%E5%9C%B0%E7%9A%84%E4%B8%A4%E4%B8%AAip%EF%BC%8C%E6%80%8E%E6%A0%B7%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AAip%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAip%E4%B9%8B%E9%97%B4%E7%BB%8F%E8%BF%87%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">10.0.0.36.</span> <span class="toc-text">36、异地的两个ip，怎样查看一个ip到另一个ip之间经过的路由信息？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81%E6%A8%A1%E6%9D%BF%E5%A6%82%E4%BD%95%E6%8E%A8%E5%AF%BC%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">10.0.0.37.</span> <span class="toc-text">37、模板如何推导返回值类型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8E-CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%92%8CI-O%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E4%B8%8ECPU%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">10.0.0.38.</span> <span class="toc-text">38、线程池线程数与(CPU密集型任务和I&#x2F;O密集型任务)的关系？与CPU的核心数的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39%E3%80%81TCP%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%90%8E%EF%BC%8C%E5%87%BA%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83%E3%80%81%E6%96%AD%E7%94%B5%E3%80%81%E7%BD%91%E7%BA%BF%E8%A2%AB%E6%8B%94%EF%BC%88%E5%8D%B3%E6%B2%A1%E6%9C%89%E6%9C%BA%E4%BC%9A%E5%8F%91%E5%87%BA%E6%96%AD%E5%BC%80%E7%9A%84-FIN-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%EF%BC%89%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5"><span class="toc-number">10.0.0.39.</span> <span class="toc-text">39、TCP连接建立后，出现服务器崩溃、断电、网线被拔（即没有机会发出断开的 FIN 数据报文）会发生什么情况?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40%E3%80%81QQ%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E4%BF%A1%E5%8F%AA%E8%83%BD%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%EF%BC%9F"><span class="toc-number">10.0.0.40.</span> <span class="toc-text">40、QQ可以打开多个，为什么微信只能打开一个？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E3%80%81Linux-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%9F"><span class="toc-number">10.0.0.41.</span> <span class="toc-text">41、Linux 如何查看文件描述符？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E3%80%81http1-0%E3%80%81http1-1%E3%80%81http2-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.0.0.42.</span> <span class="toc-text">42、http1.0、http1.1、http2 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E3%80%81%E4%B8%8D%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E3%80%81%E5%86%85%E5%AD%98%E7%AD%89%E5%9B%A0%E7%B4%A0%EF%BC%8C%E7%90%86%E6%83%B3%E6%9D%A1%E4%BB%B6%E4%B8%8B%EF%BC%8C%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B10%E4%B8%87%E4%B8%AA%E8%BF%9E%E6%8E%A5%E5%98%9B%EF%BC%9F"><span class="toc-number">10.0.0.43.</span> <span class="toc-text">43、不考虑性能、内存等因素，理想条件下，一台主机最多可以建立10万个连接嘛？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44%E3%80%81%E5%8D%95%E6%A0%B8-CPU-%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">10.0.0.44.</span> <span class="toc-text">44、单核 CPU 运行多个线程可能出现的情况？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45%E3%80%81http-%E5%A6%82%E4%BD%95%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">10.0.0.45.</span> <span class="toc-text">45、http 如何传输大文件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46%E3%80%81fork%E4%B9%8B%E5%90%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BC%9A%E7%BB%A7%E6%89%BF%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%94%81%E5%90%97%EF%BC%9F%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%EF%BC%9F"><span class="toc-number">10.0.0.46.</span> <span class="toc-text">46、fork之后子进程会继承父进程的锁吗？子进程会如何处理父进程的未决信号？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">10.0.0.47.</span> <span class="toc-text">47、数据库索引越多越好吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48%E3%80%81d%E4%B8%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%8C%E5%A6%82%E6%9E%9Ca-b-c%E4%B8%89%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%BC%9A%E5%A6%82%E4%BD%95%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%EF%BC%9F"><span class="toc-number">10.0.0.48.</span> <span class="toc-text">48、d为单例模式的动态链接库，如果a,b,c三个进程，同时访问，会如何，是否会产生多个对象？为什么？如何访问？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">10.0.0.49.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%AF%E4%BB%A5%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">10.0.0.50.</span> <span class="toc-text">49、设计一个应用层协议可以断点续传的文件传输协议，整体流程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50%E3%80%81%E4%BC%A0%E5%80%BC-%E4%BC%A0%E6%8C%87%E9%92%88-%E4%BC%A0%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">10.0.0.51.</span> <span class="toc-text">50、传值 &#x2F; 传指针 &#x2F; 传引用，指针和引用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.0.0.52.</span> <span class="toc-text">51、数组和指针的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E3%80%81weak-ptr-%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%BE%AA%E7%8E%AF%E6%8C%87%E5%90%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.0.0.53.</span> <span class="toc-text">52、weak_ptr 如何打破循环指向的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88-hashtable-%E4%B8%AD%E6%A1%B6%E7%9A%84%E6%95%B0%E7%9B%AE%E9%83%BD%E6%98%AF%E7%94%A8%E8%B4%A8%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="toc-number">10.0.0.54.</span> <span class="toc-text">53、为什么 hashtable 中桶的数目都是用质数表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54%E3%80%81C-%E4%B8%AD-union-%E5%92%8C-struct-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.0.0.55.</span> <span class="toc-text">54、C++ 中 union 和 struct 的区别</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>