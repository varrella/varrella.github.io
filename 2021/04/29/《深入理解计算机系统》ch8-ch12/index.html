<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《深入理解计算机系统》Ch8-Ch12阅读笔记 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、异常控制流1、异常的种类异常分为四类：中断、陷阱、故障和终止。 中断：异步发生，来自处理器外部的I&#x2F;O设备的信号的结束。当中断处理程序结束时，将控制返回给下一条指令。 陷阱和系统调用：陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。陷阱处理程序将控制返回给下一条指令。普通的函数调用运行在用户模式中，用户模式限制了函数可以访问的指令的类别，而且他们只能访问和调用函数">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解计算机系统》Ch8-Ch12阅读笔记">
<meta property="og:url" content="https://varrella.github.io/2021/04/29/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8Bch8-ch12/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="一、异常控制流1、异常的种类异常分为四类：中断、陷阱、故障和终止。 中断：异步发生，来自处理器外部的I&#x2F;O设备的信号的结束。当中断处理程序结束时，将控制返回给下一条指令。 陷阱和系统调用：陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。陷阱处理程序将控制返回给下一条指令。普通的函数调用运行在用户模式中，用户模式限制了函数可以访问的指令的类别，而且他们只能访问和调用函数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___8CRApSLbi1w___0___.jpg">
<meta property="article:published_time" content="2021-04-29T10:05:52.710Z">
<meta property="article:modified_time" content="2021-06-10T12:57:53.372Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___8CRApSLbi1w___0___.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/04/29/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8Bch8-ch12/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-10 20:57:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___8CRApSLbi1w___0___.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《深入理解计算机系统》Ch8-Ch12阅读笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-29T10:05:52.710Z" title="Created 2021-04-29 18:05:52">2021-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-10T12:57:53.372Z" title="Updated 2021-06-10 20:57:53">2021-06-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《深入理解计算机系统》Ch8-Ch12阅读笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="一、异常控制流"><a href="#一、异常控制流" class="headerlink" title="一、异常控制流"></a>一、异常控制流</h4><h5 id="1、异常的种类"><a href="#1、异常的种类" class="headerlink" title="1、异常的种类"></a>1、异常的种类</h5><p>异常分为四类：中断、陷阱、故障和终止。</p>
<p>中断：异步发生，来自处理器外部的I/O设备的信号的结束。当中断处理程序结束时，将控制返回给下一条指令。</p>
<p>陷阱和系统调用：陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。陷阱处理程序将控制返回给下一条指令。普通的函数调用运行在用户模式中，用户模式限制了函数可以访问的指令的类别，而且他们只能访问和调用函数相同的栈；系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。</p>
<p>故障：由错误情况引起，可能能够被故障处理程序修正。故障程序要么重新执行引起故障的指令，要么终止引起故障的应用程序。如除法错误、缺页、一般保护故障等。</p>
<p>终止：是不可恢复的致命错误造成的结果，通常是一些硬件错误，如DRAM或SRAM位被损坏时发生的奇偶错误。</p>
<h5 id="2、进程"><a href="#2、进程" class="headerlink" title="2、进程"></a>2、进程</h5><h6 id="（1）上下文"><a href="#（1）上下文" class="headerlink" title="（1）上下文"></a>（1）上下文</h6><p>系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成，包括存放在内核中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。进程是轮流使用处理器的，每个进程执行它流的一部分。然后被抢占（暂时挂起），然后轮到其他进程。</p>
<h6 id="（2）逻辑流和并发流"><a href="#（2）逻辑流和并发流" class="headerlink" title="（2）逻辑流和并发流"></a>（2）逻辑流和并发流</h6><p>逻辑流：异常程序处理、进程、信号处理程序、线程和java进程都是逻辑流的例子。</p>
<p>并发流：一个逻辑流的执行在时间上与另一个流重叠，称为并发流。</p>
<p>并行流：如果两个流并发地运行在不同的处理器核或者计算机上，称它们为并行流。</p>
<p>多个流并发执行的一般现象称为并发。一个进程和其他进程轮流运行的概念称为多任务。一个进程执行它的控制流的一部分的每一时间段叫做时间片，因此多任务也叫做时间分片。</p>
<h6 id="（3）用户模式和内核模式"><a href="#（3）用户模式和内核模式" class="headerlink" title="（3）用户模式和内核模式"></a>（3）用户模式和内核模式</h6><p>一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>
<p>用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据。用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<h6 id="（4）进程从用户模式转变为内核模式"><a href="#（4）进程从用户模式转变为内核模式" class="headerlink" title="（4）进程从用户模式转变为内核模式"></a>（4）进程从用户模式转变为内核模式</h6><p>唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式该回到用户模式。</p>
<h6 id="（5）上下文切换"><a href="#（5）上下文切换" class="headerlink" title="（5）上下文切换"></a>（5）上下文切换</h6><p>操作系统内核使用一种上下文奇幻的较高层形式的异常控制流来实现多任务。内核为每个进程维持一个上下文，上下文就是内核重新启动一个被强占的进程所需的状态。上下文切换：保存当前进程的上下文，恢复某个先前被抢占的进程被保存的上下文；将控制流传递给这个新恢复的进程。当进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策叫做调度。是由内核中称为调度器的代码处理的。</p>
<h6 id="（6）进程控制"><a href="#（6）进程控制" class="headerlink" title="（6）进程控制"></a>（6）进程控制</h6><p>父进程通过调用fork()函数创建一个新的运行的子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈，子进程还获得与父进程任何打开文件描述符相同的副本，意味着当父进程调用fork时，子进程能读写父进程中打开的任何文件。</p>
<p>fork函数只被调用一次，却返回两次：一次是在调用进程（父进程）中，返回子进程的PID；一次是在新创建的子进程中，返回0。父进程和子进程时并发运行的独立进程，都有自己的私有地址空间。</p>
<h6 id="（7）回收子进程"><a href="#（7）回收子进程" class="headerlink" title="（7）回收子进程"></a>（7）回收子进程</h6><p>当一个进程由于某种原因终止时，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃这个已终止的进程。一个终止了单还未被回收的进程称为僵死进程。如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。即使僵死进程没有运行，它们仍然消耗系统的内存资源。</p>
<p>子进程的回收顺序是这台特定的计算机系统的属性，程序不回按照特定的顺序回收子进程。</p>
<h6 id="（8）程序和进程"><a href="#（8）程序和进程" class="headerlink" title="（8）程序和进程"></a>（8）程序和进程</h6><p>程序是一堆代码和数据，程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中；进程是执行中程序的一个具体的实例。程序总是运行在某个进程的上下文中 。fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程，新的程序仍然有相同的PID。并且继承了调用execve函数时已打开的所有文件描述符。</p>
<h5 id="3、信号"><a href="#3、信号" class="headerlink" title="3、信号"></a>3、信号</h5><p>（1）每种信号类型都对应与某种系统事件。传送一个信号到目的进程是由两个不同的步骤组成的：</p>
<p>发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有如下两种原因：内核检测到一个系统事件，比如除零错误或者子进程终止；一个进程调用了kill函数显示地要求内核发送一个信号给目的进程，可以发送信号给自己。</p>
<p>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出回应时，它就接收了信号。进程可以忽略这个信号，终止或通过执行一个称为信号处理程序的用户层函数捕获这个信号。</p>
<p>一个发出而没有被接收的信号称为待处理信号。在任何时刻一种类型至多只会有一个待处理信号，任何接下来发送到这个进程的同类型的信号都不会排队等待，会直接丢弃。一个进程可以有选择性地阻塞接收某种信号，当一种信号被阻塞时，仍可以发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。一个待处理信号至多只能被接收一次。</p>
<p>（2）每个进程只属于一个进程组。默认一个子进程和它的父进程同属于一个进程组。</p>
<p>（3）Unix shell使用作业这一抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和0个或多个后台作业。</p>
<p>Ctrl+C会导致内核发送一个SIGINT信号到前台进程组中的每个进程，默认情况下，结果是终止前台作业 ；Ctrl+Z会发送一个SIGTSTP信号到前台进程组中的每个进程，默认情况下，结果是停止（挂起）前台作业。</p>
<p>进程可以通过调用signal函数修改和信号相关联的默认行为，唯一的例外是SIGSTOP和SIGKILL的默认行为不能被修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(int signum, sighandler_t  handler);</span><br></pre></td></tr></table></figure>

<p>signal可以通过以下三种方法之一来改变和信号signum相关联的行为：</p>
<p>handler是SIG_IGN，那么忽略类型为signum的信号</p>
<p>handler是SIG_DFL，那么类型为signum的信号行为恢复为默认</p>
<p>handler是用户定义的函数地址，这个函数称为信号处理程序，只要进程接收到一个signum信号就会调用这个程序。</p>
<p>（4）安全地信号处理原则</p>
<p>处理程序要尽可能简单；在处理程序汇总只调用异步信号安全的函数；保存和恢复errno；阻塞所有的信号，保护对共享全局变量数据结构的访问；用volatile声明全局变量。</p>
<p>（5）非本地跳转</p>
<p>C语言提供了一种用户级异常控制流形式，称为非本地跳转，通过setjmp和longjmp函数来提供的。</p>
<p>setjmp函数在env缓冲区中保存当前调用环境，以供后面的longjmp函数使用，并返回0。</p>
<p>longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化额女的setjmp调用的返回。</p>
<h4 id="二、虚拟内存"><a href="#二、虚拟内存" class="headerlink" title="二、虚拟内存"></a>二、虚拟内存</h4><p>虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址通过使用页表被翻译成一个物理地址，而页表的内容是由操作系统提供的。</p>
<p>虚拟内存提供三个重要的功能：</p>
<ul>
<li>它在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。虚拟内存缓存中的块叫做页。对磁盘上页的引用会触发缺页，缺页将控制转移到操作系统中的一个缺页处理程序。缺页处理程序将页面从磁盘复制到主存缓存，如果必要，将写回被驱逐的页。</li>
<li>虚拟内存简化了内存管理，进而又简化了链接、在进程间共享数据、进程的内存分配以及程序加载。</li>
<li>虚拟内存通过在每条页表条目中加人保护位，从而了简化了内存保护。 </li>
</ul>
<p>现代系统通过将虚拟内存片和磁盘上的文件片关联起来，来初始化虚拟内存片，这个过程称为内存映射。内存映射为共享数据、创建新的进程以及加载程序提供了一种高效的机制。应用可以使用 mmap 函数来手工地创建和删除虚拟地址空间的区域。然而，大多数程序依赖于动态内存分配器，例如 malloc，它管理虚拟地址空间区域内一个称为堆的区域。动态内存分配器是一个感觉像系统级程序的应用级程序， 它直接操作内存，而无需类型系统的很多帮助。</p>
<p>分配器有两种类型。显式分配器要求应用显式地释放它们的内存块。隐式分配器（垃圾收集器）自动释放任何未使用的和不可达的块。  </p>
<h5 id="1、物理和虚拟寻址"><a href="#1、物理和虚拟寻址" class="headerlink" title="1、物理和虚拟寻址"></a>1、物理和虚拟寻址</h5><p>物理寻址：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址，CPU访问内存的最自然的方式就是使用物理地址。</p>
<p>虚拟寻址：CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换成物理地址的任务叫做地址翻译。CPU芯片上的内存管理单元（MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址。</p>
<h5 id="2、地址空间"><a href="#2、地址空间" class="headerlink" title="2、地址空间"></a>2、地址空间</h5><p>是一个非负整数地址的有序集合。如果地址空间中的整数是连续的，则它是一个线性地址空间。一个地址空间的大小是由表示最大地址所需要的位数来描述的。现代系统通常支持32位或64位虚拟地址空间。允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。</p>
<h5 id="3、虚拟内存作为缓存的工具"><a href="#3、虚拟内存作为缓存的工具" class="headerlink" title="3、虚拟内存作为缓存的工具"></a>3、虚拟内存作为缓存的工具</h5><p>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有唯一的虚拟地址作为到数组的索引。磁盘上数组的内容被缓存在主存中。磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：未分配的（VM系统还未分配或创建的页），缓存的（当前已缓存在物理内存中的已分配页），未缓存的（未缓存在物理内存中的已分配页）。</p>
<h6 id="（1）DRAM缓存的组织结构"><a href="#（1）DRAM缓存的组织结构" class="headerlink" title="（1）DRAM缓存的组织结构"></a>（1）DRAM缓存的组织结构</h6><p>DRAM比SRAM要慢大约10倍，磁盘比DRAM慢大约100000多倍，因此DRAM缓存中的不命中要比SRAM缓存中的不命中要昂贵得多，这是因为DRAM缓存不命中要由磁盘来服务，SRAM缓存不命中通常是由基于DRAM的主存来服务的。</p>
<p>由于大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是4KB-2MB，DRAM缓存是全相联的，即任何虚拟页都可以放置在任何物理页中。</p>
<h6 id="（2）页表"><a href="#（2）页表" class="headerlink" title="（2）页表"></a>（2）页表</h6><p>页表将虚拟页映射到物理页，每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会去读取页表。页表就是一个页表条目（PTE）的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE。</p>
<h6 id="（3）缺页"><a href="#（3）缺页" class="headerlink" title="（3）缺页"></a>（3）缺页</h6><p>DRAM缓存不命中称为缺页。比如：CPU引用了VP3中的一个字，VP3并未缓存在DRAM中，地址翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，比如选在缓存在DRAM中的VP4，如果VP4已经被修改了，那么内核就会将它复制回磁盘，VP4不再缓存在主存中。</p>
<h5 id="4、虚拟内存作为内存管理的工具"><a href="#4、虚拟内存作为内存管理的工具" class="headerlink" title="4、虚拟内存作为内存管理的工具"></a>4、虚拟内存作为内存管理的工具</h5><p>操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。</p>
<ul>
<li>简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处；</li>
<li>简化加载：虚拟内存使得容易向内存中加载可执行文件和共享对象文件。</li>
<li>简化共享：独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。</li>
<li>简化内存分配：虚拟内存为向用户进程提供一个简单的分配额外内存的机制。</li>
</ul>
<h5 id="5、地址翻译"><a href="#5、地址翻译" class="headerlink" title="5、地址翻译"></a>5、地址翻译</h5><h6 id="（1）使用页表的地址翻译"><a href="#（1）使用页表的地址翻译" class="headerlink" title="（1）使用页表的地址翻译"></a>（1）使用页表的地址翻译</h6><p>CPU中的一个控制寄存器，页表基址寄存器（PTBR）指向当前页表。n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（VPO）和一个（n-p）位的虚拟页号（VPN）。</p>
<p>MMU利用VPN来选择适当的PTE。将页表条目中物理页号（PPN）和虚拟地址中的VPO串联起来就得到相应的物理地址。注意：因为物理和虚拟页面都是P字节的，所以物理页面偏移（PPO）和VPO是相同的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412204536794.png"></p>
<h6 id="（2）页面命中时，CPU硬件执行的步骤"><a href="#（2）页面命中时，CPU硬件执行的步骤" class="headerlink" title="（2）页面命中时，CPU硬件执行的步骤"></a>（2）页面命中时，CPU硬件执行的步骤</h6><ol>
<li><p>处理器生成一个虚拟地址，并把它传送给MMU；</p>
</li>
<li><p>MMU生成PTE地址，并从高速缓存/主存请求得到它；</p>
</li>
<li><p>高速缓存/主存向MMU返回PTE；</p>
</li>
<li><p>MMU构造物理地址，并把它传送给高速缓存/主存；</p>
</li>
<li><p>高速缓存/主存返回所请求的数据字给处理器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412202636139.png"></p>
</li>
</ol>
<h6 id="（3）如果PTE有效位为0，则发生缺页，处理缺页要求硬件和操作系统内核协作完成。"><a href="#（3）如果PTE有效位为0，则发生缺页，处理缺页要求硬件和操作系统内核协作完成。" class="headerlink" title="（3）如果PTE有效位为0，则发生缺页，处理缺页要求硬件和操作系统内核协作完成。"></a>（3）如果PTE有效位为0，则发生缺页，处理缺页要求硬件和操作系统内核协作完成。</h6><ol>
<li><p>处理器生成一个虚拟地址，并把它传送给MMU；</p>
</li>
<li><p>MMU生成PTE地址，并从高速缓存/主存请求得到它；</p>
</li>
<li><p>高速缓存/主存向MMU返回PTE；</p>
</li>
<li><p>PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序；</p>
</li>
<li><p>缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了， 则把它换出到磁盘；</p>
</li>
<li><p>缺页处理程序页面调人新的页面，并更新内存中的 PTE；</p>
</li>
<li><p>缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU 执行了图 b）中的步骤之后，主存就会将所请求字返回给处理器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412203340465.png"></p>
</li>
</ol>
<h6 id="（4）使用TLB加速地址翻译"><a href="#（4）使用TLB加速地址翻译" class="headerlink" title="（4）使用TLB加速地址翻译"></a>（4）使用TLB加速地址翻译</h6><p>TLB（翻译后备缓冲器）是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE组成的块。TLB通常有高度的相联度。用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB有T=2‘个组，那么 TLB 索引（TLBI)是由 VPN 的 i 个最低位组成的，而 TLB 标记(TLBT)是由 VPN 中剩余的位组成的。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412204741715.png"></p>
<p>TLB命中时，通常情况下所包含的步骤，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。 </p>
<ol>
<li>CPU 产生一个虚拟地址；</li>
<li>MMU 从 TLB中取出相应的 PTE；</li>
<li>MMU 从 TLB中取出相应的 PTE；</li>
<li>MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存；</li>
<li>高速缓存/主存将所请求的数据字返回给 CPU。</li>
</ol>
<p>TLB不命中时，MMU 必须从 L1 缓存中取出相应的 PTE。新取 出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412205524908.png"></p>
<h6 id="（5）多级页表"><a href="#（5）多级页表" class="headerlink" title="（5）多级页表"></a>（5）多级页表</h6><p>用来压缩页表的常用方法是使用层次结构的页表。一级页表中的每个 PTE 负责映射虚拟地址空间中一个 4MB 的片（chunk)，这里每一片都是由 1024 个连续的页面组成的。如果片 i 中的每个页面都未被分配，那么一级 PTEi就为空。如果在片 i 中至少有一个页是分配了的，那么一级 PTEi就指向一 个二级页表的基址。</p>
<p>二级页表中的每个 PTE 都负责映射一个 4KB 的虚拟内存页面，就像我们查看只有一级的页表一样。注意，使用 4 字节的 PTE，每个一级和二级页表都是 4KB 字节，这刚好和一个页面的大小是一样的。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412210528952.png"></p>
<p>这种方法从两个方面减少了内存要求。第一，如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在。第二，只有一级页表才需要总是在主存中；虚拟内存系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中。 </p>
<h6 id="（6）k-级页表层次结构的地址翻译"><a href="#（6）k-级页表层次结构的地址翻译" class="headerlink" title="（6）k 级页表层次结构的地址翻译"></a>（6）k 级页表层次结构的地址翻译</h6><p>虚拟地址被划分成为 k 个 VPN 和 1个 VPO。 每个 VPNi 都是一个到第 i 级页表的索引，其中1≤i≤k。</p>
<p>第 j 级页表中的每个 PTE，1≤j≤k-1，都指向第 j+1 级的某个页表的基址。第 k 级页表中的每个 PTE 包含某个物理页面的 PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定 PPN 之前，MMU 必须访问 k 个 PTE。 对于只有一级的页表结构，PPO 和 VPO 是相同的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412211538482.png"></p>
<h5 id="6、Linux虚拟内存系统"><a href="#6、Linux虚拟内存系统" class="headerlink" title="6、Linux虚拟内存系统"></a>6、Linux虚拟内存系统</h5><p>Linux为每个进程维护了一个单独的虚拟地址空间。包括它那些熟悉的代码、数据、堆、共享库以及栈段，这部分虚拟内存位于用户栈之上。内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的找，以及记录虚拟地址空间当前组织的各种数据结构。</p>
<h6 id="（1）Linux虚拟内存区域"><a href="#（1）Linux虚拟内存区域" class="headerlink" title="（1）Linux虚拟内存区域"></a>（1）Linux虚拟内存区域</h6><p>Linux 将虚拟内存组织成一些区域（也叫做段）的集合。一个区域（area)就是已经存在着的（已分配的）虚拟内存的连续片（chunk)，这些页是以某种方式相关联的。例如，代码段、数据段、堆、共享库段，以及用户栈都是不同的区域。每个存在的虚拟页面都保存在 某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。</p>
<p>内核为系统中的每个进程维护一个单独的任务结构（源代码中的 task_struct)。任务结构中的一个条目指向 mm_struct， 它描述了虚拟内存的当前状态。pgd指向第一级页表(页全局目录）的基址，而 mmap指向一个 structs(区域结构）的链表，其中每个 vm_area_struct 都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将 pgd 存放在 CR3 控制寄存器中。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210412223743916.png"></p>
<h6 id="（2）Linux缺页异常处理"><a href="#（2）Linux缺页异常处理" class="headerlink" title="（2）Linux缺页异常处理"></a>（2）Linux缺页异常处理</h6><p>缺页异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤：</p>
<ul>
<li><p>虚拟地址A是否合法？即A是否在某个区域结构定义的区域内？</p>
<p>缺页处理程序搜索区域结构的链表，把A和每个区域结构中的vm_start和vm_end作比较，如果这个指令不合法，则缺页处理程序就触发一个段错误，进而终止这个进程。</p>
</li>
<li><p>试图进行的内存访问是否合法？即进程是否有读、写或者执行这个区域内页面的权限？</p>
<p>如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。</p>
</li>
<li><p>此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU 重新启动引起缺页的指令，这条指令将再次发送 A到 MMU。这次，MMU 就能正常地翻译 A 而不会再产生缺页中断了。</p>
</li>
</ul>
<h5 id="7、内存映射"><a href="#7、内存映射" class="headerlink" title="7、内存映射"></a>7、内存映射</h5><p>Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory mapping)。 虚拟内存区域可以映射到两种类型的对象中的一种：Linux 文件系统中的普通文件（一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件）、匿名文件（匿名文件是由内核创建的，包含的全是二进制零）。</p>
<h6 id="（1）共享对象"><a href="#（1）共享对象" class="headerlink" title="（1）共享对象"></a>（1）共享对象</h6><p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。一个映射到共享对象的虚拟内存区域叫做共享区域。类似地，也有私有区域。 </p>
<p>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。 </p>
<p>另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。</p>
<p>私有对象使用一种叫做写时复制（copy-on-write)的巧妙技术被映射到虚拟内存中，在物理内存中只保存有私有对象的一份副本。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。 当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。当故障处理程序返回时，CPU 重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。</p>
<h6 id="（2）-fork-函数是如何创建一个带有自己独立虚拟地址空间的新进程的？"><a href="#（2）-fork-函数是如何创建一个带有自己独立虚拟地址空间的新进程的？" class="headerlink" title="（2） fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的？"></a>（2） fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的？</h6><p>当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 </p>
<p>当 fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。 </p>
<h6 id="（3）execve-函数实际上是如何加载和执行程序的？"><a href="#（3）execve-函数实际上是如何加载和执行程序的？" class="headerlink" title="（3）execve 函数实际上是如何加载和执行程序的？"></a>（3）execve 函数实际上是如何加载和执行程序的？</h6><p>execve(‘a.out”, NULL, NULL);  加载并运行 a.out需要以下几个步骤：</p>
<ul>
<li>删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li>
<li>映射私有区域。为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 a.out 文件中的.text 和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。</li>
<li>映射共享区域。如果 a.out 程序与共享对象（或目标）链接，比如标准 C 库 libc. so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。 </li>
<li>设置程序计数器（PC)，使之指向代码区域的入口点。</li>
</ul>
<h6 id="（4）使用mmap函数的用户级内存映射"><a href="#（4）使用mmap函数的用户级内存映射" class="headerlink" title="（4）使用mmap函数的用户级内存映射"></a>（4）使用mmap函数的用户级内存映射</h6><p>Linux进程可以使用 mmap 函数来创建新的虚拟内存区域，并将对象映射到这些区域中。mmap 函数要求内核创建一个新的虚拟内存区域，最好是从地址 start 开始的一个区 域，并将文件描述符 fd 指定的对象的一个连续的片（chunk)映射到这个新的区域。</p>
<p>如果设置了 MAP_ANON 标记位，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。MAP_PRIVATE 表示被映射的对象是一个私有的、写时复制的对象，而 MAP_SHARED 表示是一 个共享对象。</p>
<h5 id="8、动态内存分配"><a href="#8、动态内存分配" class="headerlink" title="8、动态内存分配"></a>8、动态内存分配</h5><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。系统之间细节不同， 但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。 对于每个进程，内核维护着一个变量 brk(读做”break”)，它指向堆的顶部。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210413111315407.png"></p>
<h6 id="（1）分配器–显式和隐式"><a href="#（1）分配器–显式和隐式" class="headerlink" title="（1）分配器–显式和隐式"></a>（1）分配器–显式和隐式</h6><p>分配器将堆视为一组不同大小的块（block)的集合来维护。每个块就是一个连续的虚拟内存片（chunk), 要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。<br>分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责 释放已分配的块。 </p>
<ul>
<li>显式分配器（explicit allocator）：要求应用显式地释放任何已分配的块。如malloc和free、new和delete。</li>
<li>隐式分配器（implicit allocator)：要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector)，而自动释放未使用的已分配的块的过程叫做垃级收集。</li>
</ul>
<p>动态地分配数组，数组大小的最大值就只由可用的虚拟内存数量来限制了。一个系统中被所有进程分配的虚拟内存的全部数量是受磁盘上交换空间的数量限制的。</p>
<h6 id="（2）碎片"><a href="#（2）碎片" class="headerlink" title="（2）碎片"></a>（2）碎片</h6><p>造成堆利用率很低的主要原因是一种称为碎片（fragmentation)的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象。有两种形式的碎片：内部碎片和外部碎片。</p>
<ul>
<li>内部碎片是在一个已分配块比有效载荷大时发生的。例如，一个分配器的实现可能对已分配块强加一个最小的大小值，而这个大小要比某个请求的有效载荷大。内部碎片就是已分配块大小和它们的有效载荷大小之差的和。因此，在任意时刻，内部碎片的数量只取决于以前请求的模式和分配器的实现方式。</li>
<li>外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。外部碎片不仅取决于以前请求的模式和分配器的实现方式，还取决于将来请求的模式。例如，假设在 个请求之后，所有空闲块的大小 都恰好是 4 个字。这个堆会有外部碎片吗？答案取决于将来请求的模式。如果将来所有的分配请求都要求小于或者等于 4 个字的块，那么就不会有外部碎片。另一方面，如果有一个或者多个请求要求比 4 个字大的块，那么这个堆就会有外部碎片。 </li>
</ul>
<h6 id="（3）隐式空闲链表"><a href="#（3）隐式空闲链表" class="headerlink" title="（3）隐式空闲链表"></a>（3）隐式空闲链表</h6><p>一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小(包括头部和所有的填充），以及这个块是已分配的还是空闲的。</p>
<p>如果我们强加一个双字的对齐约束条件，那么块大小就总是 8 的倍数，且块大小的最低 3 位总是零。因此，我们只需要内存大小的 29 个高位，释放剩余的 3 位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位)来指明这个块是已分配的还是空闲的。</p>
<p>头部后面就是应用调用 malloc 时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210413122009627.png"></p>
<p>隐式空闲链表中，空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210413122207277.png"></p>
<h6 id="（4）放置已分配的块–放置策略"><a href="#（4）放置已分配的块–放置策略" class="headerlink" title="（4）放置已分配的块–放置策略"></a>（4）放置已分配的块–放置策略</h6><p>当一个应用请求一个 6 字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的。 一些常见的策略是首次适配（first Ht)、下一次适配（next Ht)和最佳适配（best fit)。 </p>
<ul>
<li>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。优点是它趋向于将大的空闲块保留在链表的后面。缺点是它趋向于在靠近链表起始处留下小空闲块的“碎片”，这就增加了对较大块的搜索时间。</li>
<li>下一次适配：从上一次査询结束的地方开始。如果我们上 一次在某个空闲块里已经发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。</li>
<li>最佳适配：检査每个空闲块，选择适合所需请求大小的最小空闲块。 然而在简单空闲链表组织结构中，比如隐式空闲链表中，使用最佳适配的缺点是它要求对堆进行彻底的搜索。但分离式空闲链表组织，它接近于最佳适配策略， 不需要进行彻底的堆搜索。</li>
</ul>
<p>下一次适配的内存利用率要比首次适配低得多，最佳适配比首次适配和下一次适配的内存利用率都要高一些。</p>
<h6 id="（5）获取额外的堆内存"><a href="#（5）获取额外的堆内存" class="headerlink" title="（5）获取额外的堆内存"></a>（5）获取额外的堆内存</h6><p>如果分配器不能为请求块找到合适的空闲块，则有两种选择：</p>
<ul>
<li>通过合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块。 </li>
<li>如果这样还是不能生成一个足够大的块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用 sbrk 函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。</li>
</ul>
<h6 id="（6）合并空闲块"><a href="#（6）合并空闲块" class="headerlink" title="（6）合并空闲块"></a>（6）合并空闲块</h6><p>假碎片：当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种假碎片的现象。即有很多空闲块被分割成小的、无法使用的空闲块。</p>
<p>为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块。分配器可以选择：</p>
<ul>
<li>立即合并：在每次一个块被释放时，就合并所有的相邻块。</li>
<li>推迟合并：等到某个稍晚的时候再合并空闲块。</li>
</ul>
<p>立即合并很简单明了，可以在常数时间内执行完成，但是对于某些请求模式，这种方式会产生一种形式的抖动，块会反复地合并，然后马上分割。快速的分配器通常会选择某种形式的推迟合并。</p>
<h6 id="（7）带边界标记的合并"><a href="#（7）带边界标记的合并" class="headerlink" title="（7）带边界标记的合并"></a>（7）带边界标记的合并</h6><p>当前块的头部指向下一个块的头部，可以检查这个指针以判断下一个块是否是空闲的。如果是，就将它的大小简单地加到当前块头部的大小上，这 两个块在常数时间内被合并。 </p>
<p>当要合并前面的块时，采用边界标记的方法，在每个块的结尾处添加一个脚部（边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检查它的脚部，判断前面一个块的起始位置和状态， 这个脚部总是在距当前块开始位置一个字的距离。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210413124857344.png"></p>
<p>缺陷：它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。</p>
<p>优化方法：当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到它的脚部。如果我们把前面块的已分配/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部。 </p>
<h6 id="（8）显式空闲链表"><a href="#（8）显式空闲链表" class="headerlink" title="（8）显式空闲链表"></a>（8）显式空闲链表</h6><p>使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数， 这取决于我们所选择的空闲链表中块的排序策略。 </p>
<ul>
<li>后进先出（LIFO)的顺序维护链表：将新释放的块放置在链表的开始处。 使用 LIFO 的顺序和首次适配的放置策略，分配器会最先检査最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。 </li>
<li>地址顺序维护链表：其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。按照地址排序的首次适配比 LIFO 排序的首次适配有更高的内存利用率，接近最佳适配的利用率。 </li>
</ul>
<p>一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210413131422449.png"></p>
<h6 id="（9）分离的空闲链表"><a href="#（9）分离的空闲链表" class="headerlink" title="（9）分离的空闲链表"></a>（9）分离的空闲链表</h6><p>分离存储：就是维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类。有很多种方式来定义大小类。例如，我们可以根据 2 的幂来划分块大小： {1},{2}，{3,4}， {5-8}，⋯，{1025-2048},{2049-4096},{4097-…} </p>
<p>分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。 当分配器需要一个大小为k 的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表。</p>
<ul>
<li><p>简单分离存储：每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。例如，如果某个大小类定义为{17-32}，那么这个类的空闲链表全由大小为 32 的块组成。</p>
<p>为了分配一个给定大小的块，我们检査相应的空闲链表。如果链表非空，我们简单地分配其中第一块的全部。空闲块是不会分割以满足分配请求的。如果链表为空，分配器就向操作系统请求一个固定大小的额外内存片（通常是页大小的整数倍），将这个片分成大小相等的块，并将这些块链接起来形成新的空闲链表。要释放一个块，分配器只要简单地将 这个块插人到相应的空闲链表的前部。</p>
<p>分配和释放块都是很快的常数时间操作。而且每个片中都是大小相等的块，不分割，不合并，这意味着每个块只有很少的内存开销。因为空闲块是不会被分割的，所以可能会造成内部碎片。更糟的是，因为不会合并空闲块，所以某些引用模式会引起极多的外部碎片。</p>
</li>
<li><p>分离适配</p>
<p>分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块， 这些块的大小是大小类的成员。</p>
<p>为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，査找一个合适的块。如果找到了一个，那么就(可选地)分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中分配出一个块，将剩余部分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。 </p>
<p>分离适配方法是一种常见的选择，C标准库中提供的 GNU malloc 包就是采用的这种方法，因为这种方法既快速，对内存的使用也很有效率。（因为搜索被限制在堆的某个部分，而不是整个堆。对分离空闲链表的简单的首次适配搜索，其内存利用率近似于对整个堆的最佳适配搜索的内存利用率） </p>
</li>
<li><p>伙伴系统</p>
</li>
</ul>
<p>伙伴系统是分离适配的一种特例，其中每个大小类都是 2 的幂。为了分配一个大小为2^k^的块，我们找到第一个可用的、大小为2^j^的块，其中k≤j≤m。 如果j=k，那么我们就完成了。否则，我们递归地二分割这个块，直到当我们进行这样的分割时，每个剩下的半块(也叫做伙伴)被放置在相应的空闲链表中。要释放一个大小为2^k^的块，我们继续合并空闲的伙伴。当遇到一个已分配的伙伴时，我们就停止合并。 </p>
<p>伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为 2 的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些特定应用的工作负载，其中块大小预先知道是 2 的幂，伙伴系统分配器就很有吸引力了。</p>
<h5 id="9、垃圾收集"><a href="#9、垃圾收集" class="headerlink" title="9、垃圾收集"></a>9、垃圾收集</h5><h6 id="（1）垃圾收集器（garbage-collector"><a href="#（1）垃圾收集器（garbage-collector" class="headerlink" title="（1）垃圾收集器（garbage collector)"></a>（1）垃圾收集器（garbage collector)</h6><p>是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为垃圾。</p>
<p>垃圾收集器将内存视为一张有向可达图，该图的节点被分成一组根节点和一组堆节点。 每个堆节点对应于 堆中的一个已分配块。有向边 p→q 意味着块 p 中的某个位置指向块 q 中的某个位置。根节点对应于这样一种不在堆中的位置，它们中包含指向堆中的指针。这些位置可以是寄存器、栈里的变量，或者是虚拟内存中读写数据区域内的全局变量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-20210413143150393.png"></p>
<p>当存在一条从任意根节点出发并到达 P 的有向路径时，我们说节点 P 是可达的。在任何时刻，不可达节点对应于垃圾，是不能被应用再次使用的。垃圾收集器的角色是维护可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期地回收它们。 </p>
<p>如果 malloc 找不到一个合适的空闲块，那么它就调用垃圾收集器，希望能够回收一些垃圾到空闲链表。收集器识别出垃圾块，并通过调用 free 函数将它们返回给堆。关键的思想是收集器代替应用去调用 free。</p>
<p>当对收集器的调用返回时，malloc 重试，试图发现一个合适的空闲块。如果还是失败了，那么它就会向操作系统要求额外的内存。最后，malloc 返回一个指向请求块的指针（如果成功）或者返回一个空指针（如果不成功）。</p>
<h6 id="（2）-Mark-amp-Sweep-垃圾收集器"><a href="#（2）-Mark-amp-Sweep-垃圾收集器" class="headerlink" title="（2） Mark&amp;Sweep 垃圾收集器"></a>（2） Mark&amp;Sweep 垃圾收集器</h6><p>由标记（mark)阶段和清除（sweep)阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个块是否被标记了。 </p>
<p>标记阶段为每个根节点调用一次 mark 函数。如果 p 不指向一个已分配并且未标记的堆块，mark 函数就立即返回。否则，它就标记这个块，并对块中的每个字递归地调用它自己。每次对 mark 函数的调用都标记某个根节点的所有未标记并且可达 的后继节点。在标记阶段的末尾，任何未标记的已分配块都被认定为是不可达的，是垃圾，可在清除阶段回收。 </p>
<p>清除阶段是对 sweep 函数的一次调用。sweep 函数在堆中每个块上反复循环，释放它所遇到的所有未标记的已分配块（也就是垃圾）。 </p>
<h5 id="10、常见的与内存有关的错误"><a href="#10、常见的与内存有关的错误" class="headerlink" title="10、常见的与内存有关的错误"></a>10、常见的与内存有关的错误</h5><p>间接引用坏指针：在进程的虚拟地址空间中有较大的洞，没有映射到任何有 意义的数据。如果我们试图间接引用一个指向这些洞的指针，那么操作系统就会以段异常中止 程序。</p>
<p>读未初始化的内存 ：虽然 bss内存位置（诸如未初始化的全局C变量）总是被加载器初始化为零，但是对于 堆内存却并不是这样的。</p>
<p> 允许栈缓冲区溢出：如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。</p>
<p>假设指针和它们指向的对象是相同大小的；</p>
<p> 引用不存在的变量 ； 引用指针，而不是它所指向的对象 ； 引用空闲堆块中的数据：</p>
<p>引起内存泄漏：忘记释放已分配块，而在堆里创建了垃圾时，会发生这种问题；</p>
<h4 id="三、系统级I-O"><a href="#三、系统级I-O" class="headerlink" title="三、系统级I/O"></a>三、系统级I/O</h4><h5 id="1、Unix-I-O"><a href="#1、Unix-I-O" class="headerlink" title="1、Unix I/O"></a>1、Unix I/O</h5><p>一个Linux文件就是一个m个字节的序列，所有的I/O设备都被映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输人和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li><p>打开文件：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。 </p>
</li>
<li><p>Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入(描述符为 0)、标准输出（描述符为 1)和标准错误（描述符为 2)。头文件&lt; unistd.h&gt; 定义了常量 STDIN_FILENO、STDOUT_FILENO和 STDERR_FILENO， 它们可用来代替显式的描述符值。</p>
</li>
<li><p>改变当前文件位置：对于每个打开的文件，内核保持着一个文件位置 k，初始为 0。 这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为k。 </p>
</li>
<li><p>读写文件：一个读操作就是从文件复制 n&gt;0 个字节到内存，从当前文件位置 k 开始，然后将k增加 k+n。给定一个大小为 m 字节的文件，当 k≥m 时执行读操作会触发一个称为 end-of-file(EOF)的条件。 </p>
<p>写操作就是从内存复制 n&gt;0 个字节到一个文件，从当前文件位置 k 开始，然后更新k。 </p>
</li>
<li><p>关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</p>
</li>
</ul>
<h5 id="2、文件"><a href="#2、文件" class="headerlink" title="2、文件"></a>2、文件</h5><p>每个 Linux 文件都有一个类型来表明它在系统中的角色： </p>
<ul>
<li>普通文件：包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有 ASCII 或 Unicode 字符的普通文件；二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。</li>
<li>目录：包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目： “.”是到该目录自身的链接，”..”是到目录层次结构中父目录的链接。</li>
<li>套接字：是用来与另一个进程进行跨网络通信的文件。</li>
</ul>
<h5 id="3、共享文件"><a href="#3、共享文件" class="headerlink" title="3、共享文件"></a>3、共享文件</h5><p>内核用三个相关的数据结构来表示打开的文件： </p>
<ul>
<li>描述符表：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。 </li>
<li>文件表：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数(即当前指向该表项的描述符表项数），以及一个指向 v-node 表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。</li>
<li>v-node表：同文件表一样，所有的进程共享这张 v-node 表。每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。 </li>
</ul>
<p>多个描述符也可以通过不同的文件表表项来引用同一个文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-1013.png"></p>
<p> 子进程继承父进程的打开文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-1014.png"></p>
<h5 id="4、I-O重定向"><a href="#4、I-O重定向" class="headerlink" title="4、I/O重定向"></a>4、I/O重定向</h5><p>I/O重定向使用dup2函数进行工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dup2 函数复制描述符表表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 newfd 以前的内容。如果 newfd已经打开了，dup2 会在复制 oldfd 之前关闭 newfd。</p>
<h5 id="5、Unix-I-O、标准-VO-和-RIO-之间的关系"><a href="#5、Unix-I-O、标准-VO-和-RIO-之间的关系" class="headerlink" title="5、Unix I/O、标准 VO 和 RIO 之间的关系"></a>5、Unix I/O、标准 VO 和 RIO 之间的关系</h5><p>Unix I/O 模型是在操作系统内核中实现的。应用程序可以通过诸如 open、close、lseek、read、write 和 stat 这样的函数来访问 Unix I/O。较高级别的 RIO 和标准I/O 函数都是基于(使用）Unix I/O 函数来实现的。</p>
<p>RIO 函数是专为本书开发的 read 和 write 的健壮的包装函数。它们自动处理不足值，并且为读文本行提供一种高效的带缓冲的方法。</p>
<p>标准 I/O 函数提供了 Unix I/O 函数的一个更加完整的带缓冲的替代品，包括格式化的 I/O 例程，如 printf 和 scanf。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-1016.png"></p>
<h4 id="四、网络编程"><a href="#四、网络编程" class="headerlink" title="四、网络编程"></a>四、网络编程</h4><h5 id="1、客户端-服务器编程模型"><a href="#1、客户端-服务器编程模型" class="headerlink" title="1、客户端-服务器编程模型"></a>1、客户端-服务器编程模型</h5><p>一个应用是由一个服 务器进程和一个或者多个客户端进程组成。客户端-服务器模型中的基本操作是事务。一个客户端-服务器事务由以下四步组成：</p>
<ul>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源。</li>
<li>服务器给客户端发送一个响应，并等待下一个请求。</li>
<li>客户端收到响应并处理它。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-11111.png"></p>
<h5 id="2、网络"><a href="#2、网络" class="headerlink" title="2、网络"></a>2、网络</h5><p>物理上而言，网络是一个按照地理远近组成的层次系统。最低层是 LAN(Local Area Network, 局域网），在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是以太网。一个以太网段（Ethernet segment)包括一些电缆（通常是双绞线）和一个叫做集线器的小盒子。每根电缆一端连接到主机的适配器，另一端连接到集线器的一个端口上。</p>
<p>一台主机可以发送一段位(称为帧（frame))到这个网段内的其他任何主机。每个帧包括一些固定数量的头部位，用来标识此帧的源和目的地址以及此帧的长度，此后紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<h5 id="3、IP地址和域名"><a href="#3、IP地址和域名" class="headerlink" title="3、IP地址和域名"></a>3、IP地址和域名</h5><h6 id="（1）网络字节顺序和主机字节顺序-amp-amp-点分十进制"><a href="#（1）网络字节顺序和主机字节顺序-amp-amp-点分十进制" class="headerlink" title="（1）网络字节顺序和主机字节顺序&amp;&amp;点分十进制"></a>（1）网络字节顺序和主机字节顺序&amp;&amp;点分十进制</h6><p>在 IP地址结构中存放的地址总是以(大端法）网络字节顺序存放的，即使主机字节顺序 (host byte order)是小端法。htonl 函数将 32 位整数由主机字节顺序转换为网络字节顺序。ntohl 函数将 32 位整数从网络字节顺序转换为主机字节。htons 和 ntohs 函数为 16 位无符号整数执行相应的转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回按照网络字节顺序的值：</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="comment">// 返回按照主机字节顺序的值：</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inet_pton 函数将一个点分十进制串（src)转换为一个二进制的网络字节顺序的 IP 地址(dst)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(AF_INET, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">// inet_ntop 函数将一个二进制的网络字节顺序的 IP 地址（src)转换为它所对应的点分十进制表示</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(AF_INET, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="（2）因特网域名"><a href="#（2）因特网域名" class="headerlink" title="（2）因特网域名"></a>（2）因特网域名</h6><p>域名层次结构可以表示为一 棵树。树的节点表示域名，反向到根的路径形成了域名。子树称为子域。层次结构中的第一层是一个未命名的根节点。下一层是一组一级域名，再下一层是二级域名。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-regrrthr.png"></p>
<p>每台因特网主机都有本地定义的域名 localhost。 这个域名总是映射为回送地址 (loopback address)127.0.0.1。</p>
<p>在最简单的情况中，一个域名和一个 IP 地址之间是一一映射；</p>
<p>在某些情况下，多个域名可以映射为同一个 IP 地址；</p>
<p>在最通常的情况下，多个域名可以映射到同一组的多个 IP 地址。</p>
<h6 id="（3）因特网连接"><a href="#（3）因特网连接" class="headerlink" title="（3）因特网连接"></a>（3）因特网连接</h6><p>因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。并且从由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它也是可靠的。 </p>
<p>一个套接字是连接的一个端点。毎个套接字都有相应的套接字地址，是由一个因特网地址和一个 16 位的整数端口组成的，用“地址：端口”来表示。 </p>
<p>当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，为临时端口。服务器套接字地址中的端口通常是某个知名端口， 是和这个服务相对应的，如Web 服务器通常使用端口 80。</p>
<p>—个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做套接字对，由下列元组来表示： （cliaddr: cliport, servaddr: servport）</p>
<h5 id="4、套接字"><a href="#4、套接字" class="headerlink" title="4、套接字"></a>4、套接字</h5><p>客户端和服务器通过使用套接字接口建立连接。一个套接字是连接的一个端点，连接以文件描述符的形式提供给应用程序。套接字接口提供了打开和关闭套接字描述符的函数。客户端和服务器通过读写这些描述符来实现彼此间的通信。 </p>
<h6 id="（1）套接字地址结构"><a href="#（1）套接字地址结构" class="headerlink" title="（1）套接字地址结构"></a>（1）套接字地址结构</h6><p>因特网的套接字地址存放在类型为 sockaddr_in的 16 字节结构中。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="comment">// 协议族，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（AF_UNIX）、AF_ROUTE等</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sin_family;        </span><br><span class="line">    <span class="keyword">uint16_t</span> sin_port;          <span class="comment">// 16位端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">// 32 位IP地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="（2）套接字函数"><a href="#（2）套接字函数" class="headerlink" title="（2）套接字函数"></a>（2）套接字函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端和服务器使用 socket 函数来创建一个套接字描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">// 返回sockfd</span></span><br><span class="line"><span class="comment">// 客户端通过调用 connect 函数来建立和服务器的连接。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// bind、listen 和 accept, 服务器用它们来和客户端建立连接。</span></span><br><span class="line"><span class="comment">// bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// listen 函数将 sockfd从一个主动套接字转化为一个监听套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr中填写客户端的套接字地址，并返回一个已连接描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>; <span class="comment">//返回连接connect_fd</span></span><br></pre></td></tr></table></figure>

<h6 id="（3）主机和服务的转换函数"><a href="#（3）主机和服务的转换函数" class="headerlink" title="（3）主机和服务的转换函数"></a>（3）主机和服务的转换函数</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构</span></span><br><span class="line"><span class="comment">// 给定 host 和 service(套接字地址的两个组成部分）， getaddrinfo 返回 result，指向 addrinfo结构的链表，其中每个结构指向一个对应于 host 和 service 的套接字地址结构</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *service, <span class="keyword">const</span> struct addrinfo *hints, struct addrinfo **result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getnameinfo 将一个套接字地址结构转换成相应的主机和服务名字符串</span></span><br><span class="line"><span class="comment">// 参数 sa 指向大小为 salen 字节的套接字地址结构，host 指向大小为 hostlen字节的缓冲区，service指向大小为 servlen 字节的缓冲区。getnameinfo 函数将套接字地址结构 转换成对应的主机和服务名字符串，并将它们复制到 host 和 servcice 缓冲区。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen, <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen, <span class="keyword">char</span> *service, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>; </span><br></pre></td></tr></table></figure>

<h5 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5.Web服务器"></a>5.Web服务器</h5><h6 id="（1）Web-服务器以两种不同的方式向客户端提供内容"><a href="#（1）Web-服务器以两种不同的方式向客户端提供内容" class="headerlink" title="（1）Web 服务器以两种不同的方式向客户端提供内容"></a>（1）Web 服务器以两种不同的方式向客户端提供内容</h6><ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为静态内容，而返回文件给客户端的过程称为服务静态内容。</li>
<li>通过在服务器上一个子进程的上下文中运行一个程序并将它的输出返回给客户端来服务的。运行时可执行文件产生的输出称为动态内容，而运行程序并返回它的输出到客户端的过程称为服务动态内容。</li>
</ul>
<h6 id="（2）通用资源定位符URL"><a href="#（2）通用资源定位符URL" class="headerlink" title="（2）通用资源定位符URL"></a>（2）通用资源定位符URL</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &quot;?&quot;字符分隔文件名和参数，而且每个参数都用&quot;&amp;&quot;字符分隔开。后缀中的最开始的那个&quot;&#x2F;&quot;表示的是被请求内容 类型的主目录。</span><br><span class="line">http:&#x2F;&#x2F;bluefish.ics.cs.cmu.edu:8000&#x2F;cgi-bin&#x2F;adder?15000&amp;213</span><br></pre></td></tr></table></figure>

<p>每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL。可执行文件的 URL 可以在文件名后包括程序参数。</p>
<h6 id="（3）HTTP请求和响应"><a href="#（3）HTTP请求和响应" class="headerlink" title="（3）HTTP请求和响应"></a>（3）HTTP请求和响应</h6><p>一个 HTTP 请求的组成是这样的：一个请求行，后面跟随零个或多个请求报头，再跟随一个空的文本行来终止报头列表。</p>
<p>一个 HTTP 响应的组成是这样的：一个响应行，后面跟随零个或多个响应报头，再跟随一个终止报头的空行，再跟随一个响应主体。</p>
<h6 id="（4）服务动态内容"><a href="#（4）服务动态内容" class="headerlink" title="（4）服务动态内容"></a>（4）服务动态内容</h6><ul>
<li><p>客户端如何将程序参数传递给服务器：GET请求的参数在URI中传递。</p>
</li>
<li><p>服务器如何将参数传递给子进程 ：它调用 fork 来创建一个子进程，并调用 execve在子进程的上下文中执行/cgi-bin/adder程序，即CGI程序。在调用execve之前，子进程将 CGI 环境变量 QUERY_STRING 设置为”15000&amp;213”，adder 程序在运行时可以用 Linux getenv 函数来引用它。</p>
</li>
<li><p>服务器如何将其他信息传递给子进程：CGI 定义了大量的其他环境变量，一个 CGI 程序在它运行时可以设置这些环境变量。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-11-16.png"></p>
<p>子进程将它的输出发送到哪里：一个 CGI 程序将它的动态内容发送到标准输出。在子进程加载并运行 CGI 程序之前，它使用 Linux dup2 函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何 CGI 程序写到标准输出的东西都会直接到达客户端。 </p>
</li>
</ul>
<h4 id="五、并发编程"><a href="#五、并发编程" class="headerlink" title="五、并发编程"></a>五、并发编程</h4><h5 id="1、构造并发程序的方法"><a href="#1、构造并发程序的方法" class="headerlink" title="1、构造并发程序的方法"></a>1、构造并发程序的方法</h5><h6 id="（1）进程"><a href="#（1）进程" class="headerlink" title="（1）进程"></a>（1）进程</h6><p>每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信（IPC）机制。 </p>
<h6 id="（2）I-O多路复用"><a href="#（2）I-O多路复用" class="headerlink" title="（2）I/O多路复用"></a>（2）I/O多路复用</h6><p>应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。 </p>
<h6 id="（3）线程"><a href="#（3）线程" class="headerlink" title="（3）线程"></a>（3）线程</h6><p>线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像 I/O 多路复用流一样共享同一个虚拟地址空间。 </p>
<h5 id="2、基于进程的并发编程"><a href="#2、基于进程的并发编程" class="headerlink" title="2、基于进程的并发编程"></a>2、基于进程的并发编程</h5><p>一个构造并发服务器的自然方法就是，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。</p>
<p>假设有两个客户端和一个服务器，服务器正在监听一个监听描述符（如描述符 3)上的连接请求。现在假设服务器接受了客户端 1 的连接请求， 并返回一个已连接描述符（如描述符 4)。在接受连接请求之后，服务器派生一个子进程，这个子进程获得服务器描述符表的完整副本。子进程关闭它的副本中的监听描述符3，而父进程关闭它的已连接描述符 4 的副本，因为不再需要这些描述符了。 子进程正忙于为客户端提供服务。 </p>
<p>因为父、子进程中的已连接描述符都指向同一个文件表表项，所以父进程关闭它的已连接描述符的副本是至关重要的。否则，将永不会释放已连接描述符 4 的文件表条目，而且由此引起的内存泄漏将最终消耗光可用的内存，使系统崩溃。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-12-2.png"></p>
<p>【优缺点】进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不会覆盖另一个进程的虚拟内存。但独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的 IPC(进程间通信）机制，它们往往比较慢，因为进程控制和 IPC 的开销很高。 </p>
<h5 id="3、基于I-O多路复用的并发编程"><a href="#3、基于I-O多路复用的并发编程" class="headerlink" title="3、基于I/O多路复用的并发编程"></a>3、基于I/O多路复用的并发编程</h5><h6 id="（1）-I-O-多路复用技术"><a href="#（1）-I-O-多路复用技术" class="headerlink" title="（1） I/O 多路复用技术"></a>（1） I/O 多路复用技术</h6><p>基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I/O 事件发生后，才将控制返回给应用程序。</p>
<p>select函数有两个输入：一个称为读集合的描述符集合（fdset) 和该读集合的基数（n)。</p>
<p> select 函数会一直阻塞， 直到读集合中至少有一个描述符准备好可以读。当且仅当一个从该描述符读取一个字节的请求不会阻塞时，描述符 k 就表示准备好可以读了。select 有一个副作用，它修改参数 fdset 指向的 fd_set， 指明读集合的一个子集，称为准备好集合（ready set)，这个集合是由读集合中准好可以读了的描述符组成的。该函数返回的值指明了准备好集合的基数。注意，由于这个副作用，我们必须在每次调用 select 时都更新读集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select 函数处理类型为 fd_set 的集合，也叫做描述符集合。逻辑上，我们将描述符集合看成一个大小为 n 的位向量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *fdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span></span>; <span class="comment">//返回已准备好的描述符的非零的个数，若出错则为 -1</span></span><br><span class="line"><span class="comment">// 处理描述符集合的宏</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set *fdset);          <span class="comment">/* Clear all bits in fdset */</span></span><br><span class="line"><span class="built_in">FD_CLR</span>(<span class="keyword">int</span> fd, fd.set *fdset);   <span class="comment">/* Clear bit fd in fdset */</span>  </span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="keyword">int</span> fd, fd_set *fdset);   <span class="comment">/* Turn on bit fd in fdset */</span></span><br><span class="line"><span class="built_in">FD_ISSET</span>(<span class="keyword">int</span> fd, fd_set *fdset)j <span class="comment">/* Is bit fd in fdset on? */</span></span><br></pre></td></tr></table></figure>

<h6 id="（2）基于-I-O-多路复用的并发事件驱动服务器"><a href="#（2）基于-I-O-多路复用的并发事件驱动服务器" class="headerlink" title="（2）基于 I/O 多路复用的并发事件驱动服务器"></a>（2）基于 I/O 多路复用的并发事件驱动服务器</h6><p>事件驱动程序创建它们自己的并发逻辑流，这些逻辑流被模型化为状态机，用 I/O多路复用来显式地调度这些流。因为程序运行在一个单一进程中，所以在流之间共享数据速度很快而且很容易。一个状态机是由一组状态、输入事件和转移，其中转移是将状态和输入事件映射到状态，每个转移是将一个（输入状态，输入事件）对映射到一个输出状态。</p>
<p>服务器使用I/O 多路复用，借助 select 函数检测输入事件的发生。当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移。 </p>
<p>【 优缺点 】比基于进程的设计给了程序员更多的对程序行为的控制；一个基于 I/O 多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易；事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。 </p>
<h5 id="4、基于线程的并发编程"><a href="#4、基于线程的并发编程" class="headerlink" title="4、基于线程的并发编程"></a>4、基于线程的并发编程</h5><h6 id="（1）线程执行模型"><a href="#（1）线程执行模型" class="headerlink" title="（1）线程执行模型"></a>（1）线程执行模型</h6><p>线程就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文，包括一 个唯一的整数线程ID（TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。 </p>
<p>线程的上下文切换要比进程的上下文切换快得多。线程不像进程那样，不是按照严格的父子层次来组织的。和一个进程相关的线程组成一个对等 (线程）池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程中第一个运行的线程。对等（线程）池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。</p>
<p>线程的代码和本地数据被封装在一个线程例程中。同基于进程的流一样，线程也是由内核自动调度的。同基于 I/O 多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便地共享数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_pictureimage-12-12.png"> </p>
<h6 id="（2）创建线程"><a href="#（2）创建线程" class="headerlink" title="（2）创建线程"></a>（2）创建线程</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程通过调用 pthread_create 函数来创建一个新的线程，并带着一个输入变量 arg, 在新线程的上下文中运行线程例程 f,attr 参数来改变新创建线程的默认属性。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tid, <span class="keyword">pthread_attr_t</span> *attr, func *f, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="comment">// 新线程可以通过调用 pthread_self 函数来获得它自己的线程 ID</span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="（3）终止线程"><a href="#（3）终止线程" class="headerlink" title="（3）终止线程"></a>（3）终止线程</h6><ul>
<li><p>当顶层的线程例程返回时，线程会隐式地终止。 </p>
</li>
<li><p>通过调用 pthread_exit 函数，线程会显式地终止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *thread_return)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>某个对等线程调用 Linux 的 exit 函数，该函数终止进程以及所有与该进程相关的线程。 </p>
</li>
<li><p>另一个对等线程通过以当前线程 ID 作为参数调用 pthread_cancel 函数来终止当前线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="（4）回收已终止线程的资源"><a href="#（4）回收已终止线程的资源" class="headerlink" title="（4）回收已终止线程的资源"></a>（4）回收已终止线程的资源</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthreadjoin 函数会阻塞，等待一个特定的线程 tid 终止，将线程例程返回的通用（void*)指针赋值为 thread_return 指向的位置，然后回收已终止线程占用的所有内存资源。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> tid, <span class="keyword">void</span> **thread_return)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="（5）分离线程"><a href="#（5）分离线程" class="headerlink" title="（5）分离线程"></a>（5）分离线程</h6><p>在任何一个时间点上，线程是可结合的或是分离的。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源（例如栈）是不释放的。一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</p>
<p> 默认情况下，线程被创建成可结合的。为了避免内存泄漏，每个可结合线程都应该要么被其他线程显式地收回，要么通过调用 pthreac_detach 函数被分离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分离可结合线程 tid 线程能够通过以 pthread_self()为参数的 pthread_detach 调用来分离它们自己</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="（6）初始化线程"><a href="#（6）初始化线程" class="headerlink" title="（6）初始化线程"></a>（6）初始化线程</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="（7）基于线程的并发服务器"><a href="#（7）基于线程的并发服务器" class="headerlink" title="（7）基于线程的并发服务器"></a>（7）基于线程的并发服务器</h6><p>主线程不断地等待连接请求，然后创建一个对等线程处理该请求。</p>
<h5 id="5、多线程程序中的共享变量"><a href="#5、多线程程序中的共享变量" class="headerlink" title="5、多线程程序中的共享变量"></a>5、多线程程序中的共享变量</h5><h6 id="（1）线程内存模型"><a href="#（1）线程内存模型" class="headerlink" title="（1）线程内存模型"></a>（1）线程内存模型</h6><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本 (代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享相同的打开文件的集合。 寄存器是从不共享的，而虚拟内存总是共享的。 </p>
<p>各自独立的线程栈的内存模型不是那么整齐清楚的。这些栈被保存在虚拟地址空间的栈区域中，并且通常是被相应的线程独立地访问的。我们说通常而不是总是，是因为不同的线程栈是不对其他线程设防的。所以，如果一个线程以某种方式得到一个指向其他线程栈的指针，那么它就可以读写这个栈的任何部分。</p>
<h6 id="（2）将变量映射到内存"><a href="#（2）将变量映射到内存" class="headerlink" title="（2）将变量映射到内存"></a>（2）将变量映射到内存</h6><p>多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：</p>
<ul>
<li>全局变量：定义在函数之外的变量。在运行时，虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。</li>
<li>本地自动变量：定义在函数内部但是没有 static 属性的变量。 在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。即使多个线程执行同一个线程例程时也是如此。</li>
<li>本地静态变量：定义在函数内部并有 static 属性的变量。和全局变量一样，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。</li>
</ul>
<h6 id="（3）共享变量"><a href="#（3）共享变量" class="headerlink" title="（3）共享变量"></a>（3）共享变量</h6><p>一个变量是共享的，当且仅当它的一个实例被一个以上的线程引用。</p>
<h5 id="6、用信号量同步线程"><a href="#6、用信号量同步线程" class="headerlink" title="6、用信号量同步线程"></a>6、用信号量同步线程</h5><h6 id="（1）信号量"><a href="#（1）信号量" class="headerlink" title="（1）信号量"></a>（1）信号量</h6><p>信号量 s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V。</p>
<ul>
<li> P(s)：如果 s 是非零的，那么 P 将 s 减 1，并且立即返回；如果 s 为零，那么就挂起这个线程，直到 s 变为非零；而一个 V 操作会重启这个线程，在重启之后，P 操 作将 s 减 1，并将控制返回给调用者。</li>
<li>V(s)：V 操作将 s 加 1。如果有任何线程阻塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的一个，然后该线程将 s 减 1，完成它的 P 操作。 V 必须只能重启一个正在等待的线程，当有多个线程在等待同一个信号量时，不能预测 V 操作要重启哪一个线程。 </li>
</ul>
<h6 id="（2）使用信号量来实现互斥"><a href="#（2）使用信号量来实现互斥" class="headerlink" title="（2）使用信号量来实现互斥"></a>（2）使用信号量来实现互斥</h6><p>信号量提供了一种很方便的方法来确保对共享变量的互斥访问。基本思想是将每个共享变量与一个信号量 s 联系起来，然后用 P(s) 和 V(s)操作将相应的临界区包围起来。 </p>
<p>以这种方式来保护共享变量的信号量叫做二元信号量，因为它的值总是0或者 1。</p>
<p>以提供互斥为目的的二元信号量常常也称为互斥锁（mutex)。在一个互斥锁上执行 P 操作称为对互斥锁加锁，执行 V 操作称为对互斥锁解锁。对一个 互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁。一个被用作一组可用资源的计数器的信号量被称为计数信号量。 </p>
<h5 id="7、顺序、并发和并行程序集合之间的关系"><a href="#7、顺序、并发和并行程序集合之间的关系" class="headerlink" title="7、顺序、并发和并行程序集合之间的关系"></a>7、顺序、并发和并行程序集合之间的关系</h5><p>所有程序的集合能够被划分成不相交的顺序程序集合和并发程序的集合。写顺序程序只有一条逻辑流。写并发程序有多条并发流。并行程序是一个运行在多个处理器上的并发程序。 因此，并行程序的集合是并发程序集合的真子集。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture12-30.png"></p>
<h5 id="8、刻画并行程序的性能"><a href="#8、刻画并行程序的性能" class="headerlink" title="8、刻画并行程序的性能"></a>8、刻画并行程序的性能</h5><p>运行时间随着核数的增加线性下降。也就是说，线程数每增加一倍，运行时间就下降一半。随着线程数量的增加，运行时间实际上增加了一点儿，这是由于在一个核上多个线程上下文切换的开销。由于这个原因，并行程序常 常被写为每个核上只运行一个线程。 </p>
<h5 id="9、其他并发问题"><a href="#9、其他并发问题" class="headerlink" title="9、其他并发问题"></a>9、其他并发问题</h5><h6 id="（1）线程安全"><a href="#（1）线程安全" class="headerlink" title="（1）线程安全"></a>（1）线程安全</h6><p>一个函数被称为线程安全的，当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果。四个(不相交的）线程不安全函数类： </p>
<ul>
<li><p>第1类：不保护共享变量的函数。将这类线程不安全函数变成线程安全的，相对而言比较容易，利用像 P 和V操作这样的同步操作来保护共享的变量。这个方法的优点是在调用程序中不需要做任何修改。缺点是同步操作将减慢程序的执行时间。 </p>
</li>
<li><p>第2类：保持跨越多个调用的状态的函数。某些函数如 ctime 和 gethostbyname，将计算结果放在一个 static 变量中，然后返回一个指向这个变量的指针。如果我们从并发线程中调用这些函数，那么将可能发生灾难，因为正在被一个线程使用的结果会被另一个线程悄悄地覆盖了。 </p>
<p>有两种方法来处理这类线程不安全函数。一种选择是重写函数，使得调用者传递存放结果的变量的地址。这就消除了所有共享数据，但是它要求程序员能够修改函数的源代码。 如果线程不安全函数是难以修改或不可能修改的，那么另外一种选择就是使用加锁-复制（lock-and-copy)技术。基本思想是将线程不安全函数与互斥锁联系起来。在每一个调用位置，对互斥锁加锁，调用线程不安全函数，将函数返回的结果复制到一个私有的内存位置，然后对互斥锁解锁。</p>
</li>
<li><p>第3类：返回指向静态变量的指针的函数。</p>
</li>
<li><p>第4类：调用线程不安全函数的函数。如果函数 f 调用线程不安全函数 g，那么 f 就 是线程不安全的吗？不一定。如果 g 是第 2 类函数，即依赖于跨越多次调用的状态，那么 f 也是线程不安全的，而且除了重写 g 以外，没有什么办法。然而，如果 g 是第 1 类或者 第 3 类函数，那么只要你用一个互斥锁保护调用位置和任何得到的共享数据，f 仍然可能是线程安全的。</p>
</li>
</ul>
<h6 id="（2）可重入性"><a href="#（2）可重入性" class="headerlink" title="（2）可重入性"></a>（2）可重入性</h6><p>有一类重要的线程安全函数，叫做可重入函数，其特点在于它们具有这样一种属性：当它们被多个线程调用时，不会引用任何共享数据。所有函数的集合被划分成不相交的线程安全和线程不安全函数集合。可重入函数集合是线程安全函数的一个真子集。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture12-39.png"></p>
<p>可重人函数通常要比不可重人的线程安全的函数高效一些，因为它们不需要同步操作。</p>
<h6 id="（3）竞争"><a href="#（3）竞争" class="headerlink" title="（3）竞争"></a>（3）竞争</h6><p>当一个程序的正确性依赖于一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x 点时，就会发生竞争。</p>
<h6 id="（4）死锁"><a href="#（4）死锁" class="headerlink" title="（4）死锁"></a>（4）死锁</h6><p>指的是一组线程被阻塞了，等待一个永远也不会为真的条件。</p>
<p>避免死锁的互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/04/29/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8Bch8-ch12/">https://varrella.github.io/2021/04/29/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8Bch8-ch12/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___8CRApSLbi1w___0___.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/30/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___0G1r-Cg0zS8___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">github + hexo + PicGo</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/29/%E5%89%91%E6%8C%87Offer/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-3965109.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">刷题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">一、异常控制流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%BC%82%E5%B8%B8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">1、异常的种类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2、进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.2.1.</span> <span class="toc-text">（1）上下文</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E6%B5%81%E5%92%8C%E5%B9%B6%E5%8F%91%E6%B5%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">（2）逻辑流和并发流</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">（3）用户模式和内核模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%BF%9B%E7%A8%8B%E4%BB%8E%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">（4）进程从用户模式转变为内核模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.5.</span> <span class="toc-text">（5）上下文切换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.6.</span> <span class="toc-text">（6）进程控制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text">（7）回收子进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.8.</span> <span class="toc-text">（8）程序和进程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.3.</span> <span class="toc-text">3、信号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">二、虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">1、物理和虚拟寻址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.</span> <span class="toc-text">2、地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.3.</span> <span class="toc-text">3、虚拟内存作为缓存的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89DRAM%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">（1）DRAM缓存的组织结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">（2）页表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BC%BA%E9%A1%B5"><span class="toc-number">2.3.3.</span> <span class="toc-text">（3）缺页</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">2.4.</span> <span class="toc-text">4、虚拟内存作为内存管理的工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">2.5.</span> <span class="toc-text">5、地址翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BD%BF%E7%94%A8%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">2.5.1.</span> <span class="toc-text">（1）使用页表的地址翻译</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%A1%B5%E9%9D%A2%E5%91%BD%E4%B8%AD%E6%97%B6%EF%BC%8CCPU%E7%A1%AC%E4%BB%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.5.2.</span> <span class="toc-text">（2）页面命中时，CPU硬件执行的步骤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%A6%82%E6%9E%9CPTE%E6%9C%89%E6%95%88%E4%BD%8D%E4%B8%BA0%EF%BC%8C%E5%88%99%E5%8F%91%E7%94%9F%E7%BC%BA%E9%A1%B5%EF%BC%8C%E5%A4%84%E7%90%86%E7%BC%BA%E9%A1%B5%E8%A6%81%E6%B1%82%E7%A1%AC%E4%BB%B6%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E5%8D%8F%E4%BD%9C%E5%AE%8C%E6%88%90%E3%80%82"><span class="toc-number">2.5.3.</span> <span class="toc-text">（3）如果PTE有效位为0，则发生缺页，处理缺页要求硬件和操作系统内核协作完成。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8TLB%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">2.5.4.</span> <span class="toc-text">（4）使用TLB加速地址翻译</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.5.5.</span> <span class="toc-text">（5）多级页表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89k-%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">2.5.6.</span> <span class="toc-text">（6）k 级页表层次结构的地址翻译</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6、Linux虚拟内存系统</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">2.6.1.</span> <span class="toc-text">（1）Linux虚拟内存区域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Linux%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">（2）Linux缺页异常处理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.7.</span> <span class="toc-text">7、内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.1.</span> <span class="toc-text">（1）共享对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-fork-%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E8%87%AA%E5%B7%B1%E7%8B%AC%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">（2） fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89execve-%E5%87%BD%E6%95%B0%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.7.3.</span> <span class="toc-text">（3）execve 函数实际上是如何加载和执行程序的？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BD%BF%E7%94%A8mmap%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.7.4.</span> <span class="toc-text">（4）使用mmap函数的用户级内存映射</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.8.</span> <span class="toc-text">8、动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%88%86%E9%85%8D%E5%99%A8%E2%80%93%E6%98%BE%E5%BC%8F%E5%92%8C%E9%9A%90%E5%BC%8F"><span class="toc-number">2.8.1.</span> <span class="toc-text">（1）分配器–显式和隐式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A2%8E%E7%89%87"><span class="toc-number">2.8.2.</span> <span class="toc-text">（2）碎片</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.8.3.</span> <span class="toc-text">（3）隐式空闲链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%94%BE%E7%BD%AE%E5%B7%B2%E5%88%86%E9%85%8D%E7%9A%84%E5%9D%97%E2%80%93%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="toc-number">2.8.4.</span> <span class="toc-text">（4）放置已分配的块–放置策略</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%8E%B7%E5%8F%96%E9%A2%9D%E5%A4%96%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">2.8.5.</span> <span class="toc-text">（5）获取额外的堆内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%90%88%E5%B9%B6%E7%A9%BA%E9%97%B2%E5%9D%97"><span class="toc-number">2.8.6.</span> <span class="toc-text">（6）合并空闲块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%B8%A6%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">2.8.7.</span> <span class="toc-text">（7）带边界标记的合并</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.8.8.</span> <span class="toc-text">（8）显式空闲链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E5%88%86%E7%A6%BB%E7%9A%84%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8"><span class="toc-number">2.8.9.</span> <span class="toc-text">（9）分离的空闲链表</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">2.9.</span> <span class="toc-text">9、垃圾收集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88garbage-collector"><span class="toc-number">2.9.1.</span> <span class="toc-text">（1）垃圾收集器（garbage collector)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89-Mark-amp-Sweep-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">（2） Mark&amp;Sweep 垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%8E%E5%86%85%E5%AD%98%E6%9C%89%E5%85%B3%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">2.10.</span> <span class="toc-text">10、常见的与内存有关的错误</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BA%A7I-O"><span class="toc-number">3.</span> <span class="toc-text">三、系统级I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81Unix-I-O"><span class="toc-number">3.1.</span> <span class="toc-text">1、Unix I&#x2F;O</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">2、文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.</span> <span class="toc-text">3、共享文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81I-O%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">3.4.</span> <span class="toc-text">4、I&#x2F;O重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81Unix-I-O%E3%80%81%E6%A0%87%E5%87%86-VO-%E5%92%8C-RIO-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.</span> <span class="toc-text">5、Unix I&#x2F;O、标准 VO 和 RIO 之间的关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1、客户端-服务器编程模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BD%91%E7%BB%9C"><span class="toc-number">4.2.</span> <span class="toc-text">2、网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81IP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%9F%9F%E5%90%8D"><span class="toc-number">4.3.</span> <span class="toc-text">3、IP地址和域名</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F-amp-amp-%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6"><span class="toc-number">4.3.1.</span> <span class="toc-text">（1）网络字节顺序和主机字节顺序&amp;&amp;点分十进制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9B%A0%E7%89%B9%E7%BD%91%E5%9F%9F%E5%90%8D"><span class="toc-number">4.3.2.</span> <span class="toc-text">（2）因特网域名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%9B%A0%E7%89%B9%E7%BD%91%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.3.3.</span> <span class="toc-text">（3）因特网连接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">4.4.</span> <span class="toc-text">4、套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">（1）套接字地址结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">（2）套接字函数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%BB%E6%9C%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.3.</span> <span class="toc-text">（3）主机和服务的转换函数</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">5.Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A5%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BE%9B%E5%86%85%E5%AE%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">（1）Web 服务器以两种不同的方式向客户端提供内容</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%80%9A%E7%94%A8%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6URL"><span class="toc-number">4.5.2.</span> <span class="toc-text">（2）通用资源定位符URL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">4.5.3.</span> <span class="toc-text">（3）HTTP请求和响应</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%8A%A8%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">4.5.4.</span> <span class="toc-text">（4）服务动态内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">五、并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">1、构造并发程序的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">（1）进程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">（2）I&#x2F;O多路复用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">（3）线程</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">2、基于进程的并发编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%9F%BA%E4%BA%8EI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">3、基于I&#x2F;O多路复用的并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.1.</span> <span class="toc-text">（1） I&#x2F;O 多路复用技术</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9F%BA%E4%BA%8E-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">（2）基于 I&#x2F;O 多路复用的并发事件驱动服务器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">4、基于线程的并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">（1）线程执行模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">（2）创建线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">（3）终止线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%9B%9E%E6%94%B6%E5%B7%B2%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">5.4.4.</span> <span class="toc-text">（4）回收已终止线程的资源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%88%86%E7%A6%BB%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.5.</span> <span class="toc-text">（5）分离线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.6.</span> <span class="toc-text">（6）初始化线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.4.7.</span> <span class="toc-text">（7）基于线程的并发服务器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-number">5.5.</span> <span class="toc-text">5、多线程程序中的共享变量</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">（1）线程内存模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B0%86%E5%8F%98%E9%87%8F%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98"><span class="toc-number">5.5.2.</span> <span class="toc-text">（2）将变量映射到内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F"><span class="toc-number">5.5.3.</span> <span class="toc-text">（3）共享变量</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.6.</span> <span class="toc-text">6、用信号量同步线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.6.1.</span> <span class="toc-text">（1）信号量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">5.6.2.</span> <span class="toc-text">（2）使用信号量来实现互斥</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E9%A1%BA%E5%BA%8F%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E9%9B%86%E5%90%88%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.7.</span> <span class="toc-text">7、顺序、并发和并行程序集合之间的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E5%88%BB%E7%94%BB%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">5.8.</span> <span class="toc-text">8、刻画并行程序的性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E5%85%B6%E4%BB%96%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">5.9.</span> <span class="toc-text">9、其他并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.9.1.</span> <span class="toc-text">（1）线程安全</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">5.9.2.</span> <span class="toc-text">（2）可重入性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%AB%9E%E4%BA%89"><span class="toc-number">5.9.3.</span> <span class="toc-text">（3）竞争</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%AD%BB%E9%94%81"><span class="toc-number">5.9.4.</span> <span class="toc-text">（4）死锁</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___8CRApSLbi1w___0___.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>