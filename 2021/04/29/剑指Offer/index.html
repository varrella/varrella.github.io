<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>刷题 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本篇笔记中的题解参考了https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;jyd&#x2F;。 一、二叉树二叉树的数据结构： 123456struct TreeNode &amp;#123;	int val;	TreeNode* left;	TreeNode* right;	TreeNode(int x) :val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="刷题">
<meta property="og:url" content="https://varrella.github.io/2021/04/29/%E5%89%91%E6%8C%87Offer/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="本篇笔记中的题解参考了https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;jyd&#x2F;。 一、二叉树二叉树的数据结构： 123456struct TreeNode &amp;#123;	int val;	TreeNode* left;	TreeNode* right;	TreeNode(int x) :val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;&amp;#12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___0G1r-Cg0zS8___0___.jpg">
<meta property="article:published_time" content="2021-04-29T10:05:52.705Z">
<meta property="article:modified_time" content="2021-10-17T10:31:16.545Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___0G1r-Cg0zS8___0___.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/04/29/%E5%89%91%E6%8C%87Offer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-17 18:31:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___0G1r-Cg0zS8___0___.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">刷题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-29T10:05:52.705Z" title="Created 2021-04-29 18:05:52">2021-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-10-17T10:31:16.545Z" title="Updated 2021-10-17 18:31:16">2021-10-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="刷题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本篇笔记中的题解参考了<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/jyd/%E3%80%82">https://leetcode-cn.com/u/jyd/。</a></p>
<h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h3><p>二叉树的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1、从上到下打印二叉树【剑指Offer-32-1-medium】"><a href="#1、从上到下打印二叉树【剑指Offer-32-1-medium】" class="headerlink" title="1、从上到下打印二叉树【剑指Offer 32-1 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树【剑指Offer 32-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span><br><span class="line">例如:给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回：[3,9,20,15,7]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>层次遍历。队列。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、从上到下打印二叉树-III【剑指Offer-32-3-medium】"><a href="#2、从上到下打印二叉树-III【剑指Offer-32-3-medium】" class="headerlink" title="2、从上到下打印二叉树 III【剑指Offer 32-3 | medium】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">从上到下打印二叉树 III【剑指Offer 32-3 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span><br><span class="line">例如:给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>层次遍历。把每层的节点存入<code>vector</code>中，并记录当前层次，如果当前层次为偶数，则逆序。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;TreeNode*&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">		layer++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">			tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">			Q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (layer % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		result.<span class="built_in">push_back</span>(tmp);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、从上到下打印二叉树-II【剑指Offer-32-2-easy】"><a href="#3、从上到下打印二叉树-II【剑指Offer-32-2-easy】" class="headerlink" title="3、从上到下打印二叉树 II【剑指Offer 32-2 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II【剑指Offer 32-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>层次遍历，用队列的size()来表示每层的节点个数。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	queue&lt;TreeNode*&gt; Q;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">				tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">				Q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、二叉树的层序遍历-II【LeetCode-107-medium】"><a href="#4、二叉树的层序遍历-II【LeetCode-107-medium】" class="headerlink" title="4、二叉树的层序遍历 II【LeetCode 107 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历 II【LeetCode 107 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其自底向上的层序遍历为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>普通层序遍历加一个数组反转就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、二叉树的镜像【剑指Offer-27-easy】【LeetCode-226-medium】"><a href="#5、二叉树的镜像【剑指Offer-27-easy】【LeetCode-226-medium】" class="headerlink" title="5、二叉树的镜像【剑指Offer 27 | easy】【LeetCode 226 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像【剑指Offer 27 | easy】【LeetCode 226 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class="line">例如输入：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line">镜像输出：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>递归。用<code>tmp</code>暂存<code>root</code>的左子节点，递归右子节点，返回值作为<code>root</code>的左子节点；递归左子节点，返回值作为<code>root</code>的右子节点。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode* tmp = root-&gt;left;</span><br><span class="line">	root-&gt;left = <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">	root-&gt;right = <span class="built_in">mirrorTree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、对称的二叉树【剑指Offer-28-easy】"><a href="#6、对称的二叉树【剑指Offer-28-easy】" class="headerlink" title="6、对称的二叉树【剑指Offer 28 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树【剑指Offer 28 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>递归。对于两棵子树<code>L</code>和<code>R</code>，判断两节点<code>L-&gt;left</code>和<code>R-&gt;right</code>是否对称，即<code>recur(L-&gt;left, R-&gt;right)</code>；判断两节点<code>L-&gt;right</code>和<code>R-&gt;left</code>是否对称，即<code>recur(L-&gt;right, R-&gt;left)</code>；对称则应该为L的左子树节点的值等于R的右子树节点的值。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* L, TreeNode* R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> &amp;&amp; R == <span class="literal">nullptr</span>) &#123;  <span class="comment">// L和R都为空，则true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> || R == <span class="literal">nullptr</span> || L-&gt;val != R-&gt;val) &#123; <span class="comment">// L和R有一个为空或者二者值不相等，则为false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归比较L-&gt;left和R-&gt;right以及L-&gt;right和R-&gt;left是否相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(L-&gt;left, R-&gt;right) &amp;&amp; <span class="built_in">recur</span>(L-&gt;right, R-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="built_in">recur</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。使用队列来比较两个树（根节点的左右子树）是否是相互翻转的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">    q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* leftNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        TreeNode* rightNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">        q.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">        q.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、二叉树的最大深度【剑指Offer-55-1-easy】【LeetCode-104-medium】"><a href="#7、二叉树的最大深度【剑指Offer-55-1-easy】【LeetCode-104-medium】" class="headerlink" title="7、二叉树的最大深度【剑指Offer 55-1 | easy】【LeetCode 104 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的最大深度【剑指Offer 55-1 | easy】【LeetCode 104 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span><br><span class="line">例如：给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br><span class="line"></span><br><span class="line">提示：节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>迭代法。层次遍历。用队列的<code>size()</code>来表示每层的节点个数。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		queue&lt;TreeNode*&gt; Q;</span><br><span class="line">		Q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">				Q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			height++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、二叉树的最小深度【LeetCode-111-easy】"><a href="#8、二叉树的最小深度【LeetCode-111-easy】" class="headerlink" title="8、二叉树的最小深度【LeetCode 111 | easy】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度【LeetCode 111 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span><br><span class="line">说明：叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210801140009.png" style="zoom:50%;" />

<p><strong>【解法】</strong>需要单独考虑左右子树为空的情况。当左子树为空，最小深度并不是为1，而是右子树中最小的深度；当右子树为空，最小深度并不是为1， 而是左子树中最小的深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、平衡二叉树【剑指Offer-55-2-easy】【LeetCode-110-easy】"><a href="#9、平衡二叉树【剑指Offer-55-2-easy】【LeetCode-110-easy】" class="headerlink" title="9、平衡二叉树【剑指Offer 55-2 | easy】【LeetCode 110 | easy】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">平衡二叉树【剑指Offer 55-2 | easy】【LeetCode 110 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span><br><span class="line">示例 1:给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法1（最优）】后序遍历+剪枝，对二叉树做后序遍历，从底至顶返回子树深度，因为在遍历到一个节点之前已经遍历了它的左右子树，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBalanced</span>(root-&gt;left, l) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right, r)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(l - r) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			depth = <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalanced</span>(root, depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>先序遍历+判断深度。构造一个获取当前子树的深度的函数<code>depth(root) </code>，通过比较左右子树的深度差<code>abs(depth(root.left) - depth(root.right)) &lt;= 1</code>是否成立，来判断某子树是否是二叉平衡树。然后递归判断左右子树是否都是平衡树。时间复杂度<code>O(NlogN)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left), <span class="built_in">depth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">abs</span>(<span class="built_in">depth</span>(root-&gt;left) - <span class="built_in">depth</span>(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、二叉搜索树的第k大节点【剑指Offer-54-easy】"><a href="#10、二叉搜索树的第k大节点【剑指Offer-54-easy】" class="headerlink" title="10、二叉搜索树的第k大节点【剑指Offer 54 | easy】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点【剑指Offer 54 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一棵二叉搜索树，请找出其中第k大的节点。</span><br><span class="line">示例 1:输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 2:输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br><span class="line"> </span><br><span class="line">限制：1 ≤ k ≤ 二叉搜索树元素个数</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二叉搜索树的中序遍历的倒序为递减序列。在遍历的过程中不断将<code>k-1</code>，直到为0。时间复杂度<code>O(NlogN)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> k, res;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">			res = root-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">		<span class="built_in">dfs</span>(root);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11、二叉搜索树的最近公共祖先【剑指Offer-68-1-easy】"><a href="#11、二叉搜索树的最近公共祖先【剑指Offer-68-1-easy】" class="headerlink" title="11、二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line">说明：所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br><span class="line">例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424130042.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>迭代法。循环搜索，当<code>p</code>、<code>q</code>都在<code>root</code>的左子树中，则遍历到<code>root-&gt;left</code>；当<code>p</code>、<code>q</code>都在<code>root</code>的右子树中，则遍历到<code>root-&gt;right</code>；如果<code>p</code>、<code>q</code>在<code>root</code>的两侧，则<code>root</code>即为最近公共祖先。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (root) &#123;</span><br><span class="line">		<span class="comment">// p、q都在root的左子树中</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// p、q都在root的右子树中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p、q分别在root的两侧</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>递归。若<code>p</code>、<code>q</code>都在<code>root</code>的左子树中，则递归遍历左子树；若<code>p</code>、<code>q</code>都在<code>root</code>的右子树中，则递归遍历右子树；时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p、q都在root的左子树中</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// p、q都在root的右子树中</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、二叉树的最近公共祖先【剑指Offer-68-2-easy】"><a href="#12、二叉树的最近公共祖先【剑指Offer-68-2-easy】" class="headerlink" title="12、二叉树的最近公共祖先【剑指Offer 68-2 | easy】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先【剑指Offer 68-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</span><br><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424130223.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>如果找到⼀个节点，发现左⼦树出现结点<code>p</code>，右⼦树出现节点<code>q</code>，或者 左⼦树出现结点<code>q</code>，右⼦树出现节点<code>p</code>，那么 该节点就是节点<code>p</code>和<code>q</code>的最近公共祖先。递归左子树，返回值为<code>left</code>；递归右子树，返回值为<code>right</code>；<code>left</code>和<code>right</code>同时为空，则返回空；<code>left</code>和<code>right</code>同时不为空，说明<code>p</code>、<code>q</code>在<code>root</code>异侧，返回<code>root</code>；当<code>left</code>为空<code>right</code>不为空，则<code>p</code>、<code>q</code>都不在左子树中，返回<code>right</code>；当<code>right</code>为空<code>left</code>不为空，则<code>p</code>、<code>q</code>都不在右子树中，返回<code>left</code>。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果树为空则直接返回空；如果root等于p、q其中一个，那么最近公共祖先即为root，返回root</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归遍历左子树，在左子树中寻找p或q</span></span><br><span class="line">	TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	<span class="comment">// 递归遍历右子树，在右子树中寻找p或q</span></span><br><span class="line">	TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 左子树中没找到p和q，则必然在右子树中;右子树中没找到p和q，则必然在左子树中;</span></span><br><span class="line">    <span class="comment">// 否则p、q在root两侧，则root即为最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> (left == <span class="literal">nullptr</span>) ? right: ((right == <span class="literal">nullptr</span>) ? left : root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、二叉搜索树的最近公共祖先【LeetCode-235-easy】"><a href="#13、二叉搜索树的最近公共祖先【LeetCode-235-easy】" class="headerlink" title="13、二叉搜索树的最近公共祖先【LeetCode 235 | easy】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先【LeetCode 235 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】</span><br><span class="line">示例：</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210805171055.png"></p>
<p>由于是二叉搜索树，自带排序，在有序树里，如果判断⼀个节点的左子树⾥有<code>p</code>，右子树⾥有<code>q</code>呢？</p>
<p>只要从上到下遍历的时候，<code>root</code>节点是数值在<code>[p, q]</code>区间中则说明该节点<code>root</code>就是最近公共祖先了。</p>
<p><strong>【解法】</strong>递归。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; Math.max(p.val, q.val))&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; Math.min(p.val, q.val))&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; Math.max(p.val, q.val))&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; Math.min(p.val, q.val))&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、树的子结构【剑指Offer-26-medium】"><a href="#14、树的子结构【剑指Offer-26-medium】" class="headerlink" title="14、树的子结构【剑指Offer 26 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构【剑指Offer 26 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line">B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br><span class="line">例如:给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>递归判断<code>B</code>是否是<code>A</code>的左子树的子结构，<code>B</code>是否是<code>A</code>的右子树的子结构。时间复杂度<code>O(MN)</code>，空间复杂度<code>O(M)</code>，<code>M</code>、<code>N</code>分别为<code>A</code>、<code>B</code>的节点数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当A或B为空时直接返回false；若树 B 是树 A 的子结构，则有三种情况：</span></span><br><span class="line">    <span class="comment">// 以 节点 A 为根节点的子树 包含树 B， 即(recur(A, B)</span></span><br><span class="line">    <span class="comment">// 树 B 是 树 A 左子树的子结构，对应 isSubStructure(A-&gt;left, B)；</span></span><br><span class="line">    <span class="comment">// 树 B 是 树 A 右子树的子结构，对应 isSubStructure(A-&gt;right, B)；</span></span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">nullptr</span> &amp;&amp; B != <span class="literal">nullptr</span>) &amp;&amp; (<span class="built_in">recur</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || 			<span class="built_in">isSubStructure</span>(A-&gt;right, B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断以A为根节点的树和以B为根节点的树是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || A-&gt;val != B-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">recur</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、重建二叉树（前序和中序）【剑指Offer-07-medium】【LeetCode-105-medium】"><a href="#15、重建二叉树（前序和中序）【剑指Offer-07-medium】【LeetCode-105-medium】" class="headerlink" title="15、重建二叉树（前序和中序）【剑指Offer 07 | medium】【LeetCode 105 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树（前序和中序）【剑指Offer 07 | medium】【LeetCode 105 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，给出：</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>哈希表中保存中序遍历序列值和索引的对应关系，在建树的过程中遍历前序遍历序列，找出根节点，根据哈希表找到根节点在中序序列中的索引，根据索引值确定左右子树的范围，递归构造左子树和右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; preorder;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="comment">// root_index为前序序列中根节点对应的索引值，left为树的左边界，right为树的右边界</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[root_index]);</span><br><span class="line">		<span class="keyword">int</span> index = dic[preorder[root_index]];</span><br><span class="line">        <span class="comment">// 左子树的根节点索引为上一个根节点索引值加1</span></span><br><span class="line">		node-&gt;left = <span class="built_in">recur</span>(root_index + <span class="number">1</span>, left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// index - left + 1为左子树加根节点的长度，加上根的索引值root_index，即为右子树的根节点索引</span></span><br><span class="line">		node-&gt;right = <span class="built_in">recur</span>(root_index + index - left + <span class="number">1</span>, index + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			dic[inorder[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recur</span>(<span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="16、从中序与后序遍历序列构造二叉树【LeetCode-106-medium】"><a href="#16、从中序与后序遍历序列构造二叉树【LeetCode-106-medium】" class="headerlink" title="16、从中序与后序遍历序列构造二叉树【LeetCode 106 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树【LeetCode 106 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。</span><br><span class="line">例如，给出</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>哈希表中保存中序遍历序列值和索引的对应关系，在建树的过程中，遍历后序遍历序列，找出根节点，根据哈希表找到根节点在中序序列中的索引，根据索引值递归构造左子树和右子树。<code>left</code>和<code>right</code>是用来在中序序列中计算左右子树节点个数的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; postorder;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[root_index]);</span><br><span class="line">		<span class="keyword">int</span> index = unmap[postorder[root_index]];</span><br><span class="line">        <span class="comment">// right - index + 1为右子树加根节点的长度，用根节点的索引减去该长度，即为左子树的根节点索引：root_index-(right - index + 1)，左子树左边界是left，右边界是根节点索引减1</span></span><br><span class="line">		node-&gt;left = <span class="built_in">recur</span>(root_index - right + index - <span class="number">1</span>, left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点索引为上一个根节点索引值减1，右子树的左边界是根节点索引加1，右边界是right</span></span><br><span class="line">		node-&gt;right = <span class="built_in">recur</span>(root_index - <span class="number">1</span>, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;postorder = postorder;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			unmap[inorder[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recur</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="17、二叉搜索树的后序遍历序列【剑指Offer-33-medium】"><a href="#17、二叉搜索树的后序遍历序列【剑指Offer-33-medium】" class="headerlink" title="17、二叉搜索树的后序遍历序列【剑指Offer 33 | medium】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列【剑指Offer 33 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span><br><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">提示：数组长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>借助一个单调栈存储值递增的节点；每当遇到值递减的节点 ，则通过出栈来更新节点的父节点<code>root</code>，每轮判断当前节点和父节点的关系，如果大于<code>root</code>，则不满足二叉搜索树定义，返回<code>false</code>；如果小于<code>root</code>，则满足二叉搜索树的定义，则继续遍历。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<p>设后序遍历倒序列表为<code>[rn, r(n-1),...,r1]</code>，遍历此列表，设索引为<code>i</code>，若为 二叉搜索树 ，则有：</p>
<ul>
<li>当节点值<code>ri &gt; r(i+1)</code>时： 节点<code>ri</code>一定是节点<code>r(i+1)</code>的右子节点。</li>
<li>当节点值<code>ri &lt; r(i+1)</code>时： 节点<code>ri</code>一定是某节点<code>root</code>的左子节点，且<code>root</code>为节点<code>r(i+1), r(i+2),..., r(n)</code>中值大于且最接近 <code>ri</code>的节点（∵<code>root</code>直接连接 左子节点<code>ri</code>）。</li>
<li>当遍历时遇到递减节点<code>ri &lt; r(i+1)</code>，若为二叉搜索树，则对于后序遍历中节点<code>ri</code>左边的任意节点<code>rx∈[r  (i−1), r(i-2),......,r1]</code> ，必有节点值<code>rx &lt; root</code>。节点<code>rx</code>只可能为以下两种情况：①<code>rx</code>为<code>ri</code>的左、右子树的各节点；②<code>rx</code>为<code>root</code>的父节点或更高层父节点的左子树的各节点。在二叉搜索树中，以上节点都应小于<code>root</code>。</li>
<li>遍历 “后序遍历的倒序” 会多次遇到递减节点<code>ri</code>，若所有的递减节点<code>ri</code>对应的父节点<code>root</code>都满足以上条件，则可判定为二叉搜索树。</li>
<li>根据以上特点，考虑借助<strong>单调栈</strong>实现：<ul>
<li>借助一个单调栈<code>stack</code>存储值递增的节点；</li>
<li>每当遇到值递减的节点<code>ri</code>，则通过出栈来更新节点<code>ri</code>的父节点<code>root</code>；</li>
<li>每轮判断<code>ri</code>和<code>root</code>的值关系：<ul>
<li>若<code>ri &gt; root</code>则说明不满足二叉搜索树定义，直接返回<code>false</code>。</li>
<li>若<code>ri &lt; root</code>则说明满足二叉搜索树定义，则继续遍历。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> root = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新来的元素比栈顶元素小，出栈来维护单调性</span></span><br><span class="line">        <span class="keyword">while</span> (!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() &gt; postorder[i]) &#123;</span><br><span class="line">            root = S.<span class="built_in">top</span>();  <span class="comment">// 更新root</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新来的元素比栈顶元素大，直接入栈</span></span><br><span class="line">        S.<span class="built_in">push</span>(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>根据二叉搜索树的性质递归判断所有子树的正确性。遍历后序序列<code>[i, j]</code>，寻找第一个大于根节点的节点，索引为<code>m</code>，此时可以划分出左子树区间<code>[i, m-1]</code>，右子树区间<code>[m, j-1]</code>，递归判断左右子树区间对应的是否是二叉搜索树。时间复杂度<code>O(N^2)</code>，空间复杂度<code>O(N)</code>。</p>
<ul>
<li>递推工作：<ul>
<li>划分左右子树： 遍历后序遍历的<code>[i, j]</code>区间元素，寻找第一个大于根节点的节点，索引记为<code>m</code>。此时，可划分出左子树区间<code>[i,m-1]</code>、右子树区间<code>[m, j - 1]</code>、根节点索引<code>j</code>。</li>
<li>判断是否为二叉搜索树：<ul>
<li>左子树区间<code>[i, m - 1]</code>内的所有节点都应<code>&lt; postorder[j]</code>。而第上一步骤中划分左右子树步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li>
<li>右子树区间<code>[m, j-1]</code>内的所有节点都应<code>&gt; postorder[j]</code>。实现方式为遍历，当遇到<code>≤ postorder[j]</code>的节点则跳出；则可通过<code>p = j</code>判断是否为二叉搜索树。</li>
<li>返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符<code>&amp;&amp;</code>连接。<ul>
<li><code>p = j</code>： 判断 此树 是否正确。</li>
<li><code>recur(i, m - 1)</code>： 判断 此树的左子树 是否正确。</li>
<li><code>recur(m, j - 1)</code>： 判断 此树的右子树 是否正确。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从左到右找到第一个比根节点大的节点对应的索引</span></span><br><span class="line">	<span class="keyword">while</span> (postorder[p] &lt; postorder[right]) &#123;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = p;</span><br><span class="line">	<span class="comment">// 判断右子树中的节点是否都大于根节点</span></span><br><span class="line">	<span class="keyword">while</span> (postorder[p] &gt; postorder[right]) &#123;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p == right表示满足右子树都大于根节点，递归判断两个区间是否是二叉搜索树</span></span><br><span class="line">	<span class="keyword">return</span> p == right &amp;&amp; <span class="built_in">recur</span>(postorder, left, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、二叉树中和为某一值的路径【剑指Offer-34-medium】【LeetCode-113-medium】【LeetCode-112-medium】"><a href="#18、二叉树中和为某一值的路径【剑指Offer-34-medium】【LeetCode-113-medium】【LeetCode-112-medium】" class="headerlink" title="18、二叉树中和为某一值的路径【剑指Offer 34 | medium】【LeetCode 113 | medium】【LeetCode 112 | medium】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径【剑指Offer 34 | medium】【LeetCode 113 | medium】【LeetCode 112 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。</span><br><span class="line">从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</span><br><span class="line">示例:给定如下二叉树，以及目标和 target &#x3D; 22，</span><br><span class="line">              5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   8</span><br><span class="line">           &#x2F;   &#x2F; \</span><br><span class="line">          11  13  4</span><br><span class="line">         &#x2F;  \    &#x2F; \</span><br><span class="line">        7    2  5   1</span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二叉树的搜索问题，DFS+回溯。遍历每个节点，将当前节点添加到当前路径中，遍历到叶节点的时候判断当前路径和是否和目标值相等，相等则符合要求，否则回溯。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;target, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">	target -= root-&gt;val;</span><br><span class="line">	<span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root-&gt;left, target, result, path);</span><br><span class="line">	<span class="built_in">dfs</span>(root-&gt;right, target, result, path);</span><br><span class="line">	target += root-&gt;val;   <span class="comment">// 遍历完左右子树后回溯</span></span><br><span class="line">	path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">	<span class="built_in">dfs</span>(root, target, result, path);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【LeetCode 112】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19、序列化和反序列化二叉树【剑指Offer-37-medium】"><a href="#19、序列化和反序列化二叉树【剑指Offer-37-medium】" class="headerlink" title="19、序列化和反序列化二叉树【剑指Offer 37 | medium】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">序列化和反序列化二叉树【剑指Offer 37 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line">示例: 你可以将以下二叉树：</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>序列化过程中，层次遍历，遇到空节点则表示为<code>&quot;# &quot;</code>；</p>
<p>反序列化过程中，遍历字符串，将每个值构造一个对应的节点存入数组中，遍历节点数组，根据左右节点和根节点的索引关系构造左右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	ostringstream output;</span><br><span class="line">	queue&lt;TreeNode*&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) output &lt;&lt; <span class="string">&quot;# &quot;</span>;  <span class="comment">// 注意#后面有个空格，否则反序列化函数中的stoi函数会报错</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			output &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> output.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;TreeNode*&gt; node_vec;</span><br><span class="line">	string val;</span><br><span class="line">	<span class="function">istringstream <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (input &gt;&gt; val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">			node_vec.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node_vec.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node_vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node_vec[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node_vec[i]-&gt;left = node_vec[pos++];</span><br><span class="line">		node_vec[i]-&gt;right = node_vec[pos++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【补充说明】</strong><code>ostringstream</code>：向<code>string</code>中写入数据，使用它来格式化字符串，最后通过<code>str()</code>得到<code>stream</code>中的<code>string</code>拷贝。</p>
<p><code>istringstream</code>：从<code>string</code>中读取数据，例如 有一行单词，然后对该行单词中的各个单词逐个处理。</p>
<p>包含在头文件<code>#include &lt;sstream&gt;</code>中。</p>
<h5 id="20、二叉树遍历-【LeetCode-94-144-145-easy】迭代"><a href="#20、二叉树遍历-【LeetCode-94-144-145-easy】迭代" class="headerlink" title="20、二叉树遍历 【LeetCode 94 /144/145| easy】迭代"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树遍历 【LeetCode 94 /144/145| easy】迭代</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (root || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、二叉树的右视图【LeetCode-199-medium】"><a href="#21、二叉树的右视图【LeetCode-199-medium】" class="headerlink" title="21、二叉树的右视图【LeetCode 199 | medium】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图【LeetCode 199 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210731222027.png" style="zoom:67%;" />

<p><strong>【解法】</strong>记录每层的最后一个节点，即为右视图中的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否是当前层的最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;			</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、N-叉树的层序遍历【LeetCode-429-medium】"><a href="#22、N-叉树的层序遍历【LeetCode-429-medium】" class="headerlink" title="22、N 叉树的层序遍历【LeetCode 429 | medium】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">N 叉树的层序遍历【LeetCode 429 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210731225723.png" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210731225733.png" style="zoom:67%;" />

<p><strong>【解法】</strong>同层次遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">		val = _val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">		val = _val;</span><br><span class="line">		children = _children;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;children[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23、填充每个节点的下一个右侧节点指针【LeetCode-116-medium】"><a href="#23、填充每个节点的下一个右侧节点指针【LeetCode-116-medium】" class="headerlink" title="23、填充每个节点的下一个右侧节点指针【LeetCode 116 | medium】"></a>23、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针【LeetCode 116 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</span><br><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br><span class="line">填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210731231314.png"></p>
<p><strong>【解法】</strong>层次遍历。遍历过程中将节点串联起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, Node* _left, Node* _right, Node* _next)</span><br><span class="line">        : <span class="built_in">val</span>(_val), <span class="built_in">left</span>(_left), <span class="built_in">right</span>(_right), <span class="built_in">next</span>(_next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                node-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是普通二叉树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">        Node *last = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            Node *f = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;left) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(f-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f-&gt;right) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(f-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span>) &#123; <span class="comment">// 如果不是头节点，则串联成链表</span></span><br><span class="line">                last-&gt;next = f;</span><br><span class="line">            &#125;</span><br><span class="line">            last = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="24、完全二叉树的节点个数【LeetCode-222-medium】"><a href="#24、完全二叉树的节点个数【LeetCode-222-medium】" class="headerlink" title="24、完全二叉树的节点个数【LeetCode 222 | medium】"></a>24、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数【LeetCode 222 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</span><br><span class="line">完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210801214117.png" style="zoom:50%;" />

<p><strong>【解法】</strong>可以按照普通二叉树遍历的方法，即迭代和递归。但完全⼆叉树只有两种情况，情况⼀：就是满⼆叉树，情况⼆：最后⼀层叶⼦节点没有满。对于情况⼀，可以直接⽤（2^树深度 - 1）来计算，注意这⾥根节点深度为1。 对于情况⼆，分别递归左孩⼦，和右孩⼦，递归到某⼀深度⼀定会有左孩⼦或者右孩⼦为满⼆叉树，然后依然可以 按照情况1来计算。时间复杂度：<code>O(logn * logn) </code>，空间复杂度：<code>O(logn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = root-&gt;left;</span><br><span class="line">    TreeNode* right = root-&gt;right;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = <span class="number">0</span>, rightHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left) &#123;</span><br><span class="line">        left = left-&gt;left;</span><br><span class="line">        ++leftHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right) &#123;</span><br><span class="line">        right = right-&gt;right;</span><br><span class="line">        ++rightHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树高度相等(注意计算的时候是计算left-&gt;left以及right-&gt;right)，那么说明该子树是一棵满二叉树，用完全二叉树公式即可计算节点数目</span></span><br><span class="line">    <span class="keyword">if</span> (leftHeight == rightHeight) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftHeight) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是满二叉树，则继续递归左右子树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25、二叉树的所有路径【LeetCode-257-medium】"><a href="#25、二叉树的所有路径【LeetCode-257-medium】" class="headerlink" title="25、二叉树的所有路径【LeetCode 257 | medium】"></a>25、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">二叉树的所有路径【LeetCode 257 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树，返回所有从根节点到叶子节点的路径。说明: 叶子节点是指没有子节点的节点。</span><br><span class="line">示例:</span><br><span class="line">输入:</span><br><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>DFS+回溯。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;string&gt;&amp; res, string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string tmp = <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    s += tmp;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        s.<span class="built_in">pop_back</span>();   <span class="comment">// 删除最后的 “-&gt;”,占两个字符</span></span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, res, s);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, res, s);</span><br><span class="line">    s.<span class="built_in">pop_back</span>();   <span class="comment">// 回溯，删除最后的 “val-&gt;”,占3个字符</span></span><br><span class="line">    s.<span class="built_in">pop_back</span>();</span><br><span class="line">    s.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="built_in">dfs</span>(root, res, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、左叶子之和【LeetCode-404-easy】"><a href="#26、左叶子之和【LeetCode-404-easy】" class="headerlink" title="26、左叶子之和【LeetCode 404 | easy】"></a>26、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">左叶子之和【LeetCode 404 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】计算给定二叉树的所有左叶子之和。</span><br><span class="line">示例：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>递归。判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。 <strong>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了⼀个左叶子</strong>。判当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> midNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        midNum += root-&gt;left-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> midNum + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right ==</span><br><span class="line">       <span class="literal">NULL</span>) &#123;   <span class="comment">// 如果是左叶子节点，则加上其值</span></span><br><span class="line">        	result += node-&gt;left-&gt;val;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="27、找树左下角的值【LeetCode-513-剑指Offer2-45-medium】"><a href="#27、找树左下角的值【LeetCode-513-剑指Offer2-45-medium】" class="headerlink" title="27、找树左下角的值【LeetCode 513  | 剑指Offer2 45| medium】"></a>27、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">找树左下角的值【LeetCode 513  | 剑指Offer2 45| medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。假设二叉树中至少有一个节点。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210802164350.png" style="zoom:100%;" />

<p><strong>【解法1】</strong>递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxVal = <span class="number">0</span>, maxHeight = INT_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxHeight) &#123;</span><br><span class="line">                maxHeight = depth;     <span class="comment">// 更新最大深度</span></span><br><span class="line">                maxVal = root-&gt;val;    <span class="comment">// 最大深度最左边节点的数值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;<span class="comment">// 以下三句等同于dfs(root-&gt;left, depth);</span></span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left, depth);   <span class="comment">// 递归遍历左子树</span></span><br><span class="line">            --depth;                  <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right, depth);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">            --depth;                  <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。LeetCode上提交显示超时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode* tmp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">		queue&lt;TreeNode*&gt; q;</span><br><span class="line">		q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			tmp = q.<span class="built_in">front</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;right) &#123;  <span class="comment">// 先将右子节点放入队列，再将左子节点放入队列，最后一个节点即为最后一层最左边的节点</span></span><br><span class="line">				q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">				q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="28、最大二叉树【LeetCode-654-medium】"><a href="#28、最大二叉树【LeetCode-654-medium】" class="headerlink" title="28、最大二叉树【LeetCode 654 | medium】"></a>28、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-binary-tree/">最大二叉树【LeetCode 654 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</span><br><span class="line">二叉树的根是数组 nums 中的最大元素。</span><br><span class="line">左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</span><br><span class="line">右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</span><br><span class="line">返回有给定数组 nums 构建的 最大二叉树 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210803175857.png" style="zoom:50%;" />

<p><strong>【解法】</strong>查找数组某个范围中的最大值的索引，该索引即为根节点的索引值。然后根据索引值，递归构造左子树和右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">// 找出(left, right)范围中的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxIndex</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[index]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildNode</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">findMaxIndex</span>(left, right);</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[index]);  <span class="comment">// 构造根节点</span></span><br><span class="line">        node-&gt;left = <span class="built_in">buildNode</span>(<span class="built_in">findMaxIndex</span>(left, index - <span class="number">1</span>), left, index - <span class="number">1</span>);</span><br><span class="line">        node-&gt;right = <span class="built_in">buildNode</span>(<span class="built_in">findMaxIndex</span>(index + <span class="number">1</span>, right), index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="built_in">findMaxIndex</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildNode</span>(root, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="29、合并二叉树【LeetCode-617-easy】"><a href="#29、合并二叉树【LeetCode-617-easy】" class="headerlink" title="29、合并二叉树【LeetCode 617 | easy】"></a>29、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树【LeetCode 617 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</span><br><span class="line">你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>递归。首先检查两种<code>root1</code>或<code>root2</code>为空的情况。然后用<code>root1+root2</code>的值构造新树的根节点，然后递归合并左子树和右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);</span><br><span class="line">    node-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">    node-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="30、二叉搜索树中的搜索【LeetCode-700-easy】"><a href="#30、二叉搜索树中的搜索【LeetCode-700-easy】" class="headerlink" title="30、二叉搜索树中的搜索【LeetCode 700 | easy】"></a>30、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索【LeetCode 700 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</span><br><span class="line">例如，</span><br><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line">和值: 2</span><br><span class="line">你应该返回如下子树:</span><br><span class="line"></span><br><span class="line">      2     </span><br><span class="line">     &#x2F; \   </span><br><span class="line">    1   3</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。由于是二叉搜索树，所以不需要用栈或队列来模拟广度搜索的迭代法。根绝值的大小来判断走左边还是右边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="31、验证二叉搜索树【LeetCode-98-medium】"><a href="#31、验证二叉搜索树【LeetCode-98-medium】" class="headerlink" title="31、验证二叉搜索树【LeetCode 98 | medium】"></a>31、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树【LeetCode 98 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><br><span class="line">假设一个二叉搜索树具有如下特征：</span><br><span class="line">节点的左子树只包含小于当前节点的数。</span><br><span class="line">节点的右子树只包含大于当前节点的数。</span><br><span class="line">所有左子树和右子树自身必须也是二叉搜索树。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>递归。判断中序遍历的数组是否有序即可。可以将中序遍历的结果保存到数组中，也可以直接在遍历的过程中进行比较。</p>
<p>陷阱：需要比较的是左⼦树<strong>所有节点</strong>小于中间节点，右⼦树<strong>所有节点</strong>大于中间节点。因此不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了，即错误写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxVal = -Long.MAX_VALUE;    <span class="comment">// 注意使用long类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> left = isValidBST(root.left);</span><br><span class="line">    <span class="comment">// maxVal即为中序遍历过程中每个节点的值，如果是BST则是递增关系</span></span><br><span class="line">    <span class="keyword">if</span>(maxVal &lt; root.val)&#123;</span><br><span class="line">        maxVal = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> right = isValidBST(root.right);</span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !st.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = st.peek();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.val &gt;= cur.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="32、二叉搜索树中的众数【LeetCode-501-easy】"><a href="#32、二叉搜索树中的众数【LeetCode-501-easy】" class="headerlink" title="32、二叉搜索树中的众数【LeetCode 501 | easy】"></a>32、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数【LeetCode 501 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</span><br><span class="line">假定 BST 有如下定义：</span><br><span class="line">结点左子树中所含结点的值小于等于当前结点的值</span><br><span class="line">结点右子树中所含结点的值大于等于当前结点的值</span><br><span class="line">左子树和右子树都是二叉搜索树</span><br><span class="line">例如：</span><br><span class="line">给定 BST [1,null,2,2],</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line">返回[2].</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>中序遍历，是有序的。即对中序遍历的有序数组求众数，可在遍历的过程中采用哈希表记录每个值出现的次数，最后进行排序得到众数（此方法适用于普通二叉树）。二叉搜索树在中序遍历的过程中进行计数，<code>count</code>用来记录每个值出现的次数，<code>maxCount</code>用来记录最大次数，在遍历的过程中更新<code>count</code>和<code>maxCount</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxCount;   <span class="comment">// 最大频率</span></span><br><span class="line">	<span class="keyword">int</span> count;      <span class="comment">// 统计频率</span></span><br><span class="line">	TreeNode* pre;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">searchBST</span>(root-&gt;left);</span><br><span class="line">		<span class="comment">// 如果是第一个节点</span></span><br><span class="line">		<span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果当前节点的值和前一个节点的值相同，则次数+1</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == root-&gt;val) &#123;</span><br><span class="line">			++count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果和上一个节点数值不同</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        pre = root;   <span class="comment">// 更新上一个节点</span></span><br><span class="line">		<span class="comment">// 如果次数和最大值相同，则放入res中</span></span><br><span class="line">		<span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果次数比最大值大，则清空res，将现在的值放入res</span></span><br><span class="line">		<span class="keyword">if</span> (maxCount &lt; count) &#123;</span><br><span class="line">			maxCount = count;</span><br><span class="line">			res.<span class="built_in">clear</span>();</span><br><span class="line">			res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">searchBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		maxCount = <span class="number">0</span>;</span><br><span class="line">		pre = <span class="literal">nullptr</span>;</span><br><span class="line">		res.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">searchBST</span>(root);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="33、二叉搜索树中的插入操作【LeetCode-701-medium】"><a href="#33、二叉搜索树中的插入操作【LeetCode-701-medium】" class="headerlink" title="33、二叉搜索树中的插入操作【LeetCode 701 | medium】"></a>33、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作【LeetCode 701 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</span><br><span class="line">注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]或[5,2,7,1,3,4]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210805175459.png"></p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210805175544.png" style="zoom:50%;" />

<p><strong>【解法】</strong>只要按照⼆叉搜索树的规则去遍历，遇到空节点就插⼊节点就可以。遍历的过程中需要记录前一个节点，方便后续添加新节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* tmp = root;   <span class="comment">// root的备份，之后进入while循环后root的值会变为nullptr</span></span><br><span class="line">    TreeNode* pre = root;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">        pre = tmp;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;val &gt; val) &#123;</span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = tmp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;val &lt; val) &#123;</span><br><span class="line">        pre-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pre-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="34、将有序数组转换为二叉搜索树【LeetCode-108-easy】"><a href="#34、将有序数组转换为二叉搜索树【LeetCode-108-easy】" class="headerlink" title="34、将有序数组转换为二叉搜索树【LeetCode 108 | easy】"></a>34、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树【LeetCode 108 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</span><br><span class="line">高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</span><br><span class="line">示例：</span><br><span class="line">输入：nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]或[0,-10,5,null,-3,null,9]</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210805214457.png" style="zoom:67%;" />

<p><strong>【解法】</strong>以数组最中间的数位根节点，左半部分递归构造左子树，右半部分递归构造右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; bst_nums;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(bst_nums[mid]);</span><br><span class="line">		node-&gt;left = <span class="built_in">buildTree</span>(left, mid - <span class="number">1</span>);</span><br><span class="line">		node-&gt;right = <span class="built_in">buildTree</span>(mid + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;bst_nums = nums;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">buildTree</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="35、删除二叉搜索树中的节点【LeetCode-450-medium】"><a href="#35、删除二叉搜索树中的节点【LeetCode-450-medium】" class="headerlink" title="35、删除二叉搜索树中的节点【LeetCode 450 | medium】"></a>35、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点【LeetCode 450 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</span><br><span class="line">一般来说，删除节点可分为两个步骤：</span><br><span class="line">首先找到需要删除的节点；</span><br><span class="line">如果找到了，删除它。</span><br><span class="line">说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class="line">key &#x3D; 3</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   6</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       7</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>有五种情况：</p>
<ul>
<li>第⼀种情况：没找到删除的节点，遍历到空节点直接返回了 </li>
<li>找到删除的节点：<ul>
<li>第⼆种情况：左右孩⼦都为空（叶⼦节点），直接删除节点， 返回NULL为根节点 </li>
<li>第三种情况：删除节点的左孩⼦为空，右孩⼦不为空，删除节点，右孩⼦补位，返回右孩⼦为根节点 </li>
<li>第四种情况：删除节点的右孩⼦为空，左孩⼦不为空，删除节点，左孩⼦补位，返回左孩⼦为根节点 </li>
<li>第五种情况：左右孩⼦节点都不为空，则将删除节点的左⼦树头结点（左孩⼦）放到删除节点的右⼦树 的最左⾯节点的左孩⼦上，返回删除节点右孩⼦为新的根节点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* cur = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left) &#123;  <span class="comment">// 找到右子树中最左边的节点作为新的左子树的根节点</span></span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;left = root-&gt;left;</span><br><span class="line">            TreeNode* tmp = root;</span><br><span class="line">            root = root-&gt;right;  <span class="comment">// root的右子树的根节点作为新的根节点</span></span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; key) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; key) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【补充：普通二叉树删除节点】</strong></p>
<p>⽤交换值的操作来删除⽬标节点。 ⽬标节点（要删除的节点）被操作了两次： 第⼀次是和⽬标节点的右⼦树最左⾯节点交换。 第⼆次直接被NULL覆盖了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;val, cur-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="36、修剪二叉搜索树【LeetCode-669-medium】"><a href="#36、修剪二叉搜索树【LeetCode-669-medium】" class="headerlink" title="36、修剪二叉搜索树【LeetCode 669 | medium】"></a>36、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树【LeetCode 669 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</span><br><span class="line">所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>如果<code>root</code>（当前节点）的元素⼩于<code>low</code>的数值，那么应该递归右⼦树，并返回右⼦树符合条件的头结点。如果<code>root</code>(当前节点)的元素⼤于<code>high</code>的，那么应该递归左⼦树，并返回左⼦树符合条件的头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; low)&#123; <span class="comment">// 如果root比区间的最小值还要小，那么root左子树必然也不满足，但右子树可能满足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; high) &#123; <span class="comment">// 如果root比区间的最大值还要大，那么root右子树必然也不满足，但左子树可能满足</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">    root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="37、把二叉搜索树转换为累加树【LeetCode-538-medium】"><a href="#37、把二叉搜索树转换为累加树【LeetCode-538-medium】" class="headerlink" title="37、把二叉搜索树转换为累加树【LeetCode 538 | medium】"></a>37、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树【LeetCode 538 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210805224545.png"></p>
<p><strong>【解法】</strong>按照右中左（数值递减）的顺序递归，即对数组<code>[8,7,6,5,4,3,2,1,0]</code>求累加和，每个节点的值等于其本身的值加上右边所有的数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">		count += root-&gt;val;</span><br><span class="line">		root-&gt;val = count;</span><br><span class="line">		<span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="38、二叉树剪枝【剑指Offer2-47-medium】"><a href="#38、二叉树剪枝【剑指Offer2-47-medium】" class="headerlink" title="38、二叉树剪枝【剑指Offer2 47 | medium】"></a>38、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pOCWxh/">二叉树剪枝【剑指Offer2 47 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。节点 node 的子树为 node 本身，以及所有 node 的后代。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,0,1,0,0,0,1]</span><br><span class="line">输出: [1,null,1,null,1]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210825220509.png"></p>
<p><strong>【解法】</strong>若把全为 0 的二叉树称为零树，那么判断一棵树为零树的的规则是，左右子树都为零树或者空指针且根节点的值为 0。因为二叉树结构的递归性质，所以可以用同样的规则判断左右子树是否为零树。在使用递归函数时，让根节点的左右指针指向左右子树递归函数的返回值，当该二叉树判断为零树（左右指针指向空指针且其根节点的值为 0），则返回空指针，反之则返回根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">pruneTree</span>(root-&gt;left);</span><br><span class="line">    root-&gt;right = <span class="built_in">pruneTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="39、从根节点到叶节点的路径数字之和【剑指Offer2-49-medium】"><a href="#39、从根节点到叶节点的路径数字之和【剑指Offer2-49-medium】" class="headerlink" title="39、从根节点到叶节点的路径数字之和【剑指Offer2 49 | medium】"></a>39、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3Etpl5/">从根节点到叶节点的路径数字之和【剑指Offer2 49 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字：例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</span><br><span class="line">计算从根节点到叶节点生成的 所有数字之和 。</span><br><span class="line">示例：</span><br><span class="line">输入：root &#x3D; [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210825224428.png" style="zoom:50%;" />

<p><strong>【解法】</strong>前序遍历过程中，记录每个节点的值，以及每个节点的和，递归遍历即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> num, <span class="keyword">int</span>&amp; sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;	</span><br><span class="line">    num += root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, num * <span class="number">10</span>, sum);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, num * <span class="number">10</span> , sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="40、向下的路径节点之和【剑指Offer2-50-medium】"><a href="#40、向下的路径节点之和【剑指Offer2-50-medium】" class="headerlink" title="40、向下的路径节点之和【剑指Offer2 50 | medium】"></a>40、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/6eUYwP/">向下的路径节点之和【剑指Offer2 50 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>原理同前缀和+哈希表求和为某个数值的子数组。在二叉树中也是先处理当前节点再依次遍历左右子节点，这个特点符合前序遍历的规则。</p>
<ul>
<li>更新当前的<code>sum</code>值为 <code>sum += root-&gt;val</code>;</li>
<li>因为<code>k = sum - target</code>，所以从哈希表中找到当前路径符合要求的个数<code>count = mp[k]</code>;</li>
<li>将当前的路径和存入哈希表<code>mp[sum]++</code>;</li>
<li>调用递归函数计算左右子树的符合要求的路径数<code>count1</code>和<code>count2</code>;</li>
<li>将以当前节点为根节点的子树的结果返回给上层节点<code>count += count1 + count2</code>；</li>
<li>回溯，更新哈希表去除记录当前的<code>sum</code>，mp[sum]–`;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> target, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;unmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> count = (unmap.<span class="built_in">count</span>(sum - target)) ? unmap[sum - target] : <span class="number">0</span>;</span><br><span class="line">    unmap[sum]++;</span><br><span class="line">    count+=<span class="built_in">dfs</span>(root-&gt;left, sum, target, unmap);</span><br><span class="line">    count+=<span class="built_in">dfs</span>(root-&gt;right, sum, target, unmap);</span><br><span class="line">    unmap[sum]--;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    unmap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>, targetSum, unmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="41、展平二叉搜索树【剑指Offer2-52-easy】"><a href="#41、展平二叉搜索树【剑指Offer2-52-easy】" class="headerlink" title="41、展平二叉搜索树【剑指Offer2 52 | easy】"></a>41、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/NYBBNL/">展平二叉搜索树【剑指Offer2 52 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一棵二叉搜索树，请 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</span><br><span class="line">示例：</span><br><span class="line">输入：root &#x3D; [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210826122244.png"></p>
<p><strong>【解法】</strong>对于正在被遍历的节点，设为<code>cur</code>，根据题意，<code>node</code>需作如下处理：</p>
<ul>
<li>不能有左子节点，即<code>cur-&gt;left=nullptr</code>直接赋值即可，因为中序遍历的当前节点已经遍历完左子树，不再需要左子树的信息</li>
<li>右节点指向中序的下一个节点，即<code>cur-&gt;right=next</code>。暂时拿不到<code>nextNode</code>，但可以反过来考虑，即<code>pre-&gt;right=cur</code>。而<code>pre</code>可以在遍历中保存，每次遍历完成，把<code>pre</code>保存为当前节点，<code>pre=cur</code><br>返回展平后的<code>head</code>节点：若<code>pre==nullptr</code>，说明<code>node</code>是第一个被遍历的节点，即是<code>head</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* first = <span class="literal">nullptr</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            first = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        pre = cur;			</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="42、二叉树中的最大路径和【LeetCode-124-hard】"><a href="#42、二叉树中的最大路径和【LeetCode-124-hard】" class="headerlink" title="42、二叉树中的最大路径和【LeetCode 124 | hard】"></a>42、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和【LeetCode 124 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</span><br><span class="line">路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210826134230.png" style="zoom:50%;" />

<p><strong>【解法】</strong>考虑实现一个简化的函数<code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。用一个变量来记录遍历过程中的最大值，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxNum = INT_MIN;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">		<span class="keyword">int</span> leftGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(root-&gt;left), <span class="number">0</span>); <span class="comment">// 计算左子树的贡献值,负数就舍弃</span></span><br><span class="line">		<span class="keyword">int</span> rightGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(root-&gt;right), <span class="number">0</span>); <span class="comment">// 计算右子树的贡献值,负数就舍弃</span></span><br><span class="line">		<span class="keyword">int</span> pricePath = root-&gt;val + leftGain + rightGain; </span><br><span class="line">		maxNum = <span class="built_in">max</span>(maxNum, pricePath);  <span class="comment">// 记录最大值</span></span><br><span class="line">		<span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(leftGain, rightGain); <span class="comment">// 相当于回溯</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">maxGain</span>(root);</span><br><span class="line">		<span class="keyword">return</span> maxNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="43、二叉搜索树中的中序后继【剑指Offer2-53-medium】"><a href="#43、二叉搜索树中的中序后继【剑指Offer2-53-medium】" class="headerlink" title="43、二叉搜索树中的中序后继【剑指Offer2  53 | medium】"></a>43、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/P5rCT8/">二叉搜索树中的中序后继【剑指Offer2  53 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：root &#x3D; [2,1,3], p &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>递归。用一个变量<code>found</code>来标记是否已经遍历到节点<code>p</code>，初始时为<code>FALSE</code>，当遍历到<code>p</code>之后，<code>found=true</code>，在这个变量变为<code>true</code>之后的第一个遍历到的节点就是结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">bool</span> found =<span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">if</span>(found)&#123;</span><br><span class="line">            res = root;</span><br><span class="line">            found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == p)&#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>迭代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            res = cur;</span><br><span class="line">            found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur == p) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="44、二叉搜索树中两个节点之和【剑指Offer2-56-easy】"><a href="#44、二叉搜索树中两个节点之和【剑指Offer2-56-easy】" class="headerlink" title="44、二叉搜索树中两个节点之和【剑指Offer2 56 | easy】"></a>44、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/opLdQZ/">二叉搜索树中两个节点之和【剑指Offer2 56 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉搜索树的 根节点 root 和一个整数 k , 请判断该二叉搜索树中是否存在两个节点它们的值之和等于 k 。假设二叉搜索树中节点的值均唯一。</span><br><span class="line">示例 1：</span><br><span class="line">输入: root &#x3D; [8,6,10,5,7,9,11], k &#x3D; 12</span><br><span class="line">输出: true</span><br><span class="line">解释: 节点 5 和节点 7 之和等于 12</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>考虑到二叉搜索树的中序遍历结果就是一个升序的数组，所以可以在这里使用双指针。一种直观的想法是先完成一次二叉搜索树的中序遍历，将结果保存在数组中，然后利用双指针在排序的数组中查找和为 k 的两个数。可以利用中序遍历的下一个结果而无需事先先得到中序遍历的结果数组。在使用双指针的时候，第一个指针指向第一个数字。第二个指针指向最后一个数字，然后每一步判断移动相应的指针。第一个指针的遍历顺序需要从小到大遍历二叉搜索树。同时第二个指针的遍历顺序需要从大到小遍历二叉搜索树，交换中序遍历算法中的指向左右子节点的指针，就可以实现按照从大到小的顺序遍历二叉搜索树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		leftCur = root;</span><br><span class="line">		rightCur = root;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="built_in">leftInorder</span>();</span><br><span class="line">		<span class="keyword">int</span> right = <span class="built_in">rightInorder</span>();</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">int</span> sum = left + right;</span><br><span class="line">			<span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">				right = <span class="built_in">rightInorder</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				left = <span class="built_in">leftInorder</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TreeNode* leftCur;</span><br><span class="line">	TreeNode* rightCur;</span><br><span class="line">	stack&lt;TreeNode*&gt; leftStack;</span><br><span class="line">	stack&lt;TreeNode* &gt; rightStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于中序数组从左往右遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">leftInorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (leftCur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			leftStack.<span class="built_in">push</span>(leftCur);</span><br><span class="line">			leftCur = leftCur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		leftCur = leftStack.<span class="built_in">top</span>();</span><br><span class="line">		leftStack.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> res = leftCur-&gt;val;</span><br><span class="line">		leftCur = leftCur-&gt;right;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 相当于中序数组从右往左遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">rightInorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (rightCur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			rightStack.<span class="built_in">push</span>(rightCur);</span><br><span class="line">			rightCur = rightCur-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		rightCur = rightStack.<span class="built_in">top</span>();</span><br><span class="line">		rightStack.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> res = rightCur-&gt;val;</span><br><span class="line">		rightCur = rightCur-&gt;left;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>











<h3 id="二、数组和矩阵"><a href="#二、数组和矩阵" class="headerlink" title="二、数组和矩阵"></a>二、数组和矩阵</h3><h5 id="1、旋转数组【LeetCode-189-medium】"><a href="#1、旋转数组【LeetCode-189-medium】" class="headerlink" title="1、旋转数组【LeetCode 189 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">旋转数组【LeetCode 189 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line">进阶：尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</span><br><span class="line">你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</span><br><span class="line"> </span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>将数组的元素向右移动 <code>k</code>次后，尾部<code>k mod n</code>个元素会移动至数组头部，其余元素向后移动<code>k mod n</code> 个位置。该方法为数组的翻转： 可以先将所有元素翻转，这样尾部的<code>k mod n</code>个元素就被移至数组头部，然后再翻转<code>[0, k mod n−1]</code>区间的元素和<code>[k mod n, n−1]</code>区间的元素即能得到最后的答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615162238.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、旋转数组的最小数字【剑指Offer-11-easy】【同LeetCode-154】"><a href="#2、旋转数组的最小数字【剑指Offer-11-easy】【同LeetCode-154】" class="headerlink" title="2、旋转数组的最小数字【剑指Offer 11 | easy】【同LeetCode 154】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字【剑指Offer 11 | easy】【同LeetCode 154】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】把一个数组最开始的若干个元素搬到数组的末尾， 称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。注意数组中可能存在重复的数。  </span><br><span class="line">示例 1：</span><br><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找，<code>left</code>和<code>right</code>分别指向数组两端，<code>mid</code>为<code>left</code>和<code>right</code>中点；</p>
<p>如果比较<code>nums[left]</code>和<code>nums[mid]</code>，如<code>[3, 4, 5, 1, 2]</code>与 <code>[1, 2, 3, 4, 5]</code> ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，无法进行查询；</p>
<p>如果比较<code>nums[right]</code>和<code>nums[mid]</code>，如<code>[1, 2, 3, 4, 5]</code>、<code>[3, 4, 5, 1, 2]</code>、<code>[2, 3, 4, 5 ,1]</code>，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p>
<p>时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123; <span class="comment">// 中间元素小于右边元素，则最小值在数组左半部分</span></span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123; <span class="comment">// 中间元素大于右边元素，则最小值在数组右半部</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">// 中间元素等于右边元素，则不能草率地下定结论最小数字在哪一边，但把 right 舍弃掉，并不影响结果</span></span><br><span class="line">			right -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、寻找旋转排序数组中的最小值【LeetCode-153-medium】"><a href="#3、寻找旋转排序数组中的最小值【LeetCode-153-medium】" class="headerlink" title="3、寻找旋转排序数组中的最小值【LeetCode 153 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值【LeetCode 153 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：</span><br><span class="line">若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</span><br><span class="line">若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</span><br><span class="line">注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</span><br><span class="line">给你一个元素值 【互不相同】 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。同上一题。因为数组元素互不相同，因此和上一题不同之处在于不需要额外判断<code>nums[mid] == nums[right]</code>的情况。时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、搜索旋转排序数组【LeetCode-33-medium】"><a href="#4、搜索旋转排序数组【LeetCode-33-medium】" class="headerlink" title="4、搜索旋转排序数组【LeetCode 33 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组【LeetCode 33 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】整数数组 nums 按升序排列，数组中的值 互不相同 。</span><br><span class="line">给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找，由于数组中不存在元素重复的情况，因此分别分为左边是递增区间和右边是递增区间来考虑。</p>
<p>时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 左边区间是递增区间，右边是旋转区间</span></span><br><span class="line">		<span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">			<span class="comment">// 如果是在递增区间中</span></span><br><span class="line">			<span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 右边是递增区间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果是在递增区间中</span></span><br><span class="line">			<span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、搜索旋转排序数组-II【LeetCode-81-medium】"><a href="#5、搜索旋转排序数组-II【LeetCode-81-medium】" class="headerlink" title="5、搜索旋转排序数组 II【LeetCode 81 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II【LeetCode 81 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】已知存在一个按非降序排列的整数数组 nums ，数组中的值 不必互不相同。</span><br><span class="line">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><br><span class="line">给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。对于数组中有重复元素的情况，二分查找时可能会有 <code>a[l] = a[mid] = a[r]</code>，此时无法判断区间<code>[l, mid]</code>和区间<code>[mid + 1, r]</code>哪个是有序的。</p>
<p>例如<code>nums=[3,1,2,3,3,3,3], target=2</code>，首次二分时无法判断区间<code>[0, 3]</code>和区间<code>[4, 6]</code>哪个是有序的。对于这种情况， 只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<p>时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> target == nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;</span><br><span class="line">			++left;</span><br><span class="line">			--right;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 左边区间是递增区间，右边是旋转区间</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 右边是递增区间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、调整数组顺序使奇数位于偶数前面【剑指Offer-11-easy】"><a href="#6、调整数组顺序使奇数位于偶数前面【剑指Offer-11-easy】" class="headerlink" title="6、调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</span><br><span class="line">示例：</span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class="line"> </span><br><span class="line">提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 50000，1 &lt;&#x3D; nums[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>设置头尾双指针，头指针向右遍历找到第一个偶数，尾指针向左遍历找到第一个奇数，二者交换，在遍历过程中始终保证头指针小于等于尾指针。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// i从左向右指向第一个偶数，j从右向左指向第一个奇数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; (nums[i] &amp; <span class="number">1</span>)) &#123; <span class="comment">// nums[i]是奇数，i++</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; !(nums[j] &amp; <span class="number">1</span>)) &#123; <span class="comment">// nums[j]是偶数，j--</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、最小的k个数【剑指Offer-40-easy】"><a href="#7、最小的k个数【剑指Offer-40-easy】" class="headerlink" title="7、最小的k个数【剑指Offer 40 | easy】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数【剑指Offer 40 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br><span class="line">示例 1：</span><br><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000，0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong><code>Top k</code>问题的最优解，快速选择算法。</p>
<p>基于快速排序的数组划分：题目只要求返回最小的<code>k</code>个数，对这<code>k</code>个数的顺序并没有要求。因此，只需要将数组划分为 最小的<code>k</code>个数 和 其他数字两部分即可，而快速排序的哨兵划分可完成此目标。</p>
<p>根据快速排序原理，如果某次哨兵划分后基准数正好是第<code>k+1</code>小的数字 ，那么此时基准数左边的所有数字便是题目所求的最小的<code>k</code>个数 。</p>
<p>根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于<code>k</code>，若 <code>true</code>则直接返回此时数组的前 k 个数字即可。</p>
<ul>
<li>哨兵划分：划分完毕后，基准数为<code>arr[i]</code>，左 / 右子数组区间分别为 <code>[l, i - 1]</code> , <code>[i + 1, r]</code>；</li>
<li>递归或返回：<ul>
<li>若<code>k &lt; i</code>，代表第<code>k + 1</code>小的数字在 左子数组中，则递归左子数组；</li>
<li>若<code>k &gt; i</code>，代表第<code>k + 1</code>小的数字在 右子数组中，则递归右子数组；</li>
<li>若<code>k = i</code>，代表此时<code>arr[k]</code>即为第<code>k + 1</code>小的数字，则直接返回数组前<code>k</code>个数字即可；</li>
</ul>
</li>
</ul>
<p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(logN)</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">quickSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right, key = nums[left];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= key) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">	<span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">quickSort2</span>(nums, i + <span class="number">1</span>, right, k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">quickSort2</span>(nums, left, i - <span class="number">1</span>, k);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	res.<span class="built_in">assign</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k &gt;= arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">quickSort2</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>快排。时间复杂度<code>O(NlogN)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[j] &gt;= nums[left] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &lt;= nums[left] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法3】</strong>最大堆。维护元素个数为<code>k</code>的最大堆，时间复杂度<code>O(Nlogk)</code>，空间复杂度<code>O(k)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q.<span class="built_in">size</span>() &lt; k) &#123; <span class="comment">// 当堆中元素个数小于k时直接入堆</span></span><br><span class="line">            Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 当堆中已有k个元素时，堆顶元素和新来的元素中最小的值入堆</span></span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(Q.<span class="built_in">top</span>());</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、数组中出现次数超过一半的数字【剑指Offer-39-easy】"><a href="#8、数组中出现次数超过一半的数字【剑指Offer-39-easy】" class="headerlink" title="8、数组中出现次数超过一半的数字【剑指Offer 39 | easy】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字【剑指Offer 39 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本题常见的三种解法：</p>
<ul>
<li>哈希表统计法： 遍历数组 <code>nums</code> ，用 <code>HashMap</code> 统计各数字的数量，即可找出众数 。此方法时间和空间复杂度均为 <code>O(N)</code> 。</li>
<li>数组排序法： 将数组 <code>nums </code>排序，数组中点的元素 一定为众数。</li>
<li><strong>【最优解】</strong>摩尔投票法： 核心理念为票数正负抵消 。时间和空间复杂度分别为 <code>O(N)</code>和<code>O(1)</code> 。</li>
</ul>
<p>【摩尔投票法】设输入数组<code>nums</code>的众数为<code> x</code>，数组长度为<code> n</code> 。本题将 “数组中出现次数超过一半的数字” 简称为 <strong>“众数”</strong>。</p>
<p>推论一： 若记众数的票数为 +1 ，非众数的票数为 −1 ，则一定有所有数字的票数和 &gt; 0 。</p>
<p>推论二： 若数组的前 a 个数字的票数和 = 0 ，则数组剩余 (n−a) 个数字的票数和一定仍 &gt; 0 ，即后(n−a) 个数字的众数仍为 x 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到众数</span></span><br><span class="line">	<span class="keyword">int</span> vote = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vote == <span class="number">0</span>) &#123;</span><br><span class="line">			x = num;</span><br><span class="line">		&#125;</span><br><span class="line">		vote += (x == num) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断找到的数是否超过数组元素的一半，如果题目中未提示是否存在超过一半的数的话需要加上这个判断</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == x) &#123;</span><br><span class="line">			++count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count &gt; nums.<span class="built_in">size</span>() / <span class="number">2</span> ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、求众数-II【LeetCode-229-medium】"><a href="#9、求众数-II【LeetCode-229-medium】" class="headerlink" title="9、求众数 II【LeetCode 229 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">求众数 II【LeetCode 229 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;3 ⌋ 次的元素。</span><br><span class="line">进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[3,2,3]</span><br><span class="line">输出：[3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：[1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：[1,1,1,3,3,2,2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>摩尔投票法。因为题目中的众数是超过三分之一的数，因此最多有两个候选人。第一次遍历进行抵消，计算是哪两个候选人得票数最多；第二次遍历给这两个候选人进行计数，验证得票数是否大于<code>n/3</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/1CE2A508441B6E210E498E307593F5A1.png"></p>
<p>【归纳】</p>
<p>如果至多选一个代表，那他的票数至少要超过一半<code>⌊ 1/2 ⌋</code>的票数；</p>
<p>如果至多选两个代表，那他们的票数至少要超过 <code>⌊ 1/3 ⌋</code> 的票数；</p>
<p>如果至多选<code>m</code>个代表，那他们的票数至少要超过<code>⌊ 1/(m+1) ⌋</code>的票数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">int</span> cand1 = nums[<span class="number">0</span>], cnt1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cand2 = nums[<span class="number">0</span>], cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == cand1) &#123;</span><br><span class="line">			++cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num == cand2) &#123;</span><br><span class="line">			++cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == <span class="number">0</span>) &#123;</span><br><span class="line">			cand1 = num;</span><br><span class="line">			++cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cnt2 == <span class="number">0</span>) &#123;</span><br><span class="line">			cand2 = num;</span><br><span class="line">			++cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			--cnt1;</span><br><span class="line">			--cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == cand1) &#123;</span><br><span class="line">			++cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num == cand2) &#123;</span><br><span class="line">			++cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(cand1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(cand2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、在排序数组中查找数字-I【剑指Offer-05-easy】"><a href="#10、在排序数组中查找数字-I【剑指Offer-05-easy】" class="headerlink" title="10、在排序数组中查找数字 I【剑指Offer 05 | easy】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字 I【剑指Offer 05 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】统计一个数字在排序数组中出现的次数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序数组中的查找用二分法。进行两次二分，第一次查找右边界<code>right</code>，第二次查找左边界<code>left</code>，<code>right-left-1</code>的值即为次数。</p>
<p>优化方法：第一次找到 <code>target</code> 的右边界，第二次找到<code> target-1</code> 的右边界，两数相减即为次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(nums, target) - <span class="built_in">helper</span>(nums, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、二维数组中的查找【剑指Offer-04-medium】"><a href="#11、二维数组中的查找【剑指Offer-04-medium】" class="headerlink" title="11、二维数组中的查找【剑指Offer 04 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找【剑指Offer 04 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line">示例:现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; n &lt;&#x3D; 1000，0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>根据数组的特点，指定两个指针 <code>i</code> 和<code>j</code>，初始时<code>i</code>指向最后一行，<code>j</code>指向第一列。比较当前值和<code>target</code>的大小，如果<code>matrix[i][j]</code>大于<code>target</code>，说明<code>matrix[i][j]</code>所在的行中所有的值都大于<code>target</code>，因此<code> i--</code>，即向上一行；如果<code>matrix[i][j]</code>小于<code>target</code>，说明<code>matrix[i][j]</code>所在的列中当前值以上的所有值都小于<code>target</code>，因此<code> j++</code>，即向右一行。时间复杂度<code>O(M+N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、0～n-1中缺失的数字【剑指Offer-53-2-easy】"><a href="#12、0～n-1中缺失的数字【剑指Offer-53-2-easy】" class="headerlink" title="12、0～n-1中缺失的数字【剑指Offer 53-2 | easy】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字【剑指Offer 53-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。比较<code>nums[mid]</code> 和 索引 <code>mid</code> 之间是否对应，如果相等，则在右半部分中查找；否则在左半部分查找。时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、构建乘积数组【剑指Offer-66-medium】"><a href="#13、构建乘积数组【剑指Offer-66-medium】" class="headerlink" title="13、构建乘积数组【剑指Offer 66 | medium】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">构建乘积数组【剑指Offer 66 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</span><br><span class="line">示例:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br><span class="line"> </span><br><span class="line">提示：所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">a.length &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本质就是两个<code>dp</code>数组，分别维护<code>i</code>左侧、右侧的乘积和<code>left[i]</code>、<code>right[i]</code>。那么每个元素除了自身之外的其他元素的乘积，即为<code>left[i]*right[i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义两个数组分别保存某个值左边的元素乘积和右边的元素乘积</span></span><br><span class="line">    <span class="comment">// 第一个元素最左边没有元素，left[0]=1</span></span><br><span class="line">    <span class="comment">// 最后一个元素右边没有元素，right[n-1]=1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span></span>;	</span><br><span class="line">    left[<span class="number">0</span>] = right[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        left[i] = left[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        right[i] = right[i + <span class="number">1</span>] * a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        res[i] = left[i] * right[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、数组中的逆序对【剑指Offer-51-hard】"><a href="#14、数组中的逆序对【剑指Offer-51-hard】" class="headerlink" title="14、数组中的逆序对【剑指Offer 51 | hard】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对【剑指Offer 51 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>归并排序和逆序对息息相关。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210501202136.png"></p>
<p><strong>算法流程：</strong><code>merge_sort()</code> 归并排序与逆序对统计：</p>
<ul>
<li>终止条件： 当<code>left ≥ right</code>时，代表子数组长度为 1 ，此时终止划分；</li>
<li>递归划分： 计算数组中点<code>mid</code>，递归划分左子数组<code>merge_sort(left, mid)</code>和右子数组<code>merge_sort(mid + 1, right)</code>；</li>
<li>合并与逆序对统计：<ul>
<li>暂存数组<code>nums</code>闭区间<code>[left, right]</code>内的元素至辅助数组<code>tmp</code>；</li>
<li>循环合并： 设置双指针<code>i</code>、<code>j</code>分别指向左、右子数组的首元素；<ul>
<li>当<code>i = mid + 1</code>时： 代表左子数组已合并完，因此添加右子数组当前元素 <code>tmp[j]</code>，并执行<code>j = j + 1</code>；</li>
<li>否则，当<code>j = r + 1</code>时： 代表右子数组已合并完，因此添加左子数组当前元素<code>tmp[i]</code>，并执行<code>i = i + 1</code>；</li>
<li>否则，当<code>tmp[i] ≤ tmp[j]</code>时： 添加左子数组当前元素<code>tmp[i]</code>，并执行<code>i = i + 1</code>；</li>
<li>否则（即<code>tmp[i] &gt; tmp[j]</code>）时： 添加右子数组当前元素<code>tmp[j]</code>，并执行<code>j = j + 1</code>；此时构成<code>m - i + 1</code>个「逆序对」，统计添加至<code>res</code>；</li>
<li>返回值： 返回直至目前的逆序对总数<code>res</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>时间复杂度 <code>O(NlogN) </code>，空间复杂度 <code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">mergeSort</span>(left, mid, nums, tmp) + <span class="built_in">mergeSort</span>(mid + <span class="number">1</span>, right, nums, tmp);</span><br><span class="line">        <span class="comment">// 遍历数组，先将数组暂存到tmp中，因为后面要修改nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++k) &#123;</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;    <span class="comment">// i、j分别指向左右两部分数组的第一个值</span></span><br><span class="line">        <span class="comment">// 再次遍历数组，对数组进行排序，并统计逆序对的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++k) &#123;</span><br><span class="line">            <span class="comment">// 如果左部分数组走完了，则将右部分数组添加到nums中，且j后移</span></span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123; </span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果右部分数组走完了，或者nums[i] &lt;= nums[j]时，i右移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || tmp[i] &lt;= tmp[j]) &#123;</span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有当nums[i] &gt; nums[j]时，统计逆序对数量，将j右移</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="15、最长无重复子数组"><a href="#15、最长无重复子数组" class="headerlink" title="15、最长无重复子数组"></a>15、最长无重复子数组</h5><p><strong>【解法】</strong>哈希表记录每个元素是否被访问过，双指针用作滑动窗口，如果窗口中的元素不重复，则计算长度，运行时记录最大长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; j &lt; arr.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(unmap[arr[j]] == <span class="number">0</span>)&#123;</span><br><span class="line">            unmap[arr[j]] = <span class="number">1</span>;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, j - i + <span class="number">1</span>);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; unmap[arr[j]])&#123;</span><br><span class="line">                unmap[arr[i]] = <span class="number">0</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、合并两个有序数组【LeetCode-88-easy】"><a href="#16、合并两个有序数组【LeetCode-88-easy】" class="headerlink" title="16、合并两个有序数组【LeetCode 88 | easy】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组【LeetCode 88 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>两个数组已经有序，因此从最后一个元素开始往前遍历，边遍历边比较，将<code>nums2</code>中的元素插入到<code>nums1</code>中的正确位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums2[j] &gt; nums1[i]) &#123;</span><br><span class="line">			nums1[k--] = nums2[j--];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			nums1[k--] = nums1[i--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 最后只要考虑nums2中的元素是否有剩余，有的话直接插入到nums1中</span></span><br><span class="line">	<span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		nums1[k--] = nums2[j--];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、加一【LeetCode-66-easy】"><a href="#17、加一【LeetCode-66-easy】" class="headerlink" title="17、加一【LeetCode 66 | easy】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">加一【LeetCode 66 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br><span class="line">示例 1：</span><br><span class="line">输入：digits &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br><span class="line">    </span><br><span class="line">示例 2：</span><br><span class="line">输入：digits &#x3D; [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>先计算数组最后一个元素加1，然后从后往前开始遍历，用<code>flag</code>来记录各个元素加上进位之后是否大于等于10，遍历到第一个元素为止，然后单独计算<code>digits[0]</code>加上<code>flag</code>是否大于等于10。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">    digits[len - <span class="number">1</span>] += <span class="number">1</span>;	</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digits[i] += flag;</span><br><span class="line">        flag = digits[i] / <span class="number">10</span>;</span><br><span class="line">        digits[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    digits[<span class="number">0</span>] += flag;</span><br><span class="line">    <span class="keyword">if</span> (digits[<span class="number">0</span>] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、杨辉三角【LeetCode-118-easy】"><a href="#18、杨辉三角【LeetCode-118-easy】" class="headerlink" title="18、杨辉三角【LeetCode 118 | easy】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">杨辉三角【LeetCode 118 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。</span><br><span class="line">示例:</span><br><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210613172315.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numRows; ++i) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(i, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 每行第一个和最后一个元素为1</span></span><br><span class="line">        tmp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        tmp[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">// i是从1开始的，res的下标是从0开始的，所以是i-2</span></span><br><span class="line">            tmp[j] = res[i - <span class="number">2</span>][j - <span class="number">1</span>] + res[i - <span class="number">2</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19、第三大的数【LeetCode-414-easy】"><a href="#19、第三大的数【LeetCode-414-easy】" class="headerlink" title="19、第三大的数【LeetCode 414 | easy】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/third-maximum-number/">第三大的数【LeetCode 414 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[3, 2, 1]</span><br><span class="line">输出：1</span><br><span class="line">解释：第三大的数是 1 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[1, 2]</span><br><span class="line">输出：2</span><br><span class="line">解释：第三大的数不存在, 所以返回最大的数 2 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>用三个数记录前三大的数，在遍历数组的过程中更新这三个数的值，最后分情况讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用三个数记录最大的三个值</span></span><br><span class="line">	<span class="keyword">int</span> max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN, minNum = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		minNum = <span class="built_in">min</span>(minNum, nums[i]);</span><br><span class="line">		<span class="keyword">if</span> (max1 &lt; nums[i]) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = max1;</span><br><span class="line">			max1 = nums[i];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max2 &lt; nums[i] &amp;&amp; nums[i] != max1) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = nums[i];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max3 &lt; nums[i] &amp;&amp; nums[i] != max2 &amp;&amp; nums[i] != max1) &#123;</span><br><span class="line">			max3 = nums[i];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果max3 == INT_MIN，则表示不足三个最大值或第三大值刚好是INT_MIN</span></span><br><span class="line">	<span class="keyword">if</span> (max3 == INT_MIN) &#123;</span><br><span class="line">		<span class="comment">// 如果第三大的值刚好是INT_MIN，并且</span></span><br><span class="line">		<span class="keyword">if</span> (minNum == max3 &amp;&amp; max2 != max3) &#123;</span><br><span class="line">			<span class="keyword">return</span> max3;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">max</span>(max1, max2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 存在第三大的值则返回</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> max3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20、丢失的数字【LeetCode-268-easy】"><a href="#20、丢失的数字【LeetCode-268-easy】" class="headerlink" title="20、丢失的数字【LeetCode 268 | easy】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">丢失的数字【LeetCode 268 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>先排序后遍历。</p>
<p>也可以使用哈希表保存数组中的数，第二次遍历<code>[0,n]</code>，如果没在哈希表中出现，则这个数就是丢失的数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、存在重复元素-II-【LeetCode-219-easy】"><a href="#21、存在重复元素-II-【LeetCode-219-easy】" class="headerlink" title="21、存在重复元素 II 【LeetCode 219 | easy】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate-ii/">存在重复元素 II 【LeetCode 219 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] &#x3D; nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>线性搜索会超时。采用哈希表的方法，维护一个大小为k的哈希表。</p>
<p>遍历数组，对于每个元素做以下操作：</p>
<ul>
<li>在散列表中搜索当前元素，如果找到了就返回 true。</li>
<li>在散列表中插入当前元素。</li>
<li>如果当前散列表的大小超过了 k， 删除散列表中最旧的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="comment">// 判断元素是否存在过，如果key存在，count函数返回1，否则返回0</span></span><br><span class="line">		<span class="keyword">if</span> (unmap.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		unmap[nums[i]] = i;</span><br><span class="line">		<span class="keyword">if</span> (unmap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">			unmap.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、两数之和-II-输入有序数组【LeetCode-167-easy】【LeetCode-1-easy】"><a href="#22、两数之和-II-输入有序数组【LeetCode-167-easy】【LeetCode-1-easy】" class="headerlink" title="22、两数之和 II - 输入有序数组【LeetCode 167 | easy】【LeetCode 1 | easy】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组【LeetCode 167 | easy】【LeetCode 1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</span><br><span class="line">函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;&#x3D; answer[0] &lt; answer[1] &lt;&#x3D; numbers.length 。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：numbers &#x3D; [2,3,4], target &#x3D; 6</span><br><span class="line">输出：[1,3]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：numbers &#x3D; [-1,0], target &#x3D; -1</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>方法1，利用哈希表保存出现的值和索引对，如果<code>target-nums[i]</code>存在的话，则将两数的索引保存。时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unmap[target - numbers[i]]) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(unmap[target - numbers[i]]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        unmap[numbers[i]] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>：利用数组元素的有序性，进行二分查找。时间复杂度：<code>O(nlogn)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> low = i + <span class="number">1</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123; i + <span class="number">1</span>, mid + <span class="number">1</span> &#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23、三数之和【LeetCode-15-medium】"><a href="#23、三数之和【LeetCode-15-medium】" class="headerlink" title="23、三数之和【LeetCode 15 | medium】"></a>23、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">三数之和【LeetCode 15 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序+双指针。如果直接用三重循环枚举三元组且判断不能重复，那么至少需要<code>O(n^3)</code>的时间复杂度，且需要用哈希表进行去重操作。如果枚举的三元组满足<code>(a, b, c)</code>满足<code>a≤b≤c</code>，保证了只有<code>(a, b, c)</code>这个顺序会被枚举到，而<code>(b, a, c)</code>、<code>(c, b, a)</code>等等这些不会，这样就减少了重复，因此可以先将数组从小到大排序。</p>
<p>但是，如果数组中存在相同的元素，那么进行枚举的时候仍然可能存在重复的情况，因此需要将第三重循环「跳到」下一个不相同的元素，但此时的时间复杂度仍然是<code>O(n^3)</code>。</p>
<p>继续优化，如果固定了前两重循环枚举到的元素<code>a</code>和<code>b</code>，那么只有唯一的<code>c</code>满足<code>a+b+c=0</code>。当第二重循环往后枚举一个元素<code>b′</code>时，由于<code>b&#39; &gt; b</code>，那么满足<code>a+b&#39;+c&#39;=0</code>的<code>c&#39;</code>一定有<code>c&#39; &lt; c</code>，即<code>c&#39;</code>在数组中一定出现在<code>c</code>的左侧。也就是说，我们可以从小到大枚举<code>b</code>，同时从大到小枚举<code>c</code>，即第二重循环和第三重循环实际上是并列的关系，保持第二重循环不变，而将<strong>第三重循环变成一个从数组最右端开始向左移动的指针</strong>。</p>
<p>时间复杂度：<code>O(n^2)</code>，空间复杂度：<code>O(log n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="comment">// 如果下一次遍历的数字和之前一次遍历的数字相同，则退出</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			<span class="comment">// 如果下一次遍历的数字和之前一次遍历的数字相同，则退出</span></span><br><span class="line">			<span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				--k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果此时没找到和为0的数，那么随着j增加，nums[j]数值也变大，就再不会有和为0的数了</span></span><br><span class="line">			<span class="keyword">if</span> (k == j) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(&#123; nums[i],nums[j],nums[k] &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="24、最接近的三数之和【LeetCode-16-medium】"><a href="#24、最接近的三数之和【LeetCode-16-medium】" class="headerlink" title="24、最接近的三数之和【LeetCode 16 | medium】"></a>24、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum-closest/">最接近的三数之和【LeetCode 16 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</span><br><span class="line">示例：</span><br><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同【三数之和】。时间复杂度：<code>O(n^2)</code>，空间复杂度：<code>O(log n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> best = <span class="number">1e7</span>;</span><br><span class="line">    <span class="keyword">auto</span> update = [&amp;](<span class="keyword">int</span> cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(cur - target) &lt; <span class="built_in">abs</span>(best - target)) &#123;</span><br><span class="line">            best = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; k) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k];</span><br><span class="line">            <span class="comment">// 如果和为 target 直接返回答案</span></span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">update</span>(sum);</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 如果和大于 target，移动 c 对应的指针, 移动到下一个不相等的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果和小于 target，移动 b 对应的指针, 移动到下一个不相等的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25、四数之和【LeetCode-18-medium】"><a href="#25、四数之和【LeetCode-18-medium】" class="headerlink" title="25、四数之和【LeetCode 18 | medium】"></a>25、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/">四数之和【LeetCode 18 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><br><span class="line">注意：答案中不可以包含重复的四元组。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同三数之和，排序+双指针。</p>
<p>使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。假设两重循环枚举到的前两个数分别位于下标<code>i</code>和<code>j</code>，其中<code>i&lt;j</code>。初始时，左右指针分别指向下标<code>j+1</code>和下标<code>n−1</code>。每次计算四个数的和，并进行如下操作：</p>
<ul>
<li>如果和等于<code>target</code>，则将枚举到的四个数加到答案中，然后将左指针右移直到遇到不同的数，将右指针左移直到遇到不同的数；</li>
<li>如果和小于<code>target</code>，则将左指针右移一位；</li>
<li>如果和大于<code>target</code>，则将右指针左移一位。</li>
</ul>
<p>使用双指针枚举剩下的两个数的时间复杂度是<code>O(n)</code>，因此总时间复杂度是`O(n^3)。</p>
<p>具体实现时，还可以进行一些<strong>剪枝</strong>操作：</p>
<ul>
<li>在确定第一个数之后，如果<code>nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target</code>，说明此时剩下的三个数无论取什么值，四数之和一定大于<code>target</code>，因此退出第一重循环；</li>
<li>在确定第一个数之后，如果<code>nums[i]+nums[n−3]+nums[n−2]+nums[n−1]&lt;target</code>，说明此时剩下的三个数无论取什么值，四数之和一定小于<code>target</code>，因此第一重循环直接进入下一轮，枚举<code>nums[i+1]</code>；</li>
<li>在确定前两个数之后，如果<code>nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target</code>，说明此时剩下的两个数无论取什么值，四数之和一定大于<code>target</code>，因此退出第二重循环；</li>
<li>在确定前两个数之后，如果<code>nums[i]+nums[j]+nums[n−2]+nums[n−1]&lt;target</code>，说明此时剩下的两个数无论取什么值，四数之和一定小于<code>target</code>，因此第二重循环直接进入下一轮，枚举 <code>nums[j+1]</code>。</li>
</ul>
<p>时间复杂度：<code>O(n^3)</code>，空间复杂度：<code>O(log n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">		<span class="comment">// 去重</span></span><br><span class="line">		<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果前四个最小的值之和大于target，直接退出</span></span><br><span class="line">		<span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果第一个最小的值和最后三个最大的值之和小于target，则直接进行下一轮</span></span><br><span class="line">		<span class="keyword">if</span> (nums[i] + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">3</span>] &lt; target) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">			<span class="comment">// 去重</span></span><br><span class="line">			<span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果最小的值之和大于target，直接退出</span></span><br><span class="line">			<span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果前两个最小的值和最后两个最大的值之和小于target，则直接进行下一轮</span></span><br><span class="line">			<span class="keyword">if</span> (nums[i] + nums[j] + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] &lt; target) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> k = j + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (k &lt; r) &#123;</span><br><span class="line">				<span class="keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[r];</span><br><span class="line">				<span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">					res.<span class="built_in">push_back</span>(&#123; nums[i],nums[j],nums[k],nums[r] &#125;);</span><br><span class="line">					<span class="comment">// 去重</span></span><br><span class="line">					<span class="keyword">while</span> (k &lt; r &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">						++k;</span><br><span class="line">					&#125;</span><br><span class="line">					++k;</span><br><span class="line">					<span class="comment">// 去重</span></span><br><span class="line">					<span class="keyword">while</span> (k &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">						--r;</span><br><span class="line">					&#125;</span><br><span class="line">					--r;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">					--r;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					++k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、螺旋矩阵【LeetCode-54-medium】"><a href="#26、螺旋矩阵【LeetCode-54-medium】" class="headerlink" title="26、螺旋矩阵【LeetCode 54 | medium】"></a>26、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵【LeetCode 54 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614121800.png"></p>
<p><strong>【解法】</strong>按层模拟。可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p>
<p>定义矩阵的第<code>k</code>层是到最近边界距离为<code>k</code>的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1, 1, 1, 1, 1, 1, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 2, 3, 3, 3, 2, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 1, 1, 1, 1, 1, 1]]</span><br></pre></td></tr></table></figure>

<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于<code>(top, left)</code>，右下角位于<code>(bottom, right)</code>，按照如下顺序遍历当前层的元素。</p>
<ul>
<li>从左到右遍历上侧元素，依次为<code>(top,left) </code>到 <code>(top, right)</code>。</li>
<li>从上到下遍历右侧元素，依次为<code>(top+1, right)</code> 到<code>(bottom, right)</code>。</li>
<li>如果<code>left</code> &lt; <code>right</code>且 <code>top&lt;bottom</code>，则从右到左遍历下侧元素，依次为<code>(bottom, right−1)</code> 到 <code>(bottom, left+1)</code>，以及从下到上遍历左侧元素，依次为<code>(bottom, left)</code>到<code>(top+1,left)</code>。</li>
</ul>
<p>遍历完当前层的元素之后，将<code>left</code>和 <code>top</code>分别增加 1，将<code>right</code> 和<code>bottom</code> 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614123344.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = cols - <span class="number">1</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; --i) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		++left;</span><br><span class="line">		--right;</span><br><span class="line">		++top;</span><br><span class="line">		--bottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="27、螺旋矩阵-II【LeetCode-59-medium】"><a href="#27、螺旋矩阵-II【LeetCode-59-medium】" class="headerlink" title="27、螺旋矩阵 II【LeetCode 59 | medium】"></a>27、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵 II【LeetCode 59 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614161324.png"></p>
<p><strong>【解法】</strong>和上一题一模一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">			res[top][i] = k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i) &#123;</span><br><span class="line">			res[i][right] = k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">				res[bottom][i] = k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; --i) &#123;</span><br><span class="line">				res[i][left] = k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		++left;</span><br><span class="line">		--right;</span><br><span class="line">		++top;</span><br><span class="line">		--bottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="28、插入区间【LeetCode-57-medium】"><a href="#28、插入区间【LeetCode-57-medium】" class="headerlink" title="28、插入区间【LeetCode 57 | medium】"></a>28、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-interval/">插入区间【LeetCode 57 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span><br><span class="line">在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：intervals &#x3D; [], newInterval &#x3D; [5,7]</span><br><span class="line">输出：[[5,7]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/7C9F7A0D27059D8B39B6A4FB6D736E53.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="keyword">int</span> left = newInterval[<span class="number">0</span>], right = newInterval[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// [left,right]和[x,y]完全分离</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt; intervals[i][<span class="number">1</span>] || right &lt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// [left,right]完全包含在[x,y]中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= intervals[i][<span class="number">0</span>] &amp;&amp; right &lt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">			left = intervals[i][<span class="number">0</span>];</span><br><span class="line">			right = intervals[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// right包含在[x,y]中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= intervals[i][<span class="number">0</span>] &amp;&amp; right &lt; intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">			right = intervals[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// left包含在[x,y]中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (left &gt; intervals[i][<span class="number">0</span>] &amp;&amp; left &lt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">			left = intervals[i][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res.<span class="built_in">push_back</span>(&#123; left,right &#125;);</span><br><span class="line">	<span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());  <span class="comment">// 保持区间的顺序</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【更简洁的写法】</strong></p>
<p>待插入区间<code>S = [left,right]</code>，当 遍历到区间<code>[li,ri]</code>时：</p>
<ul>
<li>如果 <code>ri &lt; left</code>，说明<code>[li,ri]</code>与 <code>S</code> 不重叠并且在其左侧， 可以直接将<code>[li,ri]</code>加入答案；</li>
<li>如果<code>li &gt; right</code>，说明<code>[li,ri]</code>与 <code>S</code>不重叠并且在其右侧， 可以直接将<code>[li,ri]</code>加入答案；</li>
<li>如果上面两种情况均不满足，说明<code>[li,ri]</code>与 <code>S</code>重叠，无需将<code>[li,ri]</code>加入答案。此时， 需要将 <code>S</code>与<code>[li,ri]</code>合并，即将 <code>S</code> 更新为其与<code>[li,ri]</code>的并集。</li>
</ul>
<p>那么应当在什么时候将区间<code>S</code>加入答案呢？</p>
<p>由于需要保证答案也是按照左端点排序的，因此当 遇到第一个满足 <code>li &gt; right</code>的区间时，说明以后遍历到的区间不会与 <code>S</code> 重叠，并且它们左端点一定会大于 <code>S</code> 的左端点。此时 就可以将 <code>S</code> 加入答案。特别地，如果不存在这样的区间， 需要在遍历结束后，将 <code>S</code> 加入答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="keyword">int</span> left = newInterval[<span class="number">0</span>], right = newInterval[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">bool</span> placed = <span class="literal">false</span>;   <span class="comment">// place标记何时插入待插入区间</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval: intervals) &#123;</span><br><span class="line">		<span class="comment">// 当前区间在插入区间的右侧且无交集，此时将待插入区间存入结果中</span></span><br><span class="line">		<span class="keyword">if</span> (right &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(&#123; left,right &#125;);</span><br><span class="line">				placed = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res.<span class="built_in">push_back</span>(interval);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前区间在插入区间的左侧且无交集</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (left &gt; interval[<span class="number">1</span>]) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(interval);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前区间与插入区间有交集，计算它们的并集</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			left = <span class="built_in">min</span>(interval[<span class="number">0</span>], left);</span><br><span class="line">			right = <span class="built_in">max</span>(interval[<span class="number">1</span>], right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时待插入区间是最右边的区间</span></span><br><span class="line">	<span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(&#123; left,right &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【其他写法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">    intervals.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line">    <span class="comment">// 先按从小到大排序</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="comment">// 遍历每个区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// 区间不重叠的情况，则直接添加新区间</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他情况：有重叠，则更新右边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>] &lt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">            res.<span class="built_in">back</span>()[<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="29、搜索二维矩阵【LeetCode-74-medium】"><a href="#29、搜索二维矩阵【LeetCode-74-medium】" class="headerlink" title="29、搜索二维矩阵【LeetCode 74 | medium】"></a>29、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵【LeetCode 74 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</span><br><span class="line">每行中的整数从左到右按升序排列。</span><br><span class="line">每行的第一个整数大于前一行的最后一个整数。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614203734.png"></p>
<p><strong>【解法】</strong>两次二分查找。由于每行的第一个元素大于前一行的最后一个元素，且每行元素是升序的，所以每行的第一个元素大于前一行的第一个元素，因此矩阵第一列的元素是升序的。可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。</p>
<ol>
<li>第一次二分：从第 0 列中的「所有行」开始找，找到合适的行 <code>row</code></li>
<li>第二次二分：从 <code>row</code> 中「所有列」开始找，找到合适的列 <code>col</code></li>
</ol>
<p>时间复杂度：<code>O(logm+logn)</code>，空间复杂度：<code>O(1)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 第一次二分：定位到所在行</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> row = right;</span><br><span class="line">	<span class="keyword">if</span> (matrix[row][<span class="number">0</span>] == target) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (matrix[row][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次二分：定位到具体数字</span></span><br><span class="line">	left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (matrix[row][mid] &lt;= target) &#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> col = right;</span><br><span class="line">	<span class="keyword">return</span> matrix[row][col] == target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>根据题意已知，二维数组从左往右递增，从上往下递增，所以得出以下结论：</p>
<p>某列的某个数字，该数之上的数字，都比其小；某行的某个数字，该数右侧的数字，都比其大；</p>
<ul>
<li>以二维数组左下角为原点，开始比较</li>
<li>若当前数字大于了查找数，查找往上移一位</li>
<li>若当前数字小于了查找数，查找往右移一位</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="30、删除有序数组中的重复项【LeetCode-26-easy】"><a href="#30、删除有序数组中的重复项【LeetCode-26-easy】" class="headerlink" title="30、删除有序数组中的重复项【LeetCode 26 | easy】"></a>30、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项【LeetCode 26 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：2, nums &#x3D; [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。定义两个指针<code>fast</code>和<code>slow</code>分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。</p>
<p>假设数组<code>nums</code>的长度为 <code>n</code>。将快指针<code>fast</code>依次遍历从 1 到 <code>n-1</code>的每个位置，对于每个位置，如果 <code>nums[fast] = nums[fast−1]</code>，说明<code>nums[fast]</code>和之前的元素都不同，因此将<code>nums[fast]</code>的值复制到 <code>nums[slow]</code>，然后将<code>slow</code>的值加 1，即指向下一个位置。</p>
<p>遍历结束之后，从<code>nums[0]</code>到<code>nums[slow−1]</code>的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为<code>slow</code>，返回<code>slow</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> slow = <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[fast - <span class="number">1</span>] != nums[fast]) &#123;</span><br><span class="line">			nums[slow] = nums[fast];</span><br><span class="line">			++slow;</span><br><span class="line">		&#125;</span><br><span class="line">		++fast;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="31、删除有序数组中的重复项-II-【LeetCode-80-medium】"><a href="#31、删除有序数组中的重复项-II-【LeetCode-80-medium】" class="headerlink" title="31、删除有序数组中的重复项 II 【LeetCode 80 | medium】"></a>31、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II 【LeetCode 80 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums &#x3D; [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums &#x3D; [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。因为给定数组是有序的，所以相同元素必然连续。遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，定义两个指针<code>slow</code>和<code>fast</code>分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即<code>nums[fast]</code>表示待检查的第一个元素，<code>nums[slow−1]</code>为上一个应该被保留的元素所移动到的指定位置。</p>
<p>因为本题要求相同元素最多出现两次而非一次，所以需要检查上上个应该被保留的元素<code>nums[slow−2]</code>是否和当前待检查元素<code>nums[fast]</code>相同。当且仅当<code>nums[slow−2]=nums[fast]</code>时，当前待检查元素<code>nums[fast]</code>不应该被保留（因为此时必然有<code>nums[slow−2]=nums[slow−1]=nums[fast]</code>）。最后，<code>slow</code>即为处理好的数组的长度。</p>
<p>特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，无需进行任何处理，对于长度超过 2 的数组，直接将双指针的初始值设为 2 即可。</p>
<p>和上一题一模一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123; <span class="comment">// 特殊判断，如果nums长度小于2，直接输出长度n即可</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>; <span class="comment">// 因为上面已经做过特殊判别，所以这里快慢指针从2开始</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123; <span class="comment">// 因为题目要求最多两个数相同，所以这么判断</span></span><br><span class="line">            <span class="comment">// 如果nums[slow - 2] == nums[fast]，代表已经有两个数相等，此时nums[fast]</span></span><br><span class="line">            <span class="comment">// 对应的数值不能放进结果之中。反之，如果nums[slow - 2] != nums[fast]，</span></span><br><span class="line">            <span class="comment">// 那么nums[fast]可以放进nums[slow]中，并且slow++，记录结果的长度。</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++; <span class="comment">// 不管怎么样，快指针都是要向前遍历各个元素的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow; <span class="comment">// 返回结果的长度，即slow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【更简化的写法】</strong>扩展到<code>k</code>，只要将<code>if (i &lt; 2 || nums[i - 2] &lt; num)</code>改成<code>if (i &lt; k || nums[i - k] &lt; num)</code>就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 左指针初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123; <span class="comment">// num当右指针</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">2</span> || nums[i - <span class="number">2</span>] &lt; num) &#123; <span class="comment">// i &lt; 2是特殊判断，nums[i - 2] &lt; num</span></span><br><span class="line">			<span class="comment">// 是因为题目要求相同元素不能超过两个。之所以可以用小于号判断，是因为数组是有序的</span></span><br><span class="line">			nums[i] = num; <span class="comment">// 相当于上面解法的nums[slow] = nums[fast];</span></span><br><span class="line">			i++;           <span class="comment">// 相当于上面解法的slow++;，即左指针移动</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">// 输出长度，即相当于上面题解的slow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="32、最长连续序列【LeetCode-128-medium】"><a href="#32、最长连续序列【LeetCode-128-medium】" class="headerlink" title="32、最长连续序列【LeetCode 128 | medium】"></a>32、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列【LeetCode 128 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>哈希表+枚举。考虑枚举数组中的每个数 <code>x</code>，考虑以其为起点，不断尝试匹配<code>x+1,x+2,⋯ </code>是否存在，假设最长匹配到了<code>x+y</code>，那么以<code>x</code>为起点的最长连续序列即为<code>x,x+1,x+2,⋯,x+y</code>，其长度为<code>y+1</code>，不断枚举并更新答案即可。</p>
<p>跳过不必要的枚举：仔细分析这个过程，发现其中执行了很多不必要的枚举，如果已知有一个<code>x,x+1,x+2,⋯,x+y </code>的连续序列，而却重新从<code>x+1，x+2</code>或者是<code>x+y</code>处开始尝试匹配，那么得到的结果肯定不会优于枚举 <code>x</code>为起点的答案，因此在外层循环的时候碰到这种情况跳过即可。</p>
<p>由于要枚举的数<code>x</code>一定是在数组中不存在前驱数<code>x-1</code>的，不然会产生重复的匹配，因此每次在哈希表中检查是否存在<code>x-1</code>即能判断是否需要跳过了。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	unordered_set&lt;<span class="keyword">int</span>&gt; unset;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		unset.<span class="built_in">insert</span>(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> resLen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; num : unset) &#123;</span><br><span class="line">		<span class="comment">// 如果前一个数不存在，则开始新一轮计算</span></span><br><span class="line">		<span class="keyword">if</span> (!unset.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> curNum = num;</span><br><span class="line">			<span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果后一个数存在，则长度加1</span></span><br><span class="line">			<span class="keyword">while</span> (unset.<span class="built_in">count</span>(curNum + <span class="number">1</span>)) &#123;</span><br><span class="line">				curNum += <span class="number">1</span>;</span><br><span class="line">				curLen += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			resLen = <span class="built_in">max</span>(resLen, curLen);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="33、长度最小的子数组【LeetCode-209-medium】"><a href="#33、长度最小的子数组【LeetCode-209-medium】" class="headerlink" title="33、长度最小的子数组【LeetCode 209 | medium】"></a>33、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">长度最小的子数组【LeetCode 209 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个含有 n 个正整数的数组和一个正整数 target 。</span><br><span class="line">找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>滑动窗口。维护两个变量<code>i</code>和<code>j</code>分别表示滑动窗口的开始和结束位置，维护<code>sum</code>表示滑动窗口内的元素总和，当<code>sum &lt; target</code>时，则<code>j</code>右移；当<code>sum &gt;= target</code>时，<code>i</code>右移，并在移动过程中记录最小长度。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen1</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, minLen = INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		sum += nums[j];</span><br><span class="line">		<span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">			minLen = <span class="built_in">min</span>(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">			sum -= nums[i];</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minLen == INT_MAX ? <span class="number">0</span> : minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="34、矩阵置零【LeetCode-73-medium】"><a href="#34、矩阵置零【LeetCode-73-medium】" class="headerlink" title="34、矩阵置零【LeetCode 73 | medium】"></a>34、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-matrix-zeroes/">矩阵置零【LeetCode 73 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</span><br><span class="line">进阶：</span><br><span class="line">一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</span><br><span class="line">一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</span><br><span class="line">你能想出一个仅使用常量空间的解决方案吗？</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614210615.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例2：</span><br><span class="line">输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614210701.png"></p>
<p><strong>【解法】</strong>可以用矩阵的第一行和第一列作为两个标记数组，以达到 O(1)的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</p>
<p>首先预处理出两个标记变量，记录第一行和第一列原本是否包含0；接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p>
<p>时间复杂度：<code>O(mn)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> flag_col0 = <span class="literal">false</span>, flag_row0 = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 遍历第一列检查第一列是否有0，如果有的话就做标记</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">			flag_col0 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历第一行检查第一行是否有0，如果有的话就做标记</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">			flag_row0 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从第2行第2列开始遍历，如果存在0，则将对应的第1行和第1列的位置置0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">				matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从第2行第2列开始遍历，如果其对应的第1行和第1列的位置为0，则将该位置置0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果第一列存在0，则将第一列全部置为0</span></span><br><span class="line">	<span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果第一行存在0，则将第一行全部置为0</span></span><br><span class="line">	<span class="keyword">if</span> (flag_row0) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【优化！更简洁的写法】</strong>对上面的写法进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新， 需要从最后一行开始，倒序地处理矩阵元素，如果正序处理，那么如果<code>matrix[0][0]=0</code>的话，会先把第一行全部置为0，这样会影响后面的行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> flag_col0 = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="comment">// 检查第一列是否有0，如果有的话就做标记</span></span><br><span class="line">		<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">			flag_col0 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从第2行第2列开始遍历，如果存在0，则将对应的第1行和第1列的位置置0</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">				matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从第2行第2列开始遍历，如果其对应的第1行和第1列的位置为0，则将该位置置0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果第一列存在0，则第一列全置为0</span></span><br><span class="line">		<span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line">			matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="35、缺失的第一个正数【LeetCode-41-hard】"><a href="#35、缺失的第一个正数【LeetCode-41-hard】" class="headerlink" title="35、缺失的第一个正数【LeetCode 41 | hard】"></a>35、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数【LeetCode 41 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span><br><span class="line">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,0]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [3,4,-1,1]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>置换。将给定的数组「恢复」成下面的形式：如果数组中包含<code>x∈[1,N]</code>，那么恢复后，数组的第<code>x - 1</code>个元素为<code>x</code>，即将数值和索引进行对应。</p>
<p>对数组进行遍历，对于遍历到的数 <code>x</code>，如果它在<code>[1, N]</code>范围内，那么就将它交换到数组中的第<code>x−1</code>个位置（注意：数组下标从 0 开始）。在完成交换后，新的<code>nums[i]</code>可能还在<code>[1, N]</code>的范围内， 需要继续进行交换操作，直到 <code>x∈ [1,N]</code>。</p>
<p>上面的方法可能会陷入死循环。如果<code>nums[i]</code>恰好与<code>nums[x−1] </code>相等，那么就会无限交换下去。此时 有 <code>nums[i]=x=nums[x−1]</code>，说明 xx 已经出现在了正确的位置。因此 可以跳出循环，开始遍历下一个数。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 对于存在[1，n]之间的数，则将该数交换到和索引相对应的位置</span></span><br><span class="line">	<span class="comment">// 因为索引从0开始，正整数从1开始，所以对应关系需要减1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历数组，如果当前元素和索引不对应，则返回</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] != i+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="36、寻找峰值【LeetCode-162-medium】"><a href="#36、寻找峰值【LeetCode-162-medium】" class="headerlink" title="36、寻找峰值【LeetCode 162 | medium】"></a>36、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值【LeetCode 162 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】峰值元素是指其值大于左右相邻值的元素。给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</span><br><span class="line">你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>线性扫描。从头开始遍历<code>nums</code>数组。每当 遇到数字<code>nums[i]</code>，只需要检查它是否大于下一个元素<code>nums[i+1]</code>即可判断<code>nums[i]</code>是否是峰值，因为峰值总是出现在升序序列中。分为三种情况：</p>
<ul>
<li><p>所有的数字以降序排列。这种情况下，第一个元素即为峰值。首先检查当前元素是否大于下个元素。第一个元素满足这一条件，因此被正确判断为峰值。此时，不需要继续向下判断，也就不会有需要判断 <code>nums[i]</code>和上一个元素<code>nums[i−1]</code>的大小的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615200759.png"></p>
</li>
<li><p>所有的数字以升序排列。这种情况下，一直比较<code>nums[i]</code>与<code>nums[i+1]</code>以判断<code>nums[i]</code>是否是峰值元素。没有元素符合这一条件，说明处于上坡而非峰值。于是，返回末尾元素作为峰值元素。在这种情况下，同样不需要比较<code>nums[i]</code>和上一个元素<code>nums[i−1]</code>，因为处于上坡是<code>nums[i]</code>不是峰值的充分条件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615200948.png"></p>
</li>
<li><p>峰值出现在中间某处。这种情况下，当遍历上升部分时，与情况 2 相同，没有元素满足<code>nums[i] &gt; nums[i + 1]</code>。不需要比较<code>nums[i]</code>和上一个元素<code>nums[i−1]</code>。当到达峰值元素时，<code>nums[i] &gt; nums[i + 1]</code>条件满足。此时，同样不需要比较<code>nums[i]</code>和上一个元素<code>nums[i−1]</code>。这是由于“遍历会到达第i个元素”本身就说明上一个元素（第<code>i- 1</code>个）不满足<code>nums[i]&gt;nums[i+1]</code>这一条件，也就说明<code>nums[i-1] &lt; nums[i]</code>。同样可以得到正确结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615201046.png"></p>
<p>时间复杂度 :<code>O(n)</code>，空间复杂度 : <code>O(1)</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>递归二分查找。</p>
<p>首先从数组<code>nums</code>中找到中间的元素<code>mid</code>。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将<code>nums[i]</code>与右侧比较判断)，则说明峰值会在本元素的左边。于是，将搜索空间缩小为<code>mid</code>的左边(包括其本身)，并在左侧子数组上重复上述过程。</p>
<p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将<code>nums[i]</code>与右侧比较判断)，则说明峰值会在本元素的右边。于是，将搜索空间缩小为<code>mid</code>的右边，并在右侧子数组上重复上述过程。不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p>
<p>时间复杂度 : <code>O(log2 n)</code>，空间复杂度：<code>O(log2 n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">search</span>(nums, left, mid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">search</span>(nums, mid + <span class="number">1</span>, right);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">search</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【【解法3】】</strong>迭代二分查找。时间复杂度 : <code>O(log2 n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="37、数组中重复的数字【剑指Offer-03-easy】【LeetCode-442-medium】"><a href="#37、数组中重复的数字【剑指Offer-03-easy】【LeetCode-442-medium】" class="headerlink" title="37、数组中重复的数字【剑指Offer 03 | easy】【LeetCode 442 | medium】"></a>37、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字【剑指Offer 03 | easy】【LeetCode 442 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】找出数组中重复的数字。</span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：2 &lt;&#x3D; n &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>哈希表，遍历数组，存放次数每个元素出现的次数。时间复杂度<code> O(N)</code>，空间复杂度 <code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unmap[num]) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;				</span><br><span class="line">        &#125;		</span><br><span class="line">        unmap[num] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>就地交换。注意所有数字都在<code> 0～n-1</code> 的范围内，即数组元素的索引和值是一对多的关系，因此可以建立索引和值的映射。第一次遇到数字<code>nums[i]</code>时，将其交换到索引<code>i</code>处；当第二次遇到数字<code>nums[i]</code>时，一定有<code>nums[nums[i]]=nums[i]</code>。时间复杂度<code> O(N)</code>，空间复杂度 <code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i) &#123; <span class="comment">// 如果值等于索引，则遍历下一个元素</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表索引nums[i]处和索引i处的元素值都为nums[i],即找到一组重复值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将值和索引对应</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【LeetCode 442】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</span><br><span class="line">找到所有出现两次的元素。你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</span><br><span class="line">示例：</span><br><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] == i + <span class="number">1</span>) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">				ans[nums[i] - <span class="number">1</span>]++;</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ans[i]) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="38、汇总区间【LeetCode-228-medium】"><a href="#38、汇总区间【LeetCode-228-medium】" class="headerlink" title="38、汇总区间【LeetCode 228 | medium】"></a>38、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/summary-ranges/">汇总区间【LeetCode 228 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个无重复元素的有序整数数组 nums 。</span><br><span class="line">返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</span><br><span class="line">列表中的每个区间范围 [a,b] 应该按如下格式输出：</span><br><span class="line">&quot;a-&gt;b&quot; ，如果 a !&#x3D; b</span><br><span class="line">&quot;a&quot; ，如果 a &#x3D;&#x3D; b</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>从数组的位置 0 出发，向右遍历。每次遇到相邻元素之间的差值大于 1 时，就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。</p>
<p>在遍历过程中，维护下标<code>low </code>和<code>high </code>分别记录区间的起点和终点，对于任何区间都有<code>low≤high</code>。当得到一个区间时，根据<code>low </code>和 <code>high </code>的值生成区间的字符串表示。</p>
<p>当 <code>low &lt; high</code> 时，区间的字符串表示为 <code>&quot;low→high&quot;</code>；</p>
<p>当 <code>low=high</code>时，区间的字符串表示为 <code>&quot;low&quot;</code>。</p>
<p>时间复杂度<code> O(N)</code>，空间复杂度 <code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; res;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">		<span class="keyword">int</span> low = i;</span><br><span class="line">		++i;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">		string tmp = <span class="built_in">to_string</span>(nums[low]);</span><br><span class="line">		<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">			tmp.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">			tmp.<span class="built_in">append</span>(<span class="built_in">to_string</span>(nums[high]));</span><br><span class="line">		&#125;</span><br><span class="line">		res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="39、三个数的最大乘积【LeetCode-628-easy】"><a href="#39、三个数的最大乘积【LeetCode-628-easy】" class="headerlink" title="39、三个数的最大乘积【LeetCode 628 | easy】"></a>39、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">三个数的最大乘积【LeetCode 628 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：24</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [-1,-2,-3]</span><br><span class="line">输出：-6</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。</p>
<p>如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</p>
<p>综上， 在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</p>
<p>时间复杂度：<code>O((n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 最小的和第二小的</span></span><br><span class="line">	<span class="keyword">int</span> min1 = INT_MAX, min2 = INT_MAX;</span><br><span class="line">	<span class="comment">// 最大的、第二大的和第三大的</span></span><br><span class="line">	<span class="keyword">int</span> max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">			min2 = min1;</span><br><span class="line">			min1 = x;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">			min2 = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = max1;</span><br><span class="line">			max1 = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">			max3 = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(max1 * max2 * max3, min1 * min2 * max1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="40、子数组最大平均数-I【LeetCode-643-easy】"><a href="#40、子数组最大平均数-I【LeetCode-643-easy】" class="headerlink" title="40、子数组最大平均数 I【LeetCode 643 | easy】"></a>40、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">子数组最大平均数 I【LeetCode 643 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</span><br><span class="line">示例：</span><br><span class="line">输入：[1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>滑动窗口。维护一个长度为k的滑动窗口。时间复杂度：<code>O((n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		sum += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxSum = sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = k; j &lt; nums.<span class="built_in">size</span>(); ++i, ++j) &#123;			</span><br><span class="line">		sum = sum - nums[i] + nums[j];	</span><br><span class="line">		maxSum = <span class="built_in">max</span>(maxSum, sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="41、数组拆分-I【LeetCode-561-easy】"><a href="#41、数组拆分-I【LeetCode-561-easy】" class="headerlink" title="41、数组拆分 I【LeetCode 561 | easy】"></a>41、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I【LeetCode 561 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。返回该 最大总和 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,4,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的分法（忽略元素顺序）为：</span><br><span class="line">1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) &#x3D; 1 + 3 &#x3D; 4</span><br><span class="line">所以最大总和为 4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [6,2,6,5,1,2]</span><br><span class="line">输出：9</span><br><span class="line">解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) &#x3D; 1 + 2 + 6 &#x3D; 9</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>贪心算法。由于每两个数， 只能选择当前小的一个进行累加。因此 猜想应该从第一个位置进行选择，然后隔一步选择下一个数。这样形成的序列的求和值最大。时间复杂度：<code>O((nlogn)</code>，空间复杂度：<code>O(logn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">		sum += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="42、寻找两个正序数组的中位数【LeetCode-4-hard】"><a href="#42、寻找两个正序数组的中位数【LeetCode-4-hard】" class="headerlink" title="42、寻找两个正序数组的中位数【LeetCode 4 | hard】"></a>42、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数【LeetCode 4 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">输出：0.00000</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">输出：1.00000</span><br><span class="line"></span><br><span class="line">示例 5：</span><br><span class="line">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。根据中位数的定义，当<code>m+n</code>是奇数时，中位数是两个有序数组中的第<code>(m+n)/2</code>个元素，当 <code>m+n</code>是偶数时，中位数是两个有序数组中的第<code>(m+n)/2</code>个元素和第<code>(m+n)/2+1</code>个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第<code>k</code>小的数，其中<code>k</code>为<code>(m+n)/2</code>或<code>(m+n)/2+1</code>。</p>
<p>假设两个有序数组分别是<code>A</code>和<code>B</code>。要找到第<code>k</code>个元素，我们可以比较<code>A[k/2−1]</code>和<code>B[k/2−1]</code>，其中<code>/</code>表示整数除法。由于<code>A[k/2−1]</code>和<code>B[k/2−1]</code>的前面分别有<code>A[0..k/2−2]</code>和 <code>B[0..k/2−2]</code>，即<code>k/2−1</code>个元素，对于 <code>A[k/2−1]</code>和 <code>B[k/2−1]</code>中的较小值，最多只会有<code>(k/2−1)+(k/2−1)≤k−2</code>个元素比它小，那么它就不能是第<code>k</code>小的数了。</p>
<p>因此可以归纳出三种情况：</p>
<ul>
<li>如果 <code>A[k/2−1] &lt; B[k/2−1]</code>，则比<code>A[k/2−1]</code>小的数最多只有<code>A</code>的前<code>k/2−1</code>个数和 <code>B</code>的前 <code>k/2−1</code>个数，即比<code>A[k/2−1]</code>小的数最多只有<code>k−2</code>个，因此<code>A[k/2−1]</code>不可能是第<code>k</code>个数，<code>A[0]</code>到<code>A[k/2−1]</code>也都不可能是第<code>k</code>个数，可以全部排除。</li>
<li>如果<code>A[k/2−1] &gt; B[k/2−1]</code>，则可以排除<code>B[0]</code>到<code>B[k/2−1]</code>。</li>
<li>如果<code>A[k/2−1] = B[k/2−1]</code>，则可以归入第一种情况处理。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210629103927.png"></p>
<p>可以看到，比较<code>A[k/2−1]</code>和<code>B[k/2−1]</code>之后，可以排除<code>k/2</code>个不可能是第<code>k</code>小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少<code>k</code>的值，这是因为我们排除的数都不大于第<code>k</code>小的数。</p>
<p>有以下三种情况需要特殊处理：</p>
<p>如果<code>A[k/2−1]</code>或者<code>B[k/2−1]</code>越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少<code>k</code>的值，而不能直接将<code>k</code>减去<code>k/2</code>。</p>
<p>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第<code>k</code>小的元素。如果<code>k=1</code>，我们只要返回两个数组首元素的最小值即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="43、搜索插入位置【LeetCode-35-easy】"><a href="#43、搜索插入位置【LeetCode-35-easy】" class="headerlink" title="43、搜索插入位置【LeetCode 35 | easy】"></a>43、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">搜索插入位置【LeetCode 35 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="44、在排序数组中查找元素的第一个和最后一个位置【LeetCode-34-medium】"><a href="#44、在排序数组中查找元素的第一个和最后一个位置【LeetCode-34-medium】" class="headerlink" title="44、在排序数组中查找元素的第一个和最后一个位置【LeetCode 34 | medium】"></a>44、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置【LeetCode 34 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</span><br><span class="line">进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [], target &#x3D; 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。分别查找<code>target</code>的左边界和右边界。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (mid == nums.<span class="built_in">size</span>() - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="built_in">left_bound</span>(nums, target), <span class="built_in">right_bound</span>(nums,target) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="45、寻找第K大-牛客网"><a href="#45、寻找第K大-牛客网" class="headerlink" title="45、寻找第K大 | 牛客网"></a>45、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&&tqId=38572&rp=1&ru=/ta/job-code-high-week&qru=/ta/job-code-high-week/question-ranking">寻找第K大 | 牛客网</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。</span><br><span class="line">给定一个整数数组a,同时给定它的大小n和要找的K(1&lt;&#x3D;K&lt;&#x3D;n)，请返回第K大的数(包括重复的元素，不用去重)，保证答案存在。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：[1,3,5,2,2],5,3</span><br><span class="line">返回值：2</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：[10,10,9,9,8,7,5,6,4,3,4,2],12,3</span><br><span class="line">返回值：9</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>利用快排的思想，快排一趟之后所有比基准元素大的值都在其右边，所有比基准元素小的值都在其左边，如果此时基准元素刚好是第<code>k</code>大，则直接返回；否则递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">int</span> key = nums[left];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j &amp;&amp; nums[j] &gt;= key)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j &amp;&amp; nums[i] &lt;= key)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[left]);</span><br><span class="line">    <span class="comment">// 一趟排序之后，所有比基准数大的数都在i的右边，比基准数小的数都在i的左边</span></span><br><span class="line">    <span class="keyword">if</span>(n - j == K)&#123;  <span class="comment">// n - j = K 则说明此时刚好是第 K 大，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n - j &lt; K) &#123;  <span class="comment">// n - j &lt; K则说明在左半部分查找</span></span><br><span class="line">        res = <span class="built_in">quickSort</span>(nums, left, j - <span class="number">1</span>, n, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n - j &gt; K)&#123;  <span class="comment">// n - j &gt; K则说明在右半部分查找</span></span><br><span class="line">        res = <span class="built_in">quickSort</span>(nums, j + <span class="number">1</span>, right, n, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, n, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="46、和为-k-的子数组【LeetCode-560-medium】【剑指-Offer-II-010】"><a href="#46、和为-k-的子数组【LeetCode-560-medium】【剑指-Offer-II-010】" class="headerlink" title="46、和为 k 的子数组【LeetCode 560 | medium】【剑指 Offer II 010】"></a>46、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/QTMn0o/">和为 k 的子数组【LeetCode 560 | medium】【剑指 Offer II 010】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。</span><br><span class="line">示例 1 :</span><br><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line">输入:nums &#x3D; [1,2,3], k &#x3D; 3</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104</span><br><span class="line">-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</span><br><span class="line">-107 &lt;&#x3D; k &lt;&#x3D; 107</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前缀和。因为本题中包含负数，所以不能使用双指针。前缀和主要就是用来求解子数组的和的大小的。遍历数组，求出每个位置的前缀和，要求一个结尾下标为<code>i</code>的子数组的和是否为<code>k</code>，就需要对<code>j</code>从<code>-1</code>遍历到<code>i-1</code>，来找到是存在否<code>sum[i] - k = sum[j]</code>。那么我们只要用map&lt;前i个元素的前缀和，出现的次数&gt;把<code>i</code>之前的前缀和的值记录下来，判断map中是否包含<code>sum[i] - k</code>即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; unmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    unmap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        pre += num;</span><br><span class="line">        <span class="keyword">if</span>(unmap.containsKey(pre - k))&#123;</span><br><span class="line">            count += unmap.get(pre - k);</span><br><span class="line">        &#125;</span><br><span class="line">        unmap.put(pre, unmap.getOrDefault(pre, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="47、0-和-1-个数相同的子数组【剑指Offer2-011】"><a href="#47、0-和-1-个数相同的子数组【剑指Offer2-011】" class="headerlink" title="47、0 和 1 个数相同的子数组【剑指Offer2 | 011】"></a>47、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/A1NYOS/">0 和 1 个数相同的子数组【剑指Offer2 | 011】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前缀和。哈希表的键还是存前缀和，但是值存的是最小的 i，即若有多个相同前缀和只存最小的 i，因为这样可以保证求得是最长连续子数组的长度；<br>mp[0] = -1，即前缀和为 0 时存的索引应该是 -1，代表空的连续子数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    unmap[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sum += (nums[i] == <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (unmap.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - unmap[sum]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            unmap[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="48、排序数组中只出现一次的数字【剑指Offer2-70-medium】"><a href="#48、排序数组中只出现一次的数字【剑指Offer2-70-medium】" class="headerlink" title="48、排序数组中只出现一次的数字【剑指Offer2 70 | medium】"></a>48、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/skFtm2/">排序数组中只出现一次的数字【剑指Offer2 70 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。 </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [1,1,2,3,3,4,4,8,8]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D;  [3,3,7,7,10,11,11]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>二分查找。主要看<code>mid</code>是处于奇数位还是偶数位。如果<code>mid</code>处于偶数位，则比较其左边的值和右边的值，如果和左边的值相等，则唯一数出现在<code>mid</code>左侧；如果和右边的值相等，则唯一数出现在<code>mid</code>右侧。如果<code>mid</code>处于奇数位，比较其左边和右边的值，如果和左边的值相等，则唯一数出现在<code>mid</code>右侧；如果和右边的值相等，则唯一数出现在<code>mid</code>左侧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((mid &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;  <span class="comment">// 如果mid在奇数位</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>异或。两个相同的数异或为0，把所有的数全部异或的结果即为唯一数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;num: nums)&#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="49、合并区间【剑指Offer2-74-medium】"><a href="#49、合并区间【剑指Offer2-74-medium】" class="headerlink" title="49、合并区间【剑指Offer2 74 | medium】"></a>49、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/SsGoHC/">合并区间【剑指Offer2 74 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>先将每个区间的左边界进行排序，在遍历比较的过程中，只需要判断右边界是否和当前边界相交即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">    res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; res.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123; <span class="comment">// 两个区间不想交，直接先把新区间加入结果</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 两个区间相交，因为排序过，因此新的区间的左边界必然大于等于上一个区间的左边界，因此直接比较右边界</span></span><br><span class="line">            res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="50、最长连续序列【剑指Offer2-119-medium】"><a href="#50、最长连续序列【剑指Offer2-119-medium】" class="headerlink" title="50、最长连续序列【剑指Offer2 119 | medium】"></a>50、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/WhsWhI/">最长连续序列【剑指Offer2 119 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>使用<code>set</code>集合。准备一个<code>HashSet</code>，将所有元素入<code>set</code>，之后遍历数组中的每一个数<code>num</code>：</p>
<ul>
<li>如果<code>num - 1</code>存在于<code>set</code>中，那么<code>num</code>不可能是左边界，直接跳过</li>
<li>如果<code>num - 1</code>不存在于<code>set</code>中，那么<code>num</code>会是一个左边界，我们再不断地查找<code>num+1</code>、<code>num+2</code>……是否存在于<code>set</code>中，来看以<code>num</code>为左边界的连续序列能有多长</li>
</ul>
<p>在上述遍历中，我们知道了对于每一个可能的左边界，能扩出的最长连续序列的长度，再在这些长度中取最大即为结果。</p>
<p>时间复杂度：O(n)，其中 n 为数组的长度。外层循环需要 O(n)的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此数组中的每个数只会进入内层循环一次。根据上述分析可知，总时间复杂度为 O(n)。空间复杂度：O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MLS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; unset;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num: arr)&#123;</span><br><span class="line">        unset.<span class="built_in">insert</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num: unset)&#123;</span><br><span class="line">        <span class="comment">// 如果前一个元素不存在，则当前元素可以当成一个新的左边界</span></span><br><span class="line">        <span class="keyword">if</span>(!unset.<span class="built_in">count</span>(num - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span> curNum = num;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 从num+1开始判断有多少连续的数</span></span><br><span class="line">            <span class="keyword">while</span>(unset.<span class="built_in">count</span>(curNum + <span class="number">1</span>))&#123;</span><br><span class="line">                curNum = curNum + <span class="number">1</span>;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>哈希表</p>
<ul>
<li>key存数字，value存什么？</li>
<li>新存入的数字，如果它找到相邻的数，它希望从邻居数那里获取什么信息？</li>
<li>很显然它希望，左邻居告诉它左边能提供的连续长度，右邻居告诉它右边能提供的连续长度</li>
<li>加上它自己的长度，就有了自己处在的连续序列的长度</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20211015163546.png"></p>
<p><strong>更新新序列的两端数字的value</strong></p>
<ul>
<li>同处一个连续序列的数字的value理应都相同，这是它们共同特征</li>
<li>但没有必要每个的value都是序列长度，只需要两端的数存序列的长度就好</li>
<li>因为靠的是两端和新数对接，序列是连续的，中间没有空位</li>
<li>序列的一端找到邻居后，将另一端对应的value更新为最新的序列长度</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20211015163557.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MLS</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(!map.containsKey(num))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">int</span> preLen = map.get(num-<span class="number">1</span>) == <span class="keyword">null</span> ? <span class="number">0</span> : map.get(num-<span class="number">1</span>);</span><br><span class="line">              <span class="keyword">int</span> nextLen = map.get(num+<span class="number">1</span>) == <span class="keyword">null</span> ? <span class="number">0</span> : map.get(num+<span class="number">1</span>);</span><br><span class="line">              <span class="keyword">int</span> curLen = preLen + <span class="number">1</span> + nextLen;</span><br><span class="line">              map.put(num, curLen);</span><br><span class="line">              max = Math.max(max, curLen);</span><br><span class="line">              map.put(num - preLen, curLen);</span><br><span class="line">              map.put(num + nextLen, curLen);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h3><h5 id="1、替换空格【剑指Offer-05-easy】"><a href="#1、替换空格【剑指Offer-05-easy】" class="headerlink" title="1、替换空格【剑指Offer 05 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格【剑指Offer 05 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>遍历一遍字符串，记录字符串中的空格数量，将字符串扩容；扩容后从尾部开始遍历，如果<code>i</code>对应的字符是空格的话，就在<code>j~j-2</code>位置替换成<code>&quot;%20&quot;</code>。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// i指向原字符串的最后一位</span></span><br><span class="line">    s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + <span class="number">2</span> * count);</span><br><span class="line">    <span class="comment">// j指向扩容后的字符串的最后一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>; --j, --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[j] = <span class="string">&#x27;%&#x27;</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、第一个只出现一次的字符【剑指Offer-50-easy】"><a href="#2、第一个只出现一次的字符【剑指Offer-50-easy】" class="headerlink" title="2、第一个只出现一次的字符【剑指Offer 50 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">第一个只出现一次的字符【剑指Offer 50 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</span><br><span class="line">示例:</span><br><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>利用哈希表来记录字符是否重复出现，遍历字符串，若该字符在哈希表中出现过，对应的值为<code>false</code>，若该字符没出现过，则对应的值为<code>true</code>。第二次遍历字符串，如果在哈希表中对应的值为<code>true</code>，则该字符即为第一个只出现一次的字符。时间复杂度<code>O(n)</code>，空间复杂度<code>O(∣Σ∣)</code>，其中<code>Σ</code>是字符集，在本题中<code>s</code>只包含小写字母，因此<code>∣Σ∣≤26</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">        dic[c] = (dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>());    <span class="comment">//如果没找到，说明是第一次出现为true，如果是多次出现，则是false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic[c]) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：<code>unordered_map::count()</code>是<code>C++</code>中的内置方法，用于通过给定<code>key</code>对<code>unordered_map</code>中存在的元素数量进行计数，由于<code>unordered_map</code>不允许存储具有重复键的元素，因此<code>count()</code>函数本质上检查<code>unordered_map</code>中是否存在具有给定键的元素。如果<code>Map</code>中存在具有给定键的值，则此函数返回1，否则返回0。</p>
<p>通过<code>unordered_map::find()</code>来判断<code>key</code>是否存在，如果<code>key</code>存在，则<code>find</code>返回<code>key</code>对应的迭代器，如果<code>key</code>不存在，则<code>find</code>返回<code>unordered_map::end</code>。</p>
<h5 id="3、连续子数组的最大和【剑指Offer-42-easy】"><a href="#3、连续子数组的最大和【剑指Offer-42-easy】" class="headerlink" title="3、连续子数组的最大和【剑指Offer 42 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和【剑指Offer 42 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</span><br><span class="line">要求时间复杂度为O(n)。</span><br><span class="line">示例1:</span><br><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br><span class="line"> </span><br><span class="line">提示：1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5，-100 &lt;&#x3D; arr[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>动态规划。状态转移方程：<br>$$<br>dp[i] = dp[i-1]+nums[i],   dp[i-1]&gt;0<br>$$</p>
<p>$$<br>dp[i]=nums[i],dp[i-1]&lt;=0<br>$$</p>
<p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        nums[i] += <span class="built_in">max</span>(<span class="number">0</span>, nums[i - <span class="number">1</span>]);</span><br><span class="line">        result = <span class="built_in">max</span>(result, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、翻转单词顺序【剑指Offer-58-1-easy】"><a href="#4、翻转单词顺序【剑指Offer-58-1-easy】" class="headerlink" title="4、翻转单词顺序【剑指Offer 58-1 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">翻转单词顺序【剑指Offer 58-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line"> </span><br><span class="line">说明：无空格字符构成一个单词。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个字符</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个空格</span></span><br><span class="line">        <span class="keyword">int</span> i = j;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加单词到结果，每个单词后面加上一个空格</span></span><br><span class="line">        result.<span class="built_in">append</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - i) + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">// 继续往前分割单词</span></span><br><span class="line">        j = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后的空格</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、左旋转字符串【剑指Offer58-2-easy】"><a href="#5、左旋转字符串【剑指Offer58-2-easy】" class="headerlink" title="5、左旋转字符串【剑指Offer58-2 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串【剑指Offer58-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>字符串截取。也可用求余的方法计算下标。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    string str1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, n);</span><br><span class="line">    string str2 = s.<span class="built_in">substr</span>(n, s.<span class="built_in">size</span>() - n);</span><br><span class="line">    result = str2 + str1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求余计算下标</span></span><br><span class="line">    <span class="comment">// string result;</span></span><br><span class="line">    <span class="comment">// for (int i = n; i &lt; n + s.length(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//     result += (s[i % s.length()]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、字符串的排列【剑指Offer-38-medium】"><a href="#6、字符串的排列【剑指Offer-38-medium】" class="headerlink" title="6、字符串的排列【剑指Offer 38 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">字符串的排列【剑指Offer 38 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span><br><span class="line">示例:</span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>DFS+回溯。先固定一位，然后交换后两位。时间复杂度<code>O(N!N)</code>：<code>N</code>为字符串<code>s</code>的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为<code>N×(N−1)×(N−2)…×2×1</code>，即复杂度为<code>O(N!)</code>；字符串拼接操作<code>join()</code> 使用<code>O(N)</code>；因此总体时间复杂度为<code>O(N!N)</code> 。空间复杂度<code>O(N^2)</code>： 全排列的递归深度为<code>N</code>，系统累计使用栈空间大小为<code>O(N)</code>；递归中辅助<code>set</code>累计存储的字符数量最多为<code>N + (N-1) + ... + 2 + 1 = (N+1)N/2</code>，即占用 <code>O(N^2)</code>的额外空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> index, vector&lt;string&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 添加排列方案</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 重复，进行剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">find</span>(s[i]) != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[index]); <span class="comment">// 交换，将s[i]固定在第index位</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, index + <span class="number">1</span>, result); <span class="comment">// 开启固定第index+1位字符</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[index]); <span class="comment">// 恢复交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、把数字翻译成字符串【剑指Offer-46-medium】"><a href="#7、把数字翻译成字符串【剑指Offer-46-medium】" class="headerlink" title="7、把数字翻译成字符串【剑指Offer 46 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串【剑指Offer 46 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数字， 按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; num &lt; 231</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>动态规划。状态转移方程：<br>$$<br>如果后两位能表示一个字符：dp[i]=dp[i-1]+dp[i-2]<br>$$</p>
<p>$$<br>如果后两位不能表示一个字符：dp[i]=dp[i-1]<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);  <span class="comment">// 保持下标一致</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 判断这两个字符能否符合要求，有两种情况：</span></span><br><span class="line">        <span class="comment">// 前一位字符为&#x27;1&#x27;，后一位字符能在&#x27;0&#x27;-&#x27;9&#x27;之间</span></span><br><span class="line">        <span class="comment">// 前一位字符为&#x27;2&#x27;，后一位字符只能在&#x27;0&#x27;-&#x27;5&#x27;之间</span></span><br><span class="line">        <span class="keyword">if</span> ((s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            || (s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、最长不含重复字符的子字符串【剑指Offer-48-medium】【LeetCode-3-medium】"><a href="#8、最长不含重复字符的子字符串【剑指Offer-48-medium】【LeetCode-3-medium】" class="headerlink" title="8、最长不含重复字符的子字符串【剑指Offer 48 | medium】【LeetCode 3 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">最长不含重复字符的子字符串【剑指Offer 48 | medium】【LeetCode 3 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"> </span><br><span class="line">提示：s.length &lt;&#x3D; 40000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>滑动窗口，通过<code>left</code>和<code>right</code>限定窗口的位置，确保窗口内的元素彼此不同。当窗口最右边的元素在窗口内存在了，则向右移动<code>left</code>直至排除掉重复的元素。<code>used</code>数组用来记录哪些字符已经被使用过了。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(<span class="number">256</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 若元素重复，则left一直向右移，直至该重复元素处</span></span><br><span class="line">        <span class="keyword">while</span> (used[s[right]]) &#123;</span><br><span class="line">            used[s[left]] = <span class="literal">false</span>;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, right - left + <span class="number">1</span>);</span><br><span class="line">        used[s[right]] = <span class="literal">true</span>;</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、把字符串转换成整数【剑指Offer-67-medium】【LeetCode-8-medium】"><a href="#9、把字符串转换成整数【剑指Offer-67-medium】【LeetCode-8-medium】" class="headerlink" title="9、把字符串转换成整数【剑指Offer 67 | medium】【LeetCode 8 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数【剑指Offer 67 | medium】【LeetCode 8 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span><br><span class="line">当 寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。</span><br><span class="line">说明：</span><br><span class="line">假设 的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">      尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">     </span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">     </span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>注意考虑各种情况。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 去掉开头的空格</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == str.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果全是空格，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;   <span class="comment">// flag标记正负数</span></span><br><span class="line">    <span class="keyword">if</span> (str[k] == <span class="string">&#x27;+&#x27;</span> || str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 2的31次方等于2147483648</span></span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">214748364</span> || (result == <span class="number">214748364</span> &amp;&amp; tmp &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + tmp;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? result : (-result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、整数反转【LeetCode-7-easy】"><a href="#10、整数反转【LeetCode-7-easy】" class="headerlink" title="10、整数反转【LeetCode 7 | easy】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-integer/">整数反转【LeetCode 7 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</span><br><span class="line">如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</span><br><span class="line">假设环境不允许存储 64 位整数（有符号或无符号）。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x &#x3D; 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>注意数字超过<code>INT_MAX</code>和<code>INT_MIN</code>时候要做判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; INT_MAX / <span class="number">10</span> || (num == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; INT_MIN / <span class="number">10</span> || (num == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + pop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、回文数【LeetCode-9-easy】"><a href="#11、回文数【LeetCode-9-easy】" class="headerlink" title="11、回文数【LeetCode 9 | easy】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-number/">回文数【LeetCode 9 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</span><br><span class="line">回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：x &#x3D; 121</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x &#x3D; -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x &#x3D; 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：x &#x3D; -101</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>映入脑海的第一个想法是将数字转换为<strong>字符串</strong>，并检查字符串是否为回文。但是，这需要<strong>额外的非常量空间</strong>来创建问题描述中所不允许的字符串。第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 <code>INT_MAX</code>，我们将遇到整数溢出问题。</p>
<p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转<code>int</code>数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p>首先处理一些临界情况。所有负数都不可能是回文。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以可以对所有大于 0 且个位是 0 的数字返回 false。</p>
<p>反转后半部分的数字：</p>
<p>对于数字 1221，如果执行 1221 % 10，将得到最后一位数字 1，要得到倒数第二位数字，可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了反转后的数字。如果继续这个过程，将得到更多位数的反转数字。</p>
<p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p>
<p>由于整个过程不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着已经处理了一半位数的数字了。</p>
<p>时间复杂度：<code>O(logn)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> revertNum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x &gt; revertNum) &#123;</span><br><span class="line">		revertNum = revertNum * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x == revertNum || x == revertNum / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、最长回文子串-【LeetCode-5-medium】"><a href="#12、最长回文子串-【LeetCode-5-medium】" class="headerlink" title="12、最长回文子串 【LeetCode 5 | medium】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串 【LeetCode 5 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个字符串 s，找到 s 中最长的回文子串。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 1000</span><br><span class="line">s 仅由数字和英文字母（大写和&#x2F;或小写）组成</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>中心扩散法。分两种情况讨论。</p>
<p>（1）回文子串的长度是奇数。即遍历每一个字符<code>s[k]</code>，每次从当前字符<code>s[k]</code>开始向两边扩散，每次扩散则比较左右两边的字符是否相等，即比较<code>s[k-1]=s[k+1]</code>，相等则继续扩散，此时回文子串的长度是奇数。</p>
<p>（2）回文子串长度是偶数。即遍历每一个字符<code>s[k]</code>，从当前字符开始先比较当前字符<code>s[k]</code>和下一个字符<code>s[k+1]</code>是否相等，相等则从<code>k</code>和<code>k+1</code>位置向两边扩散。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两个参数分别代表最大回文子串长度，以及该子串第一个字符的下标位置（方便后面使用substr()）</span></span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; result;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        i = k, j = k;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 是奇数的情况，从中心扩散</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.first &lt; (j - i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    result.first = j - i + <span class="number">1</span>;</span><br><span class="line">                    result.second = i;</span><br><span class="line">                &#125;               </span><br><span class="line">                --i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是偶数的情况</span></span><br><span class="line">        i = k, j = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.first &lt; (j - i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    result.first = j - i + <span class="number">1</span>;</span><br><span class="line">                    result.second = i;</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(result.second, result.first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、回文子字符串的个数【剑指Offer2-20-medium】"><a href="#13、回文子字符串的个数【剑指Offer2-20-medium】" class="headerlink" title="13、回文子字符串的个数【剑指Offer2  20 | medium】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/a7VOhD/">回文子字符串的个数【剑指Offer2  20 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。</span><br><span class="line">具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>中心扩散法。分为回文长度是奇数和回文长度是偶数分别讨论。同上一题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n = s.<span class="built_in">size</span>(), count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        i = k, j = k;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                --i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = k, j = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                --i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、最长公共子序列-【LeetCode-1143-medium】"><a href="#14、最长公共子序列-【LeetCode-1143-medium】" class="headerlink" title="14、最长公共子序列 【LeetCode 1143 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列 【LeetCode 1143 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回&quot;-1&quot;。目前给出的数据，仅仅会存在一个最长的公共子序列。</span><br><span class="line">示例1：</span><br><span class="line">输入：&quot;1A2C3D4B56&quot;,&quot;B1D23A456A&quot;</span><br><span class="line">返回值：&quot;123456&quot;</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：&quot;abc&quot;,&quot;def&quot;</span><br><span class="line">返回值：&quot;-1&quot;</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入：&quot;abc&quot;,&quot;abc&quot;</span><br><span class="line">返回值：&quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>典型的二维动态规划问题。假设字符串<code>text1</code>和``text2<code>的长度分别为 </code>m<code>和</code>n<code>，创建 </code>m+1<code>行 </code>n+1<code>列的二维数组 </code>dp<code>，其中 </code>dp[i]][j]<code>表示</code>text1[0:i]<code>和</code>text2[0:j]`的最长公共子序列的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606121647.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606121629.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			<span class="keyword">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 重复的子序列</span></span><br><span class="line">	string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = text1.<span class="built_in">size</span>(), j = text2.<span class="built_in">size</span>(); dp[i][j] &gt;= <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">			result += text1[i - <span class="number">1</span>];</span><br><span class="line">			--i;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; result;</span><br><span class="line">	<span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、最长公共前缀-【LeetCode-14-easy】"><a href="#15、最长公共前缀-【LeetCode-14-easy】" class="headerlink" title="15、最长公共前缀 【LeetCode 14 | easy】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀 【LeetCode 14 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; strs.length &lt;&#x3D; 200，0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200，strs[i] 仅由小写英文字母组成</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>横向扫描。先比较两个字符串，找出公共前缀，然后再用这个公共前缀和下一个字符串进行比较，并更新公共前缀。全部比较完之后最后的公共前缀即为所求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606152909.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        prefix = <span class="built_in">prefixcal</span>(prefix, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (!prefix.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">prefixcal</span><span class="params">(string &amp;s1, string &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">min</span>(s1.<span class="built_in">size</span>(), s2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len &amp;&amp; s1[i] == s2[i]) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、把数组排成最小的数【剑指Offer-45-medium】"><a href="#16、把数组排成最小的数【剑指Offer-45-medium】" class="headerlink" title="16、把数组排成最小的数【剑指Offer 45 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数【剑指Offer 45 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br><span class="line"> </span><br><span class="line">提示:0 &lt; nums.length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序数组中的搜索：二分法。本质上是一个排序问题，设数组<code>nums</code>中任意两数字的字符串为<code>x</code>和<code>y</code>，则规定排序判断规则为：</p>
<p>若拼接字符串 <code>x + y &gt; y + x</code>，则 <code>x</code> “大于” <code>y</code> ；反之，若<code>x + y &lt; y + x</code>，则 <code>x</code> “小于” <code>y</code> ；<code>x</code> “小于” <code>y</code> 代表：排序完成后，数组中 <code>x</code> 应在 <code>y</code> 左边；“大于” 则反之。如：<code>x = &quot;30&quot;, y = &quot;3&quot;, x + y = &quot;303&quot; &lt; y + x = &quot;330&quot;</code>，所以 <code>x</code> 应该放在 <code>y</code> 的左侧。利用快排完成排序，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右到左找到第一个满足 x + y &lt; y + x 的j</span></span><br><span class="line">		<span class="keyword">while</span> ((str[j] + str[left] &gt;= str[left] + str[j]) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 从左到右找到第一个满足 x + y &gt; y + x 的i</span></span><br><span class="line">		<span class="keyword">while</span> ((str[i] + str[left] &lt;= str[left] + str[i]) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(str[i], str[j]);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(str[i], str[left]);</span><br><span class="line">	<span class="built_in">quickSort</span>(str, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(str, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">		str.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quickSort</span>(str, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	string result;</span><br><span class="line">	<span class="keyword">for</span> (string s : str) &#123;</span><br><span class="line">		result.<span class="built_in">append</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、最多删除一个字符得到回文【剑指Offer2-19-easy】"><a href="#17、最多删除一个字符得到回文【剑指Offer2-19-easy】" class="headerlink" title="17、最多删除一个字符得到回文【剑指Offer2 | 19 | easy】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/RQku0D/">最多删除一个字符得到回文【剑指Offer2 | 19 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。</span><br><span class="line">示例 1:</span><br><span class="line">输入: s &#x3D; &quot;aba&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s &#x3D; &quot;abca&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可以删除 &quot;c&quot; 字符 或者 &quot;b&quot; 字符</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left] != s[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++left;</span><br><span class="line">        --right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 头尾比较</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">            <span class="comment">// 如果不相等，有一次删除的机会，如果删除之后仍然是回文，那么返回true</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, i + <span class="number">1</span>, j) || <span class="built_in">isPalindrome</span>(s, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        --j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、有效的变位词【剑指Offer2-32-easy】"><a href="#18、有效的变位词【剑指Offer2-32-easy】" class="headerlink" title="18、有效的变位词【剑指Offer2 | 32 | easy】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dKk3P7/">有效的变位词【剑指Offer2 | 32 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。</span><br><span class="line">注意：若 s 和 t 中每个字符出现的次数都相同且字符顺序不完全相同，则称 s 和 t 互为变位词（字母异位词）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>遍历第一个字符串，用数组来标记每一个字符出现的次数，然后遍历第二个字符串，验证每个字符出现的次数是否相等，相等则为有效地变位词，不相等则不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(t) || s.length() != t.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i)&#123;</span><br><span class="line">        ++count[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        --count[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: count)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19、字符串中的变位词【剑指Offer2-14-medium】"><a href="#19、字符串中的变位词【剑指Offer2-14-medium】" class="headerlink" title="19、字符串中的变位词【剑指Offer2 | 14 | medium】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/MPnaiL/">字符串中的变位词【剑指Offer2 | 14 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的某个变位词。</span><br><span class="line">换句话说，第一个字符串的排列之一是第二个字符串的 子串 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>使用长度为26的数组记录<code>s1</code>中的字母出现次数，在对应位置<code>+1</code>，记录<code>s2</code>中的字母出现次数，在对应位置<code>-1</code>。使用长度与s1相等得到滑动窗口在s2中判断子字符串是否为变位词，窗口向右移动，右边位置上的字符次数<code>-1</code>，左边窗口位置上的字符次数<code>+1</code>，边移动边判断<code>count</code>中是否全为0，如果全为0，则为<code>TRUE</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s1.<span class="built_in">size</span>() &gt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			counts[s1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">			counts[s2[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">areAllZero</span>(counts)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s1.<span class="built_in">size</span>(); i &lt; s2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			counts[s2[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">			counts[s2[i - s1.<span class="built_in">size</span>()] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">areAllZero</span>(counts)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">areAllZero</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; counts)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">			<span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="20、字符串中的所有变位词【剑指Offer2-15-medium】"><a href="#20、字符串中的所有变位词【剑指Offer2-15-medium】" class="headerlink" title="20、字符串中的所有变位词【剑指Offer2 | 15 | medium】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/VabMRr/">字符串中的所有变位词【剑指Offer2 | 15 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</span><br><span class="line">变位词 指字母相同，但排列不同的字符串。</span><br><span class="line">示例 1:</span><br><span class="line">输入: s &#x3D; &quot;cbaebabacd&quot;, p &#x3D; &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的变位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的变位词。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本题解法同上一题，在滑动窗口移动过程中记录变位词左边的起始值就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAllZero</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; counts)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> count : counts) &#123;</span><br><span class="line">			<span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			--count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			++count[p[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">areAllZero</span>(count)) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = p.<span class="built_in">size</span>(); i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			--count[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			++count[s[i - p.<span class="built_in">size</span>()] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">areAllZero</span>(count)) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(i - p.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="21、字符串出现次数的TopK问题"><a href="#21、字符串出现次数的TopK问题" class="headerlink" title="21、字符串出现次数的TopK问题"></a>21、字符串出现次数的TopK问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个字符串数组，再给定整数 k ，请返回出现次数前k名的字符串和对应的次数。</span><br><span class="line">返回的答案应该按字符串出现频率由高到低排序。如果不同的字符串有相同出现频率，按字典序排序。</span><br><span class="line">对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。比如&quot;ah1x&quot;小于&quot;ahb&quot;，&quot;231&quot;&lt;”32“</span><br><span class="line">字符仅包含数字和字母</span><br><span class="line"></span><br><span class="line">数据范围：字符串数满足0≤n≤100000，每个字符串长度0≤n≤10，0≤k≤2500</span><br><span class="line">要求：空间复杂度 O(n)，时间复杂度O(nlogk)</span><br><span class="line"></span><br><span class="line">示例1</span><br><span class="line">输入：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;],2</span><br><span class="line">返回值：[[&quot;b&quot;,&quot;2&quot;],[&quot;a&quot;,&quot;1&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>哈希表+最小堆。</p>
<p>哈希表存放每个字符出现的次数；自定义最小堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return topK string</span></span><br><span class="line"><span class="comment">     * @param strings string字符串vector strings</span></span><br><span class="line"><span class="comment">     * @param k int整型 the k</span></span><br><span class="line"><span class="comment">     * @return string字符串vector&lt;vector&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;vector&lt;string&gt; &gt; <span class="built_in">topKstrings</span>(vector&lt;string&gt;&amp; strings, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="comment">// 统计次数</span></span><br><span class="line">        <span class="keyword">for</span>(string&amp; s: strings)&#123;</span><br><span class="line">            unmap[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义小顶堆</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](pair&lt;string, <span class="keyword">int</span>&gt;&amp; p1, pair&lt;string, <span class="keyword">int</span>&gt;&amp; p2)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second &gt; p2.second || (p1.second == p2.second &amp;&amp; p1.first &lt; p2.first);</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pair&lt;string, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v: unmap)&#123;</span><br><span class="line">            <span class="comment">// 堆中元素小于k，则直接插入</span></span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &lt; k)&#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(pair&lt;string, <span class="keyword">int</span>&gt;&#123;v.first, v.second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，如果新来的元素出现的次数比堆顶元素出现的次数更大，或者是新来的元素出现的次数和堆顶元素出现的次数相等，但字符更小，则堆顶元素弹出，插入新元素</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v.second &gt; pq.<span class="built_in">top</span>().second || (v.second == pq.<span class="built_in">top</span>().second &amp;&amp; v.first &lt; pq.<span class="built_in">top</span>().first))&#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">push</span>(pair&lt;string, <span class="keyword">int</span>&gt;(v.first, v.second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;pq.<span class="built_in">top</span>().first, <span class="built_in">to_string</span>(pq.<span class="built_in">top</span>().second)&#125;);</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>











<h3 id="四、链表"><a href="#四、链表" class="headerlink" title="四、链表"></a>四、链表</h3><h5 id="1、从尾到头打印链表【剑指Offer-06-easy】"><a href="#1、从尾到头打印链表【剑指Offer-06-easy】" class="headerlink" title="1、从尾到头打印链表【剑指Offer 06 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表【剑指Offer 06 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>利用栈后进先出的原则，遍历链表将每个节点的值存入栈中，出栈的顺序即为链表逆序。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        S.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(S.<span class="built_in">top</span>());</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、反转链表【剑指Offer-24-easy】"><a href="#2、反转链表【剑指Offer-24-easy】" class="headerlink" title="2、反转链表【剑指Offer 24 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表【剑指Offer 24 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br><span class="line">示例:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>迭代。定义一个结点总是指向前驱，注意<code>ListNode* nex = head-&gt;next;</code>这句要放到<code>while</code>循环中。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;	</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ListNode* nex = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、合并两个排序的链表【剑指Offer-25-easy】"><a href="#3、合并两个排序的链表【剑指Offer-25-easy】" class="headerlink" title="3、合并两个排序的链表【剑指Offer 25 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表【剑指Offer 25 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br><span class="line">示例1：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同时遍历两个链表，按递增顺序，如果最后某个链表有剩余，就将这个链表剩余部分接到新链表的最后。时间复杂度<code>O(M+N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* r = new_head;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            r-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    	r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">    	r-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">    	r-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、链表中倒数第k个节点【剑指Offer-22-easy】"><a href="#4、链表中倒数第k个节点【剑指Offer-22-easy】" class="headerlink" title="4、链表中倒数第k个节点【剑指Offer 22 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点【剑指Offer 22 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>使用双指针，一开始<code>former</code>和<code>latter</code>同时指向<code>head</code>，然后<code>former</code>指针向前移动k步（即<code>former</code>和<code>latter</code>两个指针相差<code>k</code>个结点），然后两个指针再同时移动，知道<code>former</code>移动到链表结尾为空。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* former = head;</span><br><span class="line">    ListNode* latter = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!former) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        former = former-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (former) &#123;</span><br><span class="line">        latter = latter-&gt;next;</span><br><span class="line">        former = former-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> latter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、删除链表的节点【剑指Offer-18-easy】"><a href="#5、删除链表的节点【剑指Offer-18-easy】" class="headerlink" title="5、删除链表的节点【剑指Offer 18 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点【剑指Offer 18 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</span><br><span class="line">示例 1:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="line"> </span><br><span class="line">说明：题目保证链表中节点的值互不相同。若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针，定义一个指向前驱结点的指针，遍历链表寻找要删除的结点，找到后利用<code>pre-&gt;next=p-&gt;next</code>将其删除。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">		<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* pre = head;</span><br><span class="line">	ListNode* p = head-&gt;next;</span><br><span class="line">	<span class="comment">// pre指向前驱，遍历链表寻找要删除的结点</span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;val != val) &#123;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p) &#123; <span class="comment">// 此时找到了要删除的结点</span></span><br><span class="line">		pre-&gt;next = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、两个链表的第一个公共节点【剑指Offer-52-easy】"><a href="#6、两个链表的第一个公共节点【剑指Offer-52-easy】" class="headerlink" title="6、两个链表的第一个公共节点【剑指Offer 52 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点【剑指Offer 52 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个链表，找出它们的第一个公共节点。</span><br><span class="line">如果两个链表没有交点，返回 null；在返回结果后，两个链表仍须保持原有的结构；可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br><span class="line">如下面的两个链表：在节点 c1 开始相交。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424124955.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125056.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125126.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125151.png"></p>
<p><strong>【解法】</strong>使用两个指针 <code>A</code>，<code>B</code>分别指向两个链表 <code>headA</code>，<code>headB</code> 的头结点，然后同时分别逐结点遍历，当 <code>A</code>到达链表 <code>headA</code> 的末尾时，重新定位到链表<code> headB</code> 的头结点；当 <code>B</code>到达链表<code> headB</code> 的末尾时，重新定位到链表 <code>headA</code> 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。时间复杂度<code>O(M+N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* A = headA;</span><br><span class="line">	ListNode* B = headB;</span><br><span class="line">	<span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">		A = (A != <span class="literal">nullptr</span>) ? A-&gt;next : headB;</span><br><span class="line">		B = (B != <span class="literal">nullptr</span>) ? B-&gt;next : headA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、复杂链表的复制【剑指Offer-35-medium】"><a href="#7、复杂链表的复制【剑指Offer-35-medium】" class="headerlink" title="7、复杂链表的复制【剑指Offer 35 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制【剑指Offer 35 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span><br><span class="line">提示：-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000</span><br><span class="line">Node.random 为空（null）或指向链表中的节点。</span><br><span class="line">节点数目不超过 1000 。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134207.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134221.png"></p>
<p><strong>【解法】</strong>遍历链表，每次对应生成一个新结点，用哈希表存放新结点和旧结点之间的对应关系。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 哈希表存放新结点和旧结点之间的对应关系</span></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; unmap;</span><br><span class="line">        Node* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            unmap[p] = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            unmap[p]-&gt;next = unmap[p-&gt;next];</span><br><span class="line">            unmap[p]-&gt;random = unmap[p-&gt;random];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unmap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8、二叉搜索树与双向链表【剑指Offer-36-medium】"><a href="#8、二叉搜索树与双向链表【剑指Offer-36-medium】" class="headerlink" title="8、二叉搜索树与双向链表【剑指Offer 36 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表【剑指Offer 36 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。为了让您更好地理解问题，以下面的二叉搜索树为例：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134404.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</span><br><span class="line">下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</span><br><span class="line">特别地， 希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134443.png"></p>
<p><strong>【解法】</strong><code>DFS</code>中序遍历保证结点的值从小到大排序。设置一个前驱结点，在遍历的过程中，保证前驱结点和当前结点相互指向。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = <span class="literal">NULL</span>;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, Node* _left, Node* _right) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 找到第一个结点，head指向它</span></span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 不是第一个结点，则前驱结点和当前结点相互指向</span></span><br><span class="line">            pre-&gt;right = cur;   </span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="9、两数相加【LeetCode-2-medium】"><a href="#9、两数相加【LeetCode-2-medium】" class="headerlink" title="9、两数相加【LeetCode 2 | medium】"></a><strong>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加【LeetCode 2 | medium】</a></strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。</span><br><span class="line">请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>每次相加考虑是否有进位，如果有进位那么就加上1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	ListNode* p = l1;</span><br><span class="line">	ListNode* q = l2;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* r = new_head;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = (p == <span class="literal">nullptr</span>) ? <span class="number">0</span> : p-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> y = (q == <span class="literal">nullptr</span>) ? <span class="number">0</span> : q-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> sum = x + y + flag;</span><br><span class="line">		flag = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">		r = r-&gt;next;	</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q) &#123;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(flag);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、两数相加-II-【LeetCode-445-medium】"><a href="#10、两数相加-II-【LeetCode-445-medium】" class="headerlink" title="10、两数相加 II 【LeetCode 445 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">两数相加 II 【LeetCode 445 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</span><br><span class="line">你可以假设除了数字 0 之外，这两个数字都不会以零开头。</span><br><span class="line">进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</span><br><span class="line">示例：</span><br><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>具体解法和上一题完全相同，只不过这题多了一个链表反转的操作，先将链表反转，反转之后再从头开始遍历相加求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseListNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		ListNode* nex = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = nex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	ListNode* reverse_l1 =  <span class="built_in">reverseListNode</span>(l1);</span><br><span class="line">	ListNode* reverse_l2 = <span class="built_in">reverseListNode</span>(l2);</span><br><span class="line">	ListNode* p = reverse_l1;</span><br><span class="line">	ListNode* q = reverse_l2;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* r = new_head;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = (p == <span class="literal">nullptr</span>) ? <span class="number">0</span> : p-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> y = (q == <span class="literal">nullptr</span>) ? <span class="number">0</span> : q-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> sum = x + y + flag;</span><br><span class="line">		flag = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q) &#123;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(flag);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* res = <span class="built_in">reverseListNode</span>(new_head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、删除链表的倒数第-N-个结点【LeetCode-19-medium】"><a href="#11、删除链表的倒数第-N-个结点【LeetCode-19-medium】" class="headerlink" title="11、删除链表的倒数第 N 个结点【LeetCode 19 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点【LeetCode 19 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line">提示：链表中结点的数目为 sz，1 &lt;&#x3D; sz &lt;&#x3D; 30</span><br><span class="line">0 &lt;&#x3D; Node.val &lt;&#x3D; 100，1 &lt;&#x3D; n &lt;&#x3D; sz</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531113520.png"></p>
<p><strong>【解法】</strong>双指针，前后指针相差<code>n</code>个节点，这样就保证了当前指针遍历到结尾为空时，后指针刚好指向要删除的节点的前一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">	dummyHead-&gt;next = head;</span><br><span class="line">	ListNode* p = dummyHead, * q = dummyHead;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* delNode = p-&gt;next;</span><br><span class="line">	p-&gt;next = delNode-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> delNode;</span><br><span class="line"></span><br><span class="line">	ListNode* retNode = dummyHead-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> dummyHead;</span><br><span class="line">	<span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、合并K个升序链表【LeetCode-23-hard】"><a href="#12、合并K个升序链表【LeetCode-23-hard】" class="headerlink" title="12、合并K个升序链表【LeetCode 23 | hard】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表【LeetCode 23 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><br><span class="line">示例1：</span><br><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>遍历每个链表，开辟一个新的数组，将所有节点保存到新数组中，然后根据值大小进行排序，最后将新数组中的每个节点连成一个链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	vector&lt;ListNode*&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (lists[i]) &#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">			lists[i] = lists[i]-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (vec.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		vec[i - <span class="number">1</span>]-&gt;next = vec[i];</span><br><span class="line">	&#125;</span><br><span class="line">	vec.<span class="built_in">back</span>()-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>将链表数组分成两部分，两部分分别递归调用，最后两部分的结果调用合并两个链表的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* p = new_head;</span><br><span class="line">	<span class="keyword">while</span> (headA &amp;&amp; headB) &#123;</span><br><span class="line">		<span class="keyword">if</span> (headA-&gt;val &lt;= headB-&gt;val) &#123;</span><br><span class="line">			p-&gt;next = headA;</span><br><span class="line">			headA = headA-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;next = headB;</span><br><span class="line">			headB = headB-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (headA) &#123;</span><br><span class="line">		p-&gt;next = headA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (headB) &#123;</span><br><span class="line">		p-&gt;next = headB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = lists.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">	vector&lt;ListNode*&gt; tmp_vec1, tmp_vec2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; ++i) &#123;</span><br><span class="line">		tmp_vec1.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* tmp1 = <span class="built_in">mergeKLists</span>(tmp_vec1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; len; ++i) &#123;</span><br><span class="line">		tmp_vec2.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* tmp2 = <span class="built_in">mergeKLists</span>(tmp_vec2);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(tmp1, tmp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、-删除排序链表中的重复元素【LeetCode-83-easy】"><a href="#13、-删除排序链表中的重复元素【LeetCode-83-easy】" class="headerlink" title="13、 删除排序链表中的重复元素【LeetCode 83 | easy】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/"> 删除排序链表中的重复元素【LeetCode 83 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次。返回同样按升序排列的结果链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191014.png"></p>
<p><strong>【解法】</strong>定义两个指针<code>p</code>和<code>q</code>来比较两个节点的值是否相等，如果后一个指针<code>q</code>的值等于前一个指针<code>p</code>的值，那么删除<code>q</code>指向的节点，若不等于，则<code>p</code>和<code>q</code>同时往后移一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	ListNode* q = p-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == q-&gt;val) &#123;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = q;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、删除排序链表中的重复元素-II【LeetCode-82-medium】"><a href="#14、删除排序链表中的重复元素-II【LeetCode-82-medium】" class="headerlink" title="14、删除排序链表中的重复元素 II【LeetCode 82 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II【LeetCode 82 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。返回同样按升序排列的结果链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191217.png"></p>
<p><strong>【解法】</strong>一次遍历。重复元素在链表中出现的位置是连续的，因此只需要对链表进行一次遍历就可以删除重复元素。由于链表的头结点可能会删除，因此定义一个哑节点指向头节点，定义一个遍历的指针p指向哑节点。随后开始对链表进行遍历。如果当前 <code>p-&gt;next</code> 与<code>p-&gt;next-&gt;next</code> 对应的元素相同，那么 就需要将 <code>p-&gt;next</code> 以及所有后面拥有相同元素值的链表节点全部删除。 记下这个元素值<code>x</code>，随后不断将<code>p-&gt;next</code> 从链表中移除，直到 <code>p-&gt;next</code>为空节点或者其元素值不等于<code>x</code>为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == x) &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、旋转链表【LeetCode-61-medium】"><a href="#15、旋转链表【LeetCode-61-medium】" class="headerlink" title="15、旋转链表【LeetCode 61 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-list/">旋转链表【LeetCode 61 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head，旋转链表，将链表每个节点向右移动 k 个位置。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191250.png"></p>
<p><strong>【解法】</strong>闭合为环。当<code>k&gt;=len</code>时，需要向右移动<code>k mod len</code>次，因为每<code>len</code>次移动都会让链表恢复原状，新链表的最后一个节点即为<code>len - k mod len</code>个节点（从1开始计数）可以先将链表连接成环，然后再从指定位置断开。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;  <span class="comment">// 计算链表长度</span></span><br><span class="line">		len++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = head;    <span class="comment">// 首尾相连成环</span></span><br><span class="line">	<span class="keyword">int</span> add = len - k % len;  <span class="comment">// 定位到新链表的尾部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add; ++i) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* new_head = p-&gt;next; <span class="comment">// 新链表的头节点</span></span><br><span class="line">	p-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 首尾断开</span></span><br><span class="line">	<span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、两两交换链表中的节点【LeetCode-24-medium】"><a href="#16、两两交换链表中的节点【LeetCode-24-medium】" class="headerlink" title="16、两两交换链表中的节点【LeetCode 24 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点【LeetCode 24 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191358.png"></p>
<p><strong>【解法】</strong>创建哑节点，定义<code>pre</code>指向哑节点，每次两两交换哑节点之后的两个节点，一次交换之后<code>pre</code>每次指向交换后的两个节点中的后一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	new_head-&gt;next = head;</span><br><span class="line">	ListNode* pre = new_head;</span><br><span class="line">	<span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next) &#123;</span><br><span class="line">		ListNode* p = pre-&gt;next;</span><br><span class="line">		ListNode* q = pre-&gt;next-&gt;next;</span><br><span class="line">		pre-&gt;next = q;</span><br><span class="line">		p-&gt;next = q-&gt;next;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		pre = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、K-个一组翻转链表【LeetCode-25-hard】"><a href="#17、K-个一组翻转链表【LeetCode-25-hard】" class="headerlink" title="17、K 个一组翻转链表【LeetCode 25 | hard】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表【LeetCode 25 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191327.png"></p>
<p><strong>【解法】</strong>需要把链表节点按照 <code>k</code> 个一组分组，所以可以使用一个指针 <code>head</code> 依次指向每组的头节点。这个指针每次向前移动 <code>k</code> 步，直至链表结尾。对于每个分组， 先判断它的长度是否大于等于 <code>k</code>。若是， 就翻转这部分链表，否则不需要翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转链表，返回头节点和尾节点，方便后续连接</span></span><br><span class="line">pair&lt; ListNode*, ListNode*&gt; reverseKNodes(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">	ListNode* pre = tail-&gt;next;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="comment">// 反转链表</span></span><br><span class="line">	<span class="keyword">while</span> (pre != tail) &#123;</span><br><span class="line">		ListNode* q = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; tail, head &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	hair-&gt;next = head;</span><br><span class="line">	ListNode* pre = hair;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		ListNode* tail = pre;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!tail) &#123; <span class="comment">// 如果为空，则代表后面的节点个数不足k个，直接返回</span></span><br><span class="line">				<span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ListNode* nex = tail-&gt;next;</span><br><span class="line">		<span class="comment">// 反转含有k个节点的链表部分</span></span><br><span class="line">		pair&lt;ListNode*, ListNode*&gt; result = <span class="built_in">reverseKNodes</span>(head, tail);</span><br><span class="line">		head = result.first;</span><br><span class="line">		tail = result.second;</span><br><span class="line">		<span class="comment">// 将反转后的链表连接到原来的链表上</span></span><br><span class="line">		pre-&gt;next = head;</span><br><span class="line">		tail-&gt;next = nex;</span><br><span class="line">		pre = tail;</span><br><span class="line">		head = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、判断链表是否有环-找出环的入口【LeetCode-142-medium】"><a href="#18、判断链表是否有环-找出环的入口【LeetCode-142-medium】" class="headerlink" title="18、判断链表是否有环/找出环的入口【LeetCode 142 | medium】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">判断链表是否有环/找出环的入口【LeetCode 142 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环， 使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</span><br><span class="line">示例1：</span><br><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210609115655.png"></p>
<p><strong>【解法】</strong>双指针，快指针走2步，慢指针走1步，两者先同时从头节点开始走，如果相遇则代表有环。</p>
<p>头节点和慢指针从相遇节点同时走，两者相遇的位置即为环的入口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	<span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">			ListNode* p = head;</span><br><span class="line">			<span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19、移除链表元素-【LeetCode-203-easy】"><a href="#19、移除链表元素-【LeetCode-203-easy】" class="headerlink" title="19、移除链表元素 【LeetCode 203 | easy】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素 【LeetCode 203 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</span><br><span class="line">示例1：</span><br><span class="line">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210607213053.png"></p>
<p><strong>【解法】</strong>由于可能头节点就是要删除的节点，所以定义一个临时节点作为头节点，依次遍历，找到满足删除条件的节点就删除，不满足条件则往后走一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">	ListNode* p = new_head;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">			p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20、重排链表-【LeetCode-143-medium】"><a href="#20、重排链表-【LeetCode-143-medium】" class="headerlink" title="20、重排链表 【LeetCode 143 | medium】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">重排链表 【LeetCode 143 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br><span class="line">示例 1:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</p>
<p>这样 的任务即可划分为三步：找到原链表的中点（双指针，快指针走两步，满指针走一步）；将原链表的右半端反转；将原链表的两端合并（因为两链表长度相差不超过 1，因此直接合并即可）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;   <span class="comment">// 反转链表</span></span><br><span class="line">	ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		ListNode* nex = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = nex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;   <span class="comment">// 快慢指针找到链表的中点</span></span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	<span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123; <span class="comment">// 将两个链表交错接在一起</span></span><br><span class="line">	ListNode* p;</span><br><span class="line">	ListNode* q;</span><br><span class="line">	<span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">		p = l1-&gt;next;</span><br><span class="line">		q = l2-&gt;next;</span><br><span class="line">		l1-&gt;next = l2;</span><br><span class="line">		l1 = p;</span><br><span class="line">		l2-&gt;next = l1;</span><br><span class="line">		l2 = q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">	ListNode* l1 = head;</span><br><span class="line">	ListNode* l2 = mid-&gt;next;</span><br><span class="line">	mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	l2 = <span class="built_in">reverseNode</span>(l2);</span><br><span class="line">	<span class="built_in">mergeList</span>(l1, l2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、对链表进行插入排序-【LeetCode-147-medium】"><a href="#21、对链表进行插入排序-【LeetCode-147-medium】" class="headerlink" title="21、对链表进行插入排序 【LeetCode 147 | medium】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序 【LeetCode 147 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】插入排序算法：</span><br><span class="line">插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</span><br><span class="line">每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>创建哑节点，便于在头节点之前进行插入。维护<code>lastSorted</code>为链表已排序部分的最后一个节点，维护<code>cur</code>为待插入的节点。比较<code>lastSorted</code>和<code>cur</code>的节点值，如果<code>lastSorted-&gt;val&lt;=cur-&gt;val</code>，说明这两个节点已经有序，同时往后移一个；否则，从链表的头节点开始遍历，寻找插入<code>cur</code>的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    new_head-&gt;next = head;</span><br><span class="line">    ListNode* lastSorted = head;</span><br><span class="line">    ListNode* cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastSorted-&gt;val &lt;= cur-&gt;val) &#123;</span><br><span class="line">            lastSorted = lastSorted-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode* pre = new_head;</span><br><span class="line">            <span class="keyword">while</span> (pre-&gt;next-&gt;val &lt;= cur-&gt;val) &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastSorted-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cur = lastSorted-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、奇偶链表【LeetCode-328-medium】"><a href="#22、奇偶链表【LeetCode-328-medium】" class="headerlink" title="22、奇偶链表【LeetCode 328 | medium】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">奇偶链表【LeetCode 328 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">应当保持奇数节点和偶数节点的相对顺序。</span><br><span class="line">链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>分离节点后合并。更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 <code>odd.next = even.next</code>，然后令 <code>odd = odd.next</code>，此时 <code>odd</code>变成 <code>even</code> 的后一个节点。</p>
<p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 <code>even.next = odd.next</code>，然后令 <code>even = even.next</code>，此时 <code>even </code>变成 <code>odd</code> 的后一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* evenHead = head-&gt;next;</span><br><span class="line">	ListNode* even = evenHead;</span><br><span class="line">	ListNode* odd = head;</span><br><span class="line">	<span class="keyword">while</span> (even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">		odd-&gt;next = even-&gt;next;</span><br><span class="line">		odd = odd-&gt;next;</span><br><span class="line">		even-&gt;next = odd-&gt;next;</span><br><span class="line">		even = even-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	odd-&gt;next = evenHead;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23、有序链表转换二叉搜索树【LeetCode-109-medium】"><a href="#23、有序链表转换二叉搜索树【LeetCode-109-medium】" class="headerlink" title="23、有序链表转换二叉搜索树【LeetCode 109 | medium】"></a>23、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">有序链表转换二叉搜索树【LeetCode 109 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</span><br><span class="line">示例:</span><br><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line">	  0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>分治 。找到链表的中位数，中位数即为根节点，然后递归构造左半边和右半边分别为左子树和右子树。时间复杂度：<code>O*(*nlogn)</code>，空间复杂度：<code>O(logn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">	ListNode* slow = left;</span><br><span class="line">	ListNode* fast = left;</span><br><span class="line">	<span class="keyword">while</span> (fast != right &amp;&amp; fast-&gt;next != right) &#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* mid = <span class="built_in">middleNode</span>(left, right);</span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">	root-&gt;left = <span class="built_in">buildTree</span>(left, mid);</span><br><span class="line">	root-&gt;right = <span class="built_in">buildTree</span>(mid-&gt;next, right);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">buildTree</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="24、交换链表中的节点【LeetCode-1721-medium】"><a href="#24、交换链表中的节点【LeetCode-1721-medium】" class="headerlink" title="24、交换链表中的节点【LeetCode 1721 | medium】"></a>24、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/">交换链表中的节点【LeetCode 1721 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你链表的头节点 head 和一个整数 k 。交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210609164953.png"></p>
<p><strong>【解法】</strong>分别找到链表中第<code>k</code>个和倒数第<code>k</code>个节点，交换这两个节点的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* former = head;</span><br><span class="line">	ListNode* latter = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!former) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		former = former-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (former) &#123; <span class="comment">// latter指向倒数第k个节点</span></span><br><span class="line">		latter = latter-&gt;next;</span><br><span class="line">		former = former-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换节点的值</span></span><br><span class="line">	<span class="keyword">int</span> tmp = p-&gt;val;</span><br><span class="line">	p-&gt;val = latter-&gt;val;</span><br><span class="line">	latter-&gt;val = tmp;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25、分隔链表【LeetCode-725-medium】"><a href="#25、分隔链表【LeetCode-725-medium】" class="headerlink" title="25、分隔链表【LeetCode 725 | medium】"></a>25、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">分隔链表【LeetCode 725 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</span><br><span class="line">每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</span><br><span class="line">这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</span><br><span class="line">返回一个符合上述规则的链表的列表。</span><br><span class="line">举例： 1-&gt;2-&gt;3-&gt;4, k &#x3D; 5 &#x2F;&#x2F; 5 结果 [ [1], [2], [3], [4], null ]</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: root &#x3D; [1, 2, 3], k &#x3D; 5</span><br><span class="line">输出: [[1],[2],[3],[],[]]</span><br><span class="line">解释:</span><br><span class="line">输入输出各部分都应该是链表，而不是数组。</span><br><span class="line">例如, 输入的结点 root 的 val&#x3D; 1, root.next.val &#x3D; 2, root.next.next.val &#x3D; 3, 且 root.next.next.next &#x3D; null。</span><br><span class="line">第一个输出 output[0] 是 output[0].val &#x3D; 1, output[0].next &#x3D; null。</span><br><span class="line">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3</span><br><span class="line">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">解释:</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>如果链表有<code>N</code>个结点，则分隔的链表中每个部分中都有 <code>N / k</code>个结点，且前 <code>N % k</code>部分有一个额外的结点。可以用一个简单的循环来计算<code>N</code>。现在对于每个部分， 已经计算出该部分有多少个节点：<code>width + (i &lt; remainder ? 1 : 0)</code>，创建一个新列表并将该部分写入该列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        ++len;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> width = len / k, rem = len % k;</span><br><span class="line">    <span class="function">vector&lt;ListNode*&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">    p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        ListNode* head = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width + (i &lt; rem ? <span class="number">1</span> : <span class="number">0</span>) - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            ListNode* pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、回文链表【LeetCode-234-easy】"><a href="#26、回文链表【LeetCode-234-easy】" class="headerlink" title="26、回文链表【LeetCode 234 | easy】"></a>26、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表【LeetCode 234 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请判断一个链表是否为回文链表。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。1) 找到前半部分链表的尾节点。2) 反转后半部分链表。3) 判断是否回文。4) 恢复链表。<br>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* cur = head;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		ListNode* nextptr = cur-&gt;next;</span><br><span class="line">		cur-&gt;next = pre;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = nextptr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	<span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!head) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">	ListNode* re_node = <span class="built_in">reverseNode</span>(mid-&gt;next);</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	ListNode* q = re_node;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag &amp;&amp; q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	mid-&gt;next = <span class="built_in">reverseNode</span>(re_node);</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="27、链表中的下一个更大节点【LeetCode-1019-medium】"><a href="#27、链表中的下一个更大节点【LeetCode-1019-medium】" class="headerlink" title="27、链表中的下一个更大节点【LeetCode 1019 | medium】"></a>27、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/">链表中的下一个更大节点【LeetCode 1019 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</span><br><span class="line">返回整数答案数组 answer，其中 answer[i] &#x3D; next_larger(node_&#123;i+1&#125;) 。</span><br><span class="line">注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[2,1,5]</span><br><span class="line">输出：[5,5,0]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,7,4,3,5]</span><br><span class="line">输出：[7,0,5,5,0]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：[1,7,5,1,9,2,5,1]</span><br><span class="line">输出：[7,9,9,9,0,5,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>单调递减栈。首先求出链表的长度，用链表的长度初始化数组。然后遍历链表，当栈为空或栈顶元素大于新来的元素的时候，入栈。当栈不为空且栈顶元素小于新来的元素的时候，出栈直至不满足该条件，将该元素入栈。栈中的节点类型为<code>pair&lt;int, ListNode*&gt;</code>，第一个元素代表数组的下标<code>index</code>，第二个元素代表链表的节点，即下标和节点相对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		++len;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	stack&lt;pair&lt;<span class="keyword">int</span>, ListNode*&gt;&gt; s;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="comment">// 当栈非空或栈顶元素大于新来的元素</span></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">empty</span>() || p-&gt;val &lt; s.<span class="built_in">top</span>().second-&gt;val) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, ListNode*&gt;(index, p));		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当栈不为空且栈顶元素小于新来的元素，则出栈，此时栈顶元素的下一个更大值即为这个新来的元素</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; p-&gt;val &gt; s.<span class="built_in">top</span>().second-&gt;val) &#123;</span><br><span class="line">				res[s.<span class="built_in">top</span>().first] = p-&gt;val;</span><br><span class="line">				s.<span class="built_in">pop</span>();				</span><br><span class="line">			&#125;</span><br><span class="line">			s.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, ListNode*&gt;(index, p));</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		++index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后如果栈不为空，则代表栈中的元素是递减的，即下一个更大的节点为0</span></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		res[s.<span class="built_in">top</span>().first] = <span class="number">0</span>;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="28、二叉树中的链表【LeetCode-1367-medium】"><a href="#28、二叉树中的链表【LeetCode-1367-medium】" class="headerlink" title="28、二叉树中的链表【LeetCode 1367 | medium】"></a>28、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/">二叉树中的链表【LeetCode 1367 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</span><br><span class="line">如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [4,2,8], root &#x3D; [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：树中蓝色的节点构成了与链表对应的子路径。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210610105919.png"></p>
<p><strong>【解法】</strong>代码与【判断子树】完全一样。详见注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSub</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 链表为空，则为true</span></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 链表没走完，树走完了，返回false</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 两者值不同，返回false</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;val != head-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果值相同，继续比较左边和右边有一个满足即可</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSub</span>(head-&gt;next, root-&gt;left) || <span class="built_in">isSub</span>(head-&gt;next, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先判断当前节点，如果不对，再看左子树和右子树</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSub</span>(head, root) || <span class="built_in">isSubPath</span>(head, root-&gt;left) || <span class="built_in">isSubPath</span>(head, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="29、从链表中删去总和值为零的连续节点【LeetCode-1171-medium】"><a href="#29、从链表中删去总和值为零的连续节点【LeetCode-1171-medium】" class="headerlink" title="29、从链表中删去总和值为零的连续节点【LeetCode 1171 | medium】"></a>29、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">从链表中删去总和值为零的连续节点【LeetCode 1171 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。删除完毕后，请你返回最终结果链表的头节点。</span><br><span class="line">你可以返回任何满足题目要求的答案。（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,2,-3,3,1]</span><br><span class="line">输出：[3,1]</span><br><span class="line">提示：答案 [1,2,1] 也是正确的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head &#x3D; [1,2,3,-3,4]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head &#x3D; [1,2,3,-3,-2]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前缀和 + 哈希表。第一次遍历链表，用哈希表记录前缀和<code>sum</code>的最右边的节点；第二次遍历链表，若当前节点处<code>sum</code>在下一处出现了则表明两结点之间所有节点和为<code>0</code>， 直接删除区间所有节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, ListNode*&gt; unmap;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 若同一和出现多次会覆盖，即记录该sum出现的最后一次节点</span></span><br><span class="line">	<span class="keyword">for</span> (ListNode* p = new_head; p != <span class="literal">nullptr</span>; p = p-&gt;next)	&#123;</span><br><span class="line">		sum += p-&gt;val;</span><br><span class="line">		unmap[sum] = p;</span><br><span class="line">	&#125;</span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 若当前节点处sum在下一处出现了则表明两结点之间所有节点和为0 直接删除区间所有节点</span></span><br><span class="line">	<span class="keyword">for</span> (ListNode* p = new_head; p != <span class="literal">nullptr</span>; p = p-&gt;next) &#123;</span><br><span class="line">		sum += p-&gt;val;</span><br><span class="line">		p-&gt;next = unmap[sum]-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="30、设计前中后队列【LeetCode-1670-medium】"><a href="#30、设计前中后队列【LeetCode-1670-medium】" class="headerlink" title="30、设计前中后队列【LeetCode 1670 | medium】"></a>30、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">设计前中后队列【LeetCode 1670 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。请你完成 FrontMiddleBack 类：</span><br><span class="line"></span><br><span class="line">FrontMiddleBack() 初始化队列。</span><br><span class="line">void pushFront(int val) 将 val 添加到队列的 最前面 。</span><br><span class="line">void pushMiddle(int val) 将 val 添加到队列的 正中间 。</span><br><span class="line">void pushBack(int val) 将 val 添加到队里的 最后面 。</span><br><span class="line">int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><br><span class="line">int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><br><span class="line">int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><br><span class="line">请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：</span><br><span class="line"></span><br><span class="line">将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。</span><br><span class="line">从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]</span><br><span class="line">[[], [1], [2], [3], [4], [], [], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, null, null, 1, 3, 4, 2, -1]</span><br><span class="line">解释：</span><br><span class="line">FrontMiddleBackQueue q &#x3D; new FrontMiddleBackQueue();</span><br><span class="line">q.pushFront(1);   &#x2F;&#x2F; [1]</span><br><span class="line">q.pushBack(2);    &#x2F;&#x2F; [1, 2]</span><br><span class="line">q.pushMiddle(3);  &#x2F;&#x2F; [1, 3, 2]</span><br><span class="line">q.pushMiddle(4);  &#x2F;&#x2F; [1, 4, 3, 2]</span><br><span class="line">q.popFront();     &#x2F;&#x2F; 返回 1 -&gt; [4, 3, 2]</span><br><span class="line">q.popMiddle();    &#x2F;&#x2F; 返回 3 -&gt; [4, 2]</span><br><span class="line">q.popMiddle();    &#x2F;&#x2F; 返回 4 -&gt; [2]</span><br><span class="line">q.popBack();      &#x2F;&#x2F; 返回 2 -&gt; []</span><br><span class="line">q.popFront();     &#x2F;&#x2F; 返回 -1 -&gt; [] （队列为空）</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>用双向链表进行模拟，初始时该双向链表有一个头节点和一个尾节点。</p>
<p>注意点：在中间插入时找到的是中间节点的前一个节点，在该节点之后进行插入；</p>
<p>在中间删除时找到的是中间节点，进行自我删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DualListNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	DualListNode* pre;</span><br><span class="line">	DualListNode* next;</span><br><span class="line">	<span class="built_in">DualListNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrontMiddleBackQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DualListNode* _head;</span><br><span class="line">	DualListNode* _tail;</span><br><span class="line">	<span class="keyword">int</span> _length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FrontMiddleBackQueue</span>() &#123;</span><br><span class="line">		_head = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(<span class="number">-1</span>);</span><br><span class="line">		_tail = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(<span class="number">-1</span>);</span><br><span class="line">		_head-&gt;next = _tail;</span><br><span class="line">		_tail-&gt;pre = _head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushFront</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;		</span><br><span class="line">		DualListNode* node = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(val);</span><br><span class="line">		node-&gt;next = _head-&gt;next;</span><br><span class="line">		_head-&gt;next-&gt;pre = node;				</span><br><span class="line">		_head-&gt;next = node;</span><br><span class="line">		node-&gt;pre = _head;</span><br><span class="line">		++_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushMiddle</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		DualListNode* node = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(val);</span><br><span class="line">		DualListNode* fast = _head;</span><br><span class="line">		DualListNode* slow = _head;</span><br><span class="line">		<span class="comment">// 找到中间节点的前一个节点，slow指向该节点，在该节点后进行插入</span></span><br><span class="line">		<span class="keyword">while</span> (fast-&gt;next != _tail &amp;&amp; fast-&gt;next-&gt;next != _tail) &#123;</span><br><span class="line">			fast = fast-&gt;next-&gt;next;</span><br><span class="line">			slow = slow-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		node-&gt;next = slow-&gt;next;</span><br><span class="line">		slow-&gt;next-&gt;pre = node;</span><br><span class="line">		slow-&gt;next = node;</span><br><span class="line">		node-&gt;pre = slow;</span><br><span class="line">		++_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		DualListNode* node = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(val);</span><br><span class="line">		node-&gt;pre = _tail-&gt;pre;</span><br><span class="line">		_tail-&gt;pre-&gt;next = node;</span><br><span class="line">		_tail-&gt;pre = node;</span><br><span class="line">		node-&gt;next = _tail;</span><br><span class="line">		++_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">popFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = _head-&gt;next-&gt;val;</span><br><span class="line">		DualListNode* node = _head-&gt;next-&gt;next;</span><br><span class="line">		_head-&gt;next = node;</span><br><span class="line">		node-&gt;pre = _head;</span><br><span class="line">		--_length;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">popMiddle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DualListNode* fast = _head;</span><br><span class="line">		DualListNode* slow = _head;</span><br><span class="line">		<span class="comment">// 找到中间节点，进行自我删除，slow指向中间节点</span></span><br><span class="line">		<span class="keyword">while</span> (fast != _tail &amp;&amp; fast-&gt;next != _tail) &#123;</span><br><span class="line">			fast = fast-&gt;next-&gt;next;</span><br><span class="line">			slow = slow-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		slow-&gt;next-&gt;pre = slow-&gt;pre;</span><br><span class="line">		slow-&gt;pre-&gt;next = slow-&gt;next;</span><br><span class="line">		--_length;</span><br><span class="line">		<span class="keyword">return</span> slow-&gt;val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">popBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = _tail-&gt;pre-&gt;val;</span><br><span class="line">		DualListNode* node = _tail-&gt;pre-&gt;pre;</span><br><span class="line">		node-&gt;next = _tail;</span><br><span class="line">		_tail-&gt;pre = node;</span><br><span class="line">		--_length;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="31、链表组件【LeetCode-817-medium】"><a href="#31、链表组件【LeetCode-817-medium】" class="headerlink" title="31、链表组件【LeetCode 817 | medium】"></a>31、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-components/">链表组件【LeetCode 817 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 G，该列表是上述链表中整型值的一个子集。返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</span><br><span class="line">示例 1：</span><br><span class="line">输入: head: 0-&gt;1-&gt;2-&gt;3，G &#x3D; [0, 1, 3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: head: 0-&gt;1-&gt;2-&gt;3-&gt;4，G &#x3D; [0, 3, 1, 4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>将数组中的元素放入<code>set</code>中，遍历链表，检查链表的数值是否在<code>set</code>中出现过，如果出现过且下一个节点不存在或下一个节点的值没出现，则个数加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">		s.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(p-&gt;val) != s.<span class="built_in">end</span>() &amp;&amp; (p-&gt;next == <span class="literal">nullptr</span> || s.<span class="built_in">find</span>(p-&gt;next-&gt;val) == s.<span class="built_in">end</span>())) &#123;</span><br><span class="line">			++result;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="32、扁平化多级双向链表【LeetCode-430-medium】"><a href="#32、扁平化多级双向链表【LeetCode-430-medium】" class="headerlink" title="32、扁平化多级双向链表【LeetCode 430 | medium】"></a>32、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">扁平化多级双向链表【LeetCode 430 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</span><br><span class="line">给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br><span class="line">解释：</span><br><span class="line">输入的多级列表如下图所示：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113123.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扁平化后的链表如下图：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113156.png"></p>
<p><strong>【解法】</strong>举例说明，对下图的链表进行扁平化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113416.png"></p>
<p>将列表顺时针转<code> 90°</code>，那么就会看到一颗二叉树，则扁平化的操作也就是对二叉树进行先序遍历（深度优先搜索）。如图所示， 可以将<code> child</code> 指针当作二叉树中指向左子树的 <code>left </code>指针，<code>next </code>指针可以当作是二叉树中的<code>right</code>指针。然后 深度优先搜索树将得到答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113226.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Node* tail;   <span class="comment">// tail指向每次递归的尾节点</span></span><br><span class="line">	<span class="function">Node* <span class="title">dfs</span><span class="params">(Node* p)</span> </span>&#123;</span><br><span class="line">		tail = p; </span><br><span class="line">		<span class="keyword">while</span> (p) &#123;</span><br><span class="line">			Node* pnext = p-&gt;next;</span><br><span class="line">			Node* pchild = p-&gt;child;</span><br><span class="line">			<span class="keyword">if</span> (pchild) &#123;</span><br><span class="line">				p-&gt;child = <span class="literal">nullptr</span>; <span class="comment">// 将孩子节点置空</span></span><br><span class="line">				p-&gt;next = pchild;</span><br><span class="line">				pchild-&gt;prev = p;</span><br><span class="line">				Node* tmp = <span class="built_in">dfs</span>(pchild);</span><br><span class="line">				<span class="comment">// 如果p节点存在next节点，则与child的尾结点连接</span></span><br><span class="line">				<span class="keyword">if</span> (pnext) &#123;</span><br><span class="line">					tmp-&gt;next = pnext;</span><br><span class="line">					pnext-&gt;prev = tmp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			p = pnext;</span><br><span class="line">			<span class="keyword">if</span> (p) &#123; <span class="comment">// 更新尾节点</span></span><br><span class="line">				tail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(head);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="33、排序的循环链表【剑指Offer2-29-medium】"><a href="#33、排序的循环链表【剑指Offer2-29-medium】" class="headerlink" title="33、排序的循环链表【剑指Offer2 | 29 | medium】"></a>33、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4ueAj6/">排序的循环链表【剑指Offer2 | 29 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定循环升序列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。</span><br><span class="line">给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。</span><br><span class="line">如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。</span><br><span class="line">如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：head &#x3D; [3,4,1], insertVal &#x3D; 2</span><br><span class="line">输出：[3,4,1,2]</span><br><span class="line">解释：在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210815211442.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210815211457.png"></p>
<p><strong>【解法】</strong>首先找到真正的头节点，然后从真正的头节点开始往后遍历，查找要插入的位置。如果存在所有节点都小于<code>insertVal</code>或所有节点都大于<code>insertVal</code>的情况，则找到链表的尾部直接插入，避免死循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, Node* _next) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = _next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			head = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">			head-&gt;next = head;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node* cur = head;</span><br><span class="line">		Node* next = head-&gt;next;</span><br><span class="line">		Node* realHead = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">// 找到真正的头节点</span></span><br><span class="line">		<span class="keyword">while</span> (cur-&gt;val &lt;= next-&gt;val) &#123;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			next = next-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (cur == head) &#123;<span class="comment">//避免死循环</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		realHead = next;</span><br><span class="line">		<span class="comment">// 找到要插入的位置</span></span><br><span class="line">		<span class="keyword">while</span> (next-&gt;val &lt; insertVal) &#123;</span><br><span class="line">			cur = next;</span><br><span class="line">			next = next-&gt;next;</span><br><span class="line">			<span class="comment">// 如果所有节点都小于insertVal或所有节点都大于insertVal</span></span><br><span class="line">			<span class="keyword">if</span> (next == realHead) &#123;<span class="comment">//避免死循环</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">		cur-&gt;next = node;</span><br><span class="line">		node-&gt;next = next;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="34、链表排序【剑指Offer2-77-easy】"><a href="#34、链表排序【剑指Offer2-77-easy】" class="headerlink" title="34、链表排序【剑指Offer2 77 | easy】"></a>34、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/7WHec2/">链表排序【剑指Offer2 77 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表。要求 O(nlogn)时间复杂度和常数级空间复杂度。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>使用递归可以实现链表的归并排序，首先使用<code>split</code>函数将链表分为前后两半并返回后半部分的头节点。再将链表分成的两半使用递归实现排序，之后调用 <code>merge</code>函数将两个已排序链表进行合并。其中 split 函数可以使用快慢指针法，而 <code>merge</code>函数可以使用双指针法。时间复杂度为<code>O(nlogn)</code>，空间复杂度为<code>O(logn)</code>，使用迭代实现可以把空间复杂度优化为<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* second = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* q = l2;</span><br><span class="line">        ListNode* r = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">                r-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q) &#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        ListNode* second = <span class="built_in">split</span>(head);</span><br><span class="line">        ListNode* res1 = <span class="built_in">sortList</span>(head1);</span><br><span class="line">        ListNode* res2 = <span class="built_in">sortList</span>(second);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="35、单链表排序"><a href="#35、单链表排序" class="headerlink" title="35、单链表排序"></a>35、单链表排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>归并排序。将原链表分成两个链表，对两个链表进行归并排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将链表分成两个链表</span></span><br><span class="line">	<span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* second = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* p = l1;</span><br><span class="line">        ListNode* q = l2;</span><br><span class="line">        ListNode* r = dummy;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt;= q-&gt;val) &#123;</span><br><span class="line">                r-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q) &#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        ListNode* second = <span class="built_in">split</span>(head);</span><br><span class="line">        ListNode* res1 = <span class="built_in">sortList</span>(head1);</span><br><span class="line">        ListNode* res2 = <span class="built_in">sortList</span>(second);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(res1, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>快排。（牛客可以通过，力扣超时）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">solve</span><span class="params">(ListNode* head, ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == tail)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = head-&gt;val;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q != tail)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val &lt; x)&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                <span class="built_in">swap</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(head-&gt;val, p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode* head, ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == tail)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = <span class="built_in">solve</span>(head, tail);</span><br><span class="line">        <span class="built_in">quickSort</span>(head, p);</span><br><span class="line">        <span class="built_in">quickSort</span>(p-&gt;next, tail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="五、栈-队列-堆-单调栈"><a href="#五、栈-队列-堆-单调栈" class="headerlink" title="五、栈 / 队列 / 堆 / 单调栈"></a>五、栈 / 队列 / 堆 / 单调栈</h3><h5 id="1、用两个栈实现队列【剑指Offer-09-easy】"><a href="#1、用两个栈实现队列【剑指Offer-09-easy】" class="headerlink" title="1、用两个栈实现队列【剑指Offer 09 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列【剑指Offer 09 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; values &lt;&#x3D; 10000</span><br><span class="line">最多会对 appendTail、deleteHead 进行 10000 次调用</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。对于删除操作，虽然看起来是 O(N)的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)，空间复杂度：O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        _s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!_s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                _s2.<span class="built_in">push</span>(_s1.<span class="built_in">top</span>());</span><br><span class="line">                _s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = _s2.<span class="built_in">top</span>();</span><br><span class="line">            _s2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、包含min函数的栈【剑指Offer-30-easy】"><a href="#2、包含min函数的栈【剑指Offer-30-easy】" class="headerlink" title="2、包含min函数的栈【剑指Offer 30 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈【剑指Offer 30 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</span><br><span class="line">示例:</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br><span class="line"> </span><br><span class="line">提示：各函数的调用总次数不超过 20000 次</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>维护一个保存最小值的栈，和存放数据的栈一同插入和删除来保证每次插入删除后，最小值栈的栈顶总是当前数据元素中的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        _data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (_min.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _min.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; _min.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                _min.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _min.<span class="built_in">push</span>(_min.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _data.<span class="built_in">pop</span>();</span><br><span class="line">        _min.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _min;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、栈的压入、弹出序列【剑指Offer-31-medium】"><a href="#3、栈的压入、弹出序列【剑指Offer-31-medium】" class="headerlink" title="3、栈的压入、弹出序列【剑指Offer 31 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列【剑指Offer 31 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释： 可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>遍历<code>pushed</code>数组入栈，如果栈顶和<code>popped</code>数组元素相同则弹出，最后根据栈是否为空来判断是否是正确的出栈顺序。时间复杂度仍为<code>O(N)</code>，空间复杂度为<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		S.<span class="built_in">push</span>(pushed[i]);</span><br><span class="line">		<span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() == popped[j])&#123;</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、队列的最大值【剑指Offer-59-2-medium】"><a href="#4、队列的最大值【剑指Offer-59-2-medium】" class="headerlink" title="4、队列的最大值【剑指Offer 59-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">队列的最大值【剑指Offer 59-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1</span><br><span class="line">示例 1：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; value &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双端队列。维护一个递减的双端队列，时间复杂度<code>O(1)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _deq.<span class="built_in">empty</span>() ? <span class="number">-1</span> : _deq.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        _que.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="comment">// 若入队元素比队尾数字更大，则弹出队尾数字，维护队列的单调性</span></span><br><span class="line">        <span class="keyword">while</span> (!_deq.<span class="built_in">empty</span>() &amp;&amp; _deq.<span class="built_in">back</span>() &lt; value) &#123;</span><br><span class="line">            _deq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _deq.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = _que.<span class="built_in">front</span>();</span><br><span class="line">        _que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 只有当x和双端队列队首元素相同是才弹出，保证了双端队列队首元素总是最大值</span></span><br><span class="line">        <span class="keyword">if</span> (x == _deq.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            _deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; _que;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; _deq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="5、数据流中的中位数【剑指Offer-41-medium】"><a href="#5、数据流中的中位数【剑指Offer-41-medium】" class="headerlink" title="5、数据流中的中位数【剑指Offer 41 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数【剑指Offer 41 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line">例如：</span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line">[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br><span class="line"></span><br><span class="line">限制：最多会对 addNum、findMedian 进行 50000 次调用。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>优先队列（堆）。建立一个小顶堆<code>A</code>和一个大顶堆<code>B</code>，各保存一半元素：小顶堆中保存较大的一半，大顶堆中保存较小的一半，中位数可根据两个堆顶元素计算获得。设元素总数为<code>N = m + n</code> ，其中<code>m</code>和<code>n</code>分别是<code>A</code>和<code>B</code>中的元素个数。当<code>m = n</code>（即 N为偶数）时，需要向<code>A</code>中添加一个元素，实现方法：将新元素<code>num</code>插入至<code>B</code>，再将<code>B</code>堆顶元素插入至<code>A</code>，中位数为 (<code>A的堆顶元素 + B 的堆顶元素 )/2</code> ；当<code>m ≠ n</code>（即<code>N</code>为 奇数）：需向<code>B</code>添加一个元素。实现方法：将新元素<code>num</code>插入至<code>A</code>，再将<code>A</code>堆顶元素插入至<code>B </code>，则中位数为<code>A </code>的堆顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当两堆的数据个数相等时候，左边堆添加元素。</span></span><br><span class="line"><span class="comment">         * 采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后</span></span><br><span class="line"><span class="comment">         * 将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。</span></span><br><span class="line"><span class="comment">         * 同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (_big.<span class="built_in">size</span>() == _small.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            _small.<span class="built_in">push</span>(num);</span><br><span class="line">            _big.<span class="built_in">push</span>(_small.<span class="built_in">top</span>());</span><br><span class="line">            _small.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;           </span><br><span class="line">            _big.<span class="built_in">push</span>(num);</span><br><span class="line">            _small.<span class="built_in">push</span>(_big.<span class="built_in">top</span>());</span><br><span class="line">            _big.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;    </span><br><span class="line">        <span class="keyword">if</span> (_small.<span class="built_in">size</span>() == _big.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result = (_small.<span class="built_in">top</span>() + _big.<span class="built_in">top</span>())  * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _big.<span class="built_in">top</span>() * <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最大堆，存放较小的一半数字，堆顶为最大值</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; _big;</span><br><span class="line">    <span class="comment">// 最小堆， 存放较大的一半数字，堆顶为最小值</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; _small;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="6、基本计算器-II-【LeetCode-227-medium】"><a href="#6、基本计算器-II-【LeetCode-227-medium】" class="headerlink" title="6、基本计算器 II 【LeetCode 227 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">基本计算器 II 【LeetCode 227 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>【解法】可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p>
<p>具体来说，遍历字符串 <code>s</code>，并用变量<code>preSign</code> 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据<code>preSign</code> 来决定计算方式：</p>
<ul>
<li><p>加号：将数字压入栈；</p>
</li>
<li><p>减号：将数字的相反数压入栈；</p>
</li>
<li><p>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。</p>
<p>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新<code>preSign</code> 为当前遍历的字符。</p>
</li>
</ul>
<p>遍历完字符串 <code>s</code> 后，将栈中元素累加，即为该字符串表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">char</span> preSign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (preSign) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">back</span>() *= num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                stk.<span class="built_in">back</span>() /= num;</span><br><span class="line">            &#125;</span><br><span class="line">            preSign = s[i];</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、表达式求值-【牛客网】"><a href="#7、表达式求值-【牛客网】" class="headerlink" title="7、表达式求值 【牛客网】"></a>7、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">表达式求值 【牛客网】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请写一个整数计算器，支持加减乘三种运算和括号。</span><br><span class="line">示例1</span><br><span class="line">输入：&quot;1+2&quot;</span><br><span class="line">返回值：3</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;(2*(3-4))*5&quot;</span><br><span class="line">返回值：-10</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同上一题。栈 + 递归。因为此题需要计算有括号的情况，括号中的表达式需要进行递归运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//用于返回当前字符串的计算结果</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; sum; <span class="comment">//用于求和</span></span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>; <span class="comment">//记录前一个符号，初始化为+，因为可以看成当前字符串前先加0</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//用于将连续数字字符串转化成数字或者记录递归结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//遍历每一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//先处理数字字符</span></span><br><span class="line">            num = <span class="number">10</span> * num + s[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//进位后加个位数</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">//对于括号</span></span><br><span class="line">            <span class="keyword">int</span> left = i++, count = <span class="number">1</span>; <span class="comment">//用left记录最左括号位置，count记录左括号数，i当成右指针右移一格</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//最终目的是找到与最左括号匹配的右括号，类似于栈操作</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) count--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="built_in">solve</span>(s.<span class="built_in">substr</span>(left + <span class="number">1</span>, i - left - <span class="number">2</span>)); <span class="comment">//迭代计算括号内数值，注意不要包含最左最右括号，不然会死循环</span></span><br><span class="line">            i--; <span class="comment">//此时i是最右括号下一位，需要左移一位防止最右括号在字符串尾时发生越界从而使下面的判定失效</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() - <span class="number">1</span> || s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">//对于字符串尾，或者加减乘，此时 用的符号是上一次的，结算当前数字</span></span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>) sum.<span class="built_in">push</span>(num); <span class="comment">//加法入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;-&#x27;</span>) sum.<span class="built_in">push</span>(-num); <span class="comment">//减法相当于加负数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;*&#x27;</span>) sum.<span class="built_in">top</span>() *= num; <span class="comment">//乘法与栈顶相乘</span></span><br><span class="line">            sign = s[i]; <span class="comment">//更新符号，若为末尾的右括号也无妨，因为马上就退出循环了</span></span><br><span class="line">            num = <span class="number">0</span>; <span class="comment">//重置当前数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!sum.<span class="built_in">empty</span>()) &#123; <span class="comment">//将栈内所有数字相加</span></span><br><span class="line">        res += sum.<span class="built_in">top</span>();</span><br><span class="line">        sum.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">//返回当前字符串计算结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、LRU-缓存机制【LeetCode-146-medium】"><a href="#8、LRU-缓存机制【LeetCode-146-medium】" class="headerlink" title="8、LRU 缓存机制【LeetCode 146 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">LRU 缓存机制【LeetCode 146 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。</span><br><span class="line">实现 LRUCache 类：</span><br><span class="line">LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</span><br><span class="line">int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</span><br><span class="line">void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</span><br><span class="line">进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</span><br><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双端队列+哈希表。双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。哈希表即为普通的哈希映射，通过缓存数据的键映射到其在双向链表中的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> key, value;</span><br><span class="line">	DLinkedNode* prev;</span><br><span class="line">	DLinkedNode* next;</span><br><span class="line">	<span class="built_in">DLinkedNode</span>() :<span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value) :<span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">	DLinkedNode* head;</span><br><span class="line">	DLinkedNode* tail;</span><br><span class="line">	<span class="keyword">int</span> _size;</span><br><span class="line">	<span class="keyword">int</span> _capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity): _capacity(capacity), _size(<span class="number">0</span>) &#123;</span><br><span class="line">		head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">		tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">		head-&gt;next = tail;</span><br><span class="line">		tail-&gt;prev = head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DLinkedNode* node = cache[key];  <span class="comment">//key存在，则通过哈希表找到</span></span><br><span class="line">		<span class="built_in">moveToHead</span>(node);                    <span class="comment">// 并移到头部</span></span><br><span class="line">		<span class="keyword">return</span> node-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;  <span class="comment">// 如果key不存在，则创建一个新的结点，并添加到哈希表中</span></span><br><span class="line">			DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);  <span class="comment">// 创建新结点</span></span><br><span class="line">			cache[key] = node;   <span class="comment">// 添加到哈希表中</span></span><br><span class="line">			<span class="built_in">addToHead</span>(node);     <span class="comment">// 添加到双向链表头部</span></span><br><span class="line">			++_size;</span><br><span class="line">			<span class="keyword">if</span> (_size &gt; _capacity) &#123;  <span class="comment">// 如果插入之后size比capacity大，则删除尾结点</span></span><br><span class="line">				DLinkedNode* removed = <span class="built_in">removeTail</span>();  <span class="comment">// 删除尾结点</span></span><br><span class="line">				cache.<span class="built_in">erase</span>(removed-&gt;key);            <span class="comment">// 删除哈希表中对应的元素</span></span><br><span class="line">				<span class="keyword">delete</span> removed;                       <span class="comment">// 防止内存泄漏</span></span><br><span class="line">				--_size;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">// 如果key存在，则把它移动到头部</span></span><br><span class="line">			DLinkedNode* node = cache[key];  <span class="comment">// 先通过哈希表查找</span></span><br><span class="line">			node-&gt;value = value;</span><br><span class="line">			<span class="built_in">moveToHead</span>(node);                <span class="comment">// 再把它移动到头部</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;  <span class="comment">// 删除node结点</span></span><br><span class="line">		node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">		node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;   <span class="comment">// 在头部添加结点</span></span><br><span class="line">		node-&gt;prev = head;</span><br><span class="line">		node-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next-&gt;prev = node;</span><br><span class="line">		head-&gt;next = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;  <span class="comment">// 将node移动到头部</span></span><br><span class="line">		<span class="built_in">removeNode</span>(node);  <span class="comment">// 先删除node</span></span><br><span class="line">		<span class="built_in">addToHead</span>(node);   <span class="comment">// 再在头部添加node</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">		<span class="built_in">removeNode</span>(node);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="9、有效的括号【LeetCode-20-easy】"><a href="#9、有效的括号【LeetCode-20-easy】" class="headerlink" title="9、有效的括号【LeetCode 20 | easy】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号【LeetCode 20 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。</span><br><span class="line">有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s &#x3D; &quot;(]&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：s &#x3D; &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>哈希表+栈。用哈希表来保存同类型的括号，遍历整个字符串，如果是左括号，则入栈；如果是右括号，则先判断是否和栈顶是同一种类型的括号，不是则直接返回<code>false</code>，是的话则栈顶元素出栈。时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n+∣Σ∣)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; pairs = &#123;</span><br><span class="line">		&#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	stack&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pairs.<span class="built_in">count</span>(ch)) &#123;</span><br><span class="line">			<span class="comment">// 如果是右括号，则先判断是否和栈顶的左括号是同一种类型</span></span><br><span class="line">			<span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch]) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			stk.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果是左括号</span></span><br><span class="line">			stk.<span class="built_in">push</span>(ch);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、直方图最大矩形面积"><a href="#10、直方图最大矩形面积" class="headerlink" title="10、直方图最大矩形面积"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/0ynMMM/">直方图最大矩形面积</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定非负整数数组 heights ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</span><br><span class="line">求在该柱状图中，能够勾勒出来的矩形的最大面积。</span><br><span class="line">输入：heights &#x3D; [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210819214252.png"></p>
<p><strong>【解法】</strong>单调栈。分别找出每个元素的左边界和右边界，然后遍历边界数组，两个边界的距离乘上当前元素的值即为面积。</p>
<p>枚举某一根柱子<code>i</code>作为高<code>h=heights[i]</code>；随后需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于<code>h</code>。换句话说，我们需要找到左右两侧最近的高度小于<code>h</code>的柱子，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于<code>h</code>，并且就是<code>i</code>能够扩展到的最远范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从左到右遍历，left中保存的是每个元素左边最近的小于当前值的索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;  <span class="comment">// 栈中存放的是索引</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; heights[s.<span class="built_in">peek</span>()] &gt;= heights[i])&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        left[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">peek</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 从右到左遍历，right中保存的是每个元素右边最近的小于当前值的索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; heights[s.<span class="built_in">peek</span>()] &gt;= heights[i])&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        right[i] = s.<span class="built_in">empty</span>() ? n : s.<span class="built_in">peek</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        maxArea = Math.<span class="built_in">max</span>(maxArea, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、矩阵中最大的矩形【剑指Offer】"><a href="#11、矩阵中最大的矩形【剑指Offer】" class="headerlink" title="11、矩阵中最大的矩形【剑指Offer】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/PLYXKQ/">矩阵中最大的矩形【剑指Offer】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1 的最大矩形，并返回其面积。</span><br><span class="line">注意：此题 matrix 输入格式为一维 01 字符串数组。</span><br><span class="line">输入：matrix &#x3D; [&quot;10100&quot;,&quot;10111&quot;,&quot;11111&quot;,&quot;10010&quot;]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210819214632.png" style="zoom:80%;" />

<p><strong>【解法】</strong>同上一题。对于每一行数据，相当于计算一个直方图中的最大矩形。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210819215549.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(heights.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(heights.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> n = heights.<span class="built_in">size</span>(), maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; heights[s.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;		</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        left[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    s = stack&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; heights[s.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line"></span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        right[i] = s.<span class="built_in">empty</span>() ? n : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        maxArea = <span class="built_in">max</span>(maxArea, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;string&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">heights</span><span class="params">(matrix.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                heights[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                heights[j] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxArea = <span class="built_in">max</span>(maxArea, <span class="built_in">largestRectangleArea</span>(heights));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、查找和最小的K对数字【LeetCode373-medium】"><a href="#12、查找和最小的K对数字【LeetCode373-medium】" class="headerlink" title="12、查找和最小的K对数字【LeetCode373 | medium】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">查找和最小的K对数字【LeetCode373 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。</span><br><span class="line">定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</span><br><span class="line">请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>最大堆，枚举所有的组合，若<code>nums1</code>和<code>nums2</code>的长度分别为<code>m</code>和<code>n</code>，那么共有<code>O(mn)</code>种组合，之后遍历这些组合使用一个最大堆就可以找到最小的<code>k</code>对组合，时间复杂度为<code>O(mnlogk)</code>。但是这样处理未考虑两个数组本身就是升序的特点，若取<code>nums1</code> 的第<code>k + 1</code>个数<code>a</code>，其与<code>nums2</code>中的任何一个数<code>b</code>组合都不可能是最小的<code>k</code>对组合之一，因为<code>a</code>的前的<code>k</code>个数中任何一个数与<code>b</code>的组合都要比<code>a</code>与``b<code>组合要小。在</code>nums2<code>中也同理，所以最小的</code>k<code>对组合只会出现在</code>num1<code>的前</code>k<code>个数和</code>num2<code>的前</code>k<code>个数的组合中。所以可以把时间复杂度优化到 </code>O(k^2logk)`。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 最大堆</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.first + lhs.second &lt; rhs.first + rhs.second;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">heap</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.<span class="built_in">size</span>() &amp;&amp; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123; nums1[i], nums2[j] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] + nums2[j] &lt; heap.<span class="built_in">top</span>().first + heap.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">                heap.<span class="built_in">pop</span>();</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123; nums1[i], nums2[j] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = heap.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ret</span>(size, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        ret[size - <span class="number">1</span> - i][<span class="number">0</span>] = heap.<span class="built_in">top</span>().first;</span><br><span class="line">        ret[size - <span class="number">1</span> - i][<span class="number">1</span>] = heap.<span class="built_in">top</span>().second;</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>最大堆。每次都从<code>k</code>个候选数对中选取最小的数对，并将其从最小堆内出堆，记录答案。如果最小数对在两个数组内的下标为<code>i1</code>和<code>i2</code>，那么将下标为<code>i1</code>和<code>i2 + 1</code>的数对添加进最小堆。</p>
<ul>
<li><p>为什么只考虑下标为<code>[i1, i2 + 1]</code>的数对，不考虑下标为<code>[i1 + 1, i2]</code>的数对？</p>
<ul>
<li><p>若下标为<code>[i1 + 1, i2]</code>的数对已经在堆内，那自然无需考虑；</p>
</li>
<li><p>若下标为<code>[i1 + 1, i2]</code>的数对不在堆内，那么两种情况需要分析：</p>
<ul>
<li><p>若下标为<code>[i1 + 1, i2 - 1]</code>的数对在堆内并且未出堆，那么<strong>和更大</strong>的下标为<code>[i1 + 1, i2]</code>的数对不可能是当前最小的数对，没必要添加到堆内；</p>
</li>
<li><p>若下标为<code>[i1 + 1, i2 - 1]</code>的数对还未加入堆内，那么下标为<code>[i1 + 1, i2 - 2]</code>的数对也存在在与不在当前堆内的两种情况，</p>
<p>若在堆内则可以一直反推到下标为<code>[i1 + 1, i2]</code>的数对不可能是当前最小的数对；</p>
<p>若不在堆内就在考虑下标为<code>[i1 + 1, i2 - 3]</code> 的数对，但是无论如何下标为<code>[i1 + 1, 0]</code>的数对，一定在堆内存在过，因为这是一开始就添加的，所以整个判断可以完成闭环，结论得证。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以发现这种解法的巧妙之处在于，通过最小堆和初始数对的建堆让原本是需要考虑两种情况优化为只要考虑一种情况，时间复杂度为<code>O(klogk)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[lhs.first] + nums2[lhs.second] &gt; nums1[rhs.first] + nums2[rhs.second];</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">heap</span>(cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123; i,<span class="number">0</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>() &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123; nums1[tmp.first], nums2[tmp.second] &#125;);</span><br><span class="line">        <span class="keyword">if</span> (tmp.second &lt; nums2.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            heap.<span class="built_in">push</span>(&#123; tmp.first, tmp.second + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h3><h5 id="1、斐波那契数列【剑指Offer-10-1-easy】"><a href="#1、斐波那契数列【剑指Offer-10-1-easy】" class="headerlink" title="1、斐波那契数列【剑指Offer 10-1 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列【剑指Offer 10-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1, F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>斐波那契方程即为状态转移方程：<code>dp[i+1]=dp[i]+dp[i-1]</code>。但是没必要定义一个<code>dp</code>数组，用两个辅助变量即可进行空间优化。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">1</span>, fn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fn = (f0 + f1) % <span class="number">1000000007</span>;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、青蛙跳台阶问题【剑指Offer-10-2-easy】"><a href="#2、青蛙跳台阶问题【剑指Offer-10-2-easy】" class="headerlink" title="2、青蛙跳台阶问题【剑指Offer 10-2 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶问题【剑指Offer 10-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>思路同斐波那契数列。<code>dp</code>数组采用空间优化。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, fn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		fn = (f1 + f2) % <span class="number">1000000007</span>;</span><br><span class="line">		f1 = f2;</span><br><span class="line">		f2 = fn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/three-steps-problem-lcci/">三步问题【LeetCode】</a></p>
<p>一次能走1、2、3个台阶：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">3</span>) &#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> c = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tem = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		tem = (a + b + c) % <span class="number">1000000007</span>;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">		c = tem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m步问题：</p>
<p>一次能走1、2、3、……、m个台阶：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、剪绳子【剑指Offer-14-1-medium】【LeetCode-343-整数拆分】"><a href="#3、剪绳子【剑指Offer-14-1-medium】【LeetCode-343-整数拆分】" class="headerlink" title="3、剪绳子【剑指Offer 14-1 | medium】【LeetCode 343 | 整数拆分】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剪绳子【剑指Offer 14-1 | medium】【LeetCode 343 | 整数拆分】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时， 把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>动态规划。<code>dp[i]</code>表示长度为<code>i</code>的绳子剪成<code>m</code>段后的最大乘积，初始化<code>dp[2] = 1</code>。先剪下一段<code>j</code>，如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪；剩下<code>(i-j)</code>长度，可以剪也可以不剪，如果不剪的话长度乘积即为<code> j×(i-j)</code>，如果剪的话长度乘积即为<code>j×dp[i-j]</code>，两者取最大值。时间复杂度<code>O(N^2)</code>，空间复杂度<code>O(N)</code>。</p>
<p>状态转移方程：<br>$$<br>dp[i]=max(dp[i], max(j*(i-j), j*dp[i-j]))<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>贪心算法：假设将长度为n的绳子分为a段，即<code>n=n1+n2+......+na</code>，等价于求解：<br>$$<br>max(n1<em>n2</em>……*na)<br>$$<br>有如下数学推论：当所有绳段长度相等时，乘积最大；最优的绳段长度为3。</p>
<p>所以计算长度为<code>n</code>的绳子可以分为长度为<code>3</code>的几段<code>count</code>，并计算余数<code>a</code>；当余数为<code>0</code>时，最大乘积即为<code>pow(3, count)</code>；当余数是<code>1</code>时，则将最后一个长度为3的段空出来，和余数为<code>1</code>的段合并成长度为<code>4</code>的段，最大乘积为<code>2*2=4</code>；当余数为<code>2</code>时，最大乘积即为<code>2 * pow(3, count)</code>。时间复杂度<code>O(1)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> a = n % <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">		sum = <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">		sum = <span class="number">4</span> * <span class="built_in">pow</span>(<span class="number">3</span>, count - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">		sum = <span class="number">2</span> * <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、剪绳子-II【剑指Offer-14-2-medium】"><a href="#4、剪绳子-II【剑指Offer-14-2-medium】" class="headerlink" title="4、剪绳子 II【剑指Offer 14-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II【剑指Offer 14-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时， 把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>解法同上一题。唯一不同的是这道题需要考虑 <strong>“大数越界情况下的求余问题”</strong> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a; i++) &#123;</span><br><span class="line">        result = <span class="number">3</span> * result % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="number">3</span> * result % p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;  <span class="comment">// 如果余数为1，则分出一个3出来，因为 1 * 3 &lt; 2 * 2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="number">4</span> * result % p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="number">6</span> * result % p);  <span class="comment">// 如果余数为2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、礼物的最大价值【剑指Offer-47-medium】"><a href="#5、礼物的最大价值【剑指Offer-47-medium】" class="headerlink" title="5、礼物的最大价值【剑指Offer 47 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值【剑指Offer 47 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</span><br><span class="line">示例 1:</span><br><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br><span class="line"></span><br><span class="line">提示：0 &lt; grid.length &lt;&#x3D; 200，0 &lt; grid[0].length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>时间复杂度<code>O(MN)</code>，空间优化后空间复杂度<code>O(1)</code>。状态转移方程：<br>$$<br>dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]);<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地修改数组进行空间优化，不增加额外空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;  <span class="comment">// 处理第一行</span></span><br><span class="line">		grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  <span class="comment">// 处理第一列</span></span><br><span class="line">		grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  <span class="comment">// 处理第一行</span></span><br><span class="line">			grid[i][j] += <span class="built_in">max</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、丑数【剑指Offer-49-medium】"><a href="#6、丑数【剑指Offer-49-medium】" class="headerlink" title="6、丑数【剑指Offer 49 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数【剑指Offer 49 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】 把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</span><br><span class="line">示例:</span><br><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line"></span><br><span class="line">说明:  1 是丑数。n 不超过1690。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>用三个指针<code>a</code>、<code>b</code>、<code>c</code>，初始值为1，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。状态转移方程：<br>$$<br>dp[i]=min(2<em>dp[a],3</em>dp[b],5*dp[c])<br>$$<br>然后分别比较<code>dp[i]</code>和<code>2dp[a]</code>，<code>3dp[b]</code>，<code>5dp[c]</code>是否相等，如果相等则对应的指针加1。时间复杂度<code>O(N）</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span> * dp[a], n3 = <span class="number">3</span> * dp[b], n5 = <span class="number">5</span> * dp[c];</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(n2, n3), n5);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n2) &#123;</span><br><span class="line">            ++a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n3) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n5) &#123;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、分割回文串【LeetCode-131-medium】"><a href="#7、分割回文串【LeetCode-131-medium】" class="headerlink" title="7、分割回文串【LeetCode 131 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串【LeetCode 131 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</span><br><span class="line">回文串 是正着读和反着读都一样的字符串。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>搜索 + 回溯 + 动态规划预处理。</p>
<p>假设当前搜索到字符串的第<code>i</code>个字符，且<code>s[0..i-1]</code>位置的所有字符已经被分割成若干个回文串，并且分割结果被放入了答案数组<code>ans</code>中，那么 就需要枚举下一个回文串的右边界<code>j</code>，使得<code>s[i..j]</code>是一个回文串。</p>
<p>因此， 可以从<code>i</code>开始，从小到大依次枚举<code>j</code>。对于当前枚举的<code>j</code>值， 使用双指针的方法判断<code>s[i..j]</code>是否为回文串：如果<code>s[i..j]</code>是回文串，那么就将其加入答案数组<code>ans</code>中，并以<code>j+1</code>作为新的<code>i</code>进行下一层搜索，并在未来的回溯时将<code>s[i..j]</code>从<code>ans</code>中移除。如果已经搜索完了字符串的最后一个字符，那么就找到了一种满足要求的分割方法。</p>
<p>当判断<code>s[i..j]</code>是否为回文串时，常规的方法是使用双指针分别指向<code>i</code>和<code>j</code>，每次判断两个指针指向的字符是否相同，直到两个指针相遇。然而这种方法会产生重复计算，例如下面这个例子：</p>
<p>当<code>s=aaba</code>时，对于前 2 个字符<code>aa</code>， 有 2 种分割方法<code>[aa]</code>和 <code>[a,a]</code>，当每一次搜索到字符串的第<code>i=2</code>个字符<code>b</code>时，都需要对于每个<code>s[i..j]</code>使用双指针判断其是否为回文串，这就产生了重复计算。</p>
<p>因此，可以将字符串<code>s</code>的每个子串<code>s[i..j]</code>是否为回文串预处理出来，使用动态规划即可。设 <code>f(i,j)</code>表示 <code>s[i..j] </code>是否为回文串，那么有状态转移方程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210618205624.png">    </p>
<p>其中<code>∧</code>表示逻辑与运算，即<code>s[i..j]</code>为回文串，当且仅当其为空串（<code>i&gt;j</code>），其长度为 1（<code>i=j</code>），或者首尾字符相同且<code>s[i+1..j−1]</code>为回文串。</p>
<p>预处理完成之后，只需要<code>O(1)</code>的时间就可以判断任意<code>s[i..j]</code>是否为回文串了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">	vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">	vector&lt;string&gt; ans;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">			ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">				<span class="built_in">dfs</span>(s, j + <span class="number">1</span>);</span><br><span class="line">				ans.<span class="built_in">pop_back</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">		n = s.<span class="built_in">size</span>();</span><br><span class="line">		f.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line">		<span class="comment">//动态规划：判断s[i,...j]是否是回文串</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8、n个骰子的点数【剑指Offer-60-medium】"><a href="#8、n个骰子的点数【剑指Offer-60-medium】" class="headerlink" title="8、n个骰子的点数【剑指Offer 60 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数【剑指Offer 60 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="line">你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 11</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>假设已知<code>n-1</code>个骰子的解为<code>f(n-1)</code>，此时添加一个骰子，求<code>n</code>个骰子的点数和为<code>x</code>的概率为<code>f(n,x)</code>。当添加骰子的点数为 1 时，前<code> n - 1</code>个骰子的点数和应为<code> x - 1</code>，方可组成点数和<code> x</code>；同理，当此骰子为 2 时，前<code> n - 1</code> 个骰子应为 <code>x - 2</code>；以此类推，直至此骰子点数为 6 。将这 6 种情况的概率相加，即可得到概率 <code>f(n, x) </code>。递推公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210427195338.png"></p>
<p>但是<code> f(n-1, x-i)</code>会有越界问题，转换为正向递推，概率 <code>f(n-1, x) </code>只和<code> f(n, x + 1), f(n, x + 1) , ......,  f(n, x + 6)</code>相关，遍历 <code>f(n - 1)</code> 中各点数和的概率，并将其添加至 <code>f(n)</code> 中所有相关项，即可完成<code>f(n - 1)</code>至 <code>f(n)</code> 的递推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                tmp[j + k] += dp[j] / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、股票的最大利润【剑指Offer-63-medium】"><a href="#9、股票的最大利润【剑指Offer-63-medium】" class="headerlink" title="9、股票的最大利润【剑指Offer 63 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润【剑指Offer 63 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前i天的最大利润等于前<code>i-1</code>天的最大利润和第<code>i</code>天卖出的最大利润中的最大值。</p>
<p>状态转移方程，用常量进行空间优化，时间复杂度<code>O(N)</code>，空间优化后空间复杂度<code>O(1)</code>：<br>$$<br>dp[i] = max(dp[i], prices[i] - minval);<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> minval = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		minval = <span class="built_in">min</span>(minval, prices[i]);  <span class="comment">// 找price最小值</span></span><br><span class="line">		profit = <span class="built_in">max</span>(profit, prices[i] - minval);  <span class="comment">// 比较前一天的利润，和今天卖出获得的利润</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、正则表达式匹配【剑指Offer-19-hard】【LeetCode-10-hard】"><a href="#10、正则表达式匹配【剑指Offer-19-hard】【LeetCode-10-hard】" class="headerlink" title="10、正则表达式匹配【剑指Offer 19 | hard】【LeetCode 10 | hard】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">正则表达式匹配【剑指Offer 19 | hard】【LeetCode 10 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数用来匹配包含&#39;. &#39;和&#39;*&#39;的正则表达式。</span><br><span class="line">模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。</span><br><span class="line">在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入：</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#39;*&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>设<code>s</code>的长度为<code>n</code>，<code>p</code>的长度为<code>m</code>；将<code>s</code>的第<code>i</code>个字符记为<code>si</code>，<code>p</code>的第<code>j</code>个字符记为<code>pj</code>，将<code>s</code>的前<code>i</code>个字符组成的子字符串记为<code>s[:i]</code>, 同理将<code>p</code>的前<code>j</code>个字符组成的子字符串记为<code>p[:j]</code>。因此，本题可转化为求<code>s[:n]</code>是否能和<code>p[:m]</code>匹配。</p>
<p>总体思路是从<code>s[:1]</code>和<code>p[:1]</code>是否能匹配开始判断，每轮添加一个字符并判断是否能匹配，直至添加完整个字符串<code>s</code>和<code>p</code> 。展开来看，假设<code>s[:i]</code>与 <code>p[:j]</code>可以匹配，那么下一状态有两种：</p>
<ul>
<li>添加一个字符<code>s(i+1)</code>后是否能匹配？</li>
<li>添加字符<code>p(j+1)</code>后是否能匹配？</li>
</ul>
<p>因此，本题的状态共有<code>m×n</code>种，应定义状态矩阵<code>dp</code>，<code>dp[i][j]</code>代表 <code>s[:i]</code>与<code>p[:j]</code>是否可以匹配。</p>
<p><strong>动态规划解析：</strong></p>
<ul>
<li>状态定义： 设动态规划矩阵<code>dp</code>，<code>dp[i][j]</code>代表字符串<code>s</code>的前<code>i</code>个字符和<code>p</code>的前<code>j</code>个字符能否匹配。</li>
<li>转移方程： 需要注意，由于<code>dp[0][0]</code>代表的是空字符的状态， 因此 <code>dp[i][j]</code>对应的添加字符是<code>s[i - 1]</code>和<code>p[j - 1]</code>。<ul>
<li>当<code>p[j - 1] = &#39;*&#39;</code>时，<code>dp[i][j]</code>在当以下任一情况为 <code>true</code>时等于<code>true</code>：<ul>
<li><code>dp[i][j - 2]</code>： 即将字符组合<code>p[j - 2] *</code>看作出现 0 次时，能否匹配；</li>
<li><code>dp[i - 1][j]</code>且<code>s[i - 1] = p[j - 2]</code>: 即让字符<code>p[j - 2]</code>多出现 1 次时，能否匹配；</li>
<li><code>dp[i - 1][j]</code>且<code>p[j - 2] = &#39;.&#39;</code>: 即让字符<code>&#39;.&#39;</code>多出现 1 次时，能否匹配；</li>
</ul>
</li>
<li><code>p[j - 1] != &#39;*&#39;</code>时，<code>dp[i][j]</code>在当以下任一情况为<code>true</code>时等于<code>true</code>：<ul>
<li><code>dp[i - 1][j - 1]</code>且<code>s[i - 1] = p[j - 1]</code>： 即让字符 <code>p[j - 1]</code>多出现一次时，能否匹配；</li>
<li><code>dp[i - 1][j - 1]</code>且<code>p[j - 1] = &#39;.&#39;</code>： 即将字符<code>.</code>看作字符<code>s[i - 1]</code>时，能否匹配；</li>
</ul>
</li>
</ul>
</li>
<li>初始化： 需要先初始化<code>dp</code>矩阵首行，以避免状态转移时索引越界。<ul>
<li><code>dp[0][0] = true</code>： 代表两个空字符串能够匹配。</li>
<li><code>dp[0][j] = dp[0][j - 2]</code>且<code>p[j - 1] = &#39;*&#39;</code>： 首行<code>s</code>为空字符串，因此当<code>p</code>的偶数位为<code>*</code>时才能够匹配（即让<code>p</code>的奇数位出现 0 次，保持<code>p</code>是空字符串）。因此，循环遍历字符串<code>p</code>，步长为 2（即只看偶数位）。</li>
</ul>
</li>
<li>返回值：<code>dp</code>矩阵右下角字符，代表字符串<code>s</code>和<code>p</code>能否匹配。</li>
</ul>
<p>时间复杂度<code>O(MN)</code>。空间复杂度<code>O(MN)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = s.<span class="built_in">size</span>() + <span class="number">1</span>, n = p.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 初始化第一行，dp[0][j]，s为空，p只有偶数位为&#x27;*&#x27;时才匹配</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">				dp[i][j] = dp[i][j - <span class="number">2</span>] || (dp[i - <span class="number">1</span>][j] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>])) ||</span><br><span class="line">					(dp[i - <span class="number">1</span>][j] &amp;&amp; p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>])) || (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、不同路径-II【LeetCode-63-medium】"><a href="#11、不同路径-II【LeetCode-63-medium】" class="headerlink" title="11、不同路径 II【LeetCode 63 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II【LeetCode 63 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span><br><span class="line">网格中的障碍物和空位置分别用 1 和 0 来表示。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>初始化<code>dp</code>数组为1，<code>dp[i][j]</code>表示从初始位置到第<code>i</code>行第<code>j</code>列的路径数。先初始化<code>dp</code>数组的<code>第0行</code>和<code>第0列</code>，<code>flag</code>用于记录<code>第0行</code>和<code>第0列</code>中第一个出现障碍物的位置，因为<code>第0行</code>和<code>第0列</code>中，如果出现障碍物，那么障碍物之后的所有格子，<code>dp[i][0] = dp[0][i] = 0</code>，因为不能往左和往上走。</p>
<p>对于第<code>i</code>行第<code>j</code>列，有状态转移方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 先初始化dp数组的第0行和第0列，flag用于记录第0行和第0列中第一个出现障碍物的位置</span></span><br><span class="line">	<span class="comment">// 因为第0行和第0列中，如果出现障碍物，那么障碍物之后的所有格子，dp[i][0]=dp[0][i]=0</span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">			flag = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// flag&gt;=0说明存在障碍物，则将障碍物的dp值置0</span></span><br><span class="line">	<span class="keyword">if</span> (flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; m; ++i) &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	flag = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">			flag = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; n; ++i) &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、使用最小花费爬楼梯【LeetCode-746-easy】"><a href="#12、使用最小花费爬楼梯【LeetCode-746-easy】" class="headerlink" title="12、使用最小花费爬楼梯【LeetCode 746 | easy】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯【LeetCode 746 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：cost &#x3D; [10, 15, 20]</span><br><span class="line">输出：15</span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出：6</span><br><span class="line">解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>假设数组<code>cost</code>的长度为<code>n</code>，则<code>n</code>个阶梯分别对应下标 0 到<code>n−1</code>，楼层顶部对应下标 <code>n</code>，问题等价于计算达到下标<code>n</code>的最小花费。可以通过动态规划求解。</p>
<p>创建长度为<code>n+1</code>的数组<code>dp</code>，其中<code>dp[i]</code>表示达到下标<code>i</code>的最小花费。</p>
<p>由于可以选择下标 0 或1 作为初始阶梯，因此有<code>dp[0] = dp[1] = 0</code>。</p>
<p>当 <code>2 ≤ i ≤ n</code>时，可以从下标<code>i−1</code>使用<code>cost[i−1]</code>的花费达到下标<code>i</code>，或者从下标<code>i−2</code>使用<code>cost[i−2]</code>的花费达到下标<code>i</code>。为了使总花费最小，<code>dp[i]</code>应取上述两项的最小值，因此状态转移方程如下：</p>
<p><code>dp[i] = min(dp[i−1] + cost[i−1], dp[i−2] + cost[i−2])</code></p>
<p>依次计算<code>dp</code>中的每一项的值，最终得到的<code>dp[n]</code>即为达到楼层顶部的最小花费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>], dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、除数博弈【LeetCode-1025-easy】"><a href="#13、除数博弈【LeetCode-1025-easy】" class="headerlink" title="13、除数博弈【LeetCode 1025 | easy】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divisor-game/">除数博弈【LeetCode 1025 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</span><br><span class="line">选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。</span><br><span class="line">用 N - x 替换黑板上的数字 N 。</span><br><span class="line">如果玩家无法执行这些操作，就会输掉游戏。</span><br><span class="line">只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>数学方法递推。</p>
<ul>
<li><p>n = 1 的时候，区间 (0,1) 中没有整数是 n 的因数，所以此时 Alice 败。</p>
</li>
<li><p>n = 2 的时候，Alice 只能拿 1，n 变成 1， Bob 无法继续操作，故  Alice 胜。</p>
</li>
<li><p>n = 3 的时候，Alice 只能拿 1，n 变成 2，根据 n = 2 的结论，此时 Bob 会获胜，Alice 败。</p>
</li>
<li><p>n = 4 的时候，Alice 能拿 1 或 2，如果 Alice 拿 1，根据 n=3 的结论，Bob 会失败，Alice 会获胜。</p>
</li>
<li><p>n = 5 的时候，Alice 只能拿 1，根据 n=4 的结论，Alice 会失败。</p>
</li>
<li><p>……</p>
<p>发现这样一个现象：<strong>n 为奇数的时候 Alice（先手）必败，n 为偶数的时候 Alice 必胜。</strong> </p>
</li>
</ul>
<p>证明：</p>
<p>n = 1 和 n=2 时结论成立。</p>
<p>n &gt; 2 时，假设 n ≤ k 时该结论成立，则 n = k + 1 时：</p>
<ul>
<li>如果 k 为偶数，则 k+1 为奇数，x 是 k+1 的因数，只可能是奇数，而奇数减去奇数等于偶数，且 k+1−x ≤ k，故轮到 Bob 的时候都是偶数。而根据猜想假设 n≤k 的时候偶数的时候先手必胜，故此时无论 Alice 拿走什么，Bob 都会处于必胜态，所以 Alice 处于必败态。</li>
<li>如果 k 为奇数，则 k + 1为偶数，x 可以是奇数也可以是偶数，若 Alice 减去一个奇数，那么 k + 1 - x 是一个小于等于 k 的奇数，此时 Bob 占有它，处于必败态，则  Alice 处于必胜态。</li>
<li>综上所述，这个猜想是正确的。</li>
<li>时间复杂度：O(1)，空间复杂度：O(1)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>动态规划。</p>
<p>在「解法1」中，Alice 处在 n = k 的状态时，他做一步操作，必然使得 Bob 处于 n = m (m &lt; k) 的状态。因此只要看是否存在一个 m 是必败的状态，那么 Alice 直接执行对应的操作让当前的数字变成 m，Alice 就必胜了，如果没有任何一个是必败的状态的话，说明 Alice 无论怎么进行操作，最后都会让 Bob 处于必胜的状态，此时 Alice 是必败的。</p>
<p>结合以上 定义 f[i] 表示当前数字 i 的时候先手是处于必胜态还是必败态，true 表示先手必胜，false 表示先手必败，从前往后递推，根据上文的分析，枚举 i 在 (0, i) 中 i 的因数 j，看是否存在 f[i−j] 为必败态即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">5</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    f[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i % j == <span class="number">0</span> &amp;&amp; !f[i - j]) &#123;</span><br><span class="line">				f[i] = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、按摩师【LeetCode-面试题17-16-easy】"><a href="#14、按摩师【LeetCode-面试题17-16-easy】" class="headerlink" title="14、按摩师【LeetCode 面试题17.16 | easy】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-masseuse-lcci/">按摩师【LeetCode 面试题17.16 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</span><br><span class="line">示例 1：</span><br><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>定义<code>dp[i][0]</code>表示考虑前<code>i</code>个预约，第<code>i</code>个预约不接的最长预约时间，<code>dp[i][1]</code>表示考虑前<code>i</code>个预约，第<code>i</code>个预约接的最长预约时间。</p>
<p>从前往后计算<code>dp</code>值，假设已经计算出前<code>i−1</code>个<code>dp</code>值，考虑计算<code>dp[i][0/1]</code>的答案。</p>
<p>首先考虑<code>dp[i][0]</code>的转移方程，由于这个状态下第<code>i</code>个预约是不接的，所以第<code>i−1</code>个预约接或不接都可以，故可以从<code>dp[i−1][0]</code>和<code>dp[i−1][1]</code>两个状态转移过来，转移方程即为：</p>
<ul>
<li><code>dp[i][0] = max(dp[i−1][0], dp[i−1][1])</code></li>
</ul>
<p>对于<code>dp[i][1]</code>，由于这个状态下第<code>i</code>个预约要接，根据题目要求按摩师不能接受相邻的预约，所以第<code>i−1</code>个预约不能接受，故 只能从<code>dp[i−1][0]</code>这个状态转移过来，转移方程即为：</p>
<ul>
<li><code>dp[i][1] = dp[i−1][0]+nums[i]</code>，其中<code>nums [i]</code>表示第<code>i</code>个预约的时长。</li>
</ul>
<p>最后答案即为:</p>
<ul>
<li><code>max(dp[n][0],dp[n][1])</code>，其中<code>n</code>表示预约的个数。</li>
</ul>
<p>再回来看转移方程，发现计算<code>dp[i][0/1]</code>时，只与前一个状态<code>dp[i−1][0/1]</code>有关，所以 可以不用开数组，只用两个变量<code>dp_0</code>和<code>dp_1</code> 分别存储<code>dp[i−1][0]</code>和<code>dp[i−1][1]</code>的答案，然后去转移更新答案即可。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>, dp_1 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;		</span><br><span class="line">        <span class="keyword">int</span> tmp_0 = <span class="built_in">max</span>(dp_0, dp_1);</span><br><span class="line">        <span class="keyword">int</span> tmp_1 = dp_0 + nums[i];</span><br><span class="line">        dp_0 = tmp_0;</span><br><span class="line">        dp_1 = tmp_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp_0, dp_1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、打家劫舍【LeetCode-198-medium】"><a href="#15、打家劫舍【LeetCode-198-medium】" class="headerlink" title="15、打家劫舍【LeetCode 198 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍【LeetCode 198 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>
<p>如果房屋数量大于两间，有两个选项：</p>
<p>偷窃第<code>k</code>间房屋，那么就不能偷窃第<code>k-1</code>间房屋，偷窃总金额为前<code>k−2</code>间房屋的最高总金额与第<code>k</code>间房屋的金额之和；不偷窃第<code>k</code>间房屋，偷窃总金额为前<code>k−1</code>间房屋的最高总金额。在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前<code>k</code>间房屋能偷窃到的最高总金额。</p>
<ul>
<li><p>边界条件：<code>dp[0] = nums[0]</code>，<code>dp[1] = max(nums[0], nums[1])</code></p>
</li>
<li><p>状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code></p>
</li>
</ul>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、打家劫舍-II【LeetCode-213-medium】"><a href="#16、打家劫舍-II【LeetCode-213-medium】" class="headerlink" title="16、打家劫舍 II【LeetCode 213 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II【LeetCode 213 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>因为有环，如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。</p>
<p>假设数组<code>nums</code>的长度为<code>n</code>。</p>
<p>如果不偷窃最后一间房屋，则偷窃房屋的下标范围是<code> [0, n-2]</code>；如果不偷窃第一间房屋，则偷窃房屋的下标范围是<code> [1, n-1]</code>。在确定偷窃房屋的下标范围之后，即可用上一题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在<code>n</code>间房屋中可以偷窃到的最高总金额。</p>
<p>假设偷窃房屋的下标范围是<code>[start, end]</code>，用 <code>dp[i]</code>表示在下标范围<code>[start,i]</code>内可以偷窃到的最高总金额，那么就有如下：</p>
<ul>
<li><p>边界条件：<code>dp[start] = nums[start]</code>，<code>dp[start + 1] = max(nums[start], nums[start + 1])</code></p>
</li>
<li><p>状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code></p>
</li>
</ul>
<p>计算得到<code>dp[end]</code>即为下标范围<code>[start,end]</code>内可以偷窃到的最高总金额。</p>
<p>分别取<code>(start,end)=(0,n−2)</code>和<code>(start,end)=(1,n−1)</code>进行计算，取两个<code>dp[end]</code>中的最大值，即可得到最终结果。时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = nums[start], second = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = second;</span><br><span class="line">		second = <span class="built_in">max</span>(first + nums[i], second);</span><br><span class="line">		first = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robRange</span>(nums, <span class="number">0</span>, n - <span class="number">2</span>), <span class="built_in">robRange</span>(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、交错字符串【LeetCode-97-medium】"><a href="#17、交错字符串【LeetCode-97-medium】" class="headerlink" title="17、交错字符串【LeetCode 97 | medium】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串【LeetCode 97 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</span><br><span class="line">两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</span><br><span class="line">s &#x3D; s1 + s2 + ... + sn</span><br><span class="line">t &#x3D; t1 + t2 + ... + tm</span><br><span class="line">|n - m| &lt;&#x3D; 1</span><br><span class="line">交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</span><br><span class="line">提示：a + b 意味着字符串 a 和 b 连接。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s1 &#x3D; &quot;&quot;, s2 &#x3D; &quot;&quot;, s3 &#x3D; &quot;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210618212125.png"></p>
<p><strong>【解法】</strong>首先如果<code>|s1|+|s2|≠|s3∣</code>，那 <code>s3</code>必然不可能由<code>s1</code>和 <code>s2</code>交错组成。</p>
<p>在<code>|s1|+|s2|=|s3∣</code>时，可以用动态规划来求解。<strong>定义<code>f(i,j)</code>表示<code>s1</code>的前<code>i</code>个元素和 <code>s2</code>的前<code>j</code>个元素是否能交错组成<code>s3</code>的前<code>i+j</code>个元素</strong>。如果<code>s1</code>的第<code>i</code>个元素和<code>s3</code>的第<code>i+j</code>个元素相等，那么<code>s1</code>的前<code>i</code>个元素和 <code>s2</code>的前 <code>j</code>个元素是否能交错组成<code>s3</code>的前<code>i+j</code>个元素取决于<code>s1</code>的前<code>i−1</code>个元素和<code>s2</code>的前<code>j</code>个元素是否能交错组成<code>s3</code>的前 <code>i+j−1</code>个元素，即此时<code>f(i,j)</code>取决于<code>f(i−1,j)</code>，在此情况下如果<code>f(i−1,j)</code>为真，则<code>f(i,j)</code>也为真。同样的，如果 <code>s2</code>的第<code>j</code>个元素和<code>s3</code>的第<code>i+j</code>个元素相等并且<code>f(i,j−1)</code>为真，则<code>f(i, j)</code>也为真。于是可以推导出这样的动态规划转移方程：</p>
<p><code>f(i, j) = [f(i-1, j) &amp;&amp; s1[i-1] == s3[i+j-1]] or [f(i,j-1) &amp;&amp; s2[j-1] == s3[i+j-1]]</code></p>
<p>时间复杂度和空间复杂度都是 <code>O(nm)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(s1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(s2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>(), t = s3.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] |= (f[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[p]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] |= (f[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、二维区域和检索-矩阵不可变"><a href="#18、二维区域和检索-矩阵不可变" class="headerlink" title="18、二维区域和检索 - 矩阵不可变"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。上图子矩阵左上角 (row1, col1) &#x3D; (2, 1) ，右下角(row2, col2) &#x3D; (4, 3)，该子矩形内元素的总和为 8。</span><br><span class="line">示例：</span><br><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210619145021.png"></p>
<p><strong>【解法】</strong>定义一个二维<code>dp</code>数组，<code>dp[i][j]</code>表示从<code>(0,0)</code>到<code>(i,j)</code>范围内的元素总和。时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">	<span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">			dp.<span class="built_in">resize</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">					dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j] - dp[i][j] + matrix[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">return</span> dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - dp[row1][col2 + <span class="number">1</span>] - dp[row2 + <span class="number">1</span>][col1] + dp[row1][col1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="19、解码方法【LeetCode-91-medium】"><a href="#19、解码方法【LeetCode-91-medium】" class="headerlink" title="19、解码方法【LeetCode 91 | medium】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">解码方法【LeetCode 91 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span><br><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br><span class="line">要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：</span><br><span class="line">&quot;AAJF&quot; ，将消息分组为 (1 1 10 6)</span><br><span class="line">&quot;KJF&quot; ，将消息分组为 (11 10 6)</span><br><span class="line">注意，消息不能分组为  (1 11 06) ，因为 &quot;06&quot; 不能映射为 &quot;F&quot; ，这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价。</span><br><span class="line">给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</span><br><span class="line">题目数据保证答案肯定是一个 32 位 的整数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="20、目标和【LeetCode-494-medium】"><a href="#20、目标和【LeetCode-494-medium】" class="headerlink" title="20、目标和【LeetCode 494 | medium】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">目标和【LeetCode 494 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ：</span><br><span class="line">例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。</span><br><span class="line">返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1], target &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】动态规划。</strong></p>
<p>记数组的元素和为<code>sum</code>，添加<code>-</code>号的元素之和为<code>neg</code>，则其余添加<code>+</code>的元素之和为<code>sum−neg</code>，得到的表达式的结果为<code>(sum−neg)−neg = sum−2⋅neg = target</code>，即<code>neg = (sum−target) / 2</code>。    </p>
<p>由于数组<code>nums</code>中的元素都是非负整数，<code>neg</code>也必须是非负整数，所以上式成立的前提是<code>sum−target</code>是非负偶数。若不符合该条件可直接返回 0。</p>
<p>若上式成立，问题转化成在数组<code>nums</code>中选取若干元素，使得这些元素之和等于<code>neg</code>，计算选取元素的方案数。定义二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在数组<code>nums</code>的前<code>i</code>个数中选取元素，使得这些元素之和等于<code>j</code>的方案数。假设数组<code>nums</code>的长度为<code>n</code>，则最终答案为<code>dp[n][neg]</code>。</p>
<p>当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p>
<p><code>dp[0][j] = 1, j = 0 ; dp[0][j] = 0, j &gt;= 1</code></p>
<p>当<code>1≤i≤n</code>时，对于数组<code>nums</code>中的第<code>i</code>个元素<code>num</code>（<code>i</code>的计数从 1 开始），遍历<code>0 ≤ j ≤ neg</code>，计算 <code>dp[i][j]</code>的值：</p>
<ul>
<li>如果<code>j&lt;num</code>，则不能选<code>num</code>，此时有<code>dp[i][j]=dp[i−1][j]</code>；</li>
<li>如果<code>j ≥  num</code>，则如果不选<code>num</code>，方案数是<code>dp[i−1][j]</code>，如果选<code>num</code>，方案数是<code>dp[i−1][j−num]</code>，此时有<code>dp[i][j]=dp[i−1][j]+dp[i−1][j−num]</code>。</li>
</ul>
<p>因此状态转移方程如下：</p>
<p><code>dp[i][j]</code> = <code>dp[i−1][j]，j&lt;nums[i]</code>，</p>
<p><code>dp[i][j] = dp[i−1][j] + dp[i−1][j−nums[i]]，j&gt;=nums[i]</code>,</p>
<p>最终得到<code>dp[n][neg]</code>的值即为答案。</p>
<p>空间复杂度为<code>O(n×neg)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		sum += num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> diff = (sum - target) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), neg = diff / <span class="number">2</span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(neg + <span class="number">1</span>));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= neg; ++j) &#123;</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= num) &#123;</span><br><span class="line">				dp[i][j] += dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][neg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维dp数组写法--Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum - target &lt; <span class="number">0</span> || (sum - target) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> neg = (sum - target) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[neg + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = neg; j &gt;= nums[i]; --j)&#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[neg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>回溯。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, target, index + <span class="number">1</span>, sum + nums[index]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, target, index + <span class="number">1</span>, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、最长递增子序列的个数【LeetCode-673-medium】"><a href="#21、最长递增子序列的个数【LeetCode-673-medium】" class="headerlink" title="21、最长递增子序列的个数【LeetCode 673 | medium】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数【LeetCode 673 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个未排序的整数数组，找到最长递增子序列的个数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>贪心 + 二分。</p>
<p><strong>【解法】</strong>定义一个动态规划数组<code>dp</code>，<code>dp[i]</code>表示到<code>nums[i]</code>为止的最长递增子序列长度，<code>count[i]</code>表示到<code>nums[i]</code>为止的最长递增子序列个数。</p>
<ul>
<li>初始化状态：<code>dp = [1] * n</code>：代表最长递增子序列的长度至少为1，<code>count = [1] * n</code>：代表最长递增子序列的个数至少为1</li>
<li>状态转移：<br>对于每一个数<code>nums[i]</code>，看在它之前的数<code>nums[j](0&lt;= j &lt; i)</code>是否比当前数<code>nums[i]</code>小，如果<code>nums[i] &gt; nums[j]</code>，那么相当于到<code>nums[j]</code>为止的最长递增子序列长度到<code>nums[i]</code>增加了1，到<code>nums[i]</code>为止的最长递增子序列长度就变成了<code>dp[i] = dp[j] + 1</code>；但是因为满足<code>nums[i] &gt; nums[j]</code>的<code>nums[j]</code>不止一个，<code>dp[i]</code>应该取这些<code>dp[j] + 1</code>的最大值，并且这些<code>dp[j] + 1</code>还会有相等的情况，一旦相等，到<code>nums[i]</code>为止的最长递增子序列个数就应该增加了。因此，具体的状态转移如下，在<code>nums[i] &gt; nums[j]</code>的前提下：<ul>
<li>如果<code>dp[j] + 1 &gt; dp[i]</code>，说明最长递增子序列的长度增加了，<code>dp[i] = dp[j] + 1</code>，长度增加，数量不变<code>count[i] = count[j]</code></li>
<li>如果<code>dp[j] + 1 == dp[i]</code>，说明最长递增子序列的长度并没有增加，但是出现了长度一样的情况，数量增加<code>count[i] += count[j]</code></li>
<li>记录最长递增子序列的最大长度<code>max_length</code>。遍历<code>dp</code>数组，如果<code>dp</code>数组记录的最大长度<code>dp[i]</code>等于<code>max_length</code>，将对应的数量<code>count[i]</code>加到结果<code>res</code>中。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">					dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">					count[i] = count[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123;</span><br><span class="line">					count[i] += count[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到最大长度</span></span><br><span class="line">	<span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i: dp) &#123;</span><br><span class="line">		longest = <span class="built_in">max</span>(longest, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到最大长度对应的子数组个数</span></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == longest) &#123;</span><br><span class="line">			res += count[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、连续的子数组和【LeetCode-523-medium】"><a href="#22、连续的子数组和【LeetCode-523-medium】" class="headerlink" title="22、连续的子数组和【LeetCode 523 | medium】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/continuous-subarray-sum/">连续的子数组和【LeetCode 523 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：子数组大小 至少为 2 ，且子数组元素总和为 k 的倍数。(如果存在一个整数 n ，令整数 x 符合 x &#x3D; n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。)</span><br><span class="line">如果存在，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 &#x3D; 7 * 6 且 7 是一个整数。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前缀和+哈希表。首先计算出数组<code>nums</code>的前缀和数组，则对于任意一个子数组，都可以在<code>O(1)</code>的时间内得到其元素和。用<code>prefixSums[i]</code>表示数组<code>nums</code>从下标<code>0</code>到下标<code>i</code>的前缀和，则<code>nums</code>从下标<code>p+1</code>到下标 <code>q(p&lt;q）</code>的子数组的长度为<code>q−p</code>，该子数组的元素和为<code>prefixSums[q]−prefixSums[p]</code>。</p>
<p>如果<code>prefixSums[q]−prefixSums[p]</code>为<code>k</code>的倍数，且<code>q−p≥2</code>，则上述子数组即满足大小至少为 2 且元素和为 k 的倍数。</p>
<p>当<code>prefixSums[q]−prefixSums[p]</code>为<code>k</code>的倍数时，<code>prefixSums[p]</code>和<code>prefixSums[q]</code>除以<code>k</code>的余数相同。因此只需要计算每个下标对应的前缀和除以<code>k</code>的余数即可，使用哈希表存储每个余数第一次出现的下标。</p>
<p>规定空的前缀的结束下标为 −1，由于空的前缀的元素和为 0，因此在哈希表中存入键值对<code>(0,−1)</code>。对于<code>0≤i&lt;m</code>，从小到大依次遍历每个<code>i</code>，计算每个下标对应的前缀和除以<code>k</code>的余数，并维护哈希表：</p>
<ul>
<li>如果当前余数在哈希表中已经存在，则取出该余数在哈希表中对应的下标<code>prevIndex</code>，<code>nums</code>从下标 <code>prevIndex+1</code>到下标<code>i</code>的子数组的长度为<code>i−prevIndex</code>，该子数组的元素和为<code>k</code>的倍数，如果<code>i−prevIndex≥2</code>，则找到了一个大小至少为 2 且元素和为<code>k</code>的倍数的子数组，返回<code>true</code>；</li>
<li>如果当前余数在哈希表中不存在，则将当前余数和当前下标<code>i</code>的键值对存入哈希表中。</li>
</ul>
<p>由于哈希表存储的是每个余数第一次出现的下标，因此当遇到重复的余数时，根据当前下标和哈希表中存储的下标计算得到的子数组长度是以当前下标结尾的子数组中满足元素和为<code>k</code>的倍数的子数组长度中的最大值。只要最大长度至少为 2，即存在符合要求的子数组。时间复杂度：<code>O(m)</code>，其空间复杂度：<code>O(min(m,k))</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	unmap[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		remainder = (remainder + nums[i]) % k;</span><br><span class="line">        <span class="comment">// 当前余数在哈希表中存在，说明存在和为k倍数的子数组，那么判断子数组的长度是否大于2</span></span><br><span class="line">		<span class="keyword">if</span> (unmap.<span class="built_in">count</span>(remainder)) &#123;</span><br><span class="line">			<span class="keyword">int</span> prevIndex = unmap[remainder];</span><br><span class="line">			<span class="keyword">if</span> (i - prevIndex &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 当前余数在哈希表中不存在，则加入</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			unmap[remainder] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23、最长回文子序列【LeetCode-516-medium】"><a href="#23、最长回文子序列【LeetCode-516-medium】" class="headerlink" title="23、最长回文子序列【LeetCode 516 | medium】"></a>23、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列【LeetCode 516 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个字符串s，找到其中最长的回文子序列，并返回该序列的长度。可以假设s的最大长度为 1000 。</span><br><span class="line">示例 1:</span><br><span class="line">输入:&quot;bbbab&quot;</span><br><span class="line">输出:4</span><br><span class="line">一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：&quot;cbbd&quot;</span><br><span class="line">输出:2</span><br><span class="line">一个可能的最长回文子序列为 &quot;bb&quot;。</span><br></pre></td></tr></table></figure>

<p>【解法】创建一个动态规划数组<code>dp</code>，<code>dp[i][j]</code>表示<code>s</code>的第<code>i</code>个字符到第<code>j</code>个字符组成的子串中，最长的回文序列的长度。如果<code>s</code>的第<code>i</code>个字符和第<code>j</code>个字符相同的话，<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code></p>
<p>如果<code>s</code>的第<code>i</code>个字符和第<code>j</code>个字符不同的话，<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code></p>
<p>然后注意遍历顺序，<code>i</code>从最后一个字符开始往前遍历，<code>j</code>从<code>i + 1</code>开始往后遍历，这样可以保证每个子问题都已经算好了。初始化<code>dp[i][i] = 1</code>，即单个字符的最长回文序列是 1。结果即为<code>dp[0][s.size()-1]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">				dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="24、不同的二叉搜索树【LeetCode-96-medium】"><a href="#24、不同的二叉搜索树【LeetCode-96-medium】" class="headerlink" title="24、不同的二叉搜索树【LeetCode 96 | medium】"></a>24、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树【LeetCode 96 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</span><br><span class="line">示例1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210806211436.png"></p>
<p><strong>【解法】</strong><code>dp[i] += dp[以j为头结点左⼦树节点数量] * dp[以j为头结 点右⼦树节点数量</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25、分割等和子集【LeetCode-416-medium】"><a href="#25、分割等和子集【LeetCode-416-medium】" class="headerlink" title="25、分割等和子集【LeetCode 416 | medium】"></a>25、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集【LeetCode 416 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>01背包问题，如果使用一维<code>dp</code>数组，物品遍历的<code>for</code>循环放在外层，遍历背包的<code>for</code>循环放在内层。01背包的递推公式为：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[target] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、最后一块石头的重量-II【LeetCode-1049-medium】"><a href="#26、最后一块石头的重量-II【LeetCode-1049-medium】" class="headerlink" title="26、最后一块石头的重量 II【LeetCode 1049 | medium】"></a>26、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量 II【LeetCode 1049 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</span><br><span class="line">每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</span><br><span class="line">如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</span><br><span class="line">如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</span><br><span class="line">最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：stones &#x3D; [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>转化为01背包问题。尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小。<code>dp[target]</code>⾥是容量为<code>target</code>的背包所能背的最⼤重量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        sum += stones[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= stones[i]; --j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、贪心算法"><a href="#九、贪心算法" class="headerlink" title="九、贪心算法"></a>九、贪心算法</h3><h5 id="1、摆动序列【LeetCode-376-medium】"><a href="#1、摆动序列【LeetCode-376-medium】" class="headerlink" title="1、摆动序列【LeetCode 376 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列【LeetCode 376 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</span><br><span class="line">例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</span><br><span class="line">相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</span><br><span class="line">子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,7,4,9,2,5]</span><br><span class="line">输出：6</span><br><span class="line">解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个</p>
<p>局部峰值。 整体最优：整个序列有最多的局部峰值，从⽽达到最⻓摆动序列。这就是贪⼼所贪的地⽅，让峰值尽可能的保持峰值，然后删除单⼀坡度上的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> curDiff = <span class="number">0</span>, preDiff = <span class="number">0</span>, result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">        <span class="keyword">if</span> ((curDiff &gt; <span class="number">0</span> &amp;&amp; preDiff &lt;= <span class="number">0</span>) || (curDiff &lt; <span class="number">0</span> &amp;&amp; preDiff &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            ++result;</span><br><span class="line">            preDiff = curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、最大子序和【LeetCode-53-easy】"><a href="#2、最大子序和【LeetCode-53-easy】" class="headerlink" title="2、最大子序和【LeetCode 53 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和【LeetCode 53 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre + x, x);</span><br><span class="line">        maxAns = <span class="built_in">max</span>(maxAns, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h3 id="十、位运算"><a href="#十、位运算" class="headerlink" title="十、位运算"></a>十、位运算</h3><h5 id="1、二进制中1的个数【剑指Offer-15-easy】"><a href="#1、二进制中1的个数【剑指Offer-15-easy】" class="headerlink" title="1、二进制中1的个数【剑指Offer 15| easy】 "></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数【剑指Offer 15| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</span><br><span class="line">示例 1：</span><br><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br><span class="line"> </span><br><span class="line">提示：输入必须是长度为 32 的 二进制串。</span><br></pre></td></tr></table></figure>

<p>【解法1】与运算：设二进制数字 n ，则有：</p>
<ul>
<li>若 n &amp; 1 = 0，则 n 二进制最右一位为 0 ；<br>若 n &amp; 1 = 1，则 n 二进制 最右一位为1 。</li>
</ul>
<p>时间复杂度 O(log2n)，逐位判断需循环log2n次，其中n代表数字 n 最高位 1 的所在位数，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】巧用 n &amp; (n - 1)</p>
<p>(n−1) ： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。<br>n &amp; (n - 1)： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502160033.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ++res;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、不用加减乘除做加法【剑指Offer-65-easy】"><a href="#2、不用加减乘除做加法【剑指Offer-65-easy】" class="headerlink" title="2、不用加减乘除做加法【剑指Offer 65 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法【剑指Offer 65 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</span><br><span class="line">示例:</span><br><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">提示：a, b 均可能是负数或 0，结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure>

<p>【解法】位运算实现加法，设两数字的二进制形式 a, b，其求和 s = a + b，a(i)代表 a 的二进制第 i 位，则分为以下四种情况：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502161551.png" style="zoom: 67%;" />

<p>无进位和和异或运算相同，仅为和与运算相同，因此无进位和 n 与进位 c的计算公式如下：<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502161733.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、数组中数字出现的次数【剑指Offer-56-1-medium】"><a href="#3、数组中数字出现的次数【剑指Offer-56-1-medium】" class="headerlink" title="3、数组中数字出现的次数【剑指Offer 56-1 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数【剑指Offer 56-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"> </span><br><span class="line">限制：2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>所有元素进行异或运算，最终算的结果即为两个不同的数异或的结果。将所有元素分为两组，两个不同的数分别在两个组中，分组的方法如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502170832.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, m = <span class="number">1</span>, n = <span class="number">0</span>;  <span class="comment">// x、y分别为出现1次的两个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 先求所有数异或，异或的结果即为出现1次的两个数的异或，即(x^y)</span></span><br><span class="line">        n ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((n &amp; m) == <span class="number">0</span>) &#123;  <span class="comment">// 找到(x异或y)的右边第一个1,对应的m，为1表示x和y这个位置上值不同</span></span><br><span class="line">        m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123; </span><br><span class="line">        <span class="comment">// 相当于将原数组分为两组，每组包含一个仅出现1次的数字，剩下的数字均出现两次，异或的结果即为本身</span></span><br><span class="line">        <span class="comment">// m为1的位数表示x和y这个位置上值不同，那么&amp;的结果也不同，相当于将原数组分为两组</span></span><br><span class="line">        <span class="keyword">if</span> (num &amp; m) &#123;</span><br><span class="line">            x ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y &#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h5 id="4、数组中数字出现的次数-II【剑指Offer-56-2-medium】"><a href="#4、数组中数字出现的次数-II【剑指Offer-56-2-medium】" class="headerlink" title="4、数组中数字出现的次数 II【剑指Offer 56-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II【剑指Offer 56-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; nums.length &lt;&#x3D; 10000，1 &lt;&#x3D; nums[i] &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】考虑数字的二进制形式，对于出现三次的数字，各二进制位 出现的次数都是 3 的倍数。因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502202826.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// int类型有32位，统计每一位1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">            count[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将count各元素对3求余，则结果为 “只出现一次的数字” 的各二进制位</span></span><br><span class="line">    <span class="comment">// 利用 左移操作 和 或运算 ，可将 count数组中各二进位的值恢复到数字 res 上（循环区间是i∈[0,31] ）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;   <span class="comment">// 左移一位</span></span><br><span class="line">        res |= count[<span class="number">31</span> - i] % m;  <span class="comment">// 恢复第i位的直到res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、求1-2-…-n【剑指Offer-64-medium】"><a href="#5、求1-2-…-n【剑指Offer-64-medium】" class="headerlink" title="5、求1+2+…+n【剑指Offer 64 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n【剑指Offer 64 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</span><br><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】递归，用位运算作为递归的出口。逻辑运算符的短路效应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>)); <span class="comment">// 实现n=1时递归终止</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、单词长度的最大乘积【剑指Offer2-005-medium】"><a href="#6、单词长度的最大乘积【剑指Offer2-005-medium】" class="headerlink" title="6、单词长度的最大乘积【剑指Offer2 005 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/aseY1I/">单词长度的最大乘积【剑指Offer2 005 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</span><br><span class="line">示例 1:</span><br><span class="line">输入: words &#x3D; [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: words &#x3D; [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>题目说都是小写 不重复，也就最多 26位，一个 int 是 32位，所以可以一个位数表示一个单词字母有无。那么判断两个单词是否有重复字符只需要使用 <strong>与运算</strong> ，如果为 0 说明无重复部分。使用一个数组 存储 转换后的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line">    <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 将每个单词对应的数字存入数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); ++j)&#123;</span><br><span class="line">            masks[i] |= <span class="number">1</span> &lt;&lt; (words[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 比较每个单词是否有重复的字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>((masks[i] &amp; masks[j]) == <span class="number">0</span>)&#123; <span class="comment">//如果没有重复字符，则计算最大值</span></span><br><span class="line">                maxLen = Math.max(maxLen, words[i].length() * words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="十一、滑动窗口和双指针"><a href="#十一、滑动窗口和双指针" class="headerlink" title="十一、滑动窗口和双指针"></a>十一、滑动窗口和双指针</h3><h5 id="1、和为s的连续正数序列【剑指Offer-57-2-easy】"><a href="#1、和为s的连续正数序列【剑指Offer-57-2-easy】" class="headerlink" title="1、和为s的连续正数序列【剑指Offer 57-2 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列【剑指Offer 57-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; target &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。遍历数组，记录当前的数字总和<code>sum</code>。如果<code>sum</code>小于<code>target</code>，那么往后再加一个数字，即<code>++j</code>；如果<code>sum</code>大于<code>target</code>，那么减去最前面的数字，即<code>++i</code>；如果<code>sum</code>等于<code>target</code>，此时判断滑动窗口中的数字个数是不是至少2个，如果是的话，那么加入结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= (target / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            sum -= i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(k);</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、和为s的两个数字【剑指Offer-57-easy】"><a href="#2、和为s的两个数字【剑指Offer-57-easy】" class="headerlink" title="2、和为s的两个数字【剑指Offer 57 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字【剑指Offer 57 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br><span class="line"></span><br><span class="line">限制：1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5，1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>哈希表。遍历数组，将数字存入哈希表中代表该数字出现过，在遍历的过程中判断<code>target-num</code>是不是也在哈希表中，如果在的话则说明找到了一对和为<code>target</code>的数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unmap.<span class="built_in">find</span>(target - nums[i]) != unmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; nums[i], target - nums[i] &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        unmap[nums[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>双指针。设置两个指针<code>i</code>、<code>j</code>分别指向第一个元素和最后一个元素，两指针向中间移动，如果两个数和刚好为<code>target</code>，则直接返回；如果和小于<code>target</code>，则需要加一个更大的数，即<code>i++</code>；如果和大于<code>target</code>，则需要加一个更小的数才能满足，即<code>j--</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (res == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums[left]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(nums[right]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、滑动窗口的最大值【剑指Offer-59-1-hard】"><a href="#3、滑动窗口的最大值【剑指Offer-59-1-hard】" class="headerlink" title="3、滑动窗口的最大值【剑指Offer 59-1 | hard】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值【剑指Offer 59-1 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br><span class="line">示例:</span><br><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"> </span><br><span class="line">提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>维护一个递增的单调队列。窗口对应的数据结构为双端队列 ，本题使用单调队列即可解决以上问题。遍历数组时，每轮保证单调队列<code>deque</code> ，<code>deque</code>保存的是索引：</p>
<ul>
<li><code>deque</code>内仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素<code>nums[i - 1]</code>，需将<code>deque</code>内的对应元素一起删除。</li>
<li><code>deque</code>内的元素非严格递减 ⇒ 每轮窗口滑动添加了元素<code>nums[j + 1]</code>，需将<code>deque</code>内所有 &lt; <code>nums[j + 1]</code>的元素删除。</li>
<li>算法流程：<ul>
<li>初始化： 双端队列<code>deque</code>，结果列表<code>res</code>，数组长度<code>n</code>；</li>
<li>滑动窗口： 左边界范围<code>i∈[1−k,n−k]</code>，右边界范围<code>j∈[0,n−1]</code>；<br>若<code>i&gt;0</code>且 队首元素<code>deque[0]== 被删除元素 nums[i - 1]</code> ：则队首元素出队；<br>删除<code>deque</code>内所有 &lt; <code>nums[j]</code>的元素，以保持<code>deque</code>递减；<br>将<code>nums[j]</code>添加至<code>deque</code>尾部；<br>若已形成窗口（即<code>i≥0</code>）：将窗口最大值（即队首元素<code>deque[0]</code>）添加至列表<code>res</code>；</li>
<li>返回值： 返回结果列表<code>res </code>；</li>
</ul>
</li>
</ul>
<p>时间复杂度 <code>O(n)</code>， 空间复杂度<code> O(k)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (Q.<span class="built_in">size</span>() &amp;&amp; nums[i] &gt; nums[Q.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">			Q.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		Q.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (Q.<span class="built_in">size</span>() &amp;&amp; i - Q.<span class="built_in">front</span>() &gt;= k) &#123;</span><br><span class="line">			Q.<span class="built_in">pop_front</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(nums[Q.<span class="built_in">front</span>()]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、容器盛水问题-【牛客网】"><a href="#4、容器盛水问题-【牛客网】" class="headerlink" title="4、容器盛水问题 |【牛客网】"></a>4、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f?tpId=188&tags=&title=&difficulty=0&judgeStatus=0&rp=1">容器盛水问题 |【牛客网】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。</span><br><span class="line">示例1：</span><br><span class="line">输入：[3,1,2,5,2,4]  </span><br><span class="line">返回值：5 </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606105640.png"></p>
<p><strong>【解法】</strong>双指针。初始时左右指针<code>i</code>、<code>j</code>在数组的两端，选出<code>arr[i]</code>和<code>arr[j]</code>中最小的一个记为<code>minVal</code>。如果<code>arr[i]</code>最小，则左指针向右遍历，遍历过程中计算能装水的大小，直到遇到比<code>arr[i]</code>大则停止；如果<code>arr[j]</code>最小，则右指针向左遍历，遍历过程中计算能装水的大小，直到遇到比<code>arr[j]</code>大则停止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxWater</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = arr.<span class="built_in">size</span>() - <span class="number">1</span>, minVal;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        minVal = <span class="built_in">min</span>(arr[i], arr[j]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= minVal) &#123;</span><br><span class="line">            result += minVal - arr[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &lt;= minVal) &#123;</span><br><span class="line">            result += minVal - arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、盛最多水的容器【LeetCode-11-medium】"><a href="#5、盛最多水的容器【LeetCode-11-medium】" class="headerlink" title="5、盛最多水的容器【LeetCode 11 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器【LeetCode 11 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49，如下图。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210630134033.png"></p>
<p><strong>【解法】</strong>双指针。两个指针往中间移动，移动过程中记录最大盛水量。</p>
<p>容纳的水量=两个指针指向的数字中较小值 * 指针之间的距离。时间复杂度：<code>O(N)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = height.<span class="built_in">size</span>() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[i], height[j]) * (j - i));</span><br><span class="line">		<span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、和大于等于-target-的最短子数组【剑指Offer2-008-medium】"><a href="#6、和大于等于-target-的最短子数组【剑指Offer2-008-medium】" class="headerlink" title="6、和大于等于 target 的最短子数组【剑指Offer2 008 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/2VG8Kg/">和大于等于 target 的最短子数组【剑指Offer2 008 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个含有 n 个正整数的数组和一个正整数 target 。</span><br><span class="line">找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 6, nums &#x3D; [10,2,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>当滑动窗口内的数字之和大于等于<code>target</code>时，窗口缩小，即<code>++i</code>，当滑动窗口内的数字之和小于<code>target</code>时，窗口增大，即<code>++j</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; nums.length &amp;&amp; i &lt;= j)&#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            minLen = Math.min(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、乘积小于-K-的子数组【剑指Offer2-009-medium】"><a href="#7、乘积小于-K-的子数组【剑指Offer2-009-medium】" class="headerlink" title="7、乘积小于 K 的子数组【剑指Offer2 009 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ZVAVXX/">乘积小于 K 的子数组【剑指Offer2 009 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [10,5,2,6], k &#x3D; 100</span><br><span class="line">输出: 8</span><br><span class="line">解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br><span class="line">需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = i, sum = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j &amp;&amp; j &lt; nums.length)&#123;</span><br><span class="line">        sum *= nums[j];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= k &amp;&amp; i &lt;= j)&#123;</span><br><span class="line">            sum /= nums[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        count += j - i + <span class="number">1</span>;  <span class="comment">// 此时符合条件的个数为i-j+1</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h3 id="十二、DFS和BFS-回溯"><a href="#十二、DFS和BFS-回溯" class="headerlink" title="十二、DFS和BFS+回溯"></a>十二、DFS和BFS+回溯</h3><h5 id="1、组合【LeetCode-77-medium】"><a href="#1、组合【LeetCode-77-medium】" class="headerlink" title="1、组合【LeetCode 77 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">组合【LeetCode 77 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><br><span class="line">示例:</span><br><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:[</span><br><span class="line">      [2,4],</span><br><span class="line">      [3,4],</span><br><span class="line">      [2,3],</span><br><span class="line">      [1,2],</span><br><span class="line">      [1,3],</span><br><span class="line">      [1,4],</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>DFS+回溯组合枚举。<code>dfs(cur,n, k)</code>参数表示当前位置是<code>cur</code>，原序列总长度为<code>n</code>，当前序列有<code>k</code>个元素。原序列的每个位置在答案序列种的状态有被选中和不被选中两种，用<code>tmp</code>数组存放已经被选出的数字。</p>
<p>在进入<code>dfs(cur,n,k)</code>之前<code>[1, cur - 1]</code>位置的状态是确定的，而<code>[cur, n]</code>内位置的状态是不确定的，<code>dfs(cur,n,k)</code>需要确定<code>cur</code>位置的状态，然后求解子问题<code>dfs(cur+1, n,k)</code>。对于<code>cur</code>位置， 需要考虑<code>nums[cur]</code>取或者不取。如果取， 需要把<code>nums[cur]</code>放入一个临时的答案数组中（即上面代码中的<code>tmp</code>），再执行<code>dfs(cur+1, n,k)</code>，执行结束后需要对<code>tmp</code>进行回溯；如果不取，则直接执行<code>dfs(cur+1,n,k)</code>。在整个递归调用的过程中，<code>cur</code>是从小到大递增的，当<code>cur</code>增加到<code>n+1</code>的时候，记录答案并终止递归。在每次进入这个<code>dfs</code>函数时， 都去判断当前<code>tmp</code>的长度是否为<code>k</code>，如果为<code>k</code>，就把<code>tmp</code>加入答案并直接返回。</p>
<p>可以做一个剪枝，如果当前<code>tmp</code>的大小为 <code>s</code>，未确定状态的区间<code>[cur, n]</code>的长度为<code>t</code>，如果<code>s + t &lt; k</code>，那么即使<code>t</code>个都被选中，也不可能构造出一个长度为<code>k</code>的序列，故这种情况就没有必要继续向下递归，即可以在每次递归开始的时候做一次这样的判断：<code>temp.size() + (n - cur + 1) &lt; k</code>。</p>
<p>时间复杂度：<code>O((n, k) × k)</code>，空间复杂度：<code>O(n + k) = O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、组合总和-III【LeetCode-216-medium】"><a href="#2、组合总和-III【LeetCode-216-medium】" class="headerlink" title="2、组合总和 III【LeetCode 216 | medium】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">组合总和 III【LeetCode 216 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。说明：所有数字都是正整数。解集不能包含重复的组合。 </span><br><span class="line">示例 1:</span><br><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同上一题。在判断的时候加上和是否相等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() + (n - cur + <span class="number">1</span>) &lt; k || tmp.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k &amp;&amp; <span class="built_in">accumulate</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), <span class="number">0</span>) == sum) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);		</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k, sum);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">9</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res1;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">                res1.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">dfs</span>(n, k, i + <span class="number">1</span>, sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(n, k, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="3、单词接龙-II【LeetCode-126-hard】"><a href="#3、单词接龙-II【LeetCode-126-hard】" class="headerlink" title="3、单词接龙 II【LeetCode 126 | hard】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">单词接龙 II【LeetCode 126 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk 这样的单词序列，并满足：</span><br><span class="line">每对相邻的单词之间仅有单个字母不同。</span><br><span class="line">转换过程中的每个单词 si（1 &lt;&#x3D; i &lt;&#x3D; k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</span><br><span class="line">sk &#x3D;&#x3D; endWord</span><br><span class="line">给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：[[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</span><br><span class="line">解释：存在 2 种最短的转换序列：</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：[]</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典 wordList 中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、矩阵中的路径【剑指Offer-12-medium】"><a href="#4、矩阵中的路径【剑指Offer-12-medium】" class="headerlink" title="4、矩阵中的路径【剑指Offer 12 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径【剑指Offer 12 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br><span class="line">例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424132400.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br><span class="line"> </span><br><span class="line">提示：1 &lt;&#x3D; board.length &lt;&#x3D; 200，1 &lt;&#x3D; board[i].length &lt;&#x3D; 200，board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>典型的矩阵搜索问题，可用DFS+剪枝。</p>
<ul>
<li>递归参数：当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</li>
<li>终止条件：<ul>
<li>返回<code>false</code>：行或列索引越界；当前矩阵元素与目标字符不同（包含当前矩阵元素已访问过这种情况） </li>
<li>返回<code>true</code> ：<code>k = word.size() - 1</code>，即字符串<code>word</code>已全部匹配。</li>
</ul>
</li>
<li>递推工作：<ul>
<li>标记当前矩阵元素： 将<code>board[i][j]</code>修改为 空字符<code>&#39;&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用<code>或</code>连接 （代表只需找到一条可行路径就直接返回，不再做后续<code>DFS</code>）。</li>
<li>还原当前矩阵元素： 将<code>board[i][j]</code>元素还原至初始值，即<code>word[k]</code>。</li>
<li>返回值： 返回布尔量<code>res</code>，代表是否搜索到目标字符串。</li>
</ul>
</li>
</ul>
<p>时间复杂度<code>O(MN*3^K)</code>，空间复杂度<code>O(K)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || word[k] != board[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="built_in">dfs</span>(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || <span class="built_in">dfs</span>(board, word, i, j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        rows = board.<span class="built_in">size</span>();</span><br><span class="line">        cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="5、机器人的运动范围【剑指Offer-13-medium】"><a href="#5、机器人的运动范围【剑指Offer-13-medium】" class="headerlink" title="5、机器人的运动范围【剑指Offer 13 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围【剑指Offer 13 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</span><br><span class="line">示例 1：</span><br><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：1 &lt;&#x3D; n,m &lt;&#x3D; 100，0 &lt;&#x3D; k &lt;&#x3D; 20</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>深度优先遍历DFS。</p>
<p>递归参数： 当前元素在矩阵中的行列索引<code>i</code>和<code>j</code>，两者的数位和<code>si, sj</code>。</p>
<p>终止条件： 行列索引越界；数位和超出目标值 k；当前元素已访问过时，返回 0 ，代表不计入可达解。</p>
<p>递推工作：标记当前单元格 ：将索引<code>(i, j)</code>存入<code>visited数组</code>中，代表此单元格已被访问过。搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</p>
<p>回溯返回值： 返回 <code>1 + 右方搜索的可达解总数 + 下方搜索的可达解总数</code>，代表从本单元格递归搜索的可达解总数。</p>
<p>时间复杂度 <code>O(MN)</code>，空间复杂度 <code>O(MN)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robot_dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> si, <span class="keyword">int</span> sj, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= m || j &gt;= n || (si + sj) &gt; k || visited[i][j]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">robot_dfs</span>(i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span> ? (si - <span class="number">8</span>) : (si + <span class="number">1</span>), sj, m, n, k, visited) +</span><br><span class="line">		<span class="built_in">robot_dfs</span>(i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span> ? (sj - <span class="number">8</span>) : (sj + <span class="number">1</span>), m, n, k, visited);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">robot_dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = x % <span class="number">10</span>;</span><br><span class="line">            num += tmp;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = y % <span class="number">10</span>;</span><br><span class="line">            num2 += tmp;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (num + num2) &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; vis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || !<span class="built_in">isValid</span>(x, y, k) || vis[x][y])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">dfs</span>(x + <span class="number">1</span>, y, m, n, k, vis) + <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, m, n, k, vis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vis</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n, k, vis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>广度优先遍历BFS。</p>
<ul>
<li>初始化： 将机器人初始点<code>(0, 0)</code>加入队列<code>queue</code>；</li>
<li>迭代终止条件: <code>queue</code>为空。代表已遍历完所有可达解。</li>
<li>迭代工作：<ul>
<li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 行列索引越界；数位和超出目标值 k；当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将单元格索引<code>(i, j)</code>存入<code>visited</code>中，代表此单元格 已被访问过 。</li>
<li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入<code>queue</code>。</li>
<li>返回值：<code>visited</code>的长度<code>len(visited)</code>，即可达解的数量。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断位数和是否大于k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum += x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        sum += y % <span class="number">10</span>;</span><br><span class="line">        y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum &gt; k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 队列中存放的是</span></span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">2</span>] = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vis</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> num = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_x = num.first + dx[i];</span><br><span class="line">            <span class="keyword">int</span> new_y = num.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (new_x &lt; <span class="number">0</span> || new_x &gt;= m || new_y &lt; <span class="number">0</span> || new_y &gt;= n || vis[new_x][new_y] || <span class="built_in">isNum</span>(new_x, new_y, k)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">            Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(new_x, new_y));</span><br><span class="line">            vis[new_x][new_y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、不同的二叉搜索树-II【LeetCode-95-medium】"><a href="#6、不同的二叉搜索树-II【LeetCode-95-medium】" class="headerlink" title="6、不同的二叉搜索树 II【LeetCode 95 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II【LeetCode 95 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数n，请你生成并返回所有由n个节点组成且节点值从 1 到 n 互不相同的不同二叉搜索树。可以按任意顺序返回答案。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210618212344.png"></p>
<p><strong>【解法】</strong>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为<code>n</code>，如果枚举根节点的值为<code>i</code>，那么根据二叉搜索树的性质可以知道左子树的节点值的集合为<code>[1…i−1]</code>，右子树的节点值的集合为<code>[i+1…n]</code>。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此可以用回溯的方法来解决。</p>
<p>定义<code>generateTrees(start, end)</code>函数表示当前值的集合为<code>[start,end]</code>，返回序列<code>[start,end]</code>生成的所有可行的二叉搜索树。枚举<code>[start,end]</code>中的值<code>i</code>为当前二叉搜索树的根，那么序列划分为了<code>[start,i−1]</code>和 <code>[i+1,end]</code>两部分。递归调用这两部分，即<code>generateTrees(start, i - 1)</code>和<code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，最后一步只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p>
<p>递归的入口即为<code>generateTrees(1, n)</code>，出口为当<code>start&gt;end</code>的时候，当前二叉搜索树为空，返回空节点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">			vector&lt;TreeNode*&gt; left_trees = <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">			vector&lt;TreeNode*&gt; right_trees = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : left_trees) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : right_trees) &#123;</span><br><span class="line">					TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">					node-&gt;left = l;</span><br><span class="line">					node-&gt;right = r;</span><br><span class="line">					allTrees.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> allTrees;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/BDC683FB0DA3F895F1DB53B3F311DE4C.png"></p>
<h5 id="7、括号生成【LeetCode-22-medium】"><a href="#7、括号生成【LeetCode-22-medium】" class="headerlink" title="7、括号生成【LeetCode 22 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成【LeetCode 22 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>如果左括号数量不大于 <code>n</code>，可以放一个左括号。如果右括号数量小于左括号的数量，可以放一个右括号。时间复杂度：<code>O(4^n/根号n)</code>，空间复杂度：O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; res, string &amp;cur, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左括号有剩余，则添加一个左括号继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(res, cur, open + <span class="number">1</span>, close, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右括号数量大于左括号数量，那么添加一个右括号继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(res, cur, open, close + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string cur;</span><br><span class="line">        <span class="built_in">dfs</span>(res, cur, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另一种写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; res, string cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左括号有剩余，则添加一个左括号继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(res, cur + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右括号数量大于左括号数量，那么添加一个右括号继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(res, cur + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string cur;</span><br><span class="line">        <span class="built_in">dfs</span>(res, cur, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8、电话号码的字母组合【leetcode-17-medium】"><a href="#8、电话号码的字母组合【leetcode-17-medium】" class="headerlink" title="8、电话号码的字母组合【leetcode 17 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合【leetcode 17 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210914144813.png"></p>
<p><strong>【解法】</strong></p>
<p>终止条件：例如输⼊⽤例<code>&quot;23&quot;</code>，两个数字，那么根节点往下递归两层就可以了，叶⼦节点就是要收集的结果集。 那么终⽌条件就是如果<code>index</code>等于 输⼊的数字个数（<code>digits.size</code>）了。</p>
<p>单层遍历逻辑：⾸先要取<code>index</code>指向的数字，并找到对应的字符集（⼿机键盘的字符集）。 然后<code>for</code>循环来处理这个字符集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="keyword">const</span> string letterMap[<span class="number">10</span>] = &#123; <span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> string&amp; digits, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string letter = letterMap[digit];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(digits, index + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;           </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="9、组合总和【leetcode-39-medium】"><a href="#9、组合总和【leetcode-39-medium】" class="headerlink" title="9、组合总和【leetcode 39 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">组合总和【leetcode 39 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个【无重复】元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</span><br><span class="line">candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7</span><br><span class="line">输出: [[7],[2,2,3]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: candidates &#x3D; [2,3,5], target &#x3D; 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<p>终⽌条件：只有两种情况，<code>sum</code>⼤于<code>target</code>和<code>sum</code>等于<code>target</code>。 <code>sum</code>等于<code>target</code>的时候，需要收集结果；</p>
<p>单层搜索的逻辑：单层<code>for</code>循环依然是从<code>startIndex</code>开始，搜索<code>candidates</code>集合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否满足 sum + candidates[i] &gt; target，进行剪枝</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target, sum, i);  <span class="comment">// 关键点:不⽤i+1了，表示可以重复读取当前的数</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 排序，为了上面判断 sum + candidates[i] &gt; target，进行剪枝</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="10、组合总和-II【leetcode-40-medium】"><a href="#10、组合总和-II【leetcode-40-medium】" class="headerlink" title="10、组合总和 II【leetcode 40 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II【leetcode 40 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个【有重复】数字的数组 candidates 和一个目标数 target ，找 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。注意：解集不能包含重复的组合。 </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本题和上一题的区别在于，数组中有重复的元素，每个组合内的元素可以重复，但是结果集中的组合不能重复。即相当于树形结构的同一条路景上的元素可以重复，但是同一层上的元素不能重复。还需要加⼀个<code>bool</code>型数组<code>used</code>，⽤来记录同⼀树枝上的元素是否使⽤过。 这个集合去重的重任就是<code>used</code>来完成的。</p>
<ul>
<li>如何判断同一层上的元素是否使用过？</li>
</ul>
<p>如果<code>candidates[i] == candidates[i - 1]</code>并且<code>used[i - 1] == false</code>，就说明：前⼀个树枝，使⽤了<code>candidates[i - 1]</code>，也就是说同⼀树层使⽤过<code>candidates[i - 1]</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210914160419.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> start, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span> &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target, sum, i + <span class="number">1</span>, used);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 排序，为了上面判断 sum + candidates[i] &gt; target，进行剪枝</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11、复原-IP-地址【leetcode-93-medium】"><a href="#11、复原-IP-地址【leetcode-93-medium】" class="headerlink" title="11、复原 IP 地址【leetcode 93 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原 IP 地址【leetcode 93 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。</span><br><span class="line">有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。</span><br><span class="line">例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<p>终止条件：本题明确要求只会分成4段，所以不能⽤切割线切到最后作为终⽌条件，⽽是分割的段数作为终⽌条件。 <code>splitNum</code>表示逗点数量，<code>splitNum</code>为3说明字符串分成了4段了。 然后验证⼀下第四段是否合法，如果合法就加⼊到结果集⾥。</p>
<p>单层搜索的逻辑：在<code>for (int i = startIndex; i &lt; s.size(); i++) </code>循环中 <code>[start, i]</code>这个区间就是截取的⼦串，需要判断这个⼦串是否合法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="comment">// 判断子串是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string &amp;s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个数字为0，不合法</span></span><br><span class="line">        <span class="keyword">if</span> (s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="comment">// 非数字，不合法</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i]&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 数字大于255，不合法</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> splitNum)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 终止条件，已经添加了三个&#x27;.&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (splitNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, start, s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归调⽤时，下⼀层递归的startIndex要从i+2开始（因为需要在字符串中加⼊了分隔符 . ），同时记录分割符的数量pointNum 要 +1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, start, i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                ++splitNum;</span><br><span class="line">                <span class="built_in">dfs</span>(s, i + <span class="number">2</span>, splitNum);</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);;</span><br><span class="line">                --splitNum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="12、子集【leetcode-78-medium】"><a href="#12、子集【leetcode-78-medium】" class="headerlink" title="12、子集【leetcode 78 | medium】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">子集【leetcode 78 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>套用回溯模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start)</span> </span>&#123;   </span><br><span class="line">        <span class="comment">// 收集⼦集，要放在终⽌添加的上⾯，否则会漏掉本身</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);  <span class="comment">// 从i+1开始，元素不能重复</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="13、递增子序列【leetcode491-medium】"><a href="#13、递增子序列【leetcode491-medium】" class="headerlink" title="13、递增子序列【leetcode491 | medium】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-subsequences/">递增子序列【leetcode491 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [4,6,7,7]</span><br><span class="line">输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [4,4,3,2,1]</span><br><span class="line">输出：[[4,4]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本题求⼦序列，很明显⼀个元素不能重复使⽤，所以需要<code>startIndex</code>，调整下⼀层递归的起始位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="comment">// 这里不用加return，因为要取树上的所有节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使⽤set来对本层元素进⾏去重</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; unset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>()) || unset.<span class="built_in">find</span>(nums[i]) != unset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录这个元素在本层⽤过了，本层后⾯不能再⽤了</span></span><br><span class="line">            unset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="14、不含重复数字的全排列【leetcode-46-medium】"><a href="#14、不含重复数字的全排列【leetcode-46-medium】" class="headerlink" title="14、不含重复数字的全排列【leetcode 46 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">不含重复数字的全排列【leetcode 46 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>⾸先排列是有序的，也就是说<code>[1,2]</code>和<code>[2,1]</code>是两个集合，这和之前分析的⼦集以及组合所不同的地⽅。 可以看出元素1在<code>[1,2]</code>中已经使⽤过了，但是在<code>[2,1]</code>中还要在使⽤⼀次1，所以处理排列问题就不⽤使⽤<code>startIndex</code>了。 但排列问题需要⼀个<code>used</code>数组，标记已经选择的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果元素已经使用过，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="15、全排列-II【leetcode-47-medium】"><a href="#15、全排列-II【leetcode-47-medium】" class="headerlink" title="15、全排列 II【leetcode 47 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II【leetcode 47 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本题涉及到去重，去重⼀定要对元素经⾏排序，这样我们才⽅便通过相邻的节点来判断是否重复使⽤了。对同⼀树层，前⼀位（也就是<code>nums[i-1]</code>）如果使⽤过，那么就进⾏去重。 </p>
<p>⼀般来说：组合问题和排列问题是在树形结构的叶⼦节点上收集结果，⽽⼦集问题就是取树上所有节点 的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果元素已经使用过，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums, used);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="16、N-皇后【LeetCode-51-hard】"><a href="#16、N-皇后【LeetCode-51-hard】" class="headerlink" title="16、N 皇后【LeetCode 51 | hard】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">N 皇后【LeetCode 51 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</span><br><span class="line">每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">解释：如上图所示，4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210918174145.png"></p>
<p><strong>【解法】</strong></p>
<ul>
<li>验证棋牌是否合法：不能同行、不能同列、不能同斜线（45°和135°）</li>
<li>单层搜索的逻辑：递归深度就是<code>row</code>控制棋盘的⾏，每⼀层⾥<code>for</code>循环的<code>col</code>控制棋盘的列，⼀⾏⼀列，确定了放置皇后的位 置。 每次都是要从新的⼀⾏的起始位置开始搜，所以都是从0开始</li>
<li>递归终⽌条件：当递归到棋盘最底层（也就是叶⼦节点）的时候，就可以收集结果并返回了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; chessboard, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="comment">// 检查同一列上是否有Q</span></span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查45°上是否有Q</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查135°上是否有Q</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; chessboard, <span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(chessboard, row, i, n)) &#123;</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(chessboard, n, row + <span class="number">1</span>);</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">chessboard</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(chessboard, n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="17、解数独【LeetCode-37-hard】"><a href="#17、解数独【LeetCode-37-hard】" class="headerlink" title="17、解数独【LeetCode 37 | hard】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">解数独【LeetCode 37 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】编写一个程序，通过填充空格来解决数独问题。</span><br><span class="line">数独的解法需 遵循如下规则：</span><br><span class="line">数字 1-9 在每一行只能出现一次。</span><br><span class="line">数字 1-9 在每一列只能出现一次。</span><br><span class="line">数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</span><br><span class="line">数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：board &#x3D; </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210919150928.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210919150942.png"></p>
<p><strong>【解法】</strong></p>
<ul>
<li>本题递归不⽤终⽌条件，解数独是要遍历整个树形结构寻找可能的叶⼦节点就⽴刻返回。</li>
<li>递归单层搜索逻辑：⼀个for循环遍历棋盘的⾏，⼀个for循环遍历棋盘的列，⼀⾏⼀列确定下来之后，递归遍历这个位置放9 个数字的可能性</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> new_row = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> new_col = (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = new_row; i &lt; new_row + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = new_col; j &lt; new_col + <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;     <span class="comment">// 该位置上已经有数字了，则继续</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isValid</span>(board, i, j, k)) &#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="comment">// 如果找到一个合适的则返回</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(board)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 9个数都不行，则FALSE</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="18、重新安排行程【LeetCode-332-medium】"><a href="#18、重新安排行程【LeetCode-332-medium】" class="headerlink" title="18、重新安排行程【LeetCode 332 | medium】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程【LeetCode 332 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一份航线列表 tickets ，其中 tickets[i] &#x3D; [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</span><br><span class="line">所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</span><br><span class="line"></span><br><span class="line">例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前。</span><br><span class="line">假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210919172013.png" style="zoom:80%;" />

<p><strong>【解法】</strong>回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么就找到了⼀个⾏程，把所有航班串在⼀起了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="keyword">int</span>&gt;&gt; targets;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">const</span> string, <span class="keyword">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.second &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">                target.second--;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">                target.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="19、岛屿数量【LeetCode-200-medium】"><a href="#19、岛屿数量【LeetCode-200-medium】" class="headerlink" title="19、岛屿数量【LeetCode 200 | medium】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量【LeetCode 200 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>DFS。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[x][y] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, x, y + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, x - <span class="number">1</span>, y);</span><br><span class="line">        <span class="built_in">dfs</span>(grid, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>BFS。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x, y));</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            x = tmp.first, y = tmp.second;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x + <span class="number">1</span>, y));</span><br><span class="line">                q.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x - <span class="number">1</span>, y));</span><br><span class="line">                q.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x, y + <span class="number">1</span>));</span><br><span class="line">                q.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(x, y - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, i, j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="十三、其他"><a href="#十三、其他" class="headerlink" title="十三、其他"></a>十三、其他</h3><h5 id="1、打印从1到最大的n位数【剑指Offer-15-easy】"><a href="#1、打印从1到最大的n位数【剑指Offer-15-easy】" class="headerlink" title="1、打印从1到最大的n位数【剑指Offer 15| easy】 "></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数【剑指Offer 15| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br><span class="line">示例 1:</span><br><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class="line"> </span><br><span class="line">说明：用返回一个整数列表来代替打印，n 为正整数</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>先找出最大的<code>n</code>位数，然后遍历一遍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        maxNum = maxNum * <span class="number">10</span> + <span class="number">9</span>;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNum; ++i) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、顺时针打印矩阵【剑指Offer-29-easy】"><a href="#2、顺时针打印矩阵【剑指Offer-29-easy】" class="headerlink" title="2、顺时针打印矩阵【剑指Offer 29| easy】 "></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵【剑指Offer 29| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; matrix.length &lt;&#x3D; 100，0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同上<code>LeetCode 54</code>螺旋矩阵。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = n - <span class="number">1</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; --i) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++left;</span><br><span class="line">        --right;</span><br><span class="line">        ++top;</span><br><span class="line">        --bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、圆圈中最后剩下的数字【剑指Offer-62-easy】"><a href="#3、圆圈中最后剩下的数字【剑指Offer-62-easy】" class="headerlink" title="3、圆圈中最后剩下的数字【剑指Offer 62 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字【剑指Offer 62 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</span><br><span class="line">例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</span><br><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 10^5，1 &lt;&#x3D; m &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>约瑟夫环。将上述问题建模为函数<code>f(n, m)</code>，该函数的返回值为最终留下的元素的序号。</p>
<p>首先，长度为<code>n</code>的序列会先删除第<code>m % n</code>个元素，然后剩下一个长度为<code>n - 1</code>的序列。那么，我们可以递归地求解<code>f(n - 1, m)</code>，就可以知道对于剩下的<code>n - 1</code>个元素，最终会留下第几个元素，我们设答案为<code>x = f(n - 1, m)</code>。</p>
<p>由于我们删除了第<code>m % n</code>个元素，将序列的长度变为<code>n - 1</code>。当我们知道了<code>f(n - 1, m) </code>对应的答案<code>x</code>之后，我们也就可以知道，长度为<code>n</code>的序列最后一个删除的元素，应当是从<code>m % n</code>开始数的第<code>x</code>个元素。因此有<code>f(n, m) = (m % n + x) % n = (m + x) % n</code>。</p>
<p><code>dp[i] = (dp[i-1] + m) % i</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        res = (res + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、扑克牌中的顺子【剑指Offer-61-easy】"><a href="#4、扑克牌中的顺子【剑指Offer-61-easy】" class="headerlink" title="4、扑克牌中的顺子【剑指Offer 61 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">扑克牌中的顺子【剑指Offer 61 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">限制：数组长度为5，数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>五张牌是顺子的条件：除了大小王之外，数字不重复；最大值减最小值小于5；</p>
<p>因此只要判断数组中的数组是否满足上面的条件即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> map[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="number">14</span>, maxVal = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;num : nums) &#123;</span><br><span class="line">        <span class="comment">// 遇到大小王，则直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map[num]) &#123; <span class="comment">// 出现数字重复</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[num] = <span class="number">1</span>;</span><br><span class="line">        minVal = <span class="built_in">min</span>(minVal, num);</span><br><span class="line">        maxVal = <span class="built_in">max</span>(maxVal, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (maxVal - minVal) &lt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、表示数值的字符串【剑指Offer-20-medium】"><a href="#5、表示数值的字符串【剑指Offer-20-medium】" class="headerlink" title="5、表示数值的字符串【剑指Offer 20 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串【剑指Offer 20 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、&quot;5e2&quot;、&quot;-123&quot;、&quot;3.1416&quot;、&quot;-1E-16&quot;、&quot;0123&quot;都表示数值，但&quot;12e&quot;、&quot;1a3.14&quot;、&quot;1.2.3&quot;、&quot;+-5&quot;及&quot;12e+5.4&quot;都不是。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> string s, <span class="keyword">int</span>&amp; index)</span> </span>&#123; <span class="comment">//判断加减符号之后是否有数字</span></span><br><span class="line">        <span class="keyword">if</span> (s[index] == <span class="string">&#x27;+&#x27;</span> || s[index] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">scanUnsignedInteger</span>(s, index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否有数字</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> string s, <span class="keyword">int</span>&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beforeindex = index;</span><br><span class="line">        <span class="keyword">while</span> (index != s.<span class="built_in">size</span>() &amp;&amp; s[index] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[index] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index &gt; beforeindex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123; <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[index] == <span class="string">&#x27; &#x27;</span>) &#123;  <span class="comment">//判断开始的空格</span></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isNum = <span class="built_in">scanInteger</span>(s, index);  <span class="comment">//判断空格之后是否是正负号及数字</span></span><br><span class="line">        <span class="keyword">if</span> (s[index] == <span class="string">&#x27;.&#x27;</span>) &#123;     <span class="comment">//判断数字之后是否有&#x27;.&#x27;，&#x27;.&#x27;之后可以是数字也可以没有字符,&#x27;.&#x27;之前也可以什么都没有</span></span><br><span class="line">            ++index;</span><br><span class="line">            isNum = <span class="built_in">scanUnsignedInteger</span>(s, index) || isNum;  <span class="comment">//注意这两项的顺序不能换，必须要先算scanUnsignedInteger(s, index)，否则后面的index会出错</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[index] == <span class="string">&#x27;e&#x27;</span> || s[index] == <span class="string">&#x27;E&#x27;</span>) &#123; <span class="comment">//判断数字之后是否有&#x27;e&#x27;</span></span><br><span class="line">            ++index;</span><br><span class="line">            isNum = isNum &amp;&amp; <span class="built_in">scanInteger</span>(s, index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s[index] == <span class="string">&#x27; &#x27;</span>) &#123;  <span class="comment">//判断结尾是否有空格</span></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNum &amp;&amp; index == s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="6、数值的整数次方【剑指Offer-16-medium】"><a href="#6、数值的整数次方【剑指Offer-16-medium】" class="headerlink" title="6、数值的整数次方【剑指Offer 16 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方【剑指Offer 16 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">-2^31 &lt;&#x3D; n &lt;&#x3D; 2^31-1</span><br><span class="line">-10^4 &lt;&#x3D; x^n &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<ul>
<li><p>求<code>x^n</code>最简单的方法是通过循环将<code>n</code>个<code>x</code>乘起来，依次求<code>x^1, x^2, ..., x^&#123;n-1&#125;, x^n</code>，时间复杂度为<code>O(n)</code>。</p>
</li>
<li><p>快速幂法：可将时间复杂度降低至<code>O(log_2 n)</code>，以下从 “二分法” 和 “二进制” 两个角度解析快速幂法。</p>
<ul>
<li><p>快速幂解析（二进制角度）：利用十进制数字<code>n</code>的二进制表示，可对快速幂进行数学化解释。</p>
<p>对于任何十进制正整数<code>n</code>，设其二进制为<code>&quot;bm...b3b2b1</code>（<code>bi</code>为二进制某位值，<code>i∈[1,m]</code>），则有：</p>
<ul>
<li><p>二进制转十进制：<code>n = 1b1 + 2b2 + 4b3 + ... + 2^&#123;m-1&#125;bm</code>（即二进制转十进制公式）；</p>
</li>
<li><p>幂的二进制展开： <code>x^n = x^&#123;1b1 + 2b2 + 4b3 + ... + 2^&#123;m-1&#125;bm&#125; = x^&#123;1b1&#125;x^&#123;2b2&#125;x^&#123;4b3&#125;...x^&#123;2^&#123;m-1&#125;bm&#125;</code></p>
</li>
</ul>
</li>
<li><p>根据以上推导，可把计算<code>x^n</code>转化为解决以下两个问题：</p>
<ul>
<li>计算<code>x^1, x^2, x^4, ..., x^&#123;2^&#123;m-1&#125;&#125;</code>的值： 循环赋值操作<code>x = x^2</code>即可；</li>
<li>获取二进制各位<code>b1, b2, b3, ..., bm</code>的值： 循环执行以下操作即可。<ul>
<li><code>n &amp; 1</code>（与操作）： 判断<code>n</code>二进制最右一位是否为 1 ；</li>
<li><code>n&gt;&gt;1</code>（移位操作）：<code>n</code>右移一位（可理解为删除最后一位）。</li>
</ul>
</li>
</ul>
</li>
<li><p>因此，应用以上操作，可在循环中依次计算<code>x^&#123;2^&#123;0&#125;b1&#125;, x^&#123;2^&#123;1&#125;b2&#125;, ..., x^&#123;2^&#123;m-1&#125;bm&#125;</code>的值，并将所有<code>x^&#123;2^&#123;i-1&#125;b_i</code>累计相乘即可。</p>
<ul>
<li>当<code>bi = 0</code> 时，<code>x^&#123;2^&#123;i-1&#125;bi&#125; = 1</code></li>
<li>当<code>bi = 1</code> 时，<code>x^&#123;2^&#123;i-1&#125;bi&#125; = x^&#123;2^&#123;i-1&#125;&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>快速幂解析（二分法角度）：快速幂实际上是二分思想的一种应用。</p>
<ul>
<li>二分推导： <code>x^n = x^&#123;n/2&#125; * x^&#123;n/2&#125; = (x^2)^&#123;n/2&#125;</code>，令<code>n/2</code>为整数，则需要分为奇偶两种情况（设向下取整除法符号为<code>&quot;//&quot;</code> ）：<ul>
<li>当<code>n</code>为偶数：<code>x^n = (x^2)^&#123;n//2&#125;</code>；</li>
<li>当<code>n</code>为奇数：<code>x^n = x(x^2)^&#123;n//2&#125;</code>，即会多出一项 <code>x</code>；</li>
</ul>
</li>
<li>幂结果获取：<ul>
<li>根据二分推导，可通过循环<code>x = x^2</code>操作，每次把幂从<code>n</code>降至<code>n//2</code>，直至将幂降为<code>0</code>；</li>
<li>设<code>res=1</code>，则初始状态<code>x^n = x^n * res</code>。在循环二分时，每当<code>n</code>为奇数时，将多出的一项<code>x</code>乘入<code>res</code>，则最终可化至<code>x^n = x^0 * res = res</code>，返回<code>res</code>即可。</li>
</ul>
</li>
<li>转化为位运算：<ul>
<li>向下整除<code>n // 2</code>等价于 右移一位<code>n &gt;&gt; 1</code>；</li>
<li>取余数<code>n % 2</code>等价于 判断二进制最右一位值<code>n &amp; 1</code>；</li>
</ul>
</li>
<li>算法流程：<ul>
<li>当<code>x = 0</code>时：直接返回 0 （避免后续<code>x = 1 / x</code>操作报错）。</li>
<li>初始化<code>res = 1</code>；</li>
<li>当<code>n &lt; 0</code>时：把问题转化至<code>n ≥ 0</code>的范围内，即执行<code>x = 1/x</code>，<code>n = - n</code>；</li>
<li>循环计算：当<code>n = 0</code>时跳出；<ul>
<li>当<code>n &amp; 1 = 1</code>时：将当前<code>x</code>乘入<code>res</code> （即<code>res *= x</code>）；</li>
<li>执行<code>x = x^2</code>（即<code>x *= x</code>）；</li>
<li>执行<code>n</code>右移一位（即<code>n &gt;&gt;= 1</code>）。</li>
</ul>
</li>
<li>返回<code>res</code>。</li>
</ul>
</li>
<li>时间复杂度 <code>O(log2 n)</code>，二分的时间复杂度为对数级别。空间复杂度<code>O(1)</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">long</span> b = n;</span><br><span class="line">	<span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span> / x;</span><br><span class="line">		b = -b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123; <span class="comment">// 如果是奇数，需要多乘一个x</span></span><br><span class="line">			res *= x;</span><br><span class="line">		&#125;</span><br><span class="line">		x *= x;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;  <span class="comment">// 相当于除2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、数字序列中某一位的数字【剑指Offer-44-medium】"><a href="#7、数字序列中某一位的数字【剑指Offer-44-medium】" class="headerlink" title="7、数字序列中某一位的数字【剑指Offer 44 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">数字序列中某一位的数字【剑指Offer 44 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>将每个数字的位数记为<code>digit</code>，将每个数字范围的起始值记为<code>start</code>。每个数字范围的数位计算公式即为<code>count = 9 * digit * start</code>。因此可将求解分为三步：</p>
<ul>
<li>确定<code>n</code>所在 数字 的 位数 ，记为<code>digit</code>；</li>
<li>确定<code>n</code>所在的 数字 ，记为<code>num</code>；</li>
<li>确定<code>n</code>是<code>num</code>中的哪一数位，并返回结果。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210622211800.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> start = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 判断n属于哪个位数范围</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; count) &#123;</span><br><span class="line">        n -= count;</span><br><span class="line">        digit += <span class="number">1</span>;</span><br><span class="line">        start *= <span class="number">10</span>;</span><br><span class="line">        count = <span class="number">9</span> * digit * start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断属于哪个数字</span></span><br><span class="line">    <span class="keyword">int</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">    <span class="comment">// 判断属于该数字的哪一位</span></span><br><span class="line">    <span class="keyword">return</span> s[(n - <span class="number">1</span>) % digit] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、1～n-整数中-1-出现的次数【剑指Offer-43-hard】"><a href="#8、1～n-整数中-1-出现的次数【剑指Offer-43-hard】" class="headerlink" title="8、1～n 整数中 1 出现的次数【剑指Offer 43 | hard】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">1～n 整数中 1 出现的次数【剑指Offer 43 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</span><br><span class="line">例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>将<code>1~n</code>的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>
<p>设数字<code>n</code>是个<code>x</code>位数，记<code>n</code>的第<code>i</code>位为<code>ni</code>，则可将<code>n</code>写为<code>nx n(x-1)...n2 n1</code></p>
<ul>
<li>称<code>ni</code>为 当前位 ，记为 cur；</li>
<li>将<code>n(i-1) n(i-2)...n2 n1</code>称为 低位 ，记为<code>low</code>；</li>
<li>将<code>nx n(x-1)...n(i+2) n(i+1)</code>称为 高位 ，记为<code>high</code>。</li>
<li>将<code>10^i</code>称为 位因子 ，记为<code>digit</code>。</li>
</ul>
<p>某位中 1 出现次数的计算方法：</p>
<p>根据当前位<code>cur</code>值的不同，分为以下三种情况：</p>
<ul>
<li><p>当<code>cur = 0</code>时： 此位 1 的出现次数只由高位<code>high</code>决定，计算公式为：<code>high × digit</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210623173551.png"></p>
</li>
<li><p>当<code>cur = 1</code>时： 此位 1 的出现次数由高位<code>high</code>和低位<code>low</code>决定，计算公式为：<code>high×digit+low+1</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210623173738.png"></p>
</li>
<li><p>当<code>cur = 2,3,⋯,9</code>时： 此位 1 的出现次数只由高位<code>high</code>决定，计算公式为：<code>(high+1)×digit</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210623174334.png"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// high和low分别表示高位和低位</span></span><br><span class="line">	<span class="keyword">int</span> high = n, low = <span class="number">0</span>, cur = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">		cur = high % <span class="number">10</span>;</span><br><span class="line">		high /= <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (cur == <span class="number">0</span>) &#123;</span><br><span class="line">			count += high * num;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">			count += high * num + low + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			count += (high + <span class="number">1</span>) * num;</span><br><span class="line">		&#125;</span><br><span class="line">		low = cur * num + low;</span><br><span class="line">		<span class="keyword">if</span> (high &gt; <span class="number">0</span>) &#123; <span class="comment">// 不加high&gt;0会溢出</span></span><br><span class="line">			num *= <span class="number">10</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、大数加法-【牛客网】"><a href="#9、大数加法-【牛客网】" class="headerlink" title="9、大数加法 【牛客网】"></a>9、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475?tpId=188&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">大数加法 【牛客网】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。（字符串长度不大于100000，保证字符串仅由&#39;0&#39;~&#39;9&#39;这10种字符组成）</span><br><span class="line">示例1</span><br><span class="line">输入：&quot;1&quot;,&quot;99&quot;</span><br><span class="line">返回值：&quot;100&quot;</span><br><span class="line"></span><br><span class="line">说明：1+99&#x3D;100 </span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>解法和链表加法一样，考虑进位。（本文中链表第10题）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">solve</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>, j = t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	string result;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			tmp = (s[i] - <span class="string">&#x27;0&#x27;</span>) + (t[j] - <span class="string">&#x27;0&#x27;</span>) + flag;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tmp = (i &gt;= <span class="number">0</span>) ? (s[i] - <span class="string">&#x27;0&#x27;</span>) + flag : (t[j] - <span class="string">&#x27;0&#x27;</span>) + flag;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			result.<span class="built_in">append</span>(<span class="built_in">to_string</span>(tmp - <span class="number">10</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			result.<span class="built_in">append</span>(<span class="built_in">to_string</span>(tmp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;  <span class="comment">// 最后一位如果有进位，需要加上</span></span><br><span class="line">		result.<span class="built_in">append</span>(<span class="built_in">to_string</span>(flag));</span><br><span class="line">	&#125;</span><br><span class="line">	std::<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、罗马数字转整数【LeetCode-13-easy】"><a href="#10、罗马数字转整数【LeetCode-13-easy】" class="headerlink" title="10、罗马数字转整数【LeetCode 13 | easy】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/roman-to-integer/">罗马数字转整数【LeetCode 13 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</span><br><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br><span class="line">给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>模拟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> preNum = <span class="built_in">getValue</span>(s[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = <span class="built_in">getValue</span>(s[i]);</span><br><span class="line">			<span class="keyword">if</span> (preNum &lt; num) &#123;</span><br><span class="line">				sum -= preNum;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				sum += preNum;</span><br><span class="line">			&#125;</span><br><span class="line">			preNum = num;</span><br><span class="line">		&#125;</span><br><span class="line">		sum += preNum;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (ch) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11、整数转罗马数字【LeetCode-12-medium】"><a href="#11、整数转罗马数字【LeetCode-12-medium】" class="headerlink" title="11、整数转罗马数字【LeetCode 12 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字【LeetCode 12 | medium】</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> values[] = &#123; <span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	string symbols[] = &#123; <span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span> &#125;;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (num &amp;&amp; i &lt; <span class="number">13</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (values[i] &lt;= num) &#123;</span><br><span class="line">			<span class="keyword">int</span> numbers = num / values[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numbers; j++) &#123;</span><br><span class="line">				num -= values[i];</span><br><span class="line">				s += symbols[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、求数组之间的交集"><a href="#12、求数组之间的交集" class="headerlink" title="12、求数组之间的交集"></a>12、求数组之间的交集</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】求数组中各个数组之间的交集。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找两个数组之间的交集</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecjoin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; unset;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">unset1</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unset1.<span class="built_in">find</span>(num) != unset1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            unset.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(unset.<span class="built_in">begin</span>(), unset.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找多个数组之间的交集</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; arrs)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (arrs.<span class="built_in">size</span>() == <span class="number">0</span> || arrs[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arrs.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(arrs[<span class="number">0</span>].<span class="built_in">begin</span>(), arrs[<span class="number">0</span>].<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> arrs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arrs.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">        res = <span class="built_in">vecjoin</span>(arrs[<span class="number">0</span>], arrs[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = arrs.<span class="built_in">size</span>(), n = arrs[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; nums1;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; nums2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; mid; ++i) &#123;</span><br><span class="line">        nums1.<span class="built_in">push_back</span>(arrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; m; ++i) &#123;</span><br><span class="line">        nums2.<span class="built_in">push_back</span>(arrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res1 = <span class="built_in">intersection</span>(nums1);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res2 = <span class="built_in">intersection</span>(nums2);</span><br><span class="line">    res = <span class="built_in">vecjoin</span>(res1, res2);</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; ss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        ss.<span class="built_in">insert</span>(res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res = vector&lt;<span class="keyword">int</span>&gt;(ss.<span class="built_in">begin</span>(), ss.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、求平方根【剑指Offer2-72】"><a href="#13、求平方根【剑指Offer2-72】" class="headerlink" title="13、求平方根【剑指Offer2 72】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jJ0w9p/">求平方根【剑指Offer2 72】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】求一个数的平方根。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 为了防止 mid 为 0 , 在后面加1</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 通过除法 x/mid 来判断比用乘法好, 乘法容易溢出</span></span><br><span class="line">            <span class="keyword">if</span>(x/mid &gt;= mid)&#123;</span><br><span class="line">                <span class="comment">// 由于 x 的平方根是向下取整的, 所以当 x/mid &gt;= mid, 也就是 mid^2 &lt;= x, </span></span><br><span class="line">                <span class="comment">// 有可能 mid 就是平方根, 所以 left = mid, 而不是 mid + 1</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十四、线段树-字典树-前缀树"><a href="#十四、线段树-字典树-前缀树" class="headerlink" title="十四、线段树/字典树/前缀树"></a>十四、线段树/字典树/前缀树</h3><h5 id="1、实现-Trie-前缀树-【LeetCode-208-medium】】"><a href="#1、实现-Trie-前缀树-【LeetCode-208-medium】】" class="headerlink" title="1、实现 Trie (前缀树)【LeetCode 208 | medium】】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)【LeetCode 208 | medium】</a>】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】Trie（发音类似 &quot;try&quot;）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</span><br><span class="line"></span><br><span class="line">请你实现 Trie 类：</span><br><span class="line">Trie() 初始化前缀树对象。</span><br><span class="line">void insert(String word) 向前缀树中插入字符串 word 。</span><br><span class="line">boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</span><br><span class="line">boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 True</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Trie</span>() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(children));</span><br><span class="line">		word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">		Trie* cur = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : word) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		cur-&gt;word = word;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">		Trie* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">		<span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;word.<span class="built_in">size</span>() == word.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string word;</span><br><span class="line">	Trie* children[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">		Trie* cur = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : word) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="2、单词替换【LeetCode-648-medium】"><a href="#2、单词替换【LeetCode-648-medium】" class="headerlink" title="2、单词替换【LeetCode 648 | medium】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/replace-words/">单词替换【LeetCode 648 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在英语中，我们有一个叫做 词根(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</span><br><span class="line">现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</span><br><span class="line">你需要输出替换之后的句子。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：dictionary &#x3D; [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence &#x3D; &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">输出：&quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>字典树是单词匹配的常用解法。先将<code>dictionary</code>列表中的每个元素插入前缀树中，然后循环每个单词判断是包含在前缀树中，若包含返回最短前缀树，不包含返回原单词最终将列表拼接为字符串返回即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TriNode* children[<span class="number">26</span>];</span><br><span class="line">	string word;</span><br><span class="line">	<span class="built_in">TriNode</span>() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(children));</span><br><span class="line">		word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将句子拆分成单词数组</span></span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string sentence)</span> </span>&#123;</span><br><span class="line">		vector&lt;string&gt; res;</span><br><span class="line">		<span class="function">stringstream <span class="title">ss</span><span class="params">(sentence)</span></span>;</span><br><span class="line">		string curr;</span><br><span class="line">		<span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, curr, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (curr.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(curr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">		TriNode* root = <span class="keyword">new</span> <span class="built_in">TriNode</span>();</span><br><span class="line">        <span class="comment">// 构造字典树</span></span><br><span class="line">		<span class="keyword">for</span> (string&amp; s : dictionary) &#123;</span><br><span class="line">			TriNode* cur = root;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">TriNode</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				cur = cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			cur-&gt;word = s;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;string&gt; words = <span class="built_in">split</span>(sentence);</span><br><span class="line">		string res;</span><br><span class="line">		<span class="keyword">for</span> (string&amp; s : words) &#123;</span><br><span class="line">			TriNode* cur = root;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">                 <span class="comment">//如果没有对应的子节点了，就跳出对words[i]的循环，不对它进行替换</span></span><br><span class="line">				<span class="keyword">if</span> (cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					cur = cur-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                    <span class="comment">//如果当前节点的前缀不为空了，意味着到达了最短的前缀，此时完成替换过程，跳出当前的循环</span></span><br><span class="line">					<span class="keyword">if</span> (!cur-&gt;word.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//除了刚开始，其他的时候在插入字符串之前，都要先插入&quot;&quot;</span></span><br><span class="line">			<span class="keyword">if</span> (!res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">				res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//如果当前的前缀是空，则说明是没有合适替换的情况，此时不进行替换，直接插入原单词，反之，如果为空，则进行最短前缀的替换</span></span><br><span class="line">			res += !cur-&gt;word.<span class="built_in">empty</span>() ? cur-&gt;word : s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="十五、排序算法"><a href="#十五、排序算法" class="headerlink" title="十五、排序算法"></a>十五、排序算法</h3><p>稳定：冒泡排序、插入排序、归并、桶</p>
<p>不稳定：选择排序、快排、希尔、堆排序</p>
<h5 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h5><p>每次交换相邻的两个数，每一轮交换之后，最大的元素放到最后面，有多少个元素就要交换多少轮。</p>
<p>稳定。时间复杂度为<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;      <span class="comment">// 用flag来标记是否有数据交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() &amp;&amp; flag; ++i) &#123;</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>() - i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h5><p>每一轮选择和当前元素相比，选择一个最小的值和当前元素进行交换。</p>
<p>不稳定。时间复杂度为<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> minIndex;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(nums[i], nums[minIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h5><p>每轮在一个已经有序的小序列上，将当前元素插入到数组中。从有序序列最后一位开始往前遍历，直到遍历的数小于当前元素，将当前元素插在后面。</p>
<p>稳定。时间复杂度为<code>O(n^2)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i - <span class="number">1</span>, tmp = nums[i];</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; tmp) &#123;</span><br><span class="line">				nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">				--j;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、快排"><a href="#4、快排" class="headerlink" title="4、快排"></a>4、快排</h5><p>每次选择第一个数为基准，索引为<code>left</code>，用两个指针<code>i</code>、<code>j</code>分别从后往前和从前往后遍历，先从后往前找到第一个比基准数小的数，再从前往后找到第一个比基准元素大的数，两数交换，交换之后则继续向下遍历直到两指针相遇，则该轮遍历结束，此时<code>i</code>位置即为基准数的最终位置，交换<code>i</code>和<code>left</code>。并对剩余两部分递归调用该函数。</p>
<p>不稳定。时间复杂度为<code>O(nlogn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">int</span> key = nums[left];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= key) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(nums[i], nums[left]);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、希尔排序"><a href="#5、希尔排序" class="headerlink" title="5、希尔排序"></a>5、希尔排序</h5><p>采用插入排序的方法，交换不相邻的元素对数组的局部进行排序。先让数组中任意间隔为<code>h</code>的元素有序，然后让<code>h</code>一直缩小，直到<code>h=1</code>时，此时数组中任意间隔为1的元素有序。</p>
<p>不稳定。时间复杂度为<code>O(nlogn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> j = i - gap, tmp = nums[i];</span><br><span class="line">			<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; tmp) &#123;				</span><br><span class="line">				nums[j + gap] = nums[j];</span><br><span class="line">				j -= gap;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j + gap] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、归并排序"><a href="#6、归并排序" class="headerlink" title="6、归并排序"></a>6、归并排序</h5><p>将一个大的无序数组分成两部分，对这两部分分别进行排序，之后把这两部分排序后的数组合并成一个有序数组。通过递归的方式，将数组分为两部分，对这两部分数组再次分别分为两部分，直到数组的大小为1，然后依次合并。</p>
<p>稳定。时间复杂度为<code>O(nlogn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeCore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; copy, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line">	<span class="built_in">mergeCore</span>(copy, nums, low1, high1);</span><br><span class="line">	<span class="built_in">mergeCore</span>(copy, nums, low2, high2);</span><br><span class="line">	<span class="keyword">int</span> index = low1;</span><br><span class="line">	<span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) &#123;</span><br><span class="line">		copy[index++] = (nums[low1] &lt; nums[low2] ? nums[low1++] : nums[low2++]);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 左半部分有剩余</span></span><br><span class="line">	<span class="keyword">while</span> (low1 &lt;= high1) &#123;</span><br><span class="line">		copy[index++] = nums[low1++];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 右半部分有剩余</span></span><br><span class="line">	<span class="keyword">while</span> (low2 &lt;= high2) &#123;</span><br><span class="line">		copy[index++] = nums[low2++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">copy</span><span class="params">(nums)</span></span>;</span><br><span class="line">	<span class="built_in">mergeCore</span>(nums, copy, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	nums.<span class="built_in">assign</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());  <span class="comment">// 最后copy数组是排好序的，赋值以下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、堆排序"><a href="#7、堆排序" class="headerlink" title="7、堆排序"></a>7、堆排序</h5><p>建立最大堆，此时堆顶元素是数组的最大值，每次交换堆顶元素（第一个元素，是最大值）和最后一个元素，并对交换之后的新堆顶元素进行下溯。</p>
<p>不稳定。时间复杂度为<code>O(nlogn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>, right_child = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> maxIndex = i;</span><br><span class="line">	<span class="comment">// 找到左右孩子中值最大的一个</span></span><br><span class="line">	<span class="keyword">if</span> (left_child &lt; n &amp;&amp; nums[left_child] &gt; nums[maxIndex]) &#123;</span><br><span class="line">		maxIndex = left_child;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (right_child &lt; n &amp;&amp; nums[right_child] &gt; nums[maxIndex]) &#123;</span><br><span class="line">		maxIndex = right_child;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果最大值是根节点本身，则不变；如果是某个孩子节点，则交换，并继续对交换后的节点进行上溯</span></span><br><span class="line">	<span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[i], nums[maxIndex]);</span><br><span class="line">		<span class="built_in">heapify</span>(nums, n, maxIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 建立最大堆，从树的倒数第二行的最后一个节点开始，对每个节点进行上溯</span></span><br><span class="line">	<span class="keyword">int</span> tmp = (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = tmp; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(nums, n, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 交换第一个（根节点，最大值）和最后一个节点</span></span><br><span class="line">	<span class="comment">// 对交换后的根节点继续进行下溯调整(此时最后一位是最大位，不用管，因此n每次都变为n-1)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums.<span class="built_in">front</span>(), nums[n - i - <span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">heapify</span>(nums, n - i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h5><p>统计小于等于该元素值的元素的个数<code>i</code>，那么该元素就放在目标数组的索引<code>i</code>位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vecRaw, vector&lt;<span class="keyword">int</span>&gt;&amp; vecObj)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 确保待排序容器非空</span></span><br><span class="line">	<span class="keyword">if</span> (vecRaw.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span></span><br><span class="line">	<span class="keyword">int</span> vecCountLength = (*<span class="built_in">max_element</span>(<span class="built_in">begin</span>(vecRaw), <span class="built_in">end</span>(vecRaw))) + <span class="number">1</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecCount</span><span class="params">(vecCountLength, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计每个键值出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecRaw.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		vecCount[vecRaw[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vecCountLength; i++) &#123;</span><br><span class="line">		vecCount[i] += vecCount[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 将键值放到目标位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = vecRaw.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; i--) &#123;   <span class="comment">// 此处逆序是为了保持相同键值的稳定性</span></span><br><span class="line">		vecObj[--vecCount[vecRaw[i - <span class="number">1</span>]]] = vecRaw[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vecRaw)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecObj</span><span class="params">(vecRaw.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">CountSort</span>(vecRaw, vecObj);</span><br><span class="line">	vecRaw.<span class="built_in">assign</span>(vecObj.<span class="built_in">begin</span>(), vecObj.<span class="built_in">end</span>());  <span class="comment">// 最后copy数组是排好序的，赋值以下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h5><p>稳定。时间复杂度为<code>O(nk)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/04/29/%E5%89%91%E6%8C%87Offer/">https://varrella.github.io/2021/04/29/%E5%89%91%E6%8C%87Offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___0G1r-Cg0zS8___0___.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/29/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8Bch8-ch12/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturebdrshrsth2560x1440-bg-af73747.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《深入理解计算机系统》Ch8-Ch12阅读笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/28/Windows10%E6%9B%B4%E6%96%B0Nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturebdrshrsth2560x1440-bg-af73747.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Windows10更新Nvidia显卡驱动</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">一、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-32-1-medium%E3%80%91"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、从上到下打印二叉树【剑指Offer 32-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III%E3%80%90%E5%89%91%E6%8C%87Offer-32-3-medium%E3%80%91"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、从上到下打印二叉树 III【剑指Offer 32-3 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II%E3%80%90%E5%89%91%E6%8C%87Offer-32-2-easy%E3%80%91"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、从上到下打印二叉树 II【剑指Offer 32-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II%E3%80%90LeetCode-107-medium%E3%80%91"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、二叉树的层序遍历 II【LeetCode 107 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%90%E5%89%91%E6%8C%87Offer-27-easy%E3%80%91%E3%80%90LeetCode-226-medium%E3%80%91"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、二叉树的镜像【剑指Offer 27 | easy】【LeetCode 226 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-28-easy%E3%80%91"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、对称的二叉树【剑指Offer 28 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E3%80%90%E5%89%91%E6%8C%87Offer-55-1-easy%E3%80%91%E3%80%90LeetCode-104-medium%E3%80%91"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、二叉树的最大深度【剑指Offer 55-1 | easy】【LeetCode 104 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E3%80%90LeetCode-111-easy%E3%80%91"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、二叉树的最小深度【LeetCode 111 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-55-2-easy%E3%80%91%E3%80%90LeetCode-110-easy%E3%80%91"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、平衡二叉树【剑指Offer 55-2 | easy】【LeetCode 110 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-54-easy%E3%80%91"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、二叉搜索树的第k大节点【剑指Offer 54 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90%E5%89%91%E6%8C%87Offer-68-1-easy%E3%80%91"><span class="toc-number">1.0.11.</span> <span class="toc-text">11、二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90%E5%89%91%E6%8C%87Offer-68-2-easy%E3%80%91"><span class="toc-number">1.0.12.</span> <span class="toc-text">12、二叉树的最近公共祖先【剑指Offer 68-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90LeetCode-235-easy%E3%80%91"><span class="toc-number">1.0.13.</span> <span class="toc-text">13、二叉搜索树的最近公共祖先【LeetCode 235 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%90%E5%89%91%E6%8C%87Offer-26-medium%E3%80%91"><span class="toc-number">1.0.14.</span> <span class="toc-text">14、树的子结构【剑指Offer 26 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%EF%BC%89%E3%80%90%E5%89%91%E6%8C%87Offer-07-medium%E3%80%91%E3%80%90LeetCode-105-medium%E3%80%91"><span class="toc-number">1.0.15.</span> <span class="toc-text">15、重建二叉树（前序和中序）【剑指Offer 07 | medium】【LeetCode 105 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90LeetCode-106-medium%E3%80%91"><span class="toc-number">1.0.16.</span> <span class="toc-text">16、从中序与后序遍历序列构造二叉树【LeetCode 106 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-33-medium%E3%80%91"><span class="toc-number">1.0.17.</span> <span class="toc-text">17、二叉搜索树的后序遍历序列【剑指Offer 33 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%90%E5%89%91%E6%8C%87Offer-34-medium%E3%80%91%E3%80%90LeetCode-113-medium%E3%80%91%E3%80%90LeetCode-112-medium%E3%80%91"><span class="toc-number">1.0.18.</span> <span class="toc-text">18、二叉树中和为某一值的路径【剑指Offer 34 | medium】【LeetCode 113 | medium】【LeetCode 112 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-37-medium%E3%80%91"><span class="toc-number">1.0.19.</span> <span class="toc-text">19、序列化和反序列化二叉树【剑指Offer 37 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86-%E3%80%90LeetCode-94-144-145-easy%E3%80%91%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.0.20.</span> <span class="toc-text">20、二叉树遍历 【LeetCode 94 &#x2F;144&#x2F;145| easy】迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE%E3%80%90LeetCode-199-medium%E3%80%91"><span class="toc-number">1.0.21.</span> <span class="toc-text">21、二叉树的右视图【LeetCode 199 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%90LeetCode-429-medium%E3%80%91"><span class="toc-number">1.0.22.</span> <span class="toc-text">22、N 叉树的层序遍历【LeetCode 429 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E3%80%81%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E3%80%90LeetCode-116-medium%E3%80%91"><span class="toc-number">1.0.23.</span> <span class="toc-text">23、填充每个节点的下一个右侧节点指针【LeetCode 116 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E3%80%90LeetCode-222-medium%E3%80%91"><span class="toc-number">1.0.24.</span> <span class="toc-text">24、完全二叉树的节点个数【LeetCode 222 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E3%80%90LeetCode-257-medium%E3%80%91"><span class="toc-number">1.0.25.</span> <span class="toc-text">25、二叉树的所有路径【LeetCode 257 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26%E3%80%81%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C%E3%80%90LeetCode-404-easy%E3%80%91"><span class="toc-number">1.0.26.</span> <span class="toc-text">26、左叶子之和【LeetCode 404 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27%E3%80%81%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC%E3%80%90LeetCode-513-%E5%89%91%E6%8C%87Offer2-45-medium%E3%80%91"><span class="toc-number">1.0.27.</span> <span class="toc-text">27、找树左下角的值【LeetCode 513  | 剑指Offer2 45| medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28%E3%80%81%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90LeetCode-654-medium%E3%80%91"><span class="toc-number">1.0.28.</span> <span class="toc-text">28、最大二叉树【LeetCode 654 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29%E3%80%81%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90LeetCode-617-easy%E3%80%91"><span class="toc-number">1.0.29.</span> <span class="toc-text">29、合并二叉树【LeetCode 617 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2%E3%80%90LeetCode-700-easy%E3%80%91"><span class="toc-number">1.0.30.</span> <span class="toc-text">30、二叉搜索树中的搜索【LeetCode 700 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90LeetCode-98-medium%E3%80%91"><span class="toc-number">1.0.31.</span> <span class="toc-text">31、验证二叉搜索树【LeetCode 98 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0%E3%80%90LeetCode-501-easy%E3%80%91"><span class="toc-number">1.0.32.</span> <span class="toc-text">32、二叉搜索树中的众数【LeetCode 501 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E3%80%90LeetCode-701-medium%E3%80%91"><span class="toc-number">1.0.33.</span> <span class="toc-text">33、二叉搜索树中的插入操作【LeetCode 701 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34%E3%80%81%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90LeetCode-108-easy%E3%80%91"><span class="toc-number">1.0.34.</span> <span class="toc-text">34、将有序数组转换为二叉搜索树【LeetCode 108 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35%E3%80%81%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90LeetCode-450-medium%E3%80%91"><span class="toc-number">1.0.35.</span> <span class="toc-text">35、删除二叉搜索树中的节点【LeetCode 450 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36%E3%80%81%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90LeetCode-669-medium%E3%80%91"><span class="toc-number">1.0.36.</span> <span class="toc-text">36、修剪二叉搜索树【LeetCode 669 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37%E3%80%81%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91%E3%80%90LeetCode-538-medium%E3%80%91"><span class="toc-number">1.0.37.</span> <span class="toc-text">37、把二叉搜索树转换为累加树【LeetCode 538 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#38%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D%E3%80%90%E5%89%91%E6%8C%87Offer2-47-medium%E3%80%91"><span class="toc-number">1.0.38.</span> <span class="toc-text">38、二叉树剪枝【剑指Offer2 47 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#39%E3%80%81%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E3%80%90%E5%89%91%E6%8C%87Offer2-49-medium%E3%80%91"><span class="toc-number">1.0.39.</span> <span class="toc-text">39、从根节点到叶节点的路径数字之和【剑指Offer2 49 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#40%E3%80%81%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E3%80%90%E5%89%91%E6%8C%87Offer2-50-medium%E3%80%91"><span class="toc-number">1.0.40.</span> <span class="toc-text">40、向下的路径节点之和【剑指Offer2 50 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#41%E3%80%81%E5%B1%95%E5%B9%B3%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer2-52-easy%E3%80%91"><span class="toc-number">1.0.41.</span> <span class="toc-text">41、展平二叉搜索树【剑指Offer2 52 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#42%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%E3%80%90LeetCode-124-hard%E3%80%91"><span class="toc-number">1.0.42.</span> <span class="toc-text">42、二叉树中的最大路径和【LeetCode 124 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#43%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7%E3%80%90%E5%89%91%E6%8C%87Offer2-53-medium%E3%80%91"><span class="toc-number">1.0.43.</span> <span class="toc-text">43、二叉搜索树中的中序后继【剑指Offer2  53 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#44%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E3%80%90%E5%89%91%E6%8C%87Offer2-56-easy%E3%80%91"><span class="toc-number">1.0.44.</span> <span class="toc-text">44、二叉搜索树中两个节点之和【剑指Offer2 56 | easy】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5"><span class="toc-number">2.</span> <span class="toc-text">二、数组和矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E3%80%90LeetCode-189-medium%E3%80%91"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、旋转数组【LeetCode 189 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-11-easy%E3%80%91%E3%80%90%E5%90%8CLeetCode-154%E3%80%91"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、旋转数组的最小数字【剑指Offer 11 | easy】【同LeetCode 154】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%90LeetCode-153-medium%E3%80%91"><span class="toc-number">2.0.3.</span> <span class="toc-text">3、寻找旋转排序数组中的最小值【LeetCode 153 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E3%80%90LeetCode-33-medium%E3%80%91"><span class="toc-number">2.0.4.</span> <span class="toc-text">4、搜索旋转排序数组【LeetCode 33 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II%E3%80%90LeetCode-81-medium%E3%80%91"><span class="toc-number">2.0.5.</span> <span class="toc-text">5、搜索旋转排序数组 II【LeetCode 81 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E3%80%90%E5%89%91%E6%8C%87Offer-11-easy%E3%80%91"><span class="toc-number">2.0.6.</span> <span class="toc-text">6、调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-40-easy%E3%80%91"><span class="toc-number">2.0.7.</span> <span class="toc-text">7、最小的k个数【剑指Offer 40 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-39-easy%E3%80%91"><span class="toc-number">2.0.8.</span> <span class="toc-text">8、数组中出现次数超过一半的数字【剑指Offer 39 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%B1%82%E4%BC%97%E6%95%B0-II%E3%80%90LeetCode-229-medium%E3%80%91"><span class="toc-number">2.0.9.</span> <span class="toc-text">9、求众数 II【LeetCode 229 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">2.0.10.</span> <span class="toc-text">10、在排序数组中查找数字 I【剑指Offer 05 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%90%E5%89%91%E6%8C%87Offer-04-medium%E3%80%91"><span class="toc-number">2.0.11.</span> <span class="toc-text">11、二维数组中的查找【剑指Offer 04 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%810%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-53-2-easy%E3%80%91"><span class="toc-number">2.0.12.</span> <span class="toc-text">12、0～n-1中缺失的数字【剑指Offer 53-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%E3%80%90%E5%89%91%E6%8C%87Offer-66-medium%E3%80%91"><span class="toc-number">2.0.13.</span> <span class="toc-text">13、构建乘积数组【剑指Offer 66 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E3%80%90%E5%89%91%E6%8C%87Offer-51-hard%E3%80%91"><span class="toc-number">2.0.14.</span> <span class="toc-text">14、数组中的逆序对【剑指Offer 51 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.15.</span> <span class="toc-text">15、最长无重复子数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E3%80%90LeetCode-88-easy%E3%80%91"><span class="toc-number">2.0.16.</span> <span class="toc-text">16、合并两个有序数组【LeetCode 88 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E5%8A%A0%E4%B8%80%E3%80%90LeetCode-66-easy%E3%80%91"><span class="toc-number">2.0.17.</span> <span class="toc-text">17、加一【LeetCode 66 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E3%80%90LeetCode-118-easy%E3%80%91"><span class="toc-number">2.0.18.</span> <span class="toc-text">18、杨辉三角【LeetCode 118 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0%E3%80%90LeetCode-414-easy%E3%80%91"><span class="toc-number">2.0.19.</span> <span class="toc-text">19、第三大的数【LeetCode 414 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90LeetCode-268-easy%E3%80%91"><span class="toc-number">2.0.20.</span> <span class="toc-text">20、丢失的数字【LeetCode 268 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-%E3%80%90LeetCode-219-easy%E3%80%91"><span class="toc-number">2.0.21.</span> <span class="toc-text">21、存在重复元素 II 【LeetCode 219 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E3%80%90LeetCode-167-easy%E3%80%91%E3%80%90LeetCode-1-easy%E3%80%91"><span class="toc-number">2.0.22.</span> <span class="toc-text">22、两数之和 II - 输入有序数组【LeetCode 167 | easy】【LeetCode 1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E3%80%81%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%90LeetCode-15-medium%E3%80%91"><span class="toc-number">2.0.23.</span> <span class="toc-text">23、三数之和【LeetCode 15 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24%E3%80%81%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%90LeetCode-16-medium%E3%80%91"><span class="toc-number">2.0.24.</span> <span class="toc-text">24、最接近的三数之和【LeetCode 16 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E3%80%81%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%90LeetCode-18-medium%E3%80%91"><span class="toc-number">2.0.25.</span> <span class="toc-text">25、四数之和【LeetCode 18 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26%E3%80%81%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E3%80%90LeetCode-54-medium%E3%80%91"><span class="toc-number">2.0.26.</span> <span class="toc-text">26、螺旋矩阵【LeetCode 54 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27%E3%80%81%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II%E3%80%90LeetCode-59-medium%E3%80%91"><span class="toc-number">2.0.27.</span> <span class="toc-text">27、螺旋矩阵 II【LeetCode 59 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28%E3%80%81%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%E3%80%90LeetCode-57-medium%E3%80%91"><span class="toc-number">2.0.28.</span> <span class="toc-text">28、插入区间【LeetCode 57 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29%E3%80%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E3%80%90LeetCode-74-medium%E3%80%91"><span class="toc-number">2.0.29.</span> <span class="toc-text">29、搜索二维矩阵【LeetCode 74 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30%E3%80%81%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E3%80%90LeetCode-26-easy%E3%80%91"><span class="toc-number">2.0.30.</span> <span class="toc-text">30、删除有序数组中的重复项【LeetCode 26 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31%E3%80%81%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II-%E3%80%90LeetCode-80-medium%E3%80%91"><span class="toc-number">2.0.31.</span> <span class="toc-text">31、删除有序数组中的重复项 II 【LeetCode 80 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E3%80%90LeetCode-128-medium%E3%80%91"><span class="toc-number">2.0.32.</span> <span class="toc-text">32、最长连续序列【LeetCode 128 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33%E3%80%81%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90LeetCode-209-medium%E3%80%91"><span class="toc-number">2.0.33.</span> <span class="toc-text">33、长度最小的子数组【LeetCode 209 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34%E3%80%81%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%E3%80%90LeetCode-73-medium%E3%80%91"><span class="toc-number">2.0.34.</span> <span class="toc-text">34、矩阵置零【LeetCode 73 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35%E3%80%81%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%E3%80%90LeetCode-41-hard%E3%80%91"><span class="toc-number">2.0.35.</span> <span class="toc-text">35、缺失的第一个正数【LeetCode 41 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36%E3%80%81%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%E3%80%90LeetCode-162-medium%E3%80%91"><span class="toc-number">2.0.36.</span> <span class="toc-text">36、寻找峰值【LeetCode 162 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-03-easy%E3%80%91%E3%80%90LeetCode-442-medium%E3%80%91"><span class="toc-number">2.0.37.</span> <span class="toc-text">37、数组中重复的数字【剑指Offer 03 | easy】【LeetCode 442 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#38%E3%80%81%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4%E3%80%90LeetCode-228-medium%E3%80%91"><span class="toc-number">2.0.38.</span> <span class="toc-text">38、汇总区间【LeetCode 228 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#39%E3%80%81%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E3%80%90LeetCode-628-easy%E3%80%91"><span class="toc-number">2.0.39.</span> <span class="toc-text">39、三个数的最大乘积【LeetCode 628 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#40%E3%80%81%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I%E3%80%90LeetCode-643-easy%E3%80%91"><span class="toc-number">2.0.40.</span> <span class="toc-text">40、子数组最大平均数 I【LeetCode 643 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#41%E3%80%81%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I%E3%80%90LeetCode-561-easy%E3%80%91"><span class="toc-number">2.0.41.</span> <span class="toc-text">41、数组拆分 I【LeetCode 561 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#42%E3%80%81%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%90LeetCode-4-hard%E3%80%91"><span class="toc-number">2.0.42.</span> <span class="toc-text">42、寻找两个正序数组的中位数【LeetCode 4 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#43%E3%80%81%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E3%80%90LeetCode-35-easy%E3%80%91"><span class="toc-number">2.0.43.</span> <span class="toc-text">43、搜索插入位置【LeetCode 35 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#44%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E3%80%90LeetCode-34-medium%E3%80%91"><span class="toc-number">2.0.44.</span> <span class="toc-text">44、在排序数组中查找元素的第一个和最后一个位置【LeetCode 34 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#45%E3%80%81%E5%AF%BB%E6%89%BE%E7%AC%ACK%E5%A4%A7-%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="toc-number">2.0.45.</span> <span class="toc-text">45、寻找第K大 | 牛客网</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#46%E3%80%81%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90LeetCode-560-medium%E3%80%91%E3%80%90%E5%89%91%E6%8C%87-Offer-II-010%E3%80%91"><span class="toc-number">2.0.46.</span> <span class="toc-text">46、和为 k 的子数组【LeetCode 560 | medium】【剑指 Offer II 010】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#47%E3%80%810-%E5%92%8C-1-%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90%E5%89%91%E6%8C%87Offer2-011%E3%80%91"><span class="toc-number">2.0.47.</span> <span class="toc-text">47、0 和 1 个数相同的子数组【剑指Offer2 | 011】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#48%E3%80%81%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer2-70-medium%E3%80%91"><span class="toc-number">2.0.48.</span> <span class="toc-text">48、排序数组中只出现一次的数字【剑指Offer2 70 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#49%E3%80%81%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%E3%80%90%E5%89%91%E6%8C%87Offer2-74-medium%E3%80%91"><span class="toc-number">2.0.49.</span> <span class="toc-text">49、合并区间【剑指Offer2 74 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#50%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer2-119-medium%E3%80%91"><span class="toc-number">2.0.50.</span> <span class="toc-text">50、最长连续序列【剑指Offer2 119 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">三、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">3.0.1.</span> <span class="toc-text">1、替换空格【剑指Offer 05 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%90%E5%89%91%E6%8C%87Offer-50-easy%E3%80%91"><span class="toc-number">3.0.2.</span> <span class="toc-text">2、第一个只出现一次的字符【剑指Offer 50 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%E3%80%90%E5%89%91%E6%8C%87Offer-42-easy%E3%80%91"><span class="toc-number">3.0.3.</span> <span class="toc-text">3、连续子数组的最大和【剑指Offer 42 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E3%80%90%E5%89%91%E6%8C%87Offer-58-1-easy%E3%80%91"><span class="toc-number">3.0.4.</span> <span class="toc-text">4、翻转单词顺序【剑指Offer 58-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer58-2-easy%E3%80%91"><span class="toc-number">3.0.5.</span> <span class="toc-text">5、左旋转字符串【剑指Offer58-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-38-medium%E3%80%91"><span class="toc-number">3.0.6.</span> <span class="toc-text">6、字符串的排列【剑指Offer 38 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-46-medium%E3%80%91"><span class="toc-number">3.0.7.</span> <span class="toc-text">7、把数字翻译成字符串【剑指Offer 46 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-48-medium%E3%80%91%E3%80%90LeetCode-3-medium%E3%80%91"><span class="toc-number">3.0.8.</span> <span class="toc-text">8、最长不含重复字符的子字符串【剑指Offer 48 | medium】【LeetCode 3 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-67-medium%E3%80%91%E3%80%90LeetCode-8-medium%E3%80%91"><span class="toc-number">3.0.9.</span> <span class="toc-text">9、把字符串转换成整数【剑指Offer 67 | medium】【LeetCode 8 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%E3%80%90LeetCode-7-easy%E3%80%91"><span class="toc-number">3.0.10.</span> <span class="toc-text">10、整数反转【LeetCode 7 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E5%9B%9E%E6%96%87%E6%95%B0%E3%80%90LeetCode-9-easy%E3%80%91"><span class="toc-number">3.0.11.</span> <span class="toc-text">11、回文数【LeetCode 9 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E3%80%90LeetCode-5-medium%E3%80%91"><span class="toc-number">3.0.12.</span> <span class="toc-text">12、最长回文子串 【LeetCode 5 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer2-20-medium%E3%80%91"><span class="toc-number">3.0.13.</span> <span class="toc-text">13、回文子字符串的个数【剑指Offer2  20 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E3%80%90LeetCode-1143-medium%E3%80%91"><span class="toc-number">3.0.14.</span> <span class="toc-text">14、最长公共子序列 【LeetCode 1143 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E3%80%90LeetCode-14-easy%E3%80%91"><span class="toc-number">3.0.15.</span> <span class="toc-text">15、最长公共前缀 【LeetCode 14 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-45-medium%E3%80%91"><span class="toc-number">3.0.16.</span> <span class="toc-text">16、把数组排成最小的数【剑指Offer 45 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E6%9C%80%E5%A4%9A%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E3%80%90%E5%89%91%E6%8C%87Offer2-19-easy%E3%80%91"><span class="toc-number">3.0.17.</span> <span class="toc-text">17、最多删除一个字符得到回文【剑指Offer2 | 19 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E6%9C%89%E6%95%88%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D%E3%80%90%E5%89%91%E6%8C%87Offer2-32-easy%E3%80%91"><span class="toc-number">3.0.18.</span> <span class="toc-text">18、有效的变位词【剑指Offer2 | 32 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D%E3%80%90%E5%89%91%E6%8C%87Offer2-14-medium%E3%80%91"><span class="toc-number">3.0.19.</span> <span class="toc-text">19、字符串中的变位词【剑指Offer2 | 14 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D%E3%80%90%E5%89%91%E6%8C%87Offer2-15-medium%E3%80%91"><span class="toc-number">3.0.20.</span> <span class="toc-text">20、字符串中的所有变位词【剑指Offer2 | 15 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E7%9A%84TopK%E9%97%AE%E9%A2%98"><span class="toc-number">3.0.21.</span> <span class="toc-text">21、字符串出现次数的TopK问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">四、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-06-easy%E3%80%91"><span class="toc-number">4.0.1.</span> <span class="toc-text">1、从尾到头打印链表【剑指Offer 06 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-24-easy%E3%80%91"><span class="toc-number">4.0.2.</span> <span class="toc-text">2、反转链表【剑指Offer 24 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-25-easy%E3%80%91"><span class="toc-number">4.0.3.</span> <span class="toc-text">3、合并两个排序的链表【剑指Offer 25 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-22-easy%E3%80%91"><span class="toc-number">4.0.4.</span> <span class="toc-text">4、链表中倒数第k个节点【剑指Offer 22 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-18-easy%E3%80%91"><span class="toc-number">4.0.5.</span> <span class="toc-text">5、删除链表的节点【剑指Offer 18 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-52-easy%E3%80%91"><span class="toc-number">4.0.6.</span> <span class="toc-text">6、两个链表的第一个公共节点【剑指Offer 52 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%90%E5%89%91%E6%8C%87Offer-35-medium%E3%80%91"><span class="toc-number">4.0.7.</span> <span class="toc-text">7、复杂链表的复制【剑指Offer 35 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-36-medium%E3%80%91"><span class="toc-number">4.0.8.</span> <span class="toc-text">8、二叉搜索树与双向链表【剑指Offer 36 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E3%80%90LeetCode-2-medium%E3%80%91"><span class="toc-number">4.0.9.</span> <span class="toc-text">9、两数相加【LeetCode 2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II-%E3%80%90LeetCode-445-medium%E3%80%91"><span class="toc-number">4.0.10.</span> <span class="toc-text">10、两数相加 II 【LeetCode 445 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%90LeetCode-19-medium%E3%80%91"><span class="toc-number">4.0.11.</span> <span class="toc-text">11、删除链表的倒数第 N 个结点【LeetCode 19 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-23-hard%E3%80%91"><span class="toc-number">4.0.12.</span> <span class="toc-text">12、合并K个升序链表【LeetCode 23 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%90LeetCode-83-easy%E3%80%91"><span class="toc-number">4.0.13.</span> <span class="toc-text">13、 删除排序链表中的重复元素【LeetCode 83 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II%E3%80%90LeetCode-82-medium%E3%80%91"><span class="toc-number">4.0.14.</span> <span class="toc-text">14、删除排序链表中的重复元素 II【LeetCode 82 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-61-medium%E3%80%91"><span class="toc-number">4.0.15.</span> <span class="toc-text">15、旋转链表【LeetCode 61 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90LeetCode-24-medium%E3%80%91"><span class="toc-number">4.0.16.</span> <span class="toc-text">16、两两交换链表中的节点【LeetCode 24 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-25-hard%E3%80%91"><span class="toc-number">4.0.17.</span> <span class="toc-text">17、K 个一组翻转链表【LeetCode 25 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF-%E6%89%BE%E5%87%BA%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E3%80%90LeetCode-142-medium%E3%80%91"><span class="toc-number">4.0.18.</span> <span class="toc-text">18、判断链表是否有环&#x2F;找出环的入口【LeetCode 142 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E3%80%90LeetCode-203-easy%E3%80%91"><span class="toc-number">4.0.19.</span> <span class="toc-text">19、移除链表元素 【LeetCode 203 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E3%80%90LeetCode-143-medium%E3%80%91"><span class="toc-number">4.0.20.</span> <span class="toc-text">20、重排链表 【LeetCode 143 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E3%80%90LeetCode-147-medium%E3%80%91"><span class="toc-number">4.0.21.</span> <span class="toc-text">21、对链表进行插入排序 【LeetCode 147 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-328-medium%E3%80%91"><span class="toc-number">4.0.22.</span> <span class="toc-text">22、奇偶链表【LeetCode 328 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E3%80%81%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90LeetCode-109-medium%E3%80%91"><span class="toc-number">4.0.23.</span> <span class="toc-text">23、有序链表转换二叉搜索树【LeetCode 109 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24%E3%80%81%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90LeetCode-1721-medium%E3%80%91"><span class="toc-number">4.0.24.</span> <span class="toc-text">24、交换链表中的节点【LeetCode 1721 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E3%80%81%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-725-medium%E3%80%91"><span class="toc-number">4.0.25.</span> <span class="toc-text">25、分隔链表【LeetCode 725 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-234-easy%E3%80%91"><span class="toc-number">4.0.26.</span> <span class="toc-text">26、回文链表【LeetCode 234 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9%E3%80%90LeetCode-1019-medium%E3%80%91"><span class="toc-number">4.0.27.</span> <span class="toc-text">27、链表中的下一个更大节点【LeetCode 1019 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-1367-medium%E3%80%91"><span class="toc-number">4.0.28.</span> <span class="toc-text">28、二叉树中的链表【LeetCode 1367 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29%E3%80%81%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9%E3%80%90LeetCode-1171-medium%E3%80%91"><span class="toc-number">4.0.29.</span> <span class="toc-text">29、从链表中删去总和值为零的连续节点【LeetCode 1171 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30%E3%80%81%E8%AE%BE%E8%AE%A1%E5%89%8D%E4%B8%AD%E5%90%8E%E9%98%9F%E5%88%97%E3%80%90LeetCode-1670-medium%E3%80%91"><span class="toc-number">4.0.30.</span> <span class="toc-text">30、设计前中后队列【LeetCode 1670 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31%E3%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6%E3%80%90LeetCode-817-medium%E3%80%91"><span class="toc-number">4.0.31.</span> <span class="toc-text">31、链表组件【LeetCode 817 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E3%80%81%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-430-medium%E3%80%91"><span class="toc-number">4.0.32.</span> <span class="toc-text">32、扁平化多级双向链表【LeetCode 430 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer2-29-medium%E3%80%91"><span class="toc-number">4.0.33.</span> <span class="toc-text">33、排序的循环链表【剑指Offer2 | 29 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34%E3%80%81%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F%E3%80%90%E5%89%91%E6%8C%87Offer2-77-easy%E3%80%91"><span class="toc-number">4.0.34.</span> <span class="toc-text">34、链表排序【剑指Offer2 77 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">4.0.35.</span> <span class="toc-text">35、单链表排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88-%E9%98%9F%E5%88%97-%E5%A0%86-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">5.</span> <span class="toc-text">五、栈 &#x2F; 队列 &#x2F; 堆 &#x2F; 单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-09-easy%E3%80%91"><span class="toc-number">5.0.1.</span> <span class="toc-text">1、用两个栈实现队列【剑指Offer 09 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E3%80%90%E5%89%91%E6%8C%87Offer-30-easy%E3%80%91"><span class="toc-number">5.0.2.</span> <span class="toc-text">2、包含min函数的栈【剑指Offer 30 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-31-medium%E3%80%91"><span class="toc-number">5.0.3.</span> <span class="toc-text">3、栈的压入、弹出序列【剑指Offer 31 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-59-2-medium%E3%80%91"><span class="toc-number">5.0.4.</span> <span class="toc-text">4、队列的最大值【剑指Offer 59-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-41-medium%E3%80%91"><span class="toc-number">5.0.5.</span> <span class="toc-text">5、数据流中的中位数【剑指Offer 41 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II-%E3%80%90LeetCode-227-medium%E3%80%91"><span class="toc-number">5.0.6.</span> <span class="toc-text">6、基本计算器 II 【LeetCode 227 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91"><span class="toc-number">5.0.7.</span> <span class="toc-text">7、表达式求值 【牛客网】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E3%80%90LeetCode-146-medium%E3%80%91"><span class="toc-number">5.0.8.</span> <span class="toc-text">8、LRU 缓存机制【LeetCode 146 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E3%80%90LeetCode-20-easy%E3%80%91"><span class="toc-number">5.0.9.</span> <span class="toc-text">9、有效的括号【LeetCode 20 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">5.0.10.</span> <span class="toc-text">10、直方图最大矩形面积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%E3%80%90%E5%89%91%E6%8C%87Offer%E3%80%91"><span class="toc-number">5.0.11.</span> <span class="toc-text">11、矩阵中最大的矩形【剑指Offer】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84K%E5%AF%B9%E6%95%B0%E5%AD%97%E3%80%90LeetCode373-medium%E3%80%91"><span class="toc-number">5.0.12.</span> <span class="toc-text">12、查找和最小的K对数字【LeetCode373 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">6.</span> <span class="toc-text">七、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-10-1-easy%E3%80%91"><span class="toc-number">6.0.1.</span> <span class="toc-text">1、斐波那契数列【剑指Offer 10-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%E3%80%90%E5%89%91%E6%8C%87Offer-10-2-easy%E3%80%91"><span class="toc-number">6.0.2.</span> <span class="toc-text">2、青蛙跳台阶问题【剑指Offer 10-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90%E3%80%90%E5%89%91%E6%8C%87Offer-14-1-medium%E3%80%91%E3%80%90LeetCode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E3%80%91"><span class="toc-number">6.0.3.</span> <span class="toc-text">3、剪绳子【剑指Offer 14-1 | medium】【LeetCode 343 | 整数拆分】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90-II%E3%80%90%E5%89%91%E6%8C%87Offer-14-2-medium%E3%80%91"><span class="toc-number">6.0.4.</span> <span class="toc-text">4、剪绳子 II【剑指Offer 14-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-47-medium%E3%80%91"><span class="toc-number">6.0.5.</span> <span class="toc-text">5、礼物的最大价值【剑指Offer 47 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%B8%91%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-49-medium%E3%80%91"><span class="toc-number">6.0.6.</span> <span class="toc-text">6、丑数【剑指Offer 49 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E3%80%90LeetCode-131-medium%E3%80%91"><span class="toc-number">6.0.7.</span> <span class="toc-text">7、分割回文串【LeetCode 131 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-60-medium%E3%80%91"><span class="toc-number">6.0.8.</span> <span class="toc-text">8、n个骰子的点数【剑指Offer 60 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%E3%80%90%E5%89%91%E6%8C%87Offer-63-medium%E3%80%91"><span class="toc-number">6.0.9.</span> <span class="toc-text">9、股票的最大利润【剑指Offer 63 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E3%80%90%E5%89%91%E6%8C%87Offer-19-hard%E3%80%91%E3%80%90LeetCode-10-hard%E3%80%91"><span class="toc-number">6.0.10.</span> <span class="toc-text">10、正则表达式匹配【剑指Offer 19 | hard】【LeetCode 10 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II%E3%80%90LeetCode-63-medium%E3%80%91"><span class="toc-number">6.0.11.</span> <span class="toc-text">11、不同路径 II【LeetCode 63 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%E3%80%90LeetCode-746-easy%E3%80%91"><span class="toc-number">6.0.12.</span> <span class="toc-text">12、使用最小花费爬楼梯【LeetCode 746 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%E3%80%90LeetCode-1025-easy%E3%80%91"><span class="toc-number">6.0.13.</span> <span class="toc-text">13、除数博弈【LeetCode 1025 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E6%8C%89%E6%91%A9%E5%B8%88%E3%80%90LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-16-easy%E3%80%91"><span class="toc-number">6.0.14.</span> <span class="toc-text">14、按摩师【LeetCode 面试题17.16 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E3%80%90LeetCode-198-medium%E3%80%91"><span class="toc-number">6.0.15.</span> <span class="toc-text">15、打家劫舍【LeetCode 198 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II%E3%80%90LeetCode-213-medium%E3%80%91"><span class="toc-number">6.0.16.</span> <span class="toc-text">16、打家劫舍 II【LeetCode 213 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90LeetCode-97-medium%E3%80%91"><span class="toc-number">6.0.17.</span> <span class="toc-text">17、交错字符串【LeetCode 97 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">6.0.18.</span> <span class="toc-text">18、二维区域和检索 - 矩阵不可变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%E3%80%90LeetCode-91-medium%E3%80%91"><span class="toc-number">6.0.19.</span> <span class="toc-text">19、解码方法【LeetCode 91 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E7%9B%AE%E6%A0%87%E5%92%8C%E3%80%90LeetCode-494-medium%E3%80%91"><span class="toc-number">6.0.20.</span> <span class="toc-text">20、目标和【LeetCode 494 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%90LeetCode-673-medium%E3%80%91"><span class="toc-number">6.0.21.</span> <span class="toc-text">21、最长递增子序列的个数【LeetCode 673 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E3%80%90LeetCode-523-medium%E3%80%91"><span class="toc-number">6.0.22.</span> <span class="toc-text">22、连续的子数组和【LeetCode 523 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90LeetCode-516-medium%E3%80%91"><span class="toc-number">6.0.23.</span> <span class="toc-text">23、最长回文子序列【LeetCode 516 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90LeetCode-96-medium%E3%80%91"><span class="toc-number">6.0.24.</span> <span class="toc-text">24、不同的二叉搜索树【LeetCode 96 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E3%80%81%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%E3%80%90LeetCode-416-medium%E3%80%91"><span class="toc-number">6.0.25.</span> <span class="toc-text">25、分割等和子集【LeetCode 416 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26%E3%80%81%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-II%E3%80%90LeetCode-1049-medium%E3%80%91"><span class="toc-number">6.0.26.</span> <span class="toc-text">26、最后一块石头的重量 II【LeetCode 1049 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">九、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%E3%80%90LeetCode-376-medium%E3%80%91"><span class="toc-number">7.0.1.</span> <span class="toc-text">1、摆动序列【LeetCode 376 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%E3%80%90LeetCode-53-easy%E3%80%91"><span class="toc-number">7.0.2.</span> <span class="toc-text">2、最大子序和【LeetCode 53 | easy】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">十、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-15-easy%E3%80%91"><span class="toc-number">8.0.1.</span> <span class="toc-text">1、二进制中1的个数【剑指Offer 15| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%E3%80%90%E5%89%91%E6%8C%87Offer-65-easy%E3%80%91"><span class="toc-number">8.0.2.</span> <span class="toc-text">2、不用加减乘除做加法【剑指Offer 65 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-56-1-medium%E3%80%91"><span class="toc-number">8.0.3.</span> <span class="toc-text">3、数组中数字出现的次数【剑指Offer 56-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II%E3%80%90%E5%89%91%E6%8C%87Offer-56-2-medium%E3%80%91"><span class="toc-number">8.0.4.</span> <span class="toc-text">4、数组中数字出现的次数 II【剑指Offer 56-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%B1%821-2-%E2%80%A6-n%E3%80%90%E5%89%91%E6%8C%87Offer-64-medium%E3%80%91"><span class="toc-number">8.0.5.</span> <span class="toc-text">5、求1+2+…+n【剑指Offer 64 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E3%80%90%E5%89%91%E6%8C%87Offer2-005-medium%E3%80%91"><span class="toc-number">8.0.6.</span> <span class="toc-text">6、单词长度的最大乘积【剑指Offer2 005 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">9.</span> <span class="toc-text">十一、滑动窗口和双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-57-2-easy%E3%80%91"><span class="toc-number">9.0.1.</span> <span class="toc-text">1、和为s的连续正数序列【剑指Offer 57-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-57-easy%E3%80%91"><span class="toc-number">9.0.2.</span> <span class="toc-text">2、和为s的两个数字【剑指Offer 57 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-59-1-hard%E3%80%91"><span class="toc-number">9.0.3.</span> <span class="toc-text">3、滑动窗口的最大值【剑指Offer 59-1 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98-%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91"><span class="toc-number">9.0.4.</span> <span class="toc-text">4、容器盛水问题 |【牛客网】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%E3%80%90LeetCode-11-medium%E3%80%91"><span class="toc-number">9.0.5.</span> <span class="toc-text">5、盛最多水的容器【LeetCode 11 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-target-%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90%E5%89%91%E6%8C%87Offer2-008-medium%E3%80%91"><span class="toc-number">9.0.6.</span> <span class="toc-text">6、和大于等于 target 的最短子数组【剑指Offer2 008 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90%E5%89%91%E6%8C%87Offer2-009-medium%E3%80%91"><span class="toc-number">9.0.7.</span> <span class="toc-text">7、乘积小于 K 的子数组【剑指Offer2 009 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81DFS%E5%92%8CBFS-%E5%9B%9E%E6%BA%AF"><span class="toc-number">10.</span> <span class="toc-text">十二、DFS和BFS+回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%BB%84%E5%90%88%E3%80%90LeetCode-77-medium%E3%80%91"><span class="toc-number">10.0.1.</span> <span class="toc-text">1、组合【LeetCode 77 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III%E3%80%90LeetCode-216-medium%E3%80%91"><span class="toc-number">10.0.2.</span> <span class="toc-text">2、组合总和 III【LeetCode 216 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-II%E3%80%90LeetCode-126-hard%E3%80%91"><span class="toc-number">10.0.3.</span> <span class="toc-text">3、单词接龙 II【LeetCode 126 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%90%E5%89%91%E6%8C%87Offer-12-medium%E3%80%91"><span class="toc-number">10.0.4.</span> <span class="toc-text">4、矩阵中的路径【剑指Offer 12 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%90%E5%89%91%E6%8C%87Offer-13-medium%E3%80%91"><span class="toc-number">10.0.5.</span> <span class="toc-text">5、机器人的运动范围【剑指Offer 13 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II%E3%80%90LeetCode-95-medium%E3%80%91"><span class="toc-number">10.0.6.</span> <span class="toc-text">6、不同的二叉搜索树 II【LeetCode 95 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%E3%80%90LeetCode-22-medium%E3%80%91"><span class="toc-number">10.0.7.</span> <span class="toc-text">7、括号生成【LeetCode 22 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E3%80%90leetcode-17-medium%E3%80%91"><span class="toc-number">10.0.8.</span> <span class="toc-text">8、电话号码的字母组合【leetcode 17 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E3%80%90leetcode-39-medium%E3%80%91"><span class="toc-number">10.0.9.</span> <span class="toc-text">9、组合总和【leetcode 39 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II%E3%80%90leetcode-40-medium%E3%80%91"><span class="toc-number">10.0.10.</span> <span class="toc-text">10、组合总和 II【leetcode 40 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80%E3%80%90leetcode-93-medium%E3%80%91"><span class="toc-number">10.0.11.</span> <span class="toc-text">11、复原 IP 地址【leetcode 93 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E5%AD%90%E9%9B%86%E3%80%90leetcode-78-medium%E3%80%91"><span class="toc-number">10.0.12.</span> <span class="toc-text">12、子集【leetcode 78 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90leetcode491-medium%E3%80%91"><span class="toc-number">10.0.13.</span> <span class="toc-text">13、递增子序列【leetcode491 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E3%80%90leetcode-46-medium%E3%80%91"><span class="toc-number">10.0.14.</span> <span class="toc-text">14、不含重复数字的全排列【leetcode 46 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E5%85%A8%E6%8E%92%E5%88%97-II%E3%80%90leetcode-47-medium%E3%80%91"><span class="toc-number">10.0.15.</span> <span class="toc-text">15、全排列 II【leetcode 47 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81N-%E7%9A%87%E5%90%8E%E3%80%90LeetCode-51-hard%E3%80%91"><span class="toc-number">10.0.16.</span> <span class="toc-text">16、N 皇后【LeetCode 51 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E8%A7%A3%E6%95%B0%E7%8B%AC%E3%80%90LeetCode-37-hard%E3%80%91"><span class="toc-number">10.0.17.</span> <span class="toc-text">17、解数独【LeetCode 37 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B%E3%80%90LeetCode-332-medium%E3%80%91"><span class="toc-number">10.0.18.</span> <span class="toc-text">18、重新安排行程【LeetCode 332 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%E3%80%90LeetCode-200-medium%E3%80%91"><span class="toc-number">10.0.19.</span> <span class="toc-text">19、岛屿数量【LeetCode 200 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">11.</span> <span class="toc-text">十三、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-15-easy%E3%80%91"><span class="toc-number">11.0.1.</span> <span class="toc-text">1、打印从1到最大的n位数【剑指Offer 15| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%E3%80%90%E5%89%91%E6%8C%87Offer-29-easy%E3%80%91"><span class="toc-number">11.0.2.</span> <span class="toc-text">2、顺时针打印矩阵【剑指Offer 29| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-62-easy%E3%80%91"><span class="toc-number">11.0.3.</span> <span class="toc-text">3、圆圈中最后剩下的数字【剑指Offer 62 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%E3%80%90%E5%89%91%E6%8C%87Offer-61-easy%E3%80%91"><span class="toc-number">11.0.4.</span> <span class="toc-text">4、扑克牌中的顺子【剑指Offer 61 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-20-medium%E3%80%91"><span class="toc-number">11.0.5.</span> <span class="toc-text">5、表示数值的字符串【剑指Offer 20 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%E3%80%90%E5%89%91%E6%8C%87Offer-16-medium%E3%80%91"><span class="toc-number">11.0.6.</span> <span class="toc-text">6、数值的整数次方【剑指Offer 16 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-44-medium%E3%80%91"><span class="toc-number">11.0.7.</span> <span class="toc-text">7、数字序列中某一位的数字【剑指Offer 44 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%811%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-43-hard%E3%80%91"><span class="toc-number">11.0.8.</span> <span class="toc-text">8、1～n 整数中 1 出现的次数【剑指Offer 43 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95-%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91"><span class="toc-number">11.0.9.</span> <span class="toc-text">9、大数加法 【牛客网】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%E3%80%90LeetCode-13-easy%E3%80%91"><span class="toc-number">11.0.10.</span> <span class="toc-text">10、罗马数字转整数【LeetCode 13 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E3%80%90LeetCode-12-medium%E3%80%91"><span class="toc-number">11.0.11.</span> <span class="toc-text">11、整数转罗马数字【LeetCode 12 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E6%B1%82%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">11.0.12.</span> <span class="toc-text">12、求数组之间的交集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9%E3%80%90%E5%89%91%E6%8C%87Offer2-72%E3%80%91"><span class="toc-number">11.0.13.</span> <span class="toc-text">13、求平方根【剑指Offer2 72】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E7%BA%BF%E6%AE%B5%E6%A0%91-%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">12.</span> <span class="toc-text">十四、线段树&#x2F;字典树&#x2F;前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91-%E3%80%90LeetCode-208-medium%E3%80%91%E3%80%91"><span class="toc-number">12.0.1.</span> <span class="toc-text">1、实现 Trie (前缀树)【LeetCode 208 | medium】】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2%E3%80%90LeetCode-648-medium%E3%80%91"><span class="toc-number">12.0.2.</span> <span class="toc-text">2、单词替换【LeetCode 648 | medium】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">十五、排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.1.</span> <span class="toc-text">1、冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.2.</span> <span class="toc-text">2、选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.3.</span> <span class="toc-text">3、插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%BF%AB%E6%8E%92"><span class="toc-number">13.0.4.</span> <span class="toc-text">4、快排</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.5.</span> <span class="toc-text">5、希尔排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.6.</span> <span class="toc-text">6、归并排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.7.</span> <span class="toc-text">7、堆排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.8.</span> <span class="toc-text">8、计数排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.9.</span> <span class="toc-text">9、桶排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">13.0.10.</span> <span class="toc-text">10、基数排序</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___0G1r-Cg0zS8___0___.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>