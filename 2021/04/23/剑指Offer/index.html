<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer &amp;&amp; Leetcode | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【剑指Offer 05 | easy】本篇笔记中的题解参考了https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;jyd&#x2F;。 一、二叉树二叉树的数据结构： 123456struct TreeNode &amp;#123;	int val;	TreeNode* left;	TreeNode* right;	TreeNode(int x) :val(x), left(nullptr), right(nullpt">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer &amp;&amp; Leetcode">
<meta property="og:url" content="https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="【剑指Offer 05 | easy】本篇笔记中的题解参考了https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;jyd&#x2F;。 一、二叉树二叉树的数据结构： 123456struct TreeNode &amp;#123;	int val;	TreeNode* left;	TreeNode* right;	TreeNode(int x) :val(x), left(nullptr), right(nullpt">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg">
<meta property="article:published_time" content="2021-04-23T14:37:14.000Z">
<meta property="article:modified_time" content="2021-06-19T13:18:04.287Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-19 21:18:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指Offer &amp;&amp; Leetcode</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-23T14:37:14.000Z" title="Created 2021-04-23 22:37:14">2021-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-19T13:18:04.287Z" title="Updated 2021-06-19 21:18:04">2021-06-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指Offer &amp;&amp; Leetcode"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h5 id="【剑指Offer-05-easy】"><a href="#【剑指Offer-05-easy】" class="headerlink" title="【剑指Offer 05 | easy】"></a>【剑指Offer 05 | easy】</h5><p>本篇笔记中的题解参考了<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/jyd/%E3%80%82">https://leetcode-cn.com/u/jyd/。</a></p>
<h4 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h4><p>二叉树的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1、从上到下打印二叉树-II【剑指Offer-32-2-easy】"><a href="#1、从上到下打印二叉树-II【剑指Offer-32-2-easy】" class="headerlink" title="1、从上到下打印二叉树 II【剑指Offer 32-2 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II【剑指Offer 32-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历，用队列的size()来表示每层的节点个数。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	queue&lt;TreeNode*&gt; Q;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">				tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">				Q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、二叉树的镜像【剑指Offer-27-easy】"><a href="#2、二叉树的镜像【剑指Offer-27-easy】" class="headerlink" title="2、二叉树的镜像【剑指Offer 27 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像【剑指Offer 27 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class="line">例如输入：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line">镜像输出：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】递归。用tmp暂存root的左子节点，递归右子节点，返回值作为root的左子节点；递归左子节点，返回值作为root的右子节点。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode* tmp = root-&gt;left;</span><br><span class="line">	root-&gt;left = <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">	root-&gt;right = <span class="built_in">mirrorTree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、对称的二叉树【剑指Offer-28-easy】"><a href="#3、对称的二叉树【剑指Offer-28-easy】" class="headerlink" title="3、对称的二叉树【剑指Offer 28 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树【剑指Offer 28 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>【解法】递归。对于两棵子树L和R，判断两节点 L-&gt;left 和 R-&gt;right 是否对称，即 recur(L-&gt;left, R-&gt;right) ；<br>判断两节点 L-&gt;right 和 R-&gt;left是否对称，即 recur(L-&gt;right, R-&gt;left) ；对称则应该为L的左子树节点的值等于R的右子树节点的值。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* L, TreeNode* R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> &amp;&amp; R == <span class="literal">nullptr</span>) &#123;  <span class="comment">// L和R都为空，则true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> || R == <span class="literal">nullptr</span> || L-&gt;val != R-&gt;val) &#123; <span class="comment">// L和R有一个为空或者二者值不相等，则为false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归比较L-&gt;left和R-&gt;right以及L-&gt;right和R-&gt;left是否相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(L-&gt;left, R-&gt;right) &amp;&amp; <span class="built_in">recur</span>(L-&gt;right, R-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="built_in">recur</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、二叉树的深度【剑指Offer-55-1-easy】"><a href="#4、二叉树的深度【剑指Offer-55-1-easy】" class="headerlink" title="4、二叉树的深度【剑指Offer 55-1 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度【剑指Offer 55-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span><br><span class="line">例如：给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br><span class="line"></span><br><span class="line">提示：节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历。用队列的size()来表示每层的节点个数。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		queue&lt;TreeNode*&gt; Q;</span><br><span class="line">		Q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">				Q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			height++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、平衡二叉树【剑指Offer-55-2-easy】"><a href="#5、平衡二叉树【剑指Offer-55-2-easy】" class="headerlink" title="5、平衡二叉树【剑指Offer 55-2 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">平衡二叉树【剑指Offer 55-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span><br><span class="line">示例 1:给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法1（最优）】后序遍历+剪枝，对二叉树做后序遍历，从底至顶返回子树深度，因为在遍历到一个节点之前已经遍历了它的左右子树，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBalanced</span>(root-&gt;left, l) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right, r)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(l - r) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			depth = <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalanced</span>(root, depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】先序遍历+判断深度。构造一个获取当前子树的深度的函数 depth(root) ，通过比较左右子树的深度差 abs(depth(root.left) - depth(root.right)) &lt;= 1 是否成立，来判断某子树是否是二叉平衡树。然后递归判断左右子树是否都是平衡树。时间复杂度O(NlogN)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left), <span class="built_in">depth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">abs</span>(<span class="built_in">depth</span>(root-&gt;left) - <span class="built_in">depth</span>(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、二叉搜索树的第k大节点【剑指Offer-54-easy】"><a href="#6、二叉搜索树的第k大节点【剑指Offer-54-easy】" class="headerlink" title="6、二叉搜索树的第k大节点【剑指Offer 54 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点【剑指Offer 54 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一棵二叉搜索树，请找出其中第k大的节点。</span><br><span class="line">示例 1:输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 2:输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br><span class="line"> </span><br><span class="line">限制：1 ≤ k ≤ 二叉搜索树元素个数</span><br></pre></td></tr></table></figure>

<p>【解法】二叉搜索树的中序遍历的倒序为递减序列。在遍历的过程中不断将k-1，直到为0。时间复杂度O(NlogN)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> k, res;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">			res = root-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">		<span class="built_in">dfs</span>(root);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="7、二叉搜索树的最近公共祖先【剑指Offer-68-1-easy】"><a href="#7、二叉搜索树的最近公共祖先【剑指Offer-68-1-easy】" class="headerlink" title="7、二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line">说明：所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br><span class="line">例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424130042.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>【解法】迭代法。循环搜索，当p、q都在root的左子树中，则遍历到root-&gt;left；当p、q都在root的右子树中，则遍历到root-&gt;right；如果p、q在root的两侧，则root即为最近公共祖先。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (root) &#123;</span><br><span class="line">		<span class="comment">// p、q都在root的左子树中</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// p、q都在root的右子树中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p、q分别在root的两侧</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】递归。若p、q都在root的左子树中，则递归遍历左子树；若p、q都在root的右子树中，则递归遍历右子树；时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p、q都在root的左子树中</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// p、q都在root的右子树中</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、二叉树的最近公共祖先【剑指Offer-68-2-easy】"><a href="#8、二叉树的最近公共祖先【剑指Offer-68-2-easy】" class="headerlink" title="8、二叉树的最近公共祖先【剑指Offer 68-2 | easy】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先【剑指Offer 68-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</span><br><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424130223.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>【解法】递归左子树，返回值为left；递归右子树，返回值为right；left和right同时为空，则返回空；left和right同时不为空，说明p、q在root异侧，返回root；当left为空right不为空，则p、q都不在左子树中，返回right；当right为空left不为空，则p、q都不在右子树中，返回left。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果树为空则直接返回空；如果root等于p、q其中一个，那么最近公共祖先即为root，返回root</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归遍历左子树，在左子树中寻找p或q</span></span><br><span class="line">	TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	<span class="comment">// 递归遍历右子树，在右子树中寻找p或q</span></span><br><span class="line">	TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 左子树中没找到p和q，则必然在右子树中;右子树中没找到p和q，则必然在左子树中;</span></span><br><span class="line">    <span class="comment">// 否则p、q在root两侧，则root即为最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> (left == <span class="literal">nullptr</span>) ? right: ((right == <span class="literal">nullptr</span>) ? left : root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、树的子结构【剑指Offer-26-medium】"><a href="#9、树的子结构【剑指Offer-26-medium】" class="headerlink" title="9、树的子结构【剑指Offer 26 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构【剑指Offer 26 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line">B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br><span class="line">例如:给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】递归判断B是否是A的左子树的子结构，B是否是A的右子树的子结构。时间复杂度O(MN)，空间复杂度O(M)，M、N分别为A、B的节点数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当A或B为空时直接返回false；若树 B 是树 A 的子结构，则有三种情况：</span></span><br><span class="line">    <span class="comment">// 以 节点 A 为根节点的子树 包含树 B， 即(recur(A, B)</span></span><br><span class="line">    <span class="comment">// 树 B 是 树 A 左子树的子结构，对应 isSubStructure(A-&gt;left, B)；</span></span><br><span class="line">    <span class="comment">// 树 B 是 树 A 右子树的子结构，对应 isSubStructure(A-&gt;right, B)；</span></span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">nullptr</span> &amp;&amp; B != <span class="literal">nullptr</span>) &amp;&amp; (<span class="built_in">recur</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || 			<span class="built_in">isSubStructure</span>(A-&gt;right, B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断以A为根节点的树和以B为根节点的树是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || A-&gt;val != B-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">recur</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、重建二叉树（前序和中序）【剑指Offer-07-medium】"><a href="#10、重建二叉树（前序和中序）【剑指Offer-07-medium】" class="headerlink" title="10、重建二叉树（前序和中序）【剑指Offer 07 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树（前序和中序）【剑指Offer 07 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，给出：</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p>【解法】哈希表中保存中序遍历序列值和索引的对应关系，在建树的过程中遍历前序遍历序列，找出根节点，根据哈希表找到根节点在中序序列中的索引，根据索引值递归构造左子树和右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; preorder;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="comment">// root_index为前序序列中根节点对应的索引值，left为树的左边界，right为树的右边界</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[root_index]);</span><br><span class="line">		<span class="keyword">int</span> index = dic[preorder[root_index]];</span><br><span class="line">        <span class="comment">// 左子树的根节点索引为上一个根节点索引值加1</span></span><br><span class="line">		node-&gt;left = <span class="built_in">recur</span>(root_index + <span class="number">1</span>, left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// index - left + 1为左子树加根节点的长度，加上根的索引值root_index，即为右子树的根节点索引</span></span><br><span class="line">		node-&gt;right = <span class="built_in">recur</span>(root_index + index - left + <span class="number">1</span>, index + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			dic[inorder[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recur</span>(<span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11、从中序与后序遍历序列构造二叉树【LeetCode-106-medium】"><a href="#11、从中序与后序遍历序列构造二叉树【LeetCode-106-medium】" class="headerlink" title="11、从中序与后序遍历序列构造二叉树【LeetCode 106 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树【LeetCode 106 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】根据一棵树的中序遍历与后序遍历构造二叉树。你可以假设树中没有重复的元素。</span><br><span class="line">例如，给出</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

<p>【解法】哈希表中保存中序遍历序列值和索引的对应关系，在建树的过程中，遍历后序遍历序列，找出根节点，根据哈希表找到根节点在中序序列中的索引，根据索引值递归构造左子树和右子树。<code>left</code>和<code>right</code>是用来在中序序列中计算左右子树节点个数的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; postorder;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[root_index]);</span><br><span class="line">		<span class="keyword">int</span> index = unmap[postorder[root_index]];</span><br><span class="line">        <span class="comment">// right - index + 1为右子树加根节点的长度，用根节点的索引减去该长度，即为左子树的根节点索引：root_index-(right - index + 1)，左子树左边界是left，右边界是根节点索引减1</span></span><br><span class="line">		node-&gt;left = <span class="built_in">recur</span>(root_index - right + index - <span class="number">1</span>, left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 右子树的根节点索引为上一个根节点索引值减1，右子树的左边界是根节点索引加1，右边界是right</span></span><br><span class="line">		node-&gt;right = <span class="built_in">recur</span>(root_index - <span class="number">1</span>, index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;postorder = postorder;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			unmap[inorder[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recur</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="12、从上到下打印二叉树【剑指Offer-32-1-medium】"><a href="#12、从上到下打印二叉树【剑指Offer-32-1-medium】" class="headerlink" title="12、从上到下打印二叉树【剑指Offer 32-1 | medium】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树【剑指Offer 32-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span><br><span class="line">例如:给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回：[3,9,20,15,7]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历。队列。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、从上到下打印二叉树-III【剑指Offer-32-3-medium】"><a href="#13、从上到下打印二叉树-III【剑指Offer-32-3-medium】" class="headerlink" title="13、从上到下打印二叉树 III【剑指Offer 32-3 | medium】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">从上到下打印二叉树 III【剑指Offer 32-3 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span><br><span class="line">例如:给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历。把每层的节点存入vector中，并记录当前层次，如果当前层次为偶数，则逆序。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;TreeNode*&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">		layer++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">			tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">			Q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (layer % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		result.<span class="built_in">push_back</span>(tmp);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、二叉搜索树的后序遍历序列【剑指Offer-33-medium】"><a href="#14、二叉搜索树的后序遍历序列【剑指Offer-33-medium】" class="headerlink" title="14、二叉搜索树的后序遍历序列【剑指Offer 33 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列【剑指Offer 33 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span><br><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">提示：数组长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法1】借助一个单调栈  存储值递增的节点；每当遇到值递减的节点 ，则通过出栈来更新节点的父节点 root，每轮判断当前节点和父节点的关系，如果大于root，则不满足二叉搜索树定义，返回false；如果小于root，则满足二叉搜索树的定义，则继续遍历。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> root = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() &gt; postorder[i]) &#123;</span><br><span class="line">            root = S.<span class="built_in">top</span>();  <span class="comment">// 更新root</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        S.<span class="built_in">push</span>(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】根据二叉搜索树的性质递归判断所有子树的正确性。遍历后序序列[i, j]，寻找第一个大于根节点的节点，索引为m，此时可以划分出左子树区间[i, m-1]，[m, j-1]，递归判断左右子树区间对应的是否是二叉搜索树。时间复杂度O(N^2)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从左到右找到第一个比根节点大的节点对应的索引</span></span><br><span class="line">	<span class="keyword">while</span> (postorder[p] &lt; postorder[right]) &#123;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = p;</span><br><span class="line">	<span class="comment">// 判断右子树中的节点是否都大于根节点</span></span><br><span class="line">	<span class="keyword">while</span> (postorder[p] &gt; postorder[right]) &#123;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p == right表示满足右子树都大于根节点，递归判断两个区间是否是二叉搜索树</span></span><br><span class="line">	<span class="keyword">return</span> p == right &amp;&amp; <span class="built_in">recur</span>(postorder, left, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、二叉树中和为某一值的路径【剑指Offer-34-medium】"><a href="#15、二叉树中和为某一值的路径【剑指Offer-34-medium】" class="headerlink" title="15、二叉树中和为某一值的路径【剑指Offer 34 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径【剑指Offer 34 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</span><br><span class="line">示例:给定如下二叉树，以及目标和 target &#x3D; 22，</span><br><span class="line">              5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   8</span><br><span class="line">           &#x2F;   &#x2F; \</span><br><span class="line">          11  13  4</span><br><span class="line">         &#x2F;  \    &#x2F; \</span><br><span class="line">        7    2  5   1</span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】二叉树的搜索问题，DFS+回溯。遍历每个节点，将当前节点添加到当前路径中，遍历到叶节点的时候判断当前路径和是否和目标值相等，相等则符合要求，否则回溯。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;target, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">	target -= root-&gt;val;</span><br><span class="line">	<span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root-&gt;left, target, result, path);</span><br><span class="line">	<span class="built_in">dfs</span>(root-&gt;right, target, result, path);</span><br><span class="line">	target += root-&gt;val;   <span class="comment">// 遍历完左右子树后回溯</span></span><br><span class="line">	path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">	<span class="built_in">dfs</span>(root, target, result, path);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、序列化和反序列化二叉树【剑指Offer-37-medium】"><a href="#16、序列化和反序列化二叉树【剑指Offer-37-medium】" class="headerlink" title="16、序列化和反序列化二叉树【剑指Offer 37 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">序列化和反序列化二叉树【剑指Offer 37 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line">示例: 你可以将以下二叉树：</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>

<p>【解法】序列化过程中，层次遍历，遇到空节点则表示为<code>&quot;# &quot;</code>；</p>
<p>反序列化过程中，遍历字符串，将每个值构造一个对应的节点存入数组中，遍历节点数组，根据左右节点和根节点的索引关系构造左右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	ostringstream output;</span><br><span class="line">	queue&lt;TreeNode*&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) output &lt;&lt; <span class="string">&quot;# &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			output &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> output.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;TreeNode*&gt; node_vec;</span><br><span class="line">	string val;</span><br><span class="line">	<span class="function">istringstream <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (input &gt;&gt; val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">			node_vec.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node_vec.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node_vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node_vec[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node_vec[i]-&gt;left = node_vec[pos++];</span><br><span class="line">		node_vec[i]-&gt;right = node_vec[pos++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【补充说明】<code>ostringstream</code>：向<code>string</code>中写入数据，使用它来格式化字符串，最后通过<code>str()</code>得到<code>stream</code>中的<code>string</code>拷贝。</p>
<p><code>istringstream</code>：从<code>string</code>中读取数据，例如 有一行单词，然后对该行单词中的各个单词逐个处理。</p>
<h4 id="二、数组和矩阵"><a href="#二、数组和矩阵" class="headerlink" title="二、数组和矩阵"></a>二、数组和矩阵</h4><h5 id="1、旋转数组【LeetCode-189-medium】"><a href="#1、旋转数组【LeetCode-189-medium】" class="headerlink" title="1、旋转数组【LeetCode 189 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">旋转数组【LeetCode 189 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line">进阶：尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</span><br><span class="line">你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</span><br><span class="line"> </span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p>【解法】将数组的元素向右移动 <code>k</code>次后，尾部<code>k mod n</code>个元素会移动至数组头部，其余元素向后移动<code>k mod n</code> 个位置。该方法为数组的翻转： 可以先将所有元素翻转，这样尾部的<code>k mod n</code>个元素就被移至数组头部，然后再翻转<code>[0, k mod n−1]</code>区间的元素和<code>[k mod n, n−1]</code>区间的元素即能得到最后的答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615162238.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	k = k % nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + k);</span><br><span class="line">	<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、旋转数组的最小数字【剑指Offer-11-easy】【同LeetCode-154】"><a href="#2、旋转数组的最小数字【剑指Offer-11-easy】【同LeetCode-154】" class="headerlink" title="2、旋转数组的最小数字【剑指Offer 11 | easy】【同LeetCode 154】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字【剑指Offer 11 | easy】【同LeetCode 154】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】把一个数组最开始的若干个元素搬到数组的末尾， 称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。注意数组中可能存在重复的数。  </span><br><span class="line">示例 1：</span><br><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找，<code>left</code>和<code>right</code>分别指向数组两端，<code>mid</code>为<code>left</code>和<code>right</code>中点；</p>
<p>如果比较<code>nums[left]</code>和<code>nums[mid]</code>，如<code>[3, 4, 5, 1, 2]</code>与 <code>[1, 2, 3, 4, 5]</code> ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，无法进行查询；</p>
<p>如果比较<code>nums[right]</code>和<code>nums[mid]</code>，如<code>[1, 2, 3, 4, 5]</code>、<code>[3, 4, 5, 1, 2]</code>、<code>[2, 3, 4, 5 ,1]</code>，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p>
<p>时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123; <span class="comment">// 中间元素小于右边元素，则最小值在数组左半部分</span></span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123; <span class="comment">// 中间元素大于右边元素，则最小值在数组右半部</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">// 中间元素等于右边元素，则不能草率地下定结论最小数字在哪一边，但把 right 舍弃掉，并不影响结果</span></span><br><span class="line">			right -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、寻找旋转排序数组中的最小值【LeetCode-153-medium】"><a href="#3、寻找旋转排序数组中的最小值【LeetCode-153-medium】" class="headerlink" title="3、寻找旋转排序数组中的最小值【LeetCode 153 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值【LeetCode 153 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：</span><br><span class="line">若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</span><br><span class="line">若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</span><br><span class="line">注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</span><br><span class="line">给你一个元素值 【互不相同】 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。同上一题。因为数组元素互不相同，因此和上一题不同之处在于不需要额外判断<code>nums[mid] == nums[right]</code>的情况。时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、搜索旋转排序数组-II【LeetCode-81-medium】"><a href="#4、搜索旋转排序数组-II【LeetCode-81-medium】" class="headerlink" title="4、搜索旋转排序数组 II【LeetCode 81 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组 II【LeetCode 81 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><br><span class="line">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><br><span class="line">给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>二分查找。对于数组中有重复元素的情况，二分查找时可能会有 <code>a[l] = a[mid] = a[r]</code>，此时无法判断区间<code>[l, mid]</code>和区间<code>[mid + 1, r]</code>哪个是有序的。</p>
<p>例如<code>nums=[3,1,2,3,3,3,3], target=2</code>，首次二分时无法判断区间<code>[0, 3]</code>和区间<code>[4, 6]</code>哪个是有序的。对于这种情况， 只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<p>时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> target == nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;</span><br><span class="line">			++left;</span><br><span class="line">			--right;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 左边区间是递增区间，右边是旋转区间</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 右边是递增区间</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、调整数组顺序使奇数位于偶数前面【剑指Offer-11-easy】"><a href="#5、调整数组顺序使奇数位于偶数前面【剑指Offer-11-easy】" class="headerlink" title="5、调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</span><br><span class="line">示例：</span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class="line"> </span><br><span class="line">提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 50000，1 &lt;&#x3D; nums[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>设置头尾双指针，头指针向右遍历找到第一个偶数，尾指针向左遍历找到第一个奇数，二者交换，在遍历过程中始终保证头指针小于等于尾指针。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// i从左向右指向第一个偶数，j从右向左指向第一个奇数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; (nums[i] &amp; <span class="number">1</span>)) &#123; <span class="comment">// nums[i]是奇数，i++</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; !(nums[j] &amp; <span class="number">1</span>)) &#123; <span class="comment">// nums[j]是偶数，j--</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、最小的k个数【剑指Offer-40-easy】"><a href="#6、最小的k个数【剑指Offer-40-easy】" class="headerlink" title="6、最小的k个数【剑指Offer 40 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数【剑指Offer 40 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br><span class="line">示例 1：</span><br><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000，0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong><code>Top k</code>问题的最优解，快速选择算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>快排。时间复杂度<code>O(NlogN)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[j] &gt;= nums[left] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &lt;= nums[left] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法3】</strong>最大堆。维护元素个数为<code>k</code>的最大堆，时间复杂度<code>O(Nlogk)</code>，空间复杂度<code>O(k)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q.<span class="built_in">size</span>() &lt; k) &#123; <span class="comment">// 当堆中元素个数小于k时直接入堆</span></span><br><span class="line">            Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 当堆中已有k个元素时，堆顶元素和新来的元素中最小的值入堆</span></span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(Q.<span class="built_in">top</span>());</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、数组中出现次数超过一半的数字【剑指Offer-39-easy】"><a href="#7、数组中出现次数超过一半的数字【剑指Offer-39-easy】" class="headerlink" title="7、数组中出现次数超过一半的数字【剑指Offer 39 | easy】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字【剑指Offer 39 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>本题常见的三种解法：</p>
<ul>
<li>哈希表统计法： 遍历数组 <code>nums</code> ，用 <code>HashMap</code> 统计各数字的数量，即可找出众数 。此方法时间和空间复杂度均为 <code>O(N)</code> 。</li>
<li>数组排序法： 将数组 <code>nums </code>排序，数组中点的元素 一定为众数。</li>
<li><strong>【最优解】</strong>摩尔投票法： 核心理念为票数正负抵消 。时间和空间复杂度分别为 <code>O(N)</code>和<code>O(1)</code> 。</li>
</ul>
<p>【摩尔投票法】设输入数组<code>nums</code>的众数为<code> x</code>，数组长度为<code> n</code> 。本题将 “数组中出现次数超过一半的数字” 简称为 <strong>“众数”</strong>。</p>
<p>推论一： 若记众数的票数为 +1 ，非众数的票数为 −1 ，则一定有所有数字的票数和 &gt; 0 。</p>
<p>推论二： 若数组的前 a 个数字的票数和 = 0 ，则数组剩余 (n−a) 个数字的票数和一定仍 &gt; 0 ，即后(n−a) 个数字的众数仍为 x 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到众数</span></span><br><span class="line">	<span class="keyword">int</span> vote = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vote == <span class="number">0</span>) &#123;</span><br><span class="line">			x = num;</span><br><span class="line">		&#125;</span><br><span class="line">		vote += (x == num) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断找到的数是否超过数组元素的一半，如果题目中未提示是否存在超过一半的数的话需要加上这个判断</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == x) &#123;</span><br><span class="line">			++count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count &gt; nums.<span class="built_in">size</span>() / <span class="number">2</span> ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、求众数-II【LeetCode-229-medium】"><a href="#8、求众数-II【LeetCode-229-medium】" class="headerlink" title="8、求众数 II【LeetCode 229 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element-ii/">求众数 II【LeetCode 229 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n&#x2F;3 ⌋ 次的元素。</span><br><span class="line">进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[3,2,3]</span><br><span class="line">输出：[3]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：[1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：[1,1,1,3,3,2,2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>摩尔投票法。因为题目中的众数是超过三分之一的数，因此最多有两个候选人。第一次遍历进行抵消，计算是哪两个候选人得票数最多；第二次遍历给这两个候选人进行计数，验证得票数是否大于<code>n/3</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/1CE2A508441B6E210E498E307593F5A1.png"></p>
<p>【归纳】</p>
<p>如果至多选一个代表，那他的票数至少要超过一半<code>⌊ 1/2 ⌋</code>的票数；</p>
<p>如果至多选两个代表，那他们的票数至少要超过 <code>⌊ 1/3 ⌋</code> 的票数；</p>
<p>如果至多选<code>m</code>个代表，那他们的票数至少要超过<code>⌊ 1/(m+1) ⌋</code>的票数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">int</span> cand1 = nums[<span class="number">0</span>], cnt1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cand2 = nums[<span class="number">0</span>], cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == cand1) &#123;</span><br><span class="line">			++cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num == cand2) &#123;</span><br><span class="line">			++cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == <span class="number">0</span>) &#123;</span><br><span class="line">			cand1 = num;</span><br><span class="line">			++cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cnt2 == <span class="number">0</span>) &#123;</span><br><span class="line">			cand2 = num;</span><br><span class="line">			++cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			--cnt1;</span><br><span class="line">			--cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == cand1) &#123;</span><br><span class="line">			++cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (num == cand2) &#123;</span><br><span class="line">			++cnt2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt1 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(cand1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cnt2 &gt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(cand2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、在排序数组中查找数字-I【剑指Offer-05-easy】"><a href="#9、在排序数组中查找数字-I【剑指Offer-05-easy】" class="headerlink" title="9、在排序数组中查找数字 I【剑指Offer 05 | easy】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字 I【剑指Offer 05 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】统计一个数字在排序数组中出现的次数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序数组中的查找用二分法。进行两次二分，第一次查找右边界<code>right</code>，第二次查找左边界<code>left</code>，<code>right-left-1</code>的值即为次数。</p>
<p>优化方法：第一次找到 <code>target</code> 的右边界，第二次找到<code> target-1</code> 的右边界，两数相减即为次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(nums, target) - <span class="built_in">helper</span>(nums, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、二维数组中的查找【剑指Offer-04-medium】"><a href="#10、二维数组中的查找【剑指Offer-04-medium】" class="headerlink" title="10、二维数组中的查找【剑指Offer 04 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找【剑指Offer 04 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line">示例:现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; n &lt;&#x3D; 1000，0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>根据数组的特点，指定两个指针 <code>i</code> 和<code>j</code>，初始时<code>i</code>指向最后一行，<code>j</code>指向第一列。比较当前值和<code>target</code>的大小，如果<code>matrix[i][j]</code>大于<code>target</code>，说明<code>matrix[i][j]</code>所在的行中所有的值都大于<code>target</code>，因此<code> i--</code>，即向上一行；如果<code>matrix[i][j]</code>小于<code>target</code>，说明<code>matrix[i][j]</code>所在的列中当前值以上的所有值都小于<code>target</code>，因此<code> j++</code>，即向右一行。时间复杂度<code>O(M+N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、0～n-1中缺失的数字【剑指Offer-53-2-easy】"><a href="#11、0～n-1中缺失的数字【剑指Offer-53-2-easy】" class="headerlink" title="11、0～n-1中缺失的数字【剑指Offer 53-2 | easy】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字【剑指Offer 53-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。比较<code>nums[mid]</code> 和 索引 <code>mid</code> 之间是否对应，如果相等，则在右半部分中查找；否则在左半部分查找。时间复杂度<code>O(logN)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、把数组排成最小的数【剑指Offer-45-medium】"><a href="#12、把数组排成最小的数【剑指Offer-45-medium】" class="headerlink" title="12、把数组排成最小的数【剑指Offer 45 | medium】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数【剑指Offer 45 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br><span class="line"> </span><br><span class="line">提示:0 &lt; nums.length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>排序数组中的搜索：二分法。本质上是一个排序问题，设数组 nums 中任意两数字的字符串为<code>x</code>和<code>y</code>，则规定排序判断规则为：</p>
<p>若拼接字符串 <code>x + y &gt; y + x</code>，则 <code>x</code> “大于” <code>y</code> ；反之，若<code>x + y &lt; y + x</code>，则 <code>x</code> “小于” <code>y</code> ；<code>x</code> “小于” <code>y</code> 代表：排序完成后，数组中 <code>x</code> 应在 <code>y</code> 左边；“大于” 则反之。如：<code>x = &quot;30&quot;, y = &quot;3&quot;, x + y = &quot;303&quot; &lt; y + x = &quot;330&quot;</code>，所以 <code>x</code> 应该放在 <code>y</code> 的左侧。利用快排完成排序，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右到左找到第一个满足 x + y &lt; y + x 的j</span></span><br><span class="line">		<span class="keyword">while</span> ((str[j] + str[left] &gt;= str[left] + str[j]) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 从左到右找到第一个满足 x + y &gt; y + x 的i</span></span><br><span class="line">		<span class="keyword">while</span> ((str[i] + str[left] &lt;= str[left] + str[i]) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(str[i], str[j]);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(str[i], str[left]);</span><br><span class="line">	<span class="built_in">quickSort</span>(str, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(str, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">		str.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quickSort</span>(str, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	string result;</span><br><span class="line">	<span class="keyword">for</span> (string s : str) &#123;</span><br><span class="line">		result.<span class="built_in">append</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、数组中的逆序对【剑指Offer-51-hard】"><a href="#13、数组中的逆序对【剑指Offer-51-hard】" class="headerlink" title="13、数组中的逆序对【剑指Offer 51 | hard】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对【剑指Offer 51 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>归并排序和逆序对息息相关。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210501202136.png"></p>
<p>时间复杂度 <code>O(NlogN) </code>，空间复杂度 <code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">merge</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">merge</span>(left, mid, nums);</span><br><span class="line">            <span class="built_in">merge</span>(mid + <span class="number">1</span>, right, nums);</span><br><span class="line">            <span class="built_in">mergeSort</span>(left, mid, right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> 	</span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">((right - left + <span class="number">1</span>), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 把右边剩余的数移入数组</span></span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; tmp.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">            nums[index + left] = tmp[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="14、寻找第K大-牛客网"><a href="#14、寻找第K大-牛客网" class="headerlink" title="14、寻找第K大 | 牛客网"></a>14、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&&tqId=38572&rp=1&ru=/ta/job-code-high-week&qru=/ta/job-code-high-week/question-ranking">寻找第K大 | 牛客网</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。</span><br><span class="line">给定一个整数数组a,同时给定它的大小n和要找的K(1&lt;&#x3D;K&lt;&#x3D;n)，请返回第K大的数(包括重复的元素，不用去重)，保证答案存在。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：[1,3,5,2,2],5,3</span><br><span class="line">返回值：2</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：[10,10,9,9,8,7,5,6,4,3,4,2],12,3</span><br><span class="line">返回值：9</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>利用快排的思想，快排一趟之后所有比基准元素大的值都在其右边，所有比基准元素小的值都在其左边，如果此时基准元素刚好是第<code>k</code>大，则直接返回；否则递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">int</span> key = nums[left];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j &amp;&amp; nums[j] &gt;= key)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j &amp;&amp; nums[i] &lt;= key)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[left]);</span><br><span class="line">    <span class="comment">// 一趟排序之后，所有比基准数大的数都在i的右边，比基准数小的数都在i的左边</span></span><br><span class="line">    <span class="keyword">if</span>(n - j == K)&#123;  <span class="comment">// n - j = K 则说明此时刚好是第 K 大，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n - j &lt; K) &#123;  <span class="comment">// n - j &lt; K则说明在左半部分查找</span></span><br><span class="line">        res = <span class="built_in">quickSort</span>(nums, left, j - <span class="number">1</span>, n, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n - j &gt; K)&#123;  <span class="comment">// n - j &gt; K则说明在右半部分查找</span></span><br><span class="line">        res = <span class="built_in">quickSort</span>(nums, j + <span class="number">1</span>, right, n, K);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, n, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、最长无重复子数组"><a href="#15、最长无重复子数组" class="headerlink" title="15、最长无重复子数组"></a>15、最长无重复子数组</h5><p><strong>【解法】</strong>哈希表记录每个元素是否被访问过，双指针用作滑动窗口，如果窗口中的元素不重复，则计算长度，运行时记录最大长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> arr.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= j &amp;&amp; j &lt; arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unmap[arr[j]]) &#123;		</span><br><span class="line">			<span class="keyword">while</span> (i &lt;= j &amp;&amp; arr[i] != arr[j]) &#123;</span><br><span class="line">				unmap[arr[i]] = <span class="number">0</span>;</span><br><span class="line">				++i;				</span><br><span class="line">			&#125;</span><br><span class="line">			++i;   <span class="comment">// 此时i刚好和j指向重复的数值，即arr[i] = arr[j]，需要再往后移一个</span></span><br><span class="line">			unmap[arr[j]] = <span class="number">0</span>;  <span class="comment">// 重复的数值标记为没被访问过</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">// 元素没被访问过，则置1, j 后移，记录后移前的长度</span></span><br><span class="line">			unmap[arr[j]] = <span class="number">1</span>;</span><br><span class="line">			++j;</span><br><span class="line">			result = <span class="built_in">max</span>(result, j - i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、合并两个有序数组【LeetCode-88-easy】"><a href="#16、合并两个有序数组【LeetCode-88-easy】" class="headerlink" title="16、合并两个有序数组【LeetCode 88 | easy】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">合并两个有序数组【LeetCode 88 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>两个数组已经有序，因此从最后一个元素开始往前遍历，边遍历边比较，将<code>nums2</code>中的元素插入到<code>nums1</code>中的正确位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums2[j] &gt; nums1[i]) &#123;</span><br><span class="line">			nums1[k--] = nums2[j--];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			nums1[k--] = nums1[i--];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 最后只要考虑nums2中的元素是否有剩余，有的话直接插入到nums1中</span></span><br><span class="line">	<span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		nums1[k--] = nums2[j--];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、加一【LeetCode-66-easy】"><a href="#17、加一【LeetCode-66-easy】" class="headerlink" title="17、加一【LeetCode 66 | easy】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">加一【LeetCode 66 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br><span class="line">示例 1：</span><br><span class="line">输入：digits &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br><span class="line">    </span><br><span class="line">示例 2：</span><br><span class="line">输入：digits &#x3D; [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>先计算数组最后一个元素加1，然后从后往前开始遍历，用<code>flag</code>来记录各个元素加上进位之后是否大于等于10，遍历到第一个元素为止，然后单独计算<code>digits[0]</code>加上<code>flag</code>是否大于等于10。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">    digits[len - <span class="number">1</span>] += <span class="number">1</span>;	</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        digits[i] += flag;</span><br><span class="line">        flag = digits[i] / <span class="number">10</span>;</span><br><span class="line">        digits[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    digits[<span class="number">0</span>] += flag;</span><br><span class="line">    <span class="keyword">if</span> (digits[<span class="number">0</span>] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        digits.<span class="built_in">insert</span>(digits.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、杨辉三角【LeetCode-118-easy】"><a href="#18、杨辉三角【LeetCode-118-easy】" class="headerlink" title="18、杨辉三角【LeetCode 118 | easy】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">杨辉三角【LeetCode 118 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。</span><br><span class="line">示例:</span><br><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210613172315.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numRows; ++i) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(i, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 每行第一个和最后一个元素为1</span></span><br><span class="line">        tmp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        tmp[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">// i是从1开始的，res的下标是从0开始的，所以是i-2</span></span><br><span class="line">            tmp[j] = res[i - <span class="number">2</span>][j - <span class="number">1</span>] + res[i - <span class="number">2</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19、第三大的数【LeetCode-414-easy】"><a href="#19、第三大的数【LeetCode-414-easy】" class="headerlink" title="19、第三大的数【LeetCode 414 | easy】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/third-maximum-number/">第三大的数【LeetCode 414 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[3, 2, 1]</span><br><span class="line">输出：1</span><br><span class="line">解释：第三大的数是 1 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[1, 2]</span><br><span class="line">输出：2</span><br><span class="line">解释：第三大的数不存在, 所以返回最大的数 2 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>用三个数记录前三大的数，在遍历数组的过程中更新这三个数的值，最后分情况讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 用三个数记录最大的三个值</span></span><br><span class="line">	<span class="keyword">int</span> max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN, minNum = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		minNum = <span class="built_in">min</span>(minNum, nums[i]);</span><br><span class="line">		<span class="keyword">if</span> (max1 &lt; nums[i]) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = max1;</span><br><span class="line">			max1 = nums[i];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max2 &lt; nums[i] &amp;&amp; nums[i] != max1) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = nums[i];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (max3 &lt; nums[i] &amp;&amp; nums[i] != max2 &amp;&amp; nums[i] != max1) &#123;</span><br><span class="line">			max3 = nums[i];</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果max3 == INT_MIN，则表示不足三个最大值或第三大值刚好是INT_MIN</span></span><br><span class="line">	<span class="keyword">if</span> (max3 == INT_MIN) &#123;</span><br><span class="line">		<span class="comment">// 如果第三大的值刚好是INT_MIN，并且</span></span><br><span class="line">		<span class="keyword">if</span> (minNum == max3 &amp;&amp; max2 != max3) &#123;</span><br><span class="line">			<span class="keyword">return</span> max3;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">max</span>(max1, max2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 存在第三大的值则返回</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> max3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20、丢失的数字【LeetCode-268-easy】"><a href="#20、丢失的数字【LeetCode-268-easy】" class="headerlink" title="20、丢失的数字【LeetCode 268 | easy】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">丢失的数字【LeetCode 268 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>先排序后遍历。</p>
<p>也可以使用哈希表保存数组中的数，第二次遍历<code>[0,n]</code>，如果没在哈希表中出现，则这个数就是丢失的数字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、存在重复元素-II-【LeetCode-219-easy】"><a href="#21、存在重复元素-II-【LeetCode-219-easy】" class="headerlink" title="21、存在重复元素 II 【LeetCode 219 | easy】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate-ii/">存在重复元素 II 【LeetCode 219 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] &#x3D; nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>线性搜索会超时。采用哈希表的方法，维护一个大小为k的哈希表。</p>
<p>遍历数组，对于每个元素做以下操作：</p>
<ul>
<li>在散列表中搜索当前元素，如果找到了就返回 true。</li>
<li>在散列表中插入当前元素。</li>
<li>如果当前散列表的大小超过了 k， 删除散列表中最旧的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="comment">// 判断元素是否存在过，如果key存在，count函数返回1，否则返回0</span></span><br><span class="line">		<span class="keyword">if</span> (unmap.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		unmap[nums[i]] = i;</span><br><span class="line">		<span class="keyword">if</span> (unmap.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">			unmap.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、两数之和-II-输入有序数组【LeetCode-167-easy】"><a href="#22、两数之和-II-输入有序数组【LeetCode-167-easy】" class="headerlink" title="22、两数之和 II - 输入有序数组【LeetCode 167 | easy】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组【LeetCode 167 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</span><br><span class="line">函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;&#x3D; answer[0] &lt; answer[1] &lt;&#x3D; numbers.length 。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：numbers &#x3D; [2,3,4], target &#x3D; 6</span><br><span class="line">输出：[1,3]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：numbers &#x3D; [-1,0], target &#x3D; -1</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>方法1，利用哈希表保存出现的值和索引对，如果<code>target-nums[i]</code>存在的话，则将两数的索引保存。时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unmap[target - numbers[i]]) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(unmap[target - numbers[i]]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        unmap[numbers[i]] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>：利用数组元素的有序性，进行二分查找。时间复杂度：<code>O(nlogn)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> low = i + <span class="number">1</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123; i + <span class="number">1</span>, mid + <span class="number">1</span> &#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23、螺旋矩阵【LeetCode-54-medium】"><a href="#23、螺旋矩阵【LeetCode-54-medium】" class="headerlink" title="23、螺旋矩阵【LeetCode 54 | medium】"></a>23、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">螺旋矩阵【LeetCode 54 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614121800.png"></p>
<p><strong>【解法】</strong>按层模拟。可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p>
<p>定义矩阵的第<code>k</code>层是到最近边界距离为<code>k</code>的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[1, 1, 1, 1, 1, 1, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 2, 3, 3, 3, 2, 1],</span><br><span class="line"> [1, 2, 2, 2, 2, 2, 1],</span><br><span class="line"> [1, 1, 1, 1, 1, 1, 1]]</span><br></pre></td></tr></table></figure>

<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于<code>(top, left)</code>，右下角位于<code>(bottom, right)</code>，按照如下顺序遍历当前层的元素。</p>
<ul>
<li>从左到右遍历上侧元素，依次为<code>(top,left) </code>到 <code>(top, right)</code>。</li>
<li>从上到下遍历右侧元素，依次为<code>(top+1, right)</code> 到<code>(bottom, right)</code>。</li>
<li>如果<code>left</code> &lt; <code>right</code>且 <code>top&lt;bottom</code>，则从右到左遍历下侧元素，依次为<code>(bottom, right−1)</code> 到 <code>(bottom, left+1)</code>，以及从下到上遍历左侧元素，依次为<code>(bottom, left)</code>到<code>(top+1,left)</code>。</li>
</ul>
<p>遍历完当前层的元素之后，将<code>left</code>和 <code>top</code>分别增加 1，将<code>right</code> 和<code>bottom</code> 分别减少 1，进入下一层继续遍历，直到遍历完所有元素为止。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614123344.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = cols - <span class="number">1</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; --i) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		++left;</span><br><span class="line">		--right;</span><br><span class="line">		++top;</span><br><span class="line">		--bottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="24、螺旋矩阵-II【LeetCode-59-medium】"><a href="#24、螺旋矩阵-II【LeetCode-59-medium】" class="headerlink" title="24、螺旋矩阵 II【LeetCode 59 | medium】"></a>24、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix-ii/">螺旋矩阵 II【LeetCode 59 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614161324.png"></p>
<p><strong>【解法】</strong>和上一题一模一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">			res[top][i] = k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i) &#123;</span><br><span class="line">			res[i][right] = k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">				res[bottom][i] = k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; --i) &#123;</span><br><span class="line">				res[i][left] = k++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		++left;</span><br><span class="line">		--right;</span><br><span class="line">		++top;</span><br><span class="line">		--bottom;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25、插入区间【LeetCode-57-medium】"><a href="#25、插入区间【LeetCode-57-medium】" class="headerlink" title="25、插入区间【LeetCode 57 | medium】"></a>25、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-interval/">插入区间【LeetCode 57 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</span><br><span class="line">在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：intervals &#x3D; [], newInterval &#x3D; [5,7]</span><br><span class="line">输出：[[5,7]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/7C9F7A0D27059D8B39B6A4FB6D736E53.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="keyword">int</span> left = newInterval[<span class="number">0</span>], right = newInterval[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// [left,right]和[x,y]完全分离</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt; intervals[i][<span class="number">1</span>] || right &lt; intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// [left,right]完全包含在[x,y]中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (left &gt;= intervals[i][<span class="number">0</span>] &amp;&amp; right &lt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">			left = intervals[i][<span class="number">0</span>];</span><br><span class="line">			right = intervals[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// right包含在[x,y]中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (right &gt;= intervals[i][<span class="number">0</span>] &amp;&amp; right &lt; intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">			right = intervals[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// left包含在[x,y]中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (left &gt; intervals[i][<span class="number">0</span>] &amp;&amp; left &lt;= intervals[i][<span class="number">1</span>]) &#123;</span><br><span class="line">			left = intervals[i][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res.<span class="built_in">push_back</span>(&#123; left,right &#125;);</span><br><span class="line">	<span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());  <span class="comment">// 保持区间的顺序</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【更简洁的写法】</strong></p>
<p>待插入区间<code>S = [left,right]</code>，当 遍历到区间<code>[li,ri]</code>时：</p>
<ul>
<li>如果 <code>ri &lt; left</code>，说明<code>[li,ri]</code>与 <code>S</code> 不重叠并且在其左侧， 可以直接将<code>[li,ri]</code>加入答案；</li>
<li>如果<code>li &gt; right</code>，说明<code>[li,ri]</code>与 <code>S</code>不重叠并且在其右侧， 可以直接将<code>[li,ri]</code>加入答案；</li>
<li>如果上面两种情况均不满足，说明<code>[li,ri]</code>与 <code>S</code>重叠，无需将<code>[li,ri]</code>加入答案。此时， 需要将 <code>S</code>与<code>[li,ri]</code>合并，即将 <code>S</code> 更新为其与<code>[li,ri]</code>的并集。</li>
</ul>
<p>那么应当在什么时候将区间<code>S</code>加入答案呢？</p>
<p>由于需要保证答案也是按照左端点排序的，因此当 遇到第一个满足 <code>li &gt; right</code>的区间时，说明以后遍历到的区间不会与 <code>S</code> 重叠，并且它们左端点一定会大于 <code>S</code> 的左端点。此时 就可以将 <code>S</code> 加入答案。特别地，如果不存在这样的区间， 需要在遍历结束后，将 <code>S</code> 加入答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">	<span class="keyword">int</span> left = newInterval[<span class="number">0</span>], right = newInterval[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">bool</span> placed = <span class="literal">false</span>;   <span class="comment">// place标记何时插入待插入区间</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; interval: intervals) &#123;</span><br><span class="line">		<span class="comment">// 当前区间在插入区间的右侧且无交集，此时将待插入区间存入结果中</span></span><br><span class="line">		<span class="keyword">if</span> (right &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">				res.<span class="built_in">push_back</span>(&#123; left,right &#125;);</span><br><span class="line">				placed = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res.<span class="built_in">push_back</span>(interval);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前区间在插入区间的左侧且无交集</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (left &gt; interval[<span class="number">1</span>]) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(interval);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当前区间与插入区间有交集，计算它们的并集</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			left = <span class="built_in">min</span>(interval[<span class="number">0</span>], left);</span><br><span class="line">			right = <span class="built_in">max</span>(interval[<span class="number">1</span>], right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时待插入区间是最右边的区间</span></span><br><span class="line">	<span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">		res.<span class="built_in">push_back</span>(&#123; left,right &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、搜索二维矩阵【LeetCode-74-medium】"><a href="#26、搜索二维矩阵【LeetCode-74-medium】" class="headerlink" title="26、搜索二维矩阵【LeetCode 74 | medium】"></a>26、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">搜索二维矩阵【LeetCode 74 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</span><br><span class="line">每行中的整数从左到右按升序排列。</span><br><span class="line">每行的第一个整数大于前一行的最后一个整数。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614203734.png"></p>
<p><strong>【解法】</strong>两次二分查找。由于每行的第一个元素大于前一行的最后一个元素，且每行元素是升序的，所以每行的第一个元素大于前一行的第一个元素，因此矩阵第一列的元素是升序的。可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。</p>
<ol>
<li>第一次二分：从第 0 列中的「所有行」开始找，找到合适的行 <code>row</code></li>
<li>第二次二分：从 <code>row</code> 中「所有列」开始找，找到合适的列 <code>col</code></li>
</ol>
<p>时间复杂度：<code>O(logm+logn)</code>，空间复杂度：<code>O(1)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 第一次二分：定位到所在行</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = m - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> row = right;</span><br><span class="line">	<span class="keyword">if</span> (matrix[row][<span class="number">0</span>] == target) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (matrix[row][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二次二分：定位到具体数字</span></span><br><span class="line">	left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (matrix[row][mid] &lt;= target) &#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> col = right;</span><br><span class="line">	<span class="keyword">return</span> matrix[row][col] == target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>根据题意已知，二维数组从左往右递增，从上往下递增，所以得出以下结论：</p>
<p>某列的某个数字，该数之上的数字，都比其小；某行的某个数字，该数右侧的数字，都比其大；</p>
<ul>
<li>以二维数组左下角为原点，开始比较</li>
<li>若当前数字大于了查找数，查找往上移一位</li>
<li>若当前数字小于了查找数，查找往右移一位</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="27、删除有序数组中的重复项【LeetCode-26-easy】"><a href="#27、删除有序数组中的重复项【LeetCode-26-easy】" class="headerlink" title="27、删除有序数组中的重复项【LeetCode 26 | easy】"></a>27、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项【LeetCode 26 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,2]</span><br><span class="line">输出：2, nums &#x3D; [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums &#x3D; [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。定义两个指针<code>fast</code>和<code>slow</code>分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。</p>
<p>假设数组<code>nums</code>的长度为 <code>n</code>。将快指针<code>fast</code>依次遍历从 1 到 <code>n-1</code>的每个位置，对于每个位置，如果 <code>nums[fast] = nums[fast−1]</code>，说明<code>nums[fast]</code>和之前的元素都不同，因此将<code>nums[fast]</code>的值复制到 <code>nums[slow]</code>，然后将<code>slow</code>的值加 1，即指向下一个位置。</p>
<p>遍历结束之后，从<code>nums[0]</code>到<code>nums[slow−1]</code>的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为<code>slow</code>，返回<code>slow</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> slow = <span class="number">1</span>, fast = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[fast - <span class="number">1</span>] != nums[fast]) &#123;</span><br><span class="line">			nums[slow] = nums[fast];</span><br><span class="line">			++slow;</span><br><span class="line">		&#125;</span><br><span class="line">		++fast;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="28、删除有序数组中的重复项-II-【LeetCode-80-medium】"><a href="#28、删除有序数组中的重复项-II-【LeetCode-80-medium】" class="headerlink" title="28、删除有序数组中的重复项 II 【LeetCode 80 | medium】"></a>28、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除有序数组中的重复项 II 【LeetCode 80 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums &#x3D; [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums &#x3D; [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>双指针。因为给定数组是有序的，所以相同元素必然连续。遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，定义两个指针<code>slow</code>和<code>fast</code>分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即<code>nums[fast]</code>表示待检查的第一个元素，<code>nums[slow−1]</code>为上一个应该被保留的元素所移动到的指定位置。</p>
<p>因为本题要求相同元素最多出现两次而非一次，所以需要检查上上个应该被保留的元素<code>nums[slow−2]</code>是否和当前待检查元素<code>nums[fast]</code>相同。当且仅当<code>nums[slow−2]=nums[fast]</code>时，当前待检查元素<code>nums[fast]</code>不应该被保留（因为此时必然有<code>nums[slow−2]=nums[slow−1]=nums[fast]</code>）。最后，<code>slow</code>即为处理好的数组的长度。</p>
<p>特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，无需进行任何处理，对于长度超过 2 的数组，直接将双指针的初始值设为 2 即可。</p>
<p>和上一题一模一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123; <span class="comment">// 特殊判断，如果nums长度小于2，直接输出长度n即可</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>; <span class="comment">// 因为上面已经做过特殊判别，所以这里快慢指针从2开始</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123; <span class="comment">// 因为题目要求最多两个数相同，所以这么判断</span></span><br><span class="line">            <span class="comment">// 如果nums[slow - 2] == nums[fast]，代表已经有两个数相等，此时nums[fast]</span></span><br><span class="line">            <span class="comment">// 对应的数值不能放进结果之中。反之，如果nums[slow - 2] != nums[fast]，</span></span><br><span class="line">            <span class="comment">// 那么nums[fast]可以放进nums[slow]中，并且slow++，记录结果的长度。</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++; <span class="comment">// 不管怎么样，快指针都是要向前遍历各个元素的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow; <span class="comment">// 返回结果的长度，即slow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【更简化的写法】</strong>扩展到<code>k</code>，只要将<code>if (i &lt; 2 || nums[i - 2] &lt; num)</code>改成<code>if (i &lt; k || nums[i - k] &lt; num)</code>就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 左指针初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123; <span class="comment">// num当右指针</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">2</span> || nums[i - <span class="number">2</span>] &lt; num) &#123; <span class="comment">// i &lt; 2是特殊判断，nums[i - 2] &lt; num</span></span><br><span class="line">			<span class="comment">// 是因为题目要求相同元素不能超过两个。之所以可以用小于号判断，是因为数组是有序的</span></span><br><span class="line">			nums[i] = num; <span class="comment">// 相当于上面解法的nums[slow] = nums[fast];</span></span><br><span class="line">			i++;           <span class="comment">// 相当于上面解法的slow++;，即左指针移动</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i; <span class="comment">// 输出长度，即相当于上面题解的slow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="29、最长连续序列【LeetCode-128-medium】"><a href="#29、最长连续序列【LeetCode-128-medium】" class="headerlink" title="29、最长连续序列【LeetCode 128 | medium】"></a>29、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列【LeetCode 128 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>哈希表+枚举。考虑枚举数组中的每个数 <code>x</code>，考虑以其为起点，不断尝试匹配<code>x+1,x+2,⋯ </code>是否存在，假设最长匹配到了<code>x+y</code>，那么以<code>x</code>为起点的最长连续序列即为<code>x,x+1,x+2,⋯,x+y</code>，其长度为<code>y+1</code>，不断枚举并更新答案即可。</p>
<p>跳过不必要的枚举：仔细分析这个过程，发现其中执行了很多不必要的枚举，如果已知有一个<code>x,x+1,x+2,⋯,x+y </code>的连续序列，而却重新从<code>x+1，x+2</code>或者是<code>x+y</code>处开始尝试匹配，那么得到的结果肯定不会优于枚举 <code>x</code>为起点的答案，因此在外层循环的时候碰到这种情况跳过即可。</p>
<p>由于要枚举的数<code>x</code>一定是在数组中不存在前驱数<code>x-1</code>的，不然会产生重复的匹配，因此每次在哈希表中检查是否存在<code>x-1</code>即能判断是否需要跳过了。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	unordered_set&lt;<span class="keyword">int</span>&gt; unset;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		unset.<span class="built_in">insert</span>(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> resLen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; num : unset) &#123;</span><br><span class="line">		<span class="comment">// 如果前一个数不存在，则开始新一轮计算</span></span><br><span class="line">		<span class="keyword">if</span> (!unset.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> curNum = num;</span><br><span class="line">			<span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果后一个数存在，则长度加1</span></span><br><span class="line">			<span class="keyword">while</span> (unset.<span class="built_in">count</span>(curNum + <span class="number">1</span>)) &#123;</span><br><span class="line">				curNum += <span class="number">1</span>;</span><br><span class="line">				curLen += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			resLen = <span class="built_in">max</span>(resLen, curLen);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="30、长度最小的子数组【LeetCode-209-medium】"><a href="#30、长度最小的子数组【LeetCode-209-medium】" class="headerlink" title="30、长度最小的子数组【LeetCode 209 | medium】"></a>30、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">长度最小的子数组【LeetCode 209 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个含有 n 个正整数的数组和一个正整数 target 。</span><br><span class="line">找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 4, nums &#x3D; [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：target &#x3D; 11, nums &#x3D; [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>滑动窗口。维护两个变量<code>i</code>和<code>j</code>分别表示滑动窗口的开始和结束位置，维护<code>sum</code>表示滑动窗口内的元素总和，当<code>sum &lt; target</code>时，则<code>j</code>右移；当<code>sum &gt;= target</code>时，<code>i</code>右移，并在移动过程中记录最小长度。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen1</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, minLen = INT_MAX, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		sum += nums[j];</span><br><span class="line">		<span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">			minLen = <span class="built_in">min</span>(minLen, j - i + <span class="number">1</span>);</span><br><span class="line">			sum -= nums[i];</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		++j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minLen == INT_MAX ? <span class="number">0</span> : minLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="31、矩阵置零【LeetCode-73-medium】"><a href="#31、矩阵置零【LeetCode-73-medium】" class="headerlink" title="31、矩阵置零【LeetCode 73 | medium】"></a>31、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-matrix-zeroes/">矩阵置零【LeetCode 73 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</span><br><span class="line">进阶：</span><br><span class="line">一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</span><br><span class="line">一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</span><br><span class="line">你能想出一个仅使用常量空间的解决方案吗？</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614210615.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例2：</span><br><span class="line">输入：matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210614210701.png"></p>
<p><strong>【解法】</strong>可以用矩阵的第一行和第一列作为两个标记数组，以达到 O(1)的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</p>
<p>首先预处理出两个标记变量，记录第一行和第一列原本是否包含0；接着使用其他行与列去处理第一行与第一列，然后反过来使用第一行与第一列去更新其他行与列，最后使用两个标记变量更新第一行与第一列即可。</p>
<p>时间复杂度：<code>O(mn)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> flag_col0 = <span class="literal">false</span>, flag_row0 = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 遍历第一列检查第一列是否有0，如果有的话就做标记</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">			flag_col0 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历第一行检查第一行是否有0，如果有的话就做标记</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">			flag_row0 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从第2行第2列开始遍历，如果存在0，则将对应的第1行和第1列的位置置0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">				matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从第2行第2列开始遍历，如果其对应的第1行和第1列的位置为0，则将该位置置0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果第一列存在0，则将第一列全部置为0</span></span><br><span class="line">	<span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">			matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果第一行存在0，则将第一行全部置为0</span></span><br><span class="line">	<span class="keyword">if</span> (flag_row0) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【优化！更简洁的写法】</strong>对上面的写法进一步优化，只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新， 需要从最后一行开始，倒序地处理矩阵元素，如果正序处理，那么如果<code>matrix[0][0]=0</code>的话，会先把第一行全部置为0，这样会影响后面的行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">int</span> flag_col0 = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="comment">// 检查第一列是否有0，如果有的话就做标记</span></span><br><span class="line">		<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">			flag_col0 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从第2行第2列开始遍历，如果存在0，则将对应的第1行和第1列的位置置0</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">				matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从第2行第2列开始遍历，如果其对应的第1行和第1列的位置为0，则将该位置置0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">				matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果第一列存在0，则第一列全置为0</span></span><br><span class="line">		<span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line">			matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="32、缺失的第一个正数【LeetCode-41-hard】"><a href="#32、缺失的第一个正数【LeetCode-41-hard】" class="headerlink" title="32、缺失的第一个正数【LeetCode 41 | hard】"></a>32、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数【LeetCode 41 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span><br><span class="line">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,0]</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [3,4,-1,1]</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>置换。将给定的数组「恢复」成下面的形式：如果数组中包含<code>x∈[1,N]</code>，那么恢复后，数组的第<code>x - 1</code>个元素为<code>x</code>，即将数值和索引进行对应。</p>
<p>对数组进行遍历，对于遍历到的数 <code>x</code>，如果它在<code>[1, N]</code>范围内，那么就将它交换到数组中的第<code>x−1</code>个位置（注意：数组下标从 0 开始）。在完成交换后，新的<code>nums[i]</code>可能还在<code>[1, N]</code>的范围内， 需要继续进行交换操作，直到 <code>x∈ [1,N]</code>。</p>
<p>上面的方法可能会陷入死循环。如果<code>nums[i]</code>恰好与<code>nums[x−1] </code>相等，那么就会无限交换下去。此时 有 <code>nums[i]=x=nums[x−1]</code>，说明 xx 已经出现在了正确的位置。因此 可以跳出循环，开始遍历下一个数。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="comment">// 对于存在[1，n]之间的数，则将该数交换到和索引相对应的位置</span></span><br><span class="line">	<span class="comment">// 因为索引从0开始，正整数从1开始，所以对应关系需要减1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[nums[i] - <span class="number">1</span>], nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历数组，如果当前元素和索引不对应，则返回</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] != i+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="33、寻找峰值【LeetCode-162-medium】"><a href="#33、寻找峰值【LeetCode-162-medium】" class="headerlink" title="33、寻找峰值【LeetCode 162 | medium】"></a>33、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值【LeetCode 162 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】峰值元素是指其值大于左右相邻值的元素。给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</span><br><span class="line">你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：3 是峰值元素，你的函数应该返回其索引 2。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,1,3,5,6,4]</span><br><span class="line">输出：1 或 5 </span><br><span class="line">解释：你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>线性扫描。从头开始遍历<code>nums</code>数组。每当 遇到数字<code>nums[i]</code>，只需要检查它是否大于下一个元素<code>nums[i+1]</code>即可判断<code>nums[i]</code>是否是峰值，因为峰值总是出现在升序序列中。分为三种情况：</p>
<ul>
<li><p>所有的数字以降序排列。这种情况下，第一个元素即为峰值。首先检查当前元素是否大于下个元素。第一个元素满足这一条件，因此被正确判断为峰值。此时，不需要继续向下判断，也就不会有需要判断 <code>nums[i]</code>和上一个元素<code>nums[i−1]</code>的大小的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615200759.png"></p>
</li>
<li><p>所有的数字以升序排列。这种情况下，一直比较<code>nums[i]</code>与<code>nums[i+1]</code>以判断<code>nums[i]</code>是否是峰值元素。没有元素符合这一条件，说明处于上坡而非峰值。于是，返回末尾元素作为峰值元素。在这种情况下，同样不需要比较<code>nums[i]</code>和上一个元素<code>nums[i−1]</code>，因为处于上坡是<code>nums[i]</code>不是峰值的充分条件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615200948.png"></p>
</li>
<li><p>峰值出现在中间某处。这种情况下，当遍历上升部分时，与情况 2 相同，没有元素满足<code>nums[i] &gt; nums[i + 1]</code>。不需要比较<code>nums[i]</code>和上一个元素<code>nums[i−1]</code>。当到达峰值元素时，<code>nums[i] &gt; nums[i + 1]</code>条件满足。此时，同样不需要比较<code>nums[i]</code>和上一个元素<code>nums[i−1]</code>。这是由于“遍历会到达第i个元素”本身就说明上一个元素（第<code>i- 1</code>个）不满足<code>nums[i]&gt;nums[i+1]</code>这一条件，也就说明<code>nums[i-1] &lt; nums[i]</code>。同样可以得到正确结果。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210615201046.png"></p>
<p>时间复杂度 :<code>O(n)</code>，空间复杂度 : <code>O(1)</code>。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>递归二分查找。</p>
<p>首先从数组<code>nums</code>中找到中间的元素<code>mid</code>。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将<code>nums[i]</code>与右侧比较判断)，则说明峰值会在本元素的左边。于是，将搜索空间缩小为<code>mid</code>的左边(包括其本身)，并在左侧子数组上重复上述过程。</p>
<p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将<code>nums[i]</code>与右侧比较判断)，则说明峰值会在本元素的右边。于是，将搜索空间缩小为<code>mid</code>的右边，并在右侧子数组上重复上述过程。不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p>
<p>时间复杂度 : <code>O(log2 n)</code>，空间复杂度：<code>O(log2 n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">search</span>(nums, left, mid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">search</span>(nums, mid + <span class="number">1</span>, right);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">search</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【【解法3】】</strong>迭代二分查找。时间复杂度 : <code>O(log2 n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="34、数组中重复的数字【剑指Offer-03-easy】【LeetCode-442-medium】"><a href="#34、数组中重复的数字【剑指Offer-03-easy】【LeetCode-442-medium】" class="headerlink" title="34、数组中重复的数字【剑指Offer 03 | easy】【LeetCode 442 | medium】"></a>34、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字【剑指Offer 03 | easy】【LeetCode 442 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】找出数组中重复的数字。</span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：2 &lt;&#x3D; n &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>哈希表，遍历数组，存放次数每个元素出现的次数。时间复杂度<code> O(N)</code>，空间复杂度 <code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unmap[num]) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;				</span><br><span class="line">        &#125;		</span><br><span class="line">        unmap[num] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>就地交换。注意所有数字都在<code> 0～n-1</code> 的范围内，即数组元素的索引和值是一对多的关系，因此可以建立索引和值的映射。第一次遇到数字<code>nums[i]</code>时，将其交换到索引<code>i</code>处；当第二次遇到数字<code>nums[i]</code>时，一定有<code>nums[nums[i]]=nums[i]</code>。时间复杂度<code> O(N)</code>，空间复杂度 <code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i) &#123; <span class="comment">// 如果值等于索引，则遍历下一个元素</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表索引nums[i]处和索引i处的元素值都为nums[i],即找到一组重复值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将值和索引对应</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【LeetCode 442】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</span><br><span class="line">找到所有出现两次的元素。你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</span><br><span class="line">示例：</span><br><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line">输出:</span><br><span class="line">[2,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] == i + <span class="number">1</span>) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">				ans[nums[i] - <span class="number">1</span>]++;</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ans[i]) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="35、汇总区间【LeetCode-228-medium】"><a href="#35、汇总区间【LeetCode-228-medium】" class="headerlink" title="35、汇总区间【LeetCode 228 | medium】"></a>35、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/summary-ranges/">汇总区间【LeetCode 228 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个无重复元素的有序整数数组 nums 。</span><br><span class="line">返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</span><br><span class="line">列表中的每个区间范围 [a,b] 应该按如下格式输出：</span><br><span class="line">&quot;a-&gt;b&quot; ，如果 a !&#x3D; b</span><br><span class="line">&quot;a&quot; ，如果 a &#x3D;&#x3D; b</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>从数组的位置 0 出发，向右遍历。每次遇到相邻元素之间的差值大于 1 时，就找到了一个区间。遍历完数组之后，就能得到一系列的区间的列表。</p>
<p>在遍历过程中，维护下标<code>low </code>和<code>high </code>分别记录区间的起点和终点，对于任何区间都有<code>low≤high</code>。当得到一个区间时，根据<code>low </code>和 <code>high </code>的值生成区间的字符串表示。</p>
<p>当 <code>low &lt; high</code> 时，区间的字符串表示为 <code>&quot;low→high&quot;</code>；</p>
<p>当 <code>low=high</code>时，区间的字符串表示为 <code>&quot;low&quot;</code>。</p>
<p>时间复杂度<code> O(N)</code>，空间复杂度 <code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; res;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">		<span class="keyword">int</span> low = i;</span><br><span class="line">		++i;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">		string tmp = <span class="built_in">to_string</span>(nums[low]);</span><br><span class="line">		<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">			tmp.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">			tmp.<span class="built_in">append</span>(<span class="built_in">to_string</span>(nums[high]));</span><br><span class="line">		&#125;</span><br><span class="line">		res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="36、三个数的最大乘积【LeetCode-628-easy】"><a href="#36、三个数的最大乘积【LeetCode-628-easy】" class="headerlink" title="36、三个数的最大乘积【LeetCode 628 | easy】"></a>36、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">三个数的最大乘积【LeetCode 628 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：24</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [-1,-2,-3]</span><br><span class="line">输出：-6</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。</p>
<p>如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</p>
<p>综上， 在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</p>
<p>时间复杂度：<code>O((n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 最小的和第二小的</span></span><br><span class="line">	<span class="keyword">int</span> min1 = INT_MAX, min2 = INT_MAX;</span><br><span class="line">	<span class="comment">// 最大的、第二大的和第三大的</span></span><br><span class="line">	<span class="keyword">int</span> max1 = INT_MIN, max2 = INT_MIN, max3 = INT_MIN;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; min1) &#123;</span><br><span class="line">			min2 = min1;</span><br><span class="line">			min1 = x;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; min2) &#123;</span><br><span class="line">			min2 = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; max1) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = max1;</span><br><span class="line">			max1 = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max2) &#123;</span><br><span class="line">			max3 = max2;</span><br><span class="line">			max2 = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; max3) &#123;</span><br><span class="line">			max3 = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(max1 * max2 * max3, min1 * min2 * max1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="37、子数组最大平均数-I【LeetCode-643-easy】"><a href="#37、子数组最大平均数-I【LeetCode-643-easy】" class="headerlink" title="37、子数组最大平均数 I【LeetCode 643 | easy】"></a>37、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">子数组最大平均数 I【LeetCode 643 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</span><br><span class="line">示例：</span><br><span class="line">输入：[1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>滑动窗口。维护一个长度为k的滑动窗口。时间复杂度：<code>O((n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		sum += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxSum = sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = k; j &lt; nums.<span class="built_in">size</span>(); ++i, ++j) &#123;			</span><br><span class="line">		sum = sum - nums[i] + nums[j];	</span><br><span class="line">		maxSum = <span class="built_in">max</span>(maxSum, sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span> * maxSum / k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="38、数组拆分-I【LeetCode-561-easy】"><a href="#38、数组拆分-I【LeetCode-561-easy】" class="headerlink" title="38、数组拆分 I【LeetCode 561 | easy】"></a>38、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">数组拆分 I【LeetCode 561 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。返回该 最大总和 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,4,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的分法（忽略元素顺序）为：</span><br><span class="line">1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) &#x3D; 1 + 3 &#x3D; 4</span><br><span class="line">所以最大总和为 4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [6,2,6,5,1,2]</span><br><span class="line">输出：9</span><br><span class="line">解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) &#x3D; 1 + 2 + 6 &#x3D; 9</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>贪心算法。由于每两个数， 只能选择当前小的一个进行累加。因此 猜想应该从第一个位置进行选择，然后隔一步选择下一个数。这样形成的序列的求和值最大。时间复杂度：<code>O((nlogn)</code>，空间复杂度：<code>O(logn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">		sum += nums[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h4><h5 id="1、替换空格【剑指Offer-05-easy】"><a href="#1、替换空格【剑指Offer-05-easy】" class="headerlink" title="1、替换空格【剑指Offer 05 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格【剑指Offer 05 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】遍历一遍字符串，记录字符串中的空格数量，将字符串扩容；扩容后从尾部开始遍历，如果i对应的字符是空格的话，就在j~j-2位置替换成”%20”。时间复杂度 O(N) ，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// i指向原字符串的最后一位</span></span><br><span class="line">    s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + <span class="number">2</span> * count);</span><br><span class="line">    <span class="comment">// j指向扩容后的字符串的最后一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>; --j, --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[j] = <span class="string">&#x27;%&#x27;</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、第一个只出现一次的字符【剑指Offer-50-easy】"><a href="#2、第一个只出现一次的字符【剑指Offer-50-easy】" class="headerlink" title="2、第一个只出现一次的字符【剑指Offer 50 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">第一个只出现一次的字符【剑指Offer 50 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</span><br><span class="line">示例:</span><br><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p>【解法】利用哈希表来记录字符是否重复出现，遍历字符串，若该字符在哈希表中出现过，对应的值为false，若该字符没出现过，则对应的值为true。第二次遍历字符串，如果在哈希表中对应的值为true，则该字符即为第一个只出现一次的字符。时间复杂度O(n)，空间复杂度O(∣Σ∣)，其中Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">        dic[c] = (dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>());    <span class="comment">//如果没找到，说明是第一次出现为true，如果是多次出现，则是false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic[c]) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：unordered_map::count()是C++中的内置方法，用于通过给定 key 对unordered_map中存在的元素数量进行计数，由于unordered_map不允许存储具有重复键的元素，因此count()函数本质上检查unordered_map中是否存在具有给定键的元素。如果Map中存在具有给定键的值，则此函数返回1，否则返回0。</p>
<p>通过unordered_map::find()来判断key是否存在，如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回unordered_map::end。</p>
<h5 id="3、连续子数组的最大和【剑指Offer-42-easy】"><a href="#3、连续子数组的最大和【剑指Offer-42-easy】" class="headerlink" title="3、连续子数组的最大和【剑指Offer 42 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和【剑指Offer 42 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</span><br><span class="line">要求时间复杂度为O(n)。</span><br><span class="line">示例1:</span><br><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br><span class="line"> </span><br><span class="line">提示：1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5，-100 &lt;&#x3D; arr[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】动态规划。状态转移方程：<br>$$<br>dp[i] = dp[i-1]+nums[i],   dp[i-1]&gt;0<br>$$</p>
<p>$$<br>dp[i]=nums[i],dp[i-1]&lt;=0<br>$$</p>
<p>时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        nums[i] += <span class="built_in">max</span>(<span class="number">0</span>, nums[i - <span class="number">1</span>]);</span><br><span class="line">        result = <span class="built_in">max</span>(result, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、翻转单词顺序【剑指Offer-58-1-easy】"><a href="#4、翻转单词顺序【剑指Offer-58-1-easy】" class="headerlink" title="4、翻转单词顺序【剑指Offer 58-1 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">翻转单词顺序【剑指Offer 58-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line"> </span><br><span class="line">说明：无空格字符构成一个单词。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>【解法】双指针。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个字符</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个空格</span></span><br><span class="line">        <span class="keyword">int</span> i = j;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加单词到结果，每个单词后面加上一个空格</span></span><br><span class="line">        result.<span class="built_in">append</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - i) + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">// 继续往前分割单词</span></span><br><span class="line">        j = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后的空格</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、左旋转字符串【剑指Offer58-2-easy】"><a href="#5、左旋转字符串【剑指Offer58-2-easy】" class="headerlink" title="5、左旋转字符串【剑指Offer58-2 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串【剑指Offer58-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】字符串截取。也可用求余的方法计算下标。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    string str1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, n);</span><br><span class="line">    string str2 = s.<span class="built_in">substr</span>(n, s.<span class="built_in">size</span>() - n);</span><br><span class="line">    result = str2 + str1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求余计算下标</span></span><br><span class="line">    <span class="comment">// string result;</span></span><br><span class="line">    <span class="comment">// for (int i = n; i &lt; n + s.length(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//     result += (s[i % s.length()]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、字符串的排列【剑指Offer-38-medium】"><a href="#6、字符串的排列【剑指Offer-38-medium】" class="headerlink" title="6、字符串的排列【剑指Offer 38 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">字符串的排列【剑指Offer 38 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span><br><span class="line">示例:</span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</span><br></pre></td></tr></table></figure>

<p>【解法】DFS+回溯。先固定一位，然后交换后两位。时间复杂度 O(N!N)： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，即复杂度为 O(N!)；字符串拼接操作 join() 使用 O(N) ；因此总体时间复杂度为 O(N!N) 。空间复杂度 O(N^2) ： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N) ；递归中辅助 Set 累计存储的字符数量最多为 N + (N-1) + … + 2 + 1 = (N+1)N/2，即占用 O(N^2)的额外空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> index, vector&lt;string&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 添加排列方案</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 重复，进行剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">find</span>(s[i]) != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[index]); <span class="comment">// 交换，将s[i]固定在第index位</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, index + <span class="number">1</span>, result); <span class="comment">// 开启固定第index+1位字符</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[index]); <span class="comment">// 恢复交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、把数字翻译成字符串【剑指Offer-46-medium】"><a href="#7、把数字翻译成字符串【剑指Offer-46-medium】" class="headerlink" title="7、把数字翻译成字符串【剑指Offer 46 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串【剑指Offer 46 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数字， 按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; num &lt; 231</span><br></pre></td></tr></table></figure>

<p>【解法】动态规划。状态转移方程：<br>$$<br>如果后两位能表示一个字符：dp[i]=dp[i-1]+dp[i-2]<br>$$</p>
<p>$$<br>如果后两位不能表示一个字符：dp[i]=dp[i-1]<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);  <span class="comment">// 保持下标一致</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 判断这两个字符能否符合要求，有两种情况：</span></span><br><span class="line">        <span class="comment">// 前一位字符为&#x27;1&#x27;，后一位字符能在&#x27;0&#x27;-&#x27;9&#x27;之间</span></span><br><span class="line">        <span class="comment">// 前一位字符为&#x27;2&#x27;，后一位字符只能在&#x27;0&#x27;-&#x27;5&#x27;之间</span></span><br><span class="line">        <span class="keyword">if</span> ((s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            || (s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、最长不含重复字符的子字符串【剑指Offer-48-medium】"><a href="#8、最长不含重复字符的子字符串【剑指Offer-48-medium】" class="headerlink" title="8、最长不含重复字符的子字符串【剑指Offer 48 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">最长不含重复字符的子字符串【剑指Offer 48 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"> </span><br><span class="line">提示：s.length &lt;&#x3D; 40000</span><br></pre></td></tr></table></figure>

<p>【解法】滑动窗口，通过left和right限定窗口的位置，确保窗口内的元素彼此不同。当窗口最右边的元素在窗口内存在了，则向右移动left直至排除掉重复的元素。used数组用来记录哪些字符已经被使用过了。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(<span class="number">256</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 若元素重复，则left一直向右移，直至该重复元素处</span></span><br><span class="line">        <span class="keyword">while</span> (used[s[right]]) &#123;</span><br><span class="line">            used[s[left]] = <span class="literal">false</span>;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, right - left + <span class="number">1</span>);</span><br><span class="line">        used[s[right]] = <span class="literal">true</span>;</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、把字符串转换成整数【剑指Offer-67-medium】"><a href="#9、把字符串转换成整数【剑指Offer-67-medium】" class="headerlink" title="9、把字符串转换成整数【剑指Offer 67 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数【剑指Offer 67 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span><br><span class="line">当 寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。</span><br><span class="line">说明：</span><br><span class="line">假设 的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">      尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">     </span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">     </span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<p>【解法】注意考虑各种情况。时间复杂度 O(N)，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 去掉开头的空格</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == str.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果全是空格，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;   <span class="comment">// flag标记正负数</span></span><br><span class="line">    <span class="keyword">if</span> (str[k] == <span class="string">&#x27;+&#x27;</span> || str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">214748364</span> || (result == <span class="number">214748364</span> &amp;&amp; tmp &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? result : (-result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、最长回文子串-【LeetCode-5-medium】"><a href="#10、最长回文子串-【LeetCode-5-medium】" class="headerlink" title="10、最长回文子串 【LeetCode 5 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串 【LeetCode 5 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个字符串 s，找到 s 中最长的回文子串。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 1000</span><br><span class="line">s 仅由数字和英文字母（大写和&#x2F;或小写）组成</span><br></pre></td></tr></table></figure>

<p>【解法】中心扩散法。分两种情况讨论。</p>
<p>（1）回文子串的长度是奇数。即遍历每一个字符<code>s[k]</code>，每次从当前字符<code>s[k]</code>开始向两边扩散，每次扩散则比较左右两边的字符是否相等，即比较<code>s[k-1]=s[k+1]</code>，相等则继续扩散，此时回文子串的长度是奇数。</p>
<p>（2）回文子串长度是偶数。即遍历每一个字符<code>s[k]</code>，从当前字符开始先比较当前字符<code>s[k]</code>和下一个字符<code>s[k+1]</code>是否相等，相等则从<code>k</code>和<code>k+1</code>位置向两边扩散。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; result;   <span class="comment">// 两个参数分别代表最大回文子串长度，以及该子串第一个字符的下标位置（方便后面使用substr()）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        i = k, j = k;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 是奇数的情况，从中心扩散</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.first &lt; (j - i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    result.first = j - i + <span class="number">1</span>;</span><br><span class="line">                    result.second = i;</span><br><span class="line">                &#125;               </span><br><span class="line">                --i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是偶数的情况</span></span><br><span class="line">        i = k, j = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result.first &lt; (j - i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    result.first = j - i + <span class="number">1</span>;</span><br><span class="line">                    result.second = i;</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(result.second, result.first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、最长公共子序列-【LeetCode-1143-medium】"><a href="#11、最长公共子序列-【LeetCode-1143-medium】" class="headerlink" title="11、最长公共子序列 【LeetCode 1143 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列 【LeetCode 1143 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回&quot;-1&quot;。目前给出的数据，仅仅会存在一个最长的公共子序列。</span><br><span class="line">示例1：</span><br><span class="line">输入：&quot;1A2C3D4B56&quot;,&quot;B1D23A456A&quot;</span><br><span class="line">返回值：&quot;123456&quot;</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：&quot;abc&quot;,&quot;def&quot;</span><br><span class="line">返回值：&quot;-1&quot;</span><br><span class="line"></span><br><span class="line">示例3：</span><br><span class="line">输入：&quot;abc&quot;,&quot;abc&quot;</span><br><span class="line">返回值：&quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>【解法】典型的二维动态规划问题。假设字符串<code>text1</code>和``text2<code>的长度分别为 </code>m<code>和</code>n<code>，创建 </code>m+1<code>行 </code>n+1<code>列的二维数组 </code>dp<code>，其中 </code>dp[i]][j]<code>表示</code>text1[0:i]<code>和</code>text2[0:j]`的最长公共子序列的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606121647.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606121629.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">			<span class="keyword">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 重复的子序列</span></span><br><span class="line">	string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = text1.<span class="built_in">size</span>(), j = text2.<span class="built_in">size</span>(); dp[i][j] &gt;= <span class="number">1</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">			result += text1[i - <span class="number">1</span>];</span><br><span class="line">			--i;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; result;</span><br><span class="line">	<span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、最长公共前缀-【LeetCode-14-easy】"><a href="#12、最长公共前缀-【LeetCode-14-easy】" class="headerlink" title="12、最长公共前缀 【LeetCode 14 | easy】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀 【LeetCode 14 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入：strs &#x3D; [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：strs &#x3D; [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; strs.length &lt;&#x3D; 200，0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200，strs[i] 仅由小写英文字母组成</span><br></pre></td></tr></table></figure>

<p>【解法】横向扫描。先比较两个字符串，找出公共前缀，然后再用这个公共前缀和下一个字符串进行比较，并更新公共前缀。全部比较完之后最后的公共前缀即为所求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606152909.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string prefix = strs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        prefix = <span class="built_in">prefixcal</span>(prefix, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (!prefix.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">prefixcal</span><span class="params">(string &amp;s1, string &amp;s2)</span> </span>&#123;</span><br><span class="line">    string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">min</span>(s1.<span class="built_in">size</span>(), s2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len &amp;&amp; s1[i] == s2[i]) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、链表"><a href="#四、链表" class="headerlink" title="四、链表"></a>四、链表</h4><h5 id="1、从尾到头打印链表【剑指Offer-06-easy】"><a href="#1、从尾到头打印链表【剑指Offer-06-easy】" class="headerlink" title="1、从尾到头打印链表【剑指Offer 06 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表【剑指Offer 06 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】利用栈后进先出的原则，遍历链表将每个节点的值存入栈中，出栈的顺序即为链表逆序。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        S.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(S.<span class="built_in">top</span>());</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、反转链表【剑指Offer-24-easy】"><a href="#2、反转链表【剑指Offer-24-easy】" class="headerlink" title="2、反转链表【剑指Offer 24 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表【剑指Offer 24 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br><span class="line">示例:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p>【解法】迭代。定义一个结点总是指向前驱，注意<code>ListNode* nex = head-&gt;next;</code>这句要放到<code>while</code>循环中。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;	</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ListNode* nex = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、合并两个排序的链表【剑指Offer-25-easy】"><a href="#3、合并两个排序的链表【剑指Offer-25-easy】" class="headerlink" title="3、合并两个排序的链表【剑指Offer 25 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表【剑指Offer 25 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br><span class="line">示例1：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】同时遍历两个链表，按递增顺序，如果最后某个链表有剩余，就将这个链表剩余部分接到新链表的最后。时间复杂度<code>O(M+N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* r = new_head;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            r-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    	r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">    	r-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">    	r-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、链表中倒数第k个节点【剑指Offer-22-easy】"><a href="#4、链表中倒数第k个节点【剑指Offer-22-easy】" class="headerlink" title="4、链表中倒数第k个节点【剑指Offer 22 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点【剑指Offer 22 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p>【解法】使用双指针，一开始<code>former</code>和<code>latter</code>同时指向<code>head</code>，然后<code>former</code>指针向前移动k步（即<code>former</code>和<code>latter</code>两个指针相差<code>k</code>个结点），然后两个指针再同时移动，知道<code>former</code>移动到链表结尾为空。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* former = head;</span><br><span class="line">    ListNode* latter = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!former) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        former = former-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (former) &#123;</span><br><span class="line">        latter = latter-&gt;next;</span><br><span class="line">        former = former-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> latter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、删除链表的节点【剑指Offer-18-easy】"><a href="#5、删除链表的节点【剑指Offer-18-easy】" class="headerlink" title="5、删除链表的节点【剑指Offer 18 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点【剑指Offer 18 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</span><br><span class="line">示例 1:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="line"> </span><br><span class="line">说明：题目保证链表中节点的值互不相同。若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。</span><br></pre></td></tr></table></figure>

<p>【解法】双指针，定义一个指向前驱结点的指针，遍历链表寻找要删除的结点，找到后利用<code>pre-&gt;next=p-&gt;next</code>将其删除。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">		<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* pre = head;</span><br><span class="line">	ListNode* p = head-&gt;next;</span><br><span class="line">	<span class="comment">// pre指向前驱，遍历链表寻找要删除的结点</span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;val != val) &#123;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p) &#123; <span class="comment">// 此时找到了要删除的结点</span></span><br><span class="line">		pre-&gt;next = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、两个链表的第一个公共节点【剑指Offer-52-easy】"><a href="#6、两个链表的第一个公共节点【剑指Offer-52-easy】" class="headerlink" title="6、两个链表的第一个公共节点【剑指Offer 52 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点【剑指Offer 52 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个链表，找出它们的第一个公共节点。</span><br><span class="line">如果两个链表没有交点，返回 null；在返回结果后，两个链表仍须保持原有的结构；可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br><span class="line">如下面的两个链表：在节点 c1 开始相交。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424124955.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125056.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125126.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125151.png"></p>
<p>【解法】使用两个指针 <code>A</code>，<code>B</code>分别指向两个链表 <code>headA</code>，<code>headB</code> 的头结点，然后同时分别逐结点遍历，当 <code>A</code>到达链表 <code>headA</code> 的末尾时，重新定位到链表<code> headB</code> 的头结点；当 <code>B</code>到达链表<code> headB</code> 的末尾时，重新定位到链表 <code>headA</code> 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。时间复杂度<code>O(M+N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* A = headA;</span><br><span class="line">	ListNode* B = headB;</span><br><span class="line">	<span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">		A = (A != <span class="literal">nullptr</span>) ? A-&gt;next : headB;</span><br><span class="line">		B = (B != <span class="literal">nullptr</span>) ? B-&gt;next : headA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、复杂链表的复制【剑指Offer-35-medium】"><a href="#7、复杂链表的复制【剑指Offer-35-medium】" class="headerlink" title="7、复杂链表的复制【剑指Offer 35 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制【剑指Offer 35 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span><br><span class="line">提示：-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000</span><br><span class="line">Node.random 为空（null）或指向链表中的节点。</span><br><span class="line">节点数目不超过 1000 。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134207.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134221.png"></p>
<p>【解法】遍历链表，每次对应生成一个新结点，用哈希表存放新结点和旧结点之间的对应关系。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 哈希表存放新结点和旧结点之间的对应关系</span></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; unmap;</span><br><span class="line">        Node* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            unmap[p] = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            unmap[p]-&gt;next = unmap[p-&gt;next];</span><br><span class="line">            unmap[p]-&gt;random = unmap[p-&gt;random];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unmap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8、二叉搜索树与双向链表【剑指Offer-36-medium】"><a href="#8、二叉搜索树与双向链表【剑指Offer-36-medium】" class="headerlink" title="8、二叉搜索树与双向链表【剑指Offer 36 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表【剑指Offer 36 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。为了让您更好地理解问题，以下面的二叉搜索树为例：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134404.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</span><br><span class="line">下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</span><br><span class="line">特别地， 希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134443.png"></p>
<p>【解法】<code>DFS</code>中序遍历保证结点的值从小到大排序。设置一个前驱结点，在遍历的过程中，保证前驱结点和当前结点相互指向。时间复杂度<code>O(N)</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = <span class="literal">NULL</span>;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, Node* _left, Node* _right) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 找到第一个结点，head指向它</span></span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 不是第一个结点，则前驱结点和当前结点相互指向</span></span><br><span class="line">            pre-&gt;right = cur;   </span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="9、两数相加【LeetCode-2-medium】"><a href="#9、两数相加【LeetCode-2-medium】" class="headerlink" title="9、两数相加【LeetCode 2 | medium】"></a><strong>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加【LeetCode 2 | medium】</a></strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。</span><br><span class="line">请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p>【解法】每次相加考虑是否有进位，如果有进位那么就加上1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	ListNode* p = l1;</span><br><span class="line">	ListNode* q = l2;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* r = new_head;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = (p == <span class="literal">nullptr</span>) ? <span class="number">0</span> : p-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> y = (q == <span class="literal">nullptr</span>) ? <span class="number">0</span> : q-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> sum = x + y + flag;</span><br><span class="line">		flag = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">		r = r-&gt;next;	</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q) &#123;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(flag);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、两数相加-II-【LeetCode-445-medium】"><a href="#10、两数相加-II-【LeetCode-445-medium】" class="headerlink" title="10、两数相加 II 【LeetCode 445 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">两数相加 II 【LeetCode 445 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</span><br><span class="line">你可以假设除了数字 0 之外，这两个数字都不会以零开头。</span><br><span class="line">进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</span><br><span class="line">示例：</span><br><span class="line">输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<p>【解法】具体解法和上一题完全相同，只不过这题多了一个链表反转的操作，先将链表反转，反转之后再从头开始遍历相加求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseListNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		ListNode* nex = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = nex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	ListNode* reverse_l1 =  <span class="built_in">reverseListNode</span>(l1);</span><br><span class="line">	ListNode* reverse_l2 = <span class="built_in">reverseListNode</span>(l2);</span><br><span class="line">	ListNode* p = reverse_l1;</span><br><span class="line">	ListNode* q = reverse_l2;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* r = new_head;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = (p == <span class="literal">nullptr</span>) ? <span class="number">0</span> : p-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> y = (q == <span class="literal">nullptr</span>) ? <span class="number">0</span> : q-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> sum = x + y + flag;</span><br><span class="line">		flag = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q) &#123;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(flag);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* res = <span class="built_in">reverseListNode</span>(new_head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、删除链表的倒数第-N-个结点【LeetCode-19-medium】"><a href="#11、删除链表的倒数第-N-个结点【LeetCode-19-medium】" class="headerlink" title="11、删除链表的倒数第 N 个结点【LeetCode 19 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点【LeetCode 19 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line">提示：链表中结点的数目为 sz，1 &lt;&#x3D; sz &lt;&#x3D; 30</span><br><span class="line">0 &lt;&#x3D; Node.val &lt;&#x3D; 100，1 &lt;&#x3D; n &lt;&#x3D; sz</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531113520.png"></p>
<p>【解法】双指针，前后指针相差<code>n</code>个节点，这样就保证了当前指针遍历到结尾为空时，后指针刚好指向要删除的节点的前一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">	dummyHead-&gt;next = head;</span><br><span class="line">	ListNode* p = dummyHead, * q = dummyHead;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* delNode = p-&gt;next;</span><br><span class="line">	p-&gt;next = delNode-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> delNode;</span><br><span class="line"></span><br><span class="line">	ListNode* retNode = dummyHead-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> dummyHead;</span><br><span class="line">	<span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、合并K个升序链表【LeetCode-23-hard】"><a href="#12、合并K个升序链表【LeetCode-23-hard】" class="headerlink" title="12、合并K个升序链表【LeetCode 23 | hard】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表【LeetCode 23 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><br><span class="line">示例1：</span><br><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p>【解法】遍历每个链表，开辟一个新的数组，将所有节点保存到新数组中，然后根据值大小进行排序，最后将新数组中的每个节点连成一个链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	vector&lt;ListNode*&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (lists[i]) &#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">			lists[i] = lists[i]-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (vec.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		vec[i - <span class="number">1</span>]-&gt;next = vec[i];</span><br><span class="line">	&#125;</span><br><span class="line">	vec.<span class="built_in">back</span>()-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】将链表数组分成两部分，两部分分别递归调用，最后两部分的结果调用合并两个链表的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* p = new_head;</span><br><span class="line">	<span class="keyword">while</span> (headA &amp;&amp; headB) &#123;</span><br><span class="line">		<span class="keyword">if</span> (headA-&gt;val &lt;= headB-&gt;val) &#123;</span><br><span class="line">			p-&gt;next = headA;</span><br><span class="line">			headA = headA-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;next = headB;</span><br><span class="line">			headB = headB-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (headA) &#123;</span><br><span class="line">		p-&gt;next = headA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (headB) &#123;</span><br><span class="line">		p-&gt;next = headB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = lists.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">	vector&lt;ListNode*&gt; tmp_vec1, tmp_vec2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; ++i) &#123;</span><br><span class="line">		tmp_vec1.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* tmp1 = <span class="built_in">mergeKLists</span>(tmp_vec1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; len; ++i) &#123;</span><br><span class="line">		tmp_vec2.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* tmp2 = <span class="built_in">mergeKLists</span>(tmp_vec2);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(tmp1, tmp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、-删除排序链表中的重复元素【LeetCode-83-easy】"><a href="#13、-删除排序链表中的重复元素【LeetCode-83-easy】" class="headerlink" title="13、 删除排序链表中的重复元素【LeetCode 83 | easy】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/"> 删除排序链表中的重复元素【LeetCode 83 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次。返回同样按升序排列的结果链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191014.png"></p>
<p>【解法】定义两个指针<code>p</code>和<code>q</code>来比较两个节点的值是否相等，如果后一个指针<code>q</code>的值等于前一个指针<code>p</code>的值，那么删除<code>q</code>指向的节点，若不等于，则<code>p</code>和<code>q</code>同时往后移一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	ListNode* q = p-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == q-&gt;val) &#123;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = q;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、删除排序链表中的重复元素-II【LeetCode-82-medium】"><a href="#14、删除排序链表中的重复元素-II【LeetCode-82-medium】" class="headerlink" title="14、删除排序链表中的重复元素 II【LeetCode 82 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II【LeetCode 82 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。返回同样按升序排列的结果链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191217.png"></p>
<p>【解法】一次遍历。重复元素在链表中出现的位置是连续的，因此只需要对链表进行一次遍历就可以删除重复元素。由于链表的头结点可能会删除，因此定义一个哑节点指向头节点，定义一个遍历的指针p指向哑节点。随后开始对链表进行遍历。如果当前 <code>p-&gt;next</code> 与<code>p-&gt;next-&gt;next</code> 对应的元素相同，那么 就需要将 <code>p-&gt;next</code> 以及所有后面拥有相同元素值的链表节点全部删除。 记下这个元素值<code>x</code>，随后不断将<code>p-&gt;next</code> 从链表中移除，直到 <code>p-&gt;next</code>为空节点或者其元素值不等于<code>x</code>为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == x) &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、旋转链表【LeetCode-61-medium】"><a href="#15、旋转链表【LeetCode-61-medium】" class="headerlink" title="15、旋转链表【LeetCode 61 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-list/">旋转链表【LeetCode 61 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head，旋转链表，将链表每个节点向右移动 k 个位置。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191250.png"></p>
<p>【解法】闭合为环。当<code>k&gt;=len</code>时，需要向右移动<code>k mod len</code>次，因为每<code>len</code>次移动都会让链表恢复原状，新链表的最后一个节点即为<code>len - k mod len</code>个节点（从1开始计数）可以先将链表连接成环，然后再从指定位置断开。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;  <span class="comment">// 计算链表长度</span></span><br><span class="line">		len++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = head;    <span class="comment">// 首尾相连成环</span></span><br><span class="line">	<span class="keyword">int</span> add = len - k % len;  <span class="comment">// 定位到新链表的尾部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add; ++i) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* new_head = p-&gt;next; <span class="comment">// 新链表的头节点</span></span><br><span class="line">	p-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 首尾断开</span></span><br><span class="line">	<span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、两两交换链表中的节点【LeetCode-24-medium】"><a href="#16、两两交换链表中的节点【LeetCode-24-medium】" class="headerlink" title="16、两两交换链表中的节点【LeetCode 24 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点【LeetCode 24 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191358.png"></p>
<p>【解法】创建哑节点，定义<code>pre</code>指向哑节点，每次两两交换哑节点之后的两个节点，一次交换之后<code>pre</code>每次指向交换后的两个节点中的后一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	new_head-&gt;next = head;</span><br><span class="line">	ListNode* pre = new_head;</span><br><span class="line">	<span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next) &#123;</span><br><span class="line">		ListNode* p = pre-&gt;next;</span><br><span class="line">		ListNode* q = pre-&gt;next-&gt;next;</span><br><span class="line">		pre-&gt;next = q;</span><br><span class="line">		p-&gt;next = q-&gt;next;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		pre = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、K-个一组翻转链表【LeetCode-25-hard】"><a href="#17、K-个一组翻转链表【LeetCode-25-hard】" class="headerlink" title="17、K 个一组翻转链表【LeetCode 25 | hard】"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表【LeetCode 25 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191327.png"></p>
<p>【解法】需要把链表节点按照 <code>k</code> 个一组分组，所以可以使用一个指针 <code>head</code> 依次指向每组的头节点。这个指针每次向前移动 <code>k</code> 步，直至链表结尾。对于每个分组， 先判断它的长度是否大于等于 <code>k</code>。若是， 就翻转这部分链表，否则不需要翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转链表，返回头节点和尾节点，方便后续连接</span></span><br><span class="line">pair&lt; ListNode*, ListNode*&gt; reverseKNodes(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">	ListNode* pre = tail-&gt;next;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="comment">// 反转链表</span></span><br><span class="line">	<span class="keyword">while</span> (pre != tail) &#123;</span><br><span class="line">		ListNode* q = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; tail, head &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	hair-&gt;next = head;</span><br><span class="line">	ListNode* pre = hair;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		ListNode* tail = pre;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!tail) &#123; <span class="comment">// 如果为空，则代表后面的节点个数不足k个，直接返回</span></span><br><span class="line">				<span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ListNode* nex = tail-&gt;next;</span><br><span class="line">		<span class="comment">// 反转含有k个节点的链表部分</span></span><br><span class="line">		pair&lt;ListNode*, ListNode*&gt; result = <span class="built_in">reverseKNodes</span>(head, tail);</span><br><span class="line">		head = result.first;</span><br><span class="line">		tail = result.second;</span><br><span class="line">		<span class="comment">// 将反转后的链表连接到原来的链表上</span></span><br><span class="line">		pre-&gt;next = head;</span><br><span class="line">		tail-&gt;next = nex;</span><br><span class="line">		pre = tail;</span><br><span class="line">		head = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="18、判断链表是否有环-找出环的入口【LeetCode-142-medium】"><a href="#18、判断链表是否有环-找出环的入口【LeetCode-142-medium】" class="headerlink" title="18、判断链表是否有环/找出环的入口【LeetCode 142 | medium】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">判断链表是否有环/找出环的入口【LeetCode 142 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环， 使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</span><br><span class="line">示例1：</span><br><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210609115655.png"></p>
<p>【解法】双指针，快指针走2步，慢指针走1步，两者先同时从头节点开始走，如果相遇则代表有环。</p>
<p>头节点和慢指针从相遇节点同时走，两者相遇的位置即为环的入口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	<span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">			ListNode* p = head;</span><br><span class="line">			<span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">				p = p-&gt;next;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="19、移除链表元素-【LeetCode-203-easy】"><a href="#19、移除链表元素-【LeetCode-203-easy】" class="headerlink" title="19、移除链表元素 【LeetCode 203 | easy】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素 【LeetCode 203 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</span><br><span class="line">示例1：</span><br><span class="line">输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210607213053.png"></p>
<p>【解法】由于可能头节点就是要删除的节点，所以定义一个临时节点作为头节点，依次遍历，找到满足删除条件的节点就删除，不满足条件则往后走一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">	ListNode* p = new_head;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">			p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20、重排链表-【LeetCode-143-medium】"><a href="#20、重排链表-【LeetCode-143-medium】" class="headerlink" title="20、重排链表 【LeetCode 143 | medium】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">重排链表 【LeetCode 143 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br><span class="line">示例 1:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<p>【解法】目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</p>
<p>这样 的任务即可划分为三步：找到原链表的中点（双指针，快指针走两步，满指针走一步）；将原链表的右半端反转；将原链表的两端合并（因为两链表长度相差不超过 1，因此直接合并即可）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;   <span class="comment">// 反转链表</span></span><br><span class="line">	ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		ListNode* nex = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = nex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;   <span class="comment">// 快慢指针找到链表的中点</span></span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	<span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123; <span class="comment">// 将两个链表交错接在一起</span></span><br><span class="line">	ListNode* p;</span><br><span class="line">	ListNode* q;</span><br><span class="line">	<span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">		p = l1-&gt;next;</span><br><span class="line">		q = l2-&gt;next;</span><br><span class="line">		l1-&gt;next = l2;</span><br><span class="line">		l1 = p;</span><br><span class="line">		l2-&gt;next = l1;</span><br><span class="line">		l2 = q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">	ListNode* l1 = head;</span><br><span class="line">	ListNode* l2 = mid-&gt;next;</span><br><span class="line">	mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	l2 = <span class="built_in">reverseNode</span>(l2);</span><br><span class="line">	<span class="built_in">mergeList</span>(l1, l2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、对链表进行插入排序-【LeetCode-147-medium】"><a href="#21、对链表进行插入排序-【LeetCode-147-medium】" class="headerlink" title="21、对链表进行插入排序 【LeetCode 147 | medium】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">对链表进行插入排序 【LeetCode 147 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】插入排序算法：</span><br><span class="line">插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</span><br><span class="line">每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p>【解法】创建哑节点，便于在头节点之前进行插入。维护<code>lastSorted</code>为链表已排序部分的最后一个节点，维护<code>cur</code>为待插入的节点。比较<code>lastSorted</code>和<code>cur</code>的节点值，如果<code>lastSorted-&gt;val&lt;=cur-&gt;val</code>，说明这两个节点已经有序，同时往后移一个；否则，从链表的头节点开始遍历，寻找插入<code>cur</code>的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    new_head-&gt;next = head;</span><br><span class="line">    ListNode* lastSorted = head;</span><br><span class="line">    ListNode* cur = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastSorted-&gt;val &lt;= cur-&gt;val) &#123;</span><br><span class="line">            lastSorted = lastSorted-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode* pre = new_head;</span><br><span class="line">            <span class="keyword">while</span> (pre-&gt;next-&gt;val &lt;= cur-&gt;val) &#123;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastSorted-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cur = lastSorted-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、奇偶链表【LeetCode-328-medium】"><a href="#22、奇偶链表【LeetCode-328-medium】" class="headerlink" title="22、奇偶链表【LeetCode 328 | medium】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">奇偶链表【LeetCode 328 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">应当保持奇数节点和偶数节点的相对顺序。</span><br><span class="line">链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</span><br></pre></td></tr></table></figure>

<p>【解法】分离节点后合并。更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 <code>odd.next = even.next</code>，然后令 <code>odd = odd.next</code>，此时 <code>odd</code>变成 <code>even</code> 的后一个节点。</p>
<p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 <code>even.next = odd.next</code>，然后令 <code>even = even.next</code>，此时 <code>even </code>变成 <code>odd</code> 的后一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* evenHead = head-&gt;next;</span><br><span class="line">	ListNode* even = evenHead;</span><br><span class="line">	ListNode* odd = head;</span><br><span class="line">	<span class="keyword">while</span> (even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">		odd-&gt;next = even-&gt;next;</span><br><span class="line">		odd = odd-&gt;next;</span><br><span class="line">		even-&gt;next = odd-&gt;next;</span><br><span class="line">		even = even-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	odd-&gt;next = evenHead;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="23、有序链表转换二叉搜索树【LeetCode-109-medium】"><a href="#23、有序链表转换二叉搜索树【LeetCode-109-medium】" class="headerlink" title="23、有序链表转换二叉搜索树【LeetCode 109 | medium】"></a>23、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">有序链表转换二叉搜索树【LeetCode 109 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</span><br><span class="line">示例:</span><br><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line">	  0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p>【解法】分治 。找到链表的中位数，中位数即为根节点，然后递归构造左半边和右半边分别为左子树和右子树。时间复杂度：<code>O*(*nlogn)</code>，空间复杂度：<code>O(logn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">	ListNode* slow = left;</span><br><span class="line">	ListNode* fast = left;</span><br><span class="line">	<span class="keyword">while</span> (fast != right &amp;&amp; fast-&gt;next != right) &#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* left, ListNode* right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* mid = <span class="built_in">middleNode</span>(left, right);</span><br><span class="line">	TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">	root-&gt;left = <span class="built_in">buildTree</span>(left, mid);</span><br><span class="line">	root-&gt;right = <span class="built_in">buildTree</span>(mid-&gt;next, right);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">buildTree</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="24、交换链表中的节点【LeetCode-1721-medium】"><a href="#24、交换链表中的节点【LeetCode-1721-medium】" class="headerlink" title="24、交换链表中的节点【LeetCode 1721 | medium】"></a>24、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/">交换链表中的节点【LeetCode 1721 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你链表的头节点 head 和一个整数 k 。交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210609164953.png"></p>
<p>【解法】分别找到链表中第<code>k</code>个和倒数第<code>k</code>个节点，交换这两个节点的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* former = head;</span><br><span class="line">	ListNode* latter = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!former) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		former = former-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (former) &#123; <span class="comment">// latter指向倒数第k个节点</span></span><br><span class="line">		latter = latter-&gt;next;</span><br><span class="line">		former = former-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换节点的值</span></span><br><span class="line">	<span class="keyword">int</span> tmp = p-&gt;val;</span><br><span class="line">	p-&gt;val = latter-&gt;val;</span><br><span class="line">	latter-&gt;val = tmp;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="25、分隔链表【LeetCode-725-medium】"><a href="#25、分隔链表【LeetCode-725-medium】" class="headerlink" title="25、分隔链表【LeetCode 725 | medium】"></a>25、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">分隔链表【LeetCode 725 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</span><br><span class="line">每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</span><br><span class="line">这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</span><br><span class="line">返回一个符合上述规则的链表的列表。</span><br><span class="line">举例： 1-&gt;2-&gt;3-&gt;4, k &#x3D; 5 &#x2F;&#x2F; 5 结果 [ [1], [2], [3], [4], null ]</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: root &#x3D; [1, 2, 3], k &#x3D; 5</span><br><span class="line">输出: [[1],[2],[3],[],[]]</span><br><span class="line">解释:</span><br><span class="line">输入输出各部分都应该是链表，而不是数组。</span><br><span class="line">例如, 输入的结点 root 的 val&#x3D; 1, root.next.val &#x3D; 2, root.next.next.val &#x3D; 3, 且 root.next.next.next &#x3D; null。</span><br><span class="line">第一个输出 output[0] 是 output[0].val &#x3D; 1, output[0].next &#x3D; null。</span><br><span class="line">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3</span><br><span class="line">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">解释:</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure>

<p>【解法】如果链表有<code>N</code>个结点，则分隔的链表中每个部分中都有 <code>N / k</code>个结点，且前 <code>N % k</code>部分有一个额外的结点。可以用一个简单的循环来计算<code>N</code>。现在对于每个部分， 已经计算出该部分有多少个节点：<code>width + (i &lt; remainder ? 1 : 0)</code>，创建一个新列表并将该部分写入该列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p = root;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        ++len;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> width = len / k, rem = len % k;</span><br><span class="line">    <span class="function">vector&lt;ListNode*&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">    p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        ListNode* head = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width + (i &lt; rem ? <span class="number">1</span> : <span class="number">0</span>) - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            ListNode* pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="26、回文链表【LeetCode-234-easy】"><a href="#26、回文链表【LeetCode-234-easy】" class="headerlink" title="26、回文链表【LeetCode 234 | easy】"></a>26、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表【LeetCode 234 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请判断一个链表是否为回文链表。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>【解法】双指针。1) 找到前半部分链表的尾节点。2) 反转后半部分链表。3) 判断是否回文。4) 恢复链表。<br>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* cur = head;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		ListNode* nextptr = cur-&gt;next;</span><br><span class="line">		cur-&gt;next = pre;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = nextptr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	<span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!head) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* mid = <span class="built_in">middleNode</span>(head);</span><br><span class="line">	ListNode* re_node = <span class="built_in">reverseNode</span>(mid-&gt;next);</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	ListNode* q = re_node;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag &amp;&amp; q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	mid-&gt;next = <span class="built_in">reverseNode</span>(re_node);</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="27、链表中的下一个更大节点【LeetCode-1019-medium】"><a href="#27、链表中的下一个更大节点【LeetCode-1019-medium】" class="headerlink" title="27、链表中的下一个更大节点【LeetCode 1019 | medium】"></a>27、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/">链表中的下一个更大节点【LeetCode 1019 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</span><br><span class="line">返回整数答案数组 answer，其中 answer[i] &#x3D; next_larger(node_&#123;i+1&#125;) 。</span><br><span class="line">注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。 </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：[2,1,5]</span><br><span class="line">输出：[5,5,0]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,7,4,3,5]</span><br><span class="line">输出：[7,0,5,5,0]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：[1,7,5,1,9,2,5,1]</span><br><span class="line">输出：[7,9,9,9,0,5,0,0]</span><br></pre></td></tr></table></figure>

<p>【解法】单调递减栈。首先求出链表的长度，用链表的长度初始化数组。然后遍历链表，当栈为空或栈顶元素大于新来的元素的时候，入栈。当栈不为空且栈顶元素小于新来的元素的时候，出栈直至不满足该条件，将该元素入栈。栈中的节点类型为<code>pair&lt;int, ListNode*&gt;</code>，第一个元素代表数组的下标<code>index</code>，第二个元素代表链表的节点，即下标和节点相对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		++len;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	stack&lt;pair&lt;<span class="keyword">int</span>, ListNode*&gt;&gt; s;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="comment">// 当栈非空或栈顶元素大于新来的元素</span></span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">empty</span>() || p-&gt;val &lt; s.<span class="built_in">top</span>().second-&gt;val) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, ListNode*&gt;(index, p));		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当栈不为空且栈顶元素小于新来的元素，则出栈，此时栈顶元素的下一个更大值即为这个新来的元素</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; p-&gt;val &gt; s.<span class="built_in">top</span>().second-&gt;val) &#123;</span><br><span class="line">				res[s.<span class="built_in">top</span>().first] = p-&gt;val;</span><br><span class="line">				s.<span class="built_in">pop</span>();				</span><br><span class="line">			&#125;</span><br><span class="line">			s.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, ListNode*&gt;(index, p));</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		++index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后如果栈不为空，则代表栈中的元素是递减的，即下一个更大的节点为0</span></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		res[s.<span class="built_in">top</span>().first] = <span class="number">0</span>;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="28、二叉树中的链表【LeetCode-1367-medium】"><a href="#28、二叉树中的链表【LeetCode-1367-medium】" class="headerlink" title="28、二叉树中的链表【LeetCode 1367 | medium】"></a>28、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/">二叉树中的链表【LeetCode 1367 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</span><br><span class="line">如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [4,2,8], root &#x3D; [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：树中蓝色的节点构成了与链表对应的子路径。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210610105919.png"></p>
<p>【解法】代码与【判断子树】完全一样。详见注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSub</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 链表为空，则为true</span></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 链表没走完，树走完了，返回false</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 两者值不同，返回false</span></span><br><span class="line">	<span class="keyword">if</span> (root-&gt;val != head-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果值相同，继续比较左边和右边有一个满足即可</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSub</span>(head-&gt;next, root-&gt;left) || <span class="built_in">isSub</span>(head-&gt;next, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(ListNode* head, TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先判断当前节点，如果不对，再看左子树和右子树</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSub</span>(head, root) || <span class="built_in">isSubPath</span>(head, root-&gt;left) || <span class="built_in">isSubPath</span>(head, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="29、从链表中删去总和值为零的连续节点【LeetCode-1171-medium】"><a href="#29、从链表中删去总和值为零的连续节点【LeetCode-1171-medium】" class="headerlink" title="29、从链表中删去总和值为零的连续节点【LeetCode 1171 | medium】"></a>29、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">从链表中删去总和值为零的连续节点【LeetCode 1171 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。删除完毕后，请你返回最终结果链表的头节点。</span><br><span class="line">你可以返回任何满足题目要求的答案。（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,2,-3,3,1]</span><br><span class="line">输出：[3,1]</span><br><span class="line">提示：答案 [1,2,1] 也是正确的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：head &#x3D; [1,2,3,-3,4]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：head &#x3D; [1,2,3,-3,-2]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p>【解法】前缀和 + 哈希表。第一次遍历链表，用哈希表记录前缀和<code>sum</code>的最右边的节点；第二次遍历链表，若当前节点处<code>sum</code>在下一处出现了则表明两结点之间所有节点和为<code>0</code>， 直接删除区间所有节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, ListNode*&gt; unmap;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 若同一和出现多次会覆盖，即记录该sum出现的最后一次节点</span></span><br><span class="line">	<span class="keyword">for</span> (ListNode* p = new_head; p != <span class="literal">nullptr</span>; p = p-&gt;next)	&#123;</span><br><span class="line">		sum += p-&gt;val;</span><br><span class="line">		unmap[sum] = p;</span><br><span class="line">	&#125;</span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 若当前节点处sum在下一处出现了则表明两结点之间所有节点和为0 直接删除区间所有节点</span></span><br><span class="line">	<span class="keyword">for</span> (ListNode* p = new_head; p != <span class="literal">nullptr</span>; p = p-&gt;next) &#123;</span><br><span class="line">		sum += p-&gt;val;</span><br><span class="line">		p-&gt;next = unmap[sum]-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="30、设计前中后队列【LeetCode-1670-medium】"><a href="#30、设计前中后队列【LeetCode-1670-medium】" class="headerlink" title="30、设计前中后队列【LeetCode 1670 | medium】"></a>30、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">设计前中后队列【LeetCode 1670 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。请你完成 FrontMiddleBack 类：</span><br><span class="line"></span><br><span class="line">FrontMiddleBack() 初始化队列。</span><br><span class="line">void pushFront(int val) 将 val 添加到队列的 最前面 。</span><br><span class="line">void pushMiddle(int val) 将 val 添加到队列的 正中间 。</span><br><span class="line">void pushBack(int val) 将 val 添加到队里的 最后面 。</span><br><span class="line">int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><br><span class="line">int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><br><span class="line">int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。</span><br><span class="line">请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：</span><br><span class="line"></span><br><span class="line">将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。</span><br><span class="line">从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]</span><br><span class="line">[[], [1], [2], [3], [4], [], [], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, null, null, 1, 3, 4, 2, -1]</span><br><span class="line">解释：</span><br><span class="line">FrontMiddleBackQueue q &#x3D; new FrontMiddleBackQueue();</span><br><span class="line">q.pushFront(1);   &#x2F;&#x2F; [1]</span><br><span class="line">q.pushBack(2);    &#x2F;&#x2F; [1, 2]</span><br><span class="line">q.pushMiddle(3);  &#x2F;&#x2F; [1, 3, 2]</span><br><span class="line">q.pushMiddle(4);  &#x2F;&#x2F; [1, 4, 3, 2]</span><br><span class="line">q.popFront();     &#x2F;&#x2F; 返回 1 -&gt; [4, 3, 2]</span><br><span class="line">q.popMiddle();    &#x2F;&#x2F; 返回 3 -&gt; [4, 2]</span><br><span class="line">q.popMiddle();    &#x2F;&#x2F; 返回 4 -&gt; [2]</span><br><span class="line">q.popBack();      &#x2F;&#x2F; 返回 2 -&gt; []</span><br><span class="line">q.popFront();     &#x2F;&#x2F; 返回 -1 -&gt; [] （队列为空）</span><br></pre></td></tr></table></figure>

<p>【解法】用双向链表进行模拟，初始时该双向链表有一个头节点和一个尾节点。</p>
<p>注意点：在中间插入时找到的是中间节点的前一个节点，在该节点之后进行插入；</p>
<p>在中间删除时找到的是中间节点，进行自我删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DualListNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	DualListNode* pre;</span><br><span class="line">	DualListNode* next;</span><br><span class="line">	<span class="built_in">DualListNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrontMiddleBackQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	DualListNode* _head;</span><br><span class="line">	DualListNode* _tail;</span><br><span class="line">	<span class="keyword">int</span> _length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FrontMiddleBackQueue</span>() &#123;</span><br><span class="line">		_head = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(<span class="number">-1</span>);</span><br><span class="line">		_tail = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(<span class="number">-1</span>);</span><br><span class="line">		_head-&gt;next = _tail;</span><br><span class="line">		_tail-&gt;pre = _head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushFront</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;		</span><br><span class="line">		DualListNode* node = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(val);</span><br><span class="line">		node-&gt;next = _head-&gt;next;</span><br><span class="line">		_head-&gt;next-&gt;pre = node;				</span><br><span class="line">		_head-&gt;next = node;</span><br><span class="line">		node-&gt;pre = _head;</span><br><span class="line">		++_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushMiddle</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		DualListNode* node = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(val);</span><br><span class="line">		DualListNode* fast = _head;</span><br><span class="line">		DualListNode* slow = _head;</span><br><span class="line">		<span class="comment">// 找到中间节点的前一个节点，slow指向该节点，在该节点后进行插入</span></span><br><span class="line">		<span class="keyword">while</span> (fast-&gt;next != _tail &amp;&amp; fast-&gt;next-&gt;next != _tail) &#123;</span><br><span class="line">			fast = fast-&gt;next-&gt;next;</span><br><span class="line">			slow = slow-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		node-&gt;next = slow-&gt;next;</span><br><span class="line">		slow-&gt;next-&gt;pre = node;</span><br><span class="line">		slow-&gt;next = node;</span><br><span class="line">		node-&gt;pre = slow;</span><br><span class="line">		++_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pushBack</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		DualListNode* node = <span class="keyword">new</span> <span class="built_in">DualListNode</span>(val);</span><br><span class="line">		node-&gt;pre = _tail-&gt;pre;</span><br><span class="line">		_tail-&gt;pre-&gt;next = node;</span><br><span class="line">		_tail-&gt;pre = node;</span><br><span class="line">		node-&gt;next = _tail;</span><br><span class="line">		++_length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">popFront</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = _head-&gt;next-&gt;val;</span><br><span class="line">		DualListNode* node = _head-&gt;next-&gt;next;</span><br><span class="line">		_head-&gt;next = node;</span><br><span class="line">		node-&gt;pre = _head;</span><br><span class="line">		--_length;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">popMiddle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DualListNode* fast = _head;</span><br><span class="line">		DualListNode* slow = _head;</span><br><span class="line">		<span class="comment">// 找到中间节点，进行自我删除，slow指向中间节点</span></span><br><span class="line">		<span class="keyword">while</span> (fast != _tail &amp;&amp; fast-&gt;next != _tail) &#123;</span><br><span class="line">			fast = fast-&gt;next-&gt;next;</span><br><span class="line">			slow = slow-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		slow-&gt;next-&gt;pre = slow-&gt;pre;</span><br><span class="line">		slow-&gt;pre-&gt;next = slow-&gt;next;</span><br><span class="line">		--_length;</span><br><span class="line">		<span class="keyword">return</span> slow-&gt;val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">popBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tmp = _tail-&gt;pre-&gt;val;</span><br><span class="line">		DualListNode* node = _tail-&gt;pre-&gt;pre;</span><br><span class="line">		node-&gt;next = _tail;</span><br><span class="line">		_tail-&gt;pre = node;</span><br><span class="line">		--_length;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="31、链表组件【LeetCode-817-medium】"><a href="#31、链表组件【LeetCode-817-medium】" class="headerlink" title="31、链表组件【LeetCode 817 | medium】"></a>31、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-components/">链表组件【LeetCode 817 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 G，该列表是上述链表中整型值的一个子集。返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</span><br><span class="line">示例 1：</span><br><span class="line">输入: head: 0-&gt;1-&gt;2-&gt;3，G &#x3D; [0, 1, 3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: head: 0-&gt;1-&gt;2-&gt;3-&gt;4，G &#x3D; [0, 3, 1, 4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</span><br></pre></td></tr></table></figure>

<p>【解法】将数组中的元素放入<code>set</code>中，遍历链表，检查链表的数值是否在<code>set</code>中出现过，如果出现过且下一个节点不存在或下一个节点的值没出现，则个数加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">		s.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s.<span class="built_in">find</span>(p-&gt;val) != s.<span class="built_in">end</span>() &amp;&amp; (p-&gt;next == <span class="literal">nullptr</span> || s.<span class="built_in">find</span>(p-&gt;next-&gt;val) == s.<span class="built_in">end</span>())) &#123;</span><br><span class="line">			++result;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="32、扁平化多级双向链表【LeetCode-430-medium】"><a href="#32、扁平化多级双向链表【LeetCode-430-medium】" class="headerlink" title="32、扁平化多级双向链表【LeetCode 430 | medium】"></a>32、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">扁平化多级双向链表【LeetCode 430 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</span><br><span class="line">给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</span><br><span class="line">输出：[1,2,3,7,8,11,12,9,10,4,5,6]</span><br><span class="line">解释：</span><br><span class="line">输入的多级列表如下图所示：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113123.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扁平化后的链表如下图：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113156.png"></p>
<p>【解法】举例说明，对下图的链表进行扁平化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113416.png"></p>
<p>将列表顺时针转<code> 90 °</code>，那么就会看到一颗二叉树，则扁平化的操作也就是对二叉树进行先序遍历（深度优先搜索）。如图所示， 可以将<code> child</code> 指针当作二叉树中指向左子树的 <code>left </code>指针，<code>next </code>指针可以当作是二叉树中的<code>right</code>指针。然后 深度优先搜索树将得到答案。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210611113226.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Node* tail;   <span class="comment">// tail指向每次递归的尾节点</span></span><br><span class="line">	<span class="function">Node* <span class="title">dfs</span><span class="params">(Node* p)</span> </span>&#123;</span><br><span class="line">		tail = p; </span><br><span class="line">		<span class="keyword">while</span> (p) &#123;</span><br><span class="line">			Node* pnext = p-&gt;next;</span><br><span class="line">			Node* pchild = p-&gt;child;</span><br><span class="line">			<span class="keyword">if</span> (pchild) &#123;</span><br><span class="line">				p-&gt;child = <span class="literal">nullptr</span>; <span class="comment">// 将孩子节点置空</span></span><br><span class="line">				p-&gt;next = pchild;</span><br><span class="line">				pchild-&gt;prev = p;</span><br><span class="line">				Node* tmp = <span class="built_in">dfs</span>(pchild);</span><br><span class="line">				<span class="comment">// 如果p节点存在next节点，则与child的尾结点连接</span></span><br><span class="line">				<span class="keyword">if</span> (pnext) &#123;</span><br><span class="line">					tmp-&gt;next = pnext;</span><br><span class="line">					pnext-&gt;prev = tmp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			p = pnext;</span><br><span class="line">			<span class="keyword">if</span> (p) &#123; <span class="comment">// 更新尾节点</span></span><br><span class="line">				tail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tail;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(head);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="五、栈-队列-堆"><a href="#五、栈-队列-堆" class="headerlink" title="五、栈 / 队列 / 堆"></a>五、栈 / 队列 / 堆</h4><h5 id="1、用两个栈实现队列【剑指Offer-09-easy】"><a href="#1、用两个栈实现队列【剑指Offer-09-easy】" class="headerlink" title="1、用两个栈实现队列【剑指Offer 09 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列【剑指Offer 09 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; values &lt;&#x3D; 10000</span><br><span class="line">最多会对 appendTail、deleteHead 进行 10000 次调用</span><br></pre></td></tr></table></figure>

<p>【解法】时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。对于删除操作，虽然看起来是 O(N)的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)，空间复杂度：O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        _s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!_s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                _s2.<span class="built_in">push</span>(_s1.<span class="built_in">top</span>());</span><br><span class="line">                _s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = _s2.<span class="built_in">top</span>();</span><br><span class="line">            _s2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、包含min函数的栈【剑指Offer-30-easy】"><a href="#2、包含min函数的栈【剑指Offer-30-easy】" class="headerlink" title="2、包含min函数的栈【剑指Offer 30 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈【剑指Offer 30 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</span><br><span class="line">示例:</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br><span class="line"> </span><br><span class="line">提示：各函数的调用总次数不超过 20000 次</span><br></pre></td></tr></table></figure>

<p>【解法】维护一个保存最小值的栈，和存放数据的栈一同插入和删除来保证每次插入删除后，最小值栈的栈顶总是当前数据元素中的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        _data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (_min.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _min.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; _min.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                _min.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _min.<span class="built_in">push</span>(_min.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _data.<span class="built_in">pop</span>();</span><br><span class="line">        _min.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _min;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、栈的压入、弹出序列【剑指Offer-31-medium】"><a href="#3、栈的压入、弹出序列【剑指Offer-31-medium】" class="headerlink" title="3、栈的压入、弹出序列【剑指Offer 31 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列【剑指Offer 31 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释： 可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<p>【解法】遍历pushed数组入栈，如果栈顶和popped数组元素相同则弹出，最后根据栈是否为空来判断是否是正确的出栈顺序。时间复杂度仍为 O(N)，空间复杂度为O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		S.<span class="built_in">push</span>(pushed[i]);</span><br><span class="line">		<span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() == popped[j])&#123;</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、队列的最大值【剑指Offer-59-2-medium】"><a href="#4、队列的最大值【剑指Offer-59-2-medium】" class="headerlink" title="4、队列的最大值【剑指Offer 59-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">队列的最大值【剑指Offer 59-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1</span><br><span class="line">示例 1：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; value &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p>【解法】双端队列。维护一个递减的双端队列，时间复杂度O(1)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _deq.<span class="built_in">empty</span>() ? <span class="number">-1</span> : _deq.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        _que.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="comment">// 若入队元素比队尾数字更大，则弹出队尾数字，维护队列的单调性</span></span><br><span class="line">        <span class="keyword">while</span> (!_deq.<span class="built_in">empty</span>() &amp;&amp; _deq.<span class="built_in">back</span>() &lt; value) &#123;</span><br><span class="line">            _deq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _deq.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = _que.<span class="built_in">front</span>();</span><br><span class="line">        _que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 只有当x和双端队列队首元素相同是才弹出，保证了双端队列队首元素总是最大值</span></span><br><span class="line">        <span class="keyword">if</span> (x == _deq.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            _deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; _que;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; _deq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="5、数据流中的中位数【剑指Offer-41-medium】"><a href="#5、数据流中的中位数【剑指Offer-41-medium】" class="headerlink" title="5、数据流中的中位数【剑指Offer 41 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数【剑指Offer 41 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line">例如：</span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line">[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br><span class="line"></span><br><span class="line">限制：最多会对 addNum、findMedian 进行 50000 次调用。</span><br></pre></td></tr></table></figure>

<p>【解法】优先队列（堆）。建立一个小顶堆<code>A</code>和一个大顶堆<code>B</code>，各保存一半元素：小顶堆中保存较大的一半，大顶堆中保存较小的一半，中位数可根据两个堆顶元素计算获得。设元素总数为<code>N = m + n</code> ，其中<code>m</code>和<code>n</code>分别是<code>A</code>和<code>B</code>中的元素个数。当<code>m = n</code>（即 N为偶数）时，需要向<code>A</code>中添加一个元素，实现方法：将新元素<code>num</code>插入至<code>B</code>，再将<code>B</code>堆顶元素插入至<code>A</code>，中位数为 (<code>A的堆顶元素 + B 的堆顶元素 )/2</code> ；当<code>m ≠ n</code>（即<code>N</code>为 奇数）：需向<code>B</code>添加一个元素。实现方法：将新元素<code>num</code>插入至<code>A</code>，再将<code>A</code>堆顶元素插入至<code>B </code>，则中位数为<code>A </code>的堆顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当两堆的数据个数相等时候，左边堆添加元素。</span></span><br><span class="line"><span class="comment">         * 采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后</span></span><br><span class="line"><span class="comment">         * 将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。</span></span><br><span class="line"><span class="comment">         * 同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (_big.<span class="built_in">size</span>() == _small.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            _small.<span class="built_in">push</span>(num);</span><br><span class="line">            _big.<span class="built_in">push</span>(_small.<span class="built_in">top</span>());</span><br><span class="line">            _small.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;           </span><br><span class="line">            _big.<span class="built_in">push</span>(num);</span><br><span class="line">            _small.<span class="built_in">push</span>(_big.<span class="built_in">top</span>());</span><br><span class="line">            _big.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;    </span><br><span class="line">        <span class="keyword">if</span> (_small.<span class="built_in">size</span>() == _big.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result = (_small.<span class="built_in">top</span>() + _big.<span class="built_in">top</span>())  * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _big.<span class="built_in">top</span>() * <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最大堆，存放较小的一半数字，堆顶为最大值</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; _big;</span><br><span class="line">    <span class="comment">// 最小堆， 存放较大的一半数字，堆顶为最小值</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; _small;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="6、基本计算器-II-【LeetCode-227-medium】"><a href="#6、基本计算器-II-【LeetCode-227-medium】" class="headerlink" title="6、基本计算器 II 【LeetCode 227 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">基本计算器 II 【LeetCode 227 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>【解法】可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p>
<p>具体来说，遍历字符串 <code>s</code>，并用变量<code>preSign</code> 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据<code>preSign</code> 来决定计算方式：</p>
<ul>
<li><p>加号：将数字压入栈；</p>
</li>
<li><p>减号：将数字的相反数压入栈；</p>
</li>
<li><p>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。</p>
<p>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新<code>preSign</code> 为当前遍历的字符。</p>
</li>
</ul>
<p>遍历完字符串 <code>s</code> 后，将栈中元素累加，即为该字符串表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">char</span> preSign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (preSign) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">push_back</span>(-num);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                stk.<span class="built_in">back</span>() *= num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                stk.<span class="built_in">back</span>() /= num;</span><br><span class="line">            &#125;</span><br><span class="line">            preSign = s[i];</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(stk.<span class="built_in">begin</span>(), stk.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、表达式求值-【牛客网】"><a href="#7、表达式求值-【牛客网】" class="headerlink" title="7、表达式求值 【牛客网】"></a>7、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">表达式求值 【牛客网】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请写一个整数计算器，支持加减乘三种运算和括号。</span><br><span class="line">示例1</span><br><span class="line">输入：&quot;1+2&quot;</span><br><span class="line">返回值：3</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;(2*(3-4))*5&quot;</span><br><span class="line">返回值：-10</span><br></pre></td></tr></table></figure>

<p>【解法】同上一题。栈 + 递归。因为此题需要计算有括号的情况，括号中的表达式需要进行递归运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//用于返回当前字符串的计算结果</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; sum; <span class="comment">//用于求和</span></span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>; <span class="comment">//记录前一个符号，初始化为+，因为可以看成当前字符串前先加0</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//用于将连续数字字符串转化成数字或者记录递归结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//遍历每一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="comment">//先处理数字字符</span></span><br><span class="line">            num = <span class="number">10</span> * num + s[i] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//进位后加个位数</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">//对于括号</span></span><br><span class="line">            <span class="keyword">int</span> left = i++, count = <span class="number">1</span>; <span class="comment">//用left记录最左括号位置，count记录左括号数，i当成右指针右移一格</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//最终目的是找到与最左括号匹配的右括号，类似于栈操作</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) count--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="built_in">solve</span>(s.<span class="built_in">substr</span>(left + <span class="number">1</span>, i - left - <span class="number">2</span>)); <span class="comment">//迭代计算括号内数值，注意不要包含最左最右括号，不然会死循环</span></span><br><span class="line">            i--; <span class="comment">//此时i是最右括号下一位，需要左移一位防止最右括号在字符串尾时发生越界从而使下面的判定失效</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() - <span class="number">1</span> || s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">//对于字符串尾，或者加减乘，此时 用的符号是上一次的，结算当前数字</span></span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>) sum.<span class="built_in">push</span>(num); <span class="comment">//加法入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;-&#x27;</span>) sum.<span class="built_in">push</span>(-num); <span class="comment">//减法相当于加负数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;*&#x27;</span>) sum.<span class="built_in">top</span>() *= num; <span class="comment">//乘法与栈顶相乘</span></span><br><span class="line">            sign = s[i]; <span class="comment">//更新符号，若为末尾的右括号也无妨，因为马上就退出循环了</span></span><br><span class="line">            num = <span class="number">0</span>; <span class="comment">//重置当前数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!sum.<span class="built_in">empty</span>()) &#123; <span class="comment">//将栈内所有数字相加</span></span><br><span class="line">        res += sum.<span class="built_in">top</span>();</span><br><span class="line">        sum.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">//返回当前字符串计算结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h4><h5 id="1、斐波那契数列【剑指Offer-10-1-easy】"><a href="#1、斐波那契数列【剑指Offer-10-1-easy】" class="headerlink" title="1、斐波那契数列【剑指Offer 10-1 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列【剑指Offer 10-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1, F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>斐波那契方程即为状态转移方程：<code>dp[i+1]=dp[i]+dp[i-1]</code>。但是没必要定义一个<code>dp</code>数组，用两个辅助变量即可进行空间优化。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">1</span>, fn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fn = (f0 + f1) % <span class="number">1000000007</span>;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、青蛙跳台阶问题【剑指Offer-10-2-easy】"><a href="#2、青蛙跳台阶问题【剑指Offer-10-2-easy】" class="headerlink" title="2、青蛙跳台阶问题【剑指Offer 10-2 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶问题【剑指Offer 10-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>思路同斐波那契数列。<code>dp</code>数组采用空间优化。时间复杂度<code>O(N)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, fn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		fn = (f1 + f2) % <span class="number">1000000007</span>;</span><br><span class="line">		f1 = f2;</span><br><span class="line">		f2 = fn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/three-steps-problem-lcci/">三步问题【LeetCode】</a></p>
<p>一次能走1、2、3个台阶：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">3</span>) &#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> c = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tem = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		tem = (a + b + c) % <span class="number">1000000007</span>;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">		c = tem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、剪绳子【剑指Offer-14-1-medium】【LeetCode-343-整数拆分】"><a href="#3、剪绳子【剑指Offer-14-1-medium】【LeetCode-343-整数拆分】" class="headerlink" title="3、剪绳子【剑指Offer 14-1 | medium】【LeetCode 343 | 整数拆分】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剪绳子【剑指Offer 14-1 | medium】【LeetCode 343 | 整数拆分】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时， 把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>动态规划。<code>dp[i]</code>表示长度为<code>i</code>的绳子剪成<code>m</code>段后的最大乘积，初始化<code>dp[2] = 1</code>。先剪下一段<code>j</code>，如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪；剩下<code>(i-j)</code>长度，可以剪也可以不剪，如果不剪的话长度乘积即为<code> j×(i-j)</code>，如果剪的话长度乘积即为<code>j×dp[i-j]</code>，两者取最大值。时间复杂度<code>O(N^2)</code>，空间复杂度<code>O(N)</code>。</p>
<p>状态转移方程：<br>$$<br>dp[i]=max(dp[i], max(j*(i-j), j*dp[i-j]))<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>贪心算法：假设将长度为n的绳子分为a段，即<code>n=n1+n2+......+na</code>，等价于求解：<br>$$<br>max(n1<em>n2</em>……*na)<br>$$<br>有如下数学推论：当所有绳段长度相等时，乘积最大；最优的绳段长度为3。</p>
<p>所以计算长度为<code>n</code>的绳子可以分为长度为<code>3</code>的几段<code>count</code>，并计算余数<code>a</code>；当余数为<code>0</code>时，最大乘积即为<code>pow(3, count)</code>；当余数是<code>1</code>时，则将最后一个长度为3的段空出来，和余数为<code>1</code>的段合并成长度为<code>4</code>的段，最大乘积为<code>2*2=4</code>；当余数为<code>2</code>时，最大乘积即为<code>2 * pow(3, count)</code>。时间复杂度<code>O(1)</code>，空间复杂度<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> a = n % <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">		sum = <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">		sum = <span class="number">4</span> * <span class="built_in">pow</span>(<span class="number">3</span>, count - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">		sum = <span class="number">2</span> * <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、礼物的最大价值【剑指Offer-47-medium】"><a href="#4、礼物的最大价值【剑指Offer-47-medium】" class="headerlink" title="4、礼物的最大价值【剑指Offer 47 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值【剑指Offer 47 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</span><br><span class="line">示例 1:</span><br><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br><span class="line"></span><br><span class="line">提示：0 &lt; grid.length &lt;&#x3D; 200，0 &lt; grid[0].length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>时间复杂度<code>O(MN)</code>，空间优化后空间复杂度<code>O(1)</code>。状态转移方程：<br>$$<br>dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]);<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地修改数组进行空间优化，不增加额外空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;  <span class="comment">// 处理第一行</span></span><br><span class="line">		grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  <span class="comment">// 处理第一列</span></span><br><span class="line">		grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  <span class="comment">// 处理第一行</span></span><br><span class="line">			grid[i][j] += <span class="built_in">max</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、丑数【剑指Offer-49-medium】"><a href="#5、丑数【剑指Offer-49-medium】" class="headerlink" title="5、丑数【剑指Offer 49 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数【剑指Offer 49 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】 把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</span><br><span class="line">示例:</span><br><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line"></span><br><span class="line">说明:  1 是丑数。n 不超过1690。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>用三个指针<code>a</code>、<code>b</code>、<code>c</code>，初始值为1，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。状态转移方程：<br>$$<br>dp[i]=min(2<em>dp[a],3</em>dp[b],5*dp[c])<br>$$<br>然后分别比较<code>dp[i]</code>和<code>2dp[a]</code>，<code>3dp[b]</code>，<code>5dp[c]</code>是否相等，如果相等则对应的指针加1。时间复杂度<code>O(N）</code>，空间复杂度<code>O(N)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span> * dp[a], n3 = <span class="number">3</span> * dp[b], n5 = <span class="number">5</span> * dp[c];</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(n2, n3), n5);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n2) &#123;</span><br><span class="line">            ++a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n3) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n5) &#123;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、分割回文串【LeetCode-131-medium】"><a href="#6、分割回文串【LeetCode-131-medium】" class="headerlink" title="6、分割回文串【LeetCode 131 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">分割回文串【LeetCode 131 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</span><br><span class="line">回文串 是正着读和反着读都一样的字符串。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;aab&quot;</span><br><span class="line">输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：[[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>搜索 + 回溯 + 动态规划预处理。</p>
<p>假设当前搜索到字符串的第<code>i</code>个字符，且<code>s[0..i-1]</code>位置的所有字符已经被分割成若干个回文串，并且分割结果被放入了答案数组<code>ans</code>中，那么 就需要枚举下一个回文串的右边界<code>j</code>，使得<code>s[i..j]</code>是一个回文串。</p>
<p>因此， 可以从<code>i</code>开始，从小到大依次枚举<code>j</code>。对于当前枚举的<code>j</code>值， 使用双指针的方法判断<code>s[i..j]</code>是否为回文串：如果<code>s[i..j]</code>是回文串，那么就将其加入答案数组<code>ans</code>中，并以<code>j+1</code>作为新的<code>i</code>进行下一层搜索，并在未来的回溯时将<code>s[i..j]</code>从<code>ans</code>中移除。如果已经搜索完了字符串的最后一个字符，那么就找到了一种满足要求的分割方法。</p>
<p>当判断<code>s[i..j]</code>是否为回文串时，常规的方法是使用双指针分别指向<code>i</code>和<code>j</code>，每次判断两个指针指向的字符是否相同，直到两个指针相遇。然而这种方法会产生重复计算，例如下面这个例子：</p>
<p>当<code>s=aaba</code>时，对于前 2 个字符<code>aa</code>， 有 2 种分割方法<code>[aa]</code>和 <code>[a,a]</code>，当每一次搜索到字符串的第<code>i=2</code>个字符<code>b</code>时，都需要对于每个<code>s[i..j]</code>使用双指针判断其是否为回文串，这就产生了重复计算。</p>
<p>因此，可以将字符串<code>s</code>的每个子串<code>s[i..j]</code>是否为回文串预处理出来，使用动态规划即可。设 <code>f(i,j)</code>表示 <code>s[i..j] </code>是否为回文串，那么有状态转移方程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210618205624.png">    </p>
<p>其中<code>∧</code>表示逻辑与运算，即<code>s[i..j]</code>为回文串，当且仅当其为空串（<code>i&gt;j</code>），其长度为 1（<code>i=j</code>），或者首尾字符相同且<code>s[i+1..j−1]</code>为回文串。</p>
<p>预处理完成之后，只需要<code>O(1)</code>的时间就可以判断任意<code>s[i..j]</code>是否为回文串了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">	vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">	vector&lt;string&gt; ans;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">			ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">				<span class="built_in">dfs</span>(s, j + <span class="number">1</span>);</span><br><span class="line">				ans.<span class="built_in">pop_back</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">		n = s.<span class="built_in">size</span>();</span><br><span class="line">		f.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line">		<span class="comment">//动态规划：判断s[i,...j]是否是回文串</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">				f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="7、n个骰子的点数【剑指Offer-60-medium】"><a href="#7、n个骰子的点数【剑指Offer-60-medium】" class="headerlink" title="7、n个骰子的点数【剑指Offer 60 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数【剑指Offer 60 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="line">你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 11</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>假设已知<code>n-1</code>个骰子的解为<code>f(n-1)</code>，此时添加一个骰子，求<code>n</code>个骰子的点数和为<code>x</code>的概率为<code>f(n,x)</code>。当添加骰子的点数为 1 时，前<code> n - 1</code>个骰子的点数和应为<code> x - 1</code>，方可组成点数和<code> x</code>；同理，当此骰子为 2 时，前<code> n - 1</code> 个骰子应为 <code>x - 2</code>；以此类推，直至此骰子点数为 6 。将这 6 种情况的概率相加，即可得到概率 <code>f(n, x) </code>。递推公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210427195338.png"></p>
<p>但是<code> f(n-1, x-i)</code>会有越界问题，转换为正向递推，概率 <code>f(n-1, x) </code>只和<code> f(n, x + 1), f(n, x + 1) , ......,  f(n, x + 6)</code>相关，遍历 <code>f(n - 1)</code> 中各点数和的概率，并将其添加至 <code>f(n)</code> 中所有相关项，即可完成<code>f(n - 1)</code>至 <code>f(n)</code> 的递推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                tmp[j + k] += dp[j] / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、股票的最大利润【剑指Offer-63-medium】"><a href="#8、股票的最大利润【剑指Offer-63-medium】" class="headerlink" title="8、股票的最大利润【剑指Offer 63 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润【剑指Offer 63 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前i天的最大利润等于前<code>i-1</code>天的最大利润和第<code>i</code>天卖出的最大利润中的最大值。</p>
<p>状态转移方程，用常量进行空间优化，时间复杂度<code>O(N)</code>，空间优化后空间复杂度<code>O(1)</code>：<br>$$<br>dp[i] = max(dp[i], prices[i] - minval);<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> minval = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		minval = <span class="built_in">min</span>(minval, prices[i]);  <span class="comment">// 找price最小值</span></span><br><span class="line">		profit = <span class="built_in">max</span>(profit, prices[i] - minval);  <span class="comment">// 比较前一天的利润，和今天卖出获得的利润</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、正则表达式匹配【剑指Offer-19-medium】"><a href="#9、正则表达式匹配【剑指Offer-19-medium】" class="headerlink" title="9、正则表达式匹配【剑指Offer 19 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">正则表达式匹配【剑指Offer 19 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数用来匹配包含&#39;. &#39;和&#39;*&#39;的正则表达式。</span><br><span class="line">模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。</span><br><span class="line">在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入：</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#39;*&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10、不同路径-II【LeetCode-63-medium】"><a href="#10、不同路径-II【LeetCode-63-medium】" class="headerlink" title="10、不同路径 II【LeetCode 63 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II【LeetCode 63 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span><br><span class="line">网格中的障碍物和空位置分别用 1 和 0 来表示。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>初始化<code>dp</code>数组为1，<code>dp[i][j]</code>表示从初始位置到第<code>i</code>行第<code>j</code>列的路径数。先初始化<code>dp</code>数组的<code>第0行</code>和<code>第0列</code>，<code>flag</code>用于记录<code>第0行</code>和<code>第0列</code>中第一个出现障碍物的位置，因为<code>第0行</code>和<code>第0列</code>中，如果出现障碍物，那么障碍物之后的所有格子，<code>dp[i][0] = dp[0][i] = 0</code>，因为不能往左和往上走。</p>
<p>对于第<code>i</code>行第<code>j</code>列，有状态转移方程：<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 先初始化dp数组的第0行和第0列，flag用于记录第0行和第0列中第一个出现障碍物的位置</span></span><br><span class="line">	<span class="comment">// 因为第0行和第0列中，如果出现障碍物，那么障碍物之后的所有格子，dp[i][0]=dp[0][i]=0</span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">			flag = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// flag&gt;=0说明存在障碍物，则将障碍物的dp值置0</span></span><br><span class="line">	<span class="keyword">if</span> (flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; m; ++i) &#123;</span><br><span class="line">			dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	flag = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">			flag = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; n; ++i) &#123;</span><br><span class="line">			dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、使用最小花费爬楼梯【LeetCode-easy】"><a href="#11、使用最小花费爬楼梯【LeetCode-easy】" class="headerlink" title="11、使用最小花费爬楼梯【LeetCode | easy】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯【LeetCode | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：cost &#x3D; [10, 15, 20]</span><br><span class="line">输出：15</span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出：6</span><br><span class="line">解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>假设数组<code>cost</code>的长度为<code>n</code>，则<code>n</code>个阶梯分别对应下标 0 到<code>n−1</code>，楼层顶部对应下标 <code>n</code>，问题等价于计算达到下标<code>n</code>的最小花费。可以通过动态规划求解。</p>
<p>创建长度为<code>n+1</code>的数组<code>dp</code>，其中<code>dp[i]</code>表示达到下标<code>i</code>的最小花费。</p>
<p>由于可以选择下标 0 或1 作为初始阶梯，因此有<code>dp[0] = dp[1] = 0</code>。</p>
<p>当 <code>2 ≤ i ≤ n</code>时，可以从下标<code>i−1</code>使用<code>cost[i−1]</code>的花费达到下标<code>i</code>，或者从下标<code>i−2</code>使用<code>cost[i−2]</code>的花费达到下标<code>i</code>。为了使总花费最小，<code>dp[i]</code>应取上述两项的最小值，因此状态转移方程如下：</p>
<p><code>dp[i] = min(dp[i−1] + cost[i−1], dp[i−2] + cost[i−2])</code></p>
<p>依次计算<code>dp</code>中的每一项的值，最终得到的<code>dp[n]</code>即为达到楼层顶部的最小花费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>], dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、除数博弈【LeetCode-1025-easy】"><a href="#12、除数博弈【LeetCode-1025-easy】" class="headerlink" title="12、除数博弈【LeetCode 1025 | easy】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divisor-game/">除数博弈【LeetCode 1025 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</span><br><span class="line">选出任一 x，满足 0 &lt; x &lt; N 且 N % x &#x3D;&#x3D; 0 。</span><br><span class="line">用 N - x 替换黑板上的数字 N 。</span><br><span class="line">如果玩家无法执行这些操作，就会输掉游戏。</span><br><span class="line">只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>数学方法递推。</p>
<ul>
<li><p>n = 1 的时候，区间 (0,1) 中没有整数是 n 的因数，所以此时 Alice 败。</p>
</li>
<li><p>n = 2 的时候，Alice 只能拿 1，n 变成 1， Bob 无法继续操作，故  Alice 胜。</p>
</li>
<li><p>n = 3 的时候，Alice 只能拿 1，n 变成 2，根据 n = 2 的结论，此时 Bob 会获胜，Alice 败。</p>
</li>
<li><p>n = 4 的时候，Alice 能拿 1 或 2，如果 Alice 拿 1，根据 n=3 的结论，Bob 会失败，Alice 会获胜。</p>
</li>
<li><p>n = 5 的时候，Alice 只能拿 1，根据 n=4 的结论，Alice 会失败。</p>
</li>
<li><p>……</p>
<p>发现这样一个现象：<strong>n 为奇数的时候 Alice（先手）必败，n 为偶数的时候 Alice 必胜。</strong> </p>
</li>
</ul>
<p>证明：</p>
<p>n = 1 和 n=2 时结论成立。</p>
<p>n &gt; 2 时，假设 n ≤ k 时该结论成立，则 n = k + 1 时：</p>
<ul>
<li>如果 k 为偶数，则 k+1 为奇数，x 是 k+1 的因数，只可能是奇数，而奇数减去奇数等于偶数，且 k+1−x ≤ k，故轮到 Bob 的时候都是偶数。而根据猜想假设 n≤k 的时候偶数的时候先手必胜，故此时无论 Alice 拿走什么，Bob 都会处于必胜态，所以 Alice 处于必败态。</li>
<li>如果 k 为奇数，则 k + 1为偶数，x 可以是奇数也可以是偶数，若 Alice 减去一个奇数，那么 k + 1 - x 是一个小于等于 k 的奇数，此时 Bob 占有它，处于必败态，则  Alice 处于必胜态。</li>
<li>综上所述，这个猜想是正确的。</li>
<li>时间复杂度：O(1)，空间复杂度：O(1)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>动态规划。</p>
<p>在「解法1」中，Alice 处在 n = k 的状态时，他做一步操作，必然使得 Bob 处于 n = m (m &lt; k) 的状态。因此只要看是否存在一个 m 是必败的状态，那么 Alice 直接执行对应的操作让当前的数字变成 m，Alice 就必胜了，如果没有任何一个是必败的状态的话，说明 Alice 无论怎么进行操作，最后都会让 Bob 处于必胜的状态，此时 Alice 是必败的。</p>
<p>结合以上 定义 f[i] 表示当前数字 i 的时候先手是处于必胜态还是必败态，true 表示先手必胜，false 表示先手必败，从前往后递推，根据上文的分析，枚举 i 在 (0, i) 中 i 的因数 j，看是否存在 f[i−j] 为必败态即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">5</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    f[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i % j == <span class="number">0</span> &amp;&amp; !f[i - j]) &#123;</span><br><span class="line">				f[i] = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、按摩师【LeetCode-面试题17-16-easy】"><a href="#13、按摩师【LeetCode-面试题17-16-easy】" class="headerlink" title="13、按摩师【LeetCode 面试题17.16 | easy】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-masseuse-lcci/">按摩师【LeetCode 面试题17.16 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</span><br><span class="line">示例 1：</span><br><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>定义<code>dp[i][0]</code>表示考虑前<code>i</code>个预约，第<code>i</code>个预约不接的最长预约时间，<code>dp[i][1]</code>表示考虑前<code>i</code>个预约，第<code>i</code>个预约接的最长预约时间。</p>
<p>从前往后计算<code>dp</code>值，假设已经计算出前<code>i−1</code>个<code>dp</code>值，考虑计算<code>dp[i][0/1]</code>的答案。</p>
<p>首先考虑<code>dp[i][0]</code>的转移方程，由于这个状态下第<code>i</code>个预约是不接的，所以第<code>i−1</code>个预约接或不接都可以，故可以从<code>dp[i−1][0]</code>和<code>dp[i−1][1]</code>两个状态转移过来，转移方程即为：</p>
<ul>
<li><code>dp[i][0] = max(dp[i−1][0], dp[i−1][1])</code></li>
</ul>
<p>对于<code>dp[i][1]</code>，由于这个状态下第<code>i</code>个预约要接，根据题目要求按摩师不能接受相邻的预约，所以第<code>i−1</code>个预约不能接受，故 只能从<code>dp[i−1][0]</code>这个状态转移过来，转移方程即为：</p>
<ul>
<li><code>dp[i][1] = dp[i−1][0]+nums[i]</code>，其中<code>nums [i]</code>表示第<code>i</code>个预约的时长。</li>
</ul>
<p>最后答案即为:</p>
<ul>
<li><code>max(dp[n][0],dp[n][1])</code>，其中<code>n</code>表示预约的个数。</li>
</ul>
<p>再回来看转移方程，发现计算<code>dp[i][0/1]</code>时，只与前一个状态<code>dp[i−1][0/1]</code>有关，所以 可以不用开数组，只用两个变量<code>dp_0</code>和<code>dp_1</code> 分别存储<code>dp[i−1][0]</code>和<code>dp[i−1][1]</code>的答案，然后去转移更新答案即可。</p>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp_0 = <span class="number">0</span>, dp_1 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;		</span><br><span class="line">        <span class="keyword">int</span> tmp_0 = <span class="built_in">max</span>(dp_0, dp_1);</span><br><span class="line">        <span class="keyword">int</span> tmp_1 = dp_0 + nums[i];</span><br><span class="line">        dp_0 = tmp_0;</span><br><span class="line">        dp_1 = tmp_1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp_0, dp_1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、打家劫舍【LeetCode-198-medium】"><a href="#14、打家劫舍【LeetCode-198-medium】" class="headerlink" title="14、打家劫舍【LeetCode 198 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍【LeetCode 198 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br><span class="line">示例 1：</span><br><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>
<p>如果房屋数量大于两间，有两个选项：</p>
<p>偷窃第<code>k</code>间房屋，那么就不能偷窃第<code>k-1</code>间房屋，偷窃总金额为前<code>k−2</code>间房屋的最高总金额与第<code>k</code>间房屋的金额之和；不偷窃第<code>k</code>间房屋，偷窃总金额为前<code>k−1</code>间房屋的最高总金额。在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前<code>k</code>间房屋能偷窃到的最高总金额。</p>
<ul>
<li><p>边界条件：<code>dp[0] = nums[0]</code>，<code>dp[1] = max(nums[0], nums[1])</code></p>
</li>
<li><p>状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code></p>
</li>
</ul>
<p>时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、打家劫舍-II【LeetCode-213-medium】"><a href="#15、打家劫舍-II【LeetCode-213-medium】" class="headerlink" title="15、打家劫舍 II【LeetCode 213 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II【LeetCode 213 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>因为有环，如果偷窃了第一间房屋，则不能偷窃最后一间房屋，因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。</p>
<p>假设数组<code>nums</code>的长度为<code>n</code>。</p>
<p>如果不偷窃最后一间房屋，则偷窃房屋的下标范围是<code> [0, n-2]</code>；如果不偷窃第一间房屋，则偷窃房屋的下标范围是<code> [1, n-1]</code>。在确定偷窃房屋的下标范围之后，即可用上一题的方法解决。对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在<code>n</code>间房屋中可以偷窃到的最高总金额。</p>
<p>假设偷窃房屋的下标范围是<code>[start, end]</code>，用 <code>dp[i]</code>表示在下标范围<code>[start,i]</code>内可以偷窃到的最高总金额，那么就有如下：</p>
<ul>
<li><p>边界条件：<code>dp[start] = nums[start]</code>，<code>dp[start + 1] = max(nums[start], nums[start + 1])</code></p>
</li>
<li><p>状态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code></p>
</li>
</ul>
<p>计算得到<code>dp[end]</code>即为下标范围<code>[start,end]</code>内可以偷窃到的最高总金额。</p>
<p>分别取<code>(start,end)=(0,n−2)</code>和<code>(start,end)=(1,n−1)</code>进行计算，取两个<code>dp[end]</code>中的最大值，即可得到最终结果。时间复杂度：<code>O(n)</code>，空间复杂度：<code>O(1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = nums[start], second = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = second;</span><br><span class="line">		second = <span class="built_in">max</span>(first + nums[i], second);</span><br><span class="line">		first = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robRange</span>(nums, <span class="number">0</span>, n - <span class="number">2</span>), <span class="built_in">robRange</span>(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、交错字符串【LeetCode-97-medium】"><a href="#16、交错字符串【LeetCode-97-medium】" class="headerlink" title="16、交错字符串【LeetCode 97 | medium】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interleaving-string/">交错字符串【LeetCode 97 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</span><br><span class="line">两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</span><br><span class="line">s &#x3D; s1 + s2 + ... + sn</span><br><span class="line">t &#x3D; t1 + t2 + ... + tm</span><br><span class="line">|n - m| &lt;&#x3D; 1</span><br><span class="line">交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</span><br><span class="line">提示：a + b 意味着字符串 a 和 b 连接。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s1 &#x3D; &quot;&quot;, s2 &#x3D; &quot;&quot;, s3 &#x3D; &quot;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210618212125.png"></p>
<p><strong>【解法】</strong>首先如果<code>|s1|+|s2|≠|s3∣</code>，那 <code>s3</code>必然不可能由<code>s1</code>和 <code>s2</code>交错组成。</p>
<p>在<code>|s1|+|s2|=|s3∣</code>时，可以用动态规划来求解。<strong>定义<code>f(i,j)</code>表示<code>s1</code>的前<code>i</code>个元素和 <code>s2</code>的前<code>j</code>个元素是否能交错组成<code>s3</code>的前<code>i+j</code>个元素</strong>。如果<code>s1</code>的第<code>i</code>个元素和<code>s3</code>的第<code>i+j</code>个元素相等，那么<code>s1</code>的前<code>i</code>个元素和 <code>s2</code>的前 <code>j</code>个元素是否能交错组成<code>s3</code>的前<code>i+j</code>个元素取决于<code>s1</code>的前<code>i−1</code>个元素和<code>s2</code>的前<code>j</code>个元素是否能交错组成<code>s3</code>的前 <code>i+j−1</code>个元素，即此时<code>f(i,j)</code>取决于<code>f(i−1,j)</code>，在此情况下如果<code>f(i−1,j)</code>为真，则<code>f(i,j)</code>也为真。同样的，如果 <code>s2</code>的第<code>j</code>个元素和<code>s3</code>的第<code>i+j</code>个元素相等并且<code>f(i,j−1)</code>为真，则<code>f(i, j)</code>也为真。于是可以推导出这样的动态规划转移方程：</p>
<p><code>f(i, j) = [f(i-1, j) &amp;&amp; s1[i-1] == s3[i+j-1]] or [f(i,j-1) &amp;&amp; s2[j-1] == s3[i+j-1]]</code></p>
<p>时间复杂度和空间复杂度都是 <code>O(nm)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(s1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(s2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>(), t = s3.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] |= (f[i - <span class="number">1</span>][j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[p]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                f[i][j] |= (f[i][j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[p]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="17、二维区域和检索-矩阵不可变"><a href="#17、二维区域和检索-矩阵不可变" class="headerlink" title="17、二维区域和检索 - 矩阵不可变"></a>17、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">二维区域和检索 - 矩阵不可变</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。上图子矩阵左上角 (row1, col1) &#x3D; (2, 1) ，右下角(row2, col2) &#x3D; (4, 3)，该子矩形内元素的总和为 8。</span><br><span class="line">示例：</span><br><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210619145021.png"></p>
<p><strong>【解法】</strong>定义一个二维<code>dp</code>数组，<code>dp[i][j]</code>表示从<code>(0,0)</code>到<code>(i,j)</code>范围内的元素总和。时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">	<span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">			dp.<span class="built_in">resize</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">					dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] + dp[i + <span class="number">1</span>][j] - dp[i][j] + matrix[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">return</span> dp[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - dp[row1][col2 + <span class="number">1</span>] - dp[row2 + <span class="number">1</span>][col1] + dp[row1][col1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="18、解码方法【LeetCode-91-medium】"><a href="#18、解码方法【LeetCode-91-medium】" class="headerlink" title="18、解码方法【LeetCode 91 | medium】"></a>18、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">解码方法【LeetCode 91 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span><br><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br><span class="line">要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：</span><br><span class="line">&quot;AAJF&quot; ，将消息分组为 (1 1 10 6)</span><br><span class="line">&quot;KJF&quot; ，将消息分组为 (11 10 6)</span><br><span class="line">注意，消息不能分组为  (1 11 06) ，因为 &quot;06&quot; 不能映射为 &quot;F&quot; ，这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价。</span><br><span class="line">给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</span><br><span class="line">题目数据保证答案肯定是一个 32 位 的整数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="19、目标和【LeetCode-494-medium】"><a href="#19、目标和【LeetCode-494-medium】" class="headerlink" title="19、目标和【LeetCode 494 | medium】"></a>19、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">目标和【LeetCode 494 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ：</span><br><span class="line">例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。</span><br><span class="line">返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1], target &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】动态规划。</strong></p>
<p>记数组的元素和为<code>sum</code>，添加<code>-</code>号的元素之和为<code>neg</code>，则其余添加<code>+</code>的元素之和为<code>sum−neg</code>，得到的表达式的结果为<code>(sum−neg)−neg = sum−2⋅neg = target</code>，即<code>neg = (sum−target) / 2</code>。    </p>
<p>由于数组<code>nums</code>中的元素都是非负整数，<code>neg</code>也必须是非负整数，所以上式成立的前提是<code>sum−target</code>是非负偶数。若不符合该条件可直接返回 0。</p>
<p>若上式成立，问题转化成在数组<code>nums</code>中选取若干元素，使得这些元素之和等于<code>neg</code>，计算选取元素的方案数。定义二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在数组<code>nums</code>的前<code>i</code>个数中选取元素，使得这些元素之和等于<code>j</code>的方案数。假设数组<code>nums</code>的长度为<code>n</code>，则最终答案为<code>dp[n][neg]</code>。</p>
<p>当没有任何元素可以选取时，元素和只能是 0，对应的方案数是 1，因此动态规划的边界条件是：</p>
<p><code>dp[0][j] = 1, j = 0 ; dp[0][j] = 0, j &gt;= 1</code></p>
<p>当<code>1≤i≤n</code>时，对于数组<code>nums</code>中的第<code>i</code>个元素<code>num</code>（<code>i</code>的计数从 1 开始），遍历<code>0 ≤ j ≤ neg</code>，计算 <code>dp[i][j]</code>的值：</p>
<ul>
<li>如果<code>j&lt;num</code>，则不能选<code>num</code>，此时有<code>dp[i][j]=dp[i−1][j]</code>；</li>
<li>如果<code>j ≥  num</code>，则如果不选<code>num</code>，方案数是<code>dp[i−1][j]</code>，如果选<code>num</code>，方案数是<code>dp[i−1][j−num]</code>，此时有<code>dp[i][j]=dp[i−1][j]+dp[i−1][j−num]</code>。</li>
</ul>
<p>因此状态转移方程如下：</p>
<p><code>dp[i][j]</code> = <code>dp[i−1][j]，j&lt;nums[i]</code>，</p>
<p><code>dp[i][j] = dp[i−1][j] + dp[i−1][j−nums[i]]，j&gt;=nums[i]</code>,</p>
<p>最终得到<code>dp[n][neg]</code>的值即为答案。</p>
<p>空间复杂度为<code>O(n×neg)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>&amp; num : nums) &#123;</span><br><span class="line">		sum += num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> diff = (sum - target) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (diff &lt; <span class="number">0</span> || diff % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), neg = diff / <span class="number">2</span>;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(neg + <span class="number">1</span>));</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> num = nums[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= neg; ++j) &#123;</span><br><span class="line">			dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= num) &#123;</span><br><span class="line">				dp[i][j] += dp[i - <span class="number">1</span>][j - num];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n][neg];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>回溯。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, target, index + <span class="number">1</span>, sum + nums[index]);</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, target, index + <span class="number">1</span>, sum - nums[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="20、最长递增子序列的个数【LeetCode-673-medium】"><a href="#20、最长递增子序列的个数【LeetCode-673-medium】" class="headerlink" title="20、最长递增子序列的个数【LeetCode 673 | medium】"></a>20、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长递增子序列的个数【LeetCode 673 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个未排序的整数数组，找到最长递增子序列的个数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>定义一个动态规划数组<code>dp</code>，<code>dp[i]</code>表示到<code>nums[i]</code>为止的最长递增子序列长度，<code>count[i]</code>表示到<code>nums[i]</code>为止的最长递增子序列个数。</p>
<ul>
<li>初始化状态：<code>dp = [1] * n</code>：代表最长递增子序列的长度至少为1，<code>count = [1] * n</code>：代表最长递增子序列的个数至少为1</li>
<li>状态转移：<br>对于每一个数<code>nums[i]</code>，看在它之前的数<code>nums[j](0&lt;= j &lt; i)</code>是否比当前数<code>nums[i]</code>小，如果<code>nums[i] &gt; nums[j]</code>，那么相当于到<code>nums[j]</code>为止的最长递增子序列长度到<code>nums[i]</code>增加了1，到<code>nums[i]</code>为止的最长递增子序列长度就变成了<code>dp[i] = dp[j] + 1</code>；但是因为满足<code>nums[i] &gt; nums[j]</code>的<code>nums[j]</code>不止一个，<code>dp[i]</code>应该取这些<code>dp[j] + 1</code>的最大值，并且这些<code>dp[j] + 1</code>还会有相等的情况，一旦相等，到<code>nums[i]</code>为止的最长递增子序列个数就应该增加了。因此，具体的状态转移如下，在<code>nums[i] &gt; nums[j]</code>的前提下：<ul>
<li>如果<code>dp[j] + 1 &gt; dp[i]</code>，说明最长递增子序列的长度增加了，<code>dp[i] = dp[j] + 1</code>，长度增加，数量不变<code>count[i] = count[j]</code></li>
<li>如果<code>dp[j] + 1 == dp[i]</code>，说明最长递增子序列的长度并没有增加，但是出现了长度一样的情况，数量增加<code>count[i] += count[j]</code></li>
<li>记录最长递增子序列的最大长度<code>max_length</code>。遍历<code>dp</code>数组，如果<code>dp</code>数组记录的最大长度<code>dp[i]</code>等于<code>max_length</code>，将对应的数量<code>count[i]</code>加到结果<code>res</code>中。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">					dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">					count[i] = count[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123;</span><br><span class="line">					count[i] += count[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到最大长度</span></span><br><span class="line">	<span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i: dp) &#123;</span><br><span class="line">		longest = <span class="built_in">max</span>(longest, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找到最大长度对应的子数组个数</span></span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dp[i] == longest) &#123;</span><br><span class="line">			res += count[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="21、连续的子数组和【LeetCode-523-medium】"><a href="#21、连续的子数组和【LeetCode-523-medium】" class="headerlink" title="21、连续的子数组和【LeetCode 523 | medium】"></a>21、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/continuous-subarray-sum/">连续的子数组和【LeetCode 523 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：子数组大小 至少为 2 ，且子数组元素总和为 k 的倍数。(如果存在一个整数 n ，令整数 x 符合 x &#x3D; n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。)</span><br><span class="line">如果存在，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 &#x3D; 7 * 6 且 7 是一个整数。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>前缀和+哈希表。首先计算出数组<code>nums</code>的前缀和数组，则对于任意一个子数组，都可以在<code>O(1)</code>的时间内得到其元素和。用<code>prefixSums[i]</code>表示数组<code>nums</code>从下标<code>0</code>到下标<code>i</code>的前缀和，则<code>nums</code>从下标<code>p+1</code>到下标 <code>q(p&lt;q）</code>的子数组的长度为<code>q−p</code>，该子数组的元素和为<code>prefixSums[q]−prefixSums[p]</code>。</p>
<p>如果<code>prefixSums[q]−prefixSums[p]</code>为<code>k</code>的倍数，且<code>q−p≥2</code>，则上述子数组即满足大小至少为 2 且元素和为 k 的倍数。</p>
<p>当<code>prefixSums[q]−prefixSums[p]</code>为<code>k</code>的倍数时，<code>prefixSums[p]</code>和<code>prefixSums[q]</code>除以<code>k</code>的余数相同。因此只需要计算每个下标对应的前缀和除以<code>k</code>的余数即可，使用哈希表存储每个余数第一次出现的下标。</p>
<p>规定空的前缀的结束下标为 −1，由于空的前缀的元素和为 0，因此在哈希表中存入键值对<code>(0,−1)</code>。对于<code>0≤i&lt;m</code>，从小到大依次遍历每个<code>i</code>，计算每个下标对应的前缀和除以<code>k</code>的余数，并维护哈希表：</p>
<ul>
<li>如果当前余数在哈希表中已经存在，则取出该余数在哈希表中对应的下标<code>prevIndex</code>，<code>nums</code>从下标 <code>prevIndex+1</code>到下标<code>i</code>的子数组的长度为<code>i−prevIndex</code>，该子数组的元素和为<code>k</code>的倍数，如果<code>i−prevIndex≥2</code>，则找到了一个大小至少为 2 且元素和为<code>k</code>的倍数的子数组，返回<code>true</code>；</li>
<li>如果当前余数在哈希表中不存在，则将当前余数和当前下标<code>i</code>的键值对存入哈希表中。</li>
</ul>
<p>由于哈希表存储的是每个余数第一次出现的下标，因此当遇到重复的余数时，根据当前下标和哈希表中存储的下标计算得到的子数组长度是以当前下标结尾的子数组中满足元素和为<code>k</code>的倍数的子数组长度中的最大值。只要最大长度至少为 2，即存在符合要求的子数组。时间复杂度：<code>O(m)</code>，其空间复杂度：<code>O(min(m,k))</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; unmap;</span><br><span class="line">	unmap[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		remainder = (remainder + nums[i]) % k;</span><br><span class="line">        <span class="comment">// 当前余数在哈希表中存在，说明存在和为k倍数的子数组，那么判断子数组的长度是否大于2</span></span><br><span class="line">		<span class="keyword">if</span> (unmap.<span class="built_in">count</span>(remainder)) &#123;</span><br><span class="line">			<span class="keyword">int</span> prevIndex = unmap[remainder];</span><br><span class="line">			<span class="keyword">if</span> (i - prevIndex &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 当前余数在哈希表中不存在，则加入</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			unmap[remainder] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="22、最长回文子序列【LeetCode-516-medium】"><a href="#22、最长回文子序列【LeetCode-516-medium】" class="headerlink" title="22、最长回文子序列【LeetCode 516 | medium】"></a>22、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列【LeetCode 516 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个字符串s，找到其中最长的回文子序列，并返回该序列的长度。可以假设s的最大长度为 1000 。</span><br><span class="line">示例 1:</span><br><span class="line">输入:&quot;bbbab&quot;</span><br><span class="line">输出:4</span><br><span class="line">一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入：&quot;cbbd&quot;</span><br><span class="line">输出:2</span><br><span class="line">一个可能的最长回文子序列为 &quot;bb&quot;。</span><br></pre></td></tr></table></figure>

<p>【解法】创建一个动态规划数组<code>dp</code>，<code>dp[i][j]</code>表示<code>s</code>的第<code>i</code>个字符到第<code>j</code>个字符组成的子串中，最长的回文序列的长度。如果<code>s</code>的第<code>i</code>个字符和第<code>j</code>个字符相同的话，<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code></p>
<p>如果<code>s</code>的第<code>i</code>个字符和第<code>j</code>个字符不同的话，<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code></p>
<p>然后注意遍历顺序，<code>i</code>从最后一个字符开始往前遍历，<code>j</code>从<code>i + 1</code>开始往后遍历，这样可以保证每个子问题都已经算好了。初始化<code>dp[i][i] = 1</code>，即单个字符的最长回文序列是 1。结果即为<code>dp[0][s.size()-1]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">				dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、贪心算法"><a href="#八、贪心算法" class="headerlink" title="八、贪心算法"></a>八、贪心算法</h4><h5 id="1、剪绳子-II【剑指Offer-14-2-medium】"><a href="#1、剪绳子-II【剑指Offer-14-2-medium】" class="headerlink" title="1、剪绳子 II【剑指Offer 14-2 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II【剑指Offer 14-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时， 把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>



<h4 id="九、位运算"><a href="#九、位运算" class="headerlink" title="九、位运算"></a>九、位运算</h4><h5 id="1、二进制中1的个数【剑指Offer-15-easy】"><a href="#1、二进制中1的个数【剑指Offer-15-easy】" class="headerlink" title="1、二进制中1的个数【剑指Offer 15| easy】 "></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数【剑指Offer 15| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</span><br><span class="line">示例 1：</span><br><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br><span class="line"> </span><br><span class="line">提示：输入必须是长度为 32 的 二进制串。</span><br></pre></td></tr></table></figure>

<p>【解法1】与运算：设二进制数字 n ，则有：</p>
<ul>
<li>若 n &amp; 1 = 0，则 n 二进制最右一位为 0 ；<br>若 n &amp; 1 = 1，则 n 二进制 最右一位为1 。</li>
</ul>
<p>时间复杂度 O(log2n)，逐位判断需循环log2n次，其中n代表数字 n 最高位 1 的所在位数，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】巧用 n &amp; (n - 1)</p>
<p>(n−1) ： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。<br>n &amp; (n - 1)： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502160033.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ++res;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、不用加减乘除做加法【剑指Offer-65-easy】"><a href="#2、不用加减乘除做加法【剑指Offer-65-easy】" class="headerlink" title="2、不用加减乘除做加法【剑指Offer 65 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法【剑指Offer 65 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</span><br><span class="line">示例:</span><br><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">提示：a, b 均可能是负数或 0，结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure>

<p>【解法】位运算实现加法，设两数字的二进制形式 a, b，其求和 s = a + b，a(i)代表 a 的二进制第 i 位，则分为以下四种情况：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502161551.png" style="zoom: 67%;" />

<p>无进位和和异或运算相同，仅为和与运算相同，因此无进位和 n 与进位 c的计算公式如下：<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502161733.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、数组中数字出现的次数【剑指Offer-56-1-medium】"><a href="#3、数组中数字出现的次数【剑指Offer-56-1-medium】" class="headerlink" title="3、数组中数字出现的次数【剑指Offer 56-1 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数【剑指Offer 56-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"> </span><br><span class="line">限制：2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】所有元素进行异或运算，最终算的结果即为两个不同的数异或的结果。将所有元素分为两组，两个不同的数分别在两个组中，分组的方法如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502170832.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, m = <span class="number">1</span>, n = <span class="number">0</span>;  <span class="comment">// x、y分别为出现1次的两个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 先求所有数异或，异或的结果即为出现1次的两个数的异或，即(x^y)</span></span><br><span class="line">        n ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((n &amp; m) == <span class="number">0</span>) &#123;  <span class="comment">// 找到(x异或y)的右边第一个1,对应的m</span></span><br><span class="line">        m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 相当于将原数组分为两组，每组包含一个仅出现1次的数字，剩下的数字均出现两次，异或的结果即为本身</span></span><br><span class="line">        <span class="keyword">if</span> (num &amp; m) &#123;</span><br><span class="line">            x ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y &#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h5 id="4、数组中数字出现的次数-II【剑指Offer-56-2-medium】"><a href="#4、数组中数字出现的次数-II【剑指Offer-56-2-medium】" class="headerlink" title="4、数组中数字出现的次数 II【剑指Offer 56-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II【剑指Offer 56-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; nums.length &lt;&#x3D; 10000，1 &lt;&#x3D; nums[i] &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】考虑数字的二进制形式，对于出现三次的数字，各二进制位 出现的次数都是 3 的倍数。因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502202826.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// int类型有32位，统计每一位1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">            count[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将count各元素对3求余，则结果为 “只出现一次的数字” 的各二进制位</span></span><br><span class="line">    <span class="comment">// 利用 左移操作 和 或运算 ，可将 countscounts 数组中各二进位的值恢复到数字 resres 上（循环区间是 i \in [0, 31]i∈[0,31] ）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;   <span class="comment">// 左移一位</span></span><br><span class="line">        res |= count[<span class="number">31</span> - i] % m;  <span class="comment">// 恢复第i位的直到res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、求1-2-…-n【剑指Offer-64-medium】"><a href="#5、求1-2-…-n【剑指Offer-64-medium】" class="headerlink" title="5、求1+2+…+n【剑指Offer 64 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n【剑指Offer 64 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</span><br><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】递归，用位运算作为递归的出口。逻辑运算符的短路效应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>)); <span class="comment">// 实现n=1时递归终止</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十、滑动窗口和双指针"><a href="#十、滑动窗口和双指针" class="headerlink" title="十、滑动窗口和双指针"></a>十、滑动窗口和双指针</h4><h5 id="1、和为s的连续正数序列【剑指Offer-57-2-easy】"><a href="#1、和为s的连续正数序列【剑指Offer-57-2-easy】" class="headerlink" title="1、和为s的连续正数序列【剑指Offer 57-2 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列【剑指Offer 57-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; target &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2、和为s的两个数字【剑指Offer-57-easy】"><a href="#2、和为s的两个数字【剑指Offer-57-easy】" class="headerlink" title="2、和为s的两个数字【剑指Offer 57 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字【剑指Offer 57 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br><span class="line"></span><br><span class="line">限制：1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5，1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3、滑动窗口的最大值【剑指Offer-59-1-medium】"><a href="#3、滑动窗口的最大值【剑指Offer-59-1-medium】" class="headerlink" title="3、滑动窗口的最大值【剑指Offer 59-1 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值【剑指Offer 59-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br><span class="line">示例:</span><br><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"> </span><br><span class="line">提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、容器盛水问题-【牛客网】"><a href="#4、容器盛水问题-【牛客网】" class="headerlink" title="4、容器盛水问题 |【牛客网】"></a>4、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/31c1aed01b394f0b8b7734de0324e00f?tpId=188&tags=&title=&difficulty=0&judgeStatus=0&rp=1">容器盛水问题 |【牛客网】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。</span><br><span class="line">示例1：</span><br><span class="line">输入：[3,1,2,5,2,4]  </span><br><span class="line">返回值：5 </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210606105640.png"></p>
<p>【解法】双指针。初始时左右指针<code>i</code>、<code>j</code>在数组的两端，选出<code>arr[i]</code>和<code>arr[j]</code>中最小的一个记为<code>minVal</code>。如果<code>arr[i]</code>最小，则左指针向右遍历，遍历过程中计算能装水的大小，直到遇到比<code>arr[i]</code>大则停止；如果<code>arr[j]</code>最小，则右指针向左遍历，遍历过程中计算能装水的大小，直到遇到比<code>arr[j]</code>大则停止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxWater</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = arr.<span class="built_in">size</span>() - <span class="number">1</span>, minVal;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        minVal = <span class="built_in">min</span>(arr[i], arr[j]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= minVal) &#123;</span><br><span class="line">            result += minVal - arr[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &lt;= minVal) &#123;</span><br><span class="line">            result += minVal - arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="十一、DFS和BFS-回溯"><a href="#十一、DFS和BFS-回溯" class="headerlink" title="十一、DFS和BFS+回溯"></a>十一、DFS和BFS+回溯</h4><h5 id="1、组合【LeetCode-77-medium】"><a href="#1、组合【LeetCode-77-medium】" class="headerlink" title="1、组合【LeetCode 77 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">组合【LeetCode 77 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span><br><span class="line">示例:</span><br><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:[</span><br><span class="line">      [2,4],</span><br><span class="line">      [3,4],</span><br><span class="line">      [2,3],</span><br><span class="line">      [1,2],</span><br><span class="line">      [1,3],</span><br><span class="line">      [1,4],</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>DFS+回溯组合枚举。<code>dfs(cur,n, k)</code>参数表示当前位置是<code>cur</code>，原序列总长度为<code>n</code>，当前序列有<code>k</code>个元素。原序列的每个位置在答案序列种的状态有被选中和不被选中两种，用<code>tmp</code>数组存放已经被选出的数字。</p>
<p>在进入<code>dfs(cur,n,k)</code>之前<code>[1, cur - 1]</code>位置的状态是确定的，而<code>[cur, n]</code>内位置的状态是不确定的，<code>dfs(cur,n,k)</code>需要确定<code>cur</code>位置的状态，然后求解子问题<code>dfs(cur+1, n,k)</code>。对于<code>cur</code>位置， 需要考虑<code>nums[cur]</code>取或者不取。如果取， 需要把<code>nums[cur]</code>放入一个临时的答案数组中（即上面代码中的<code>tmp</code>），再执行<code>dfs(cur+1, n,k)</code>，执行结束后需要对<code>tmp</code>进行回溯；如果不取，则直接执行<code>dfs(cur+1,n,k)</code>。在整个递归调用的过程中，<code>cur</code>是从小到大递增的，当<code>cur</code>增加到<code>n+1</code>的时候，记录答案并终止递归。在每次进入这个<code>dfs</code>函数时， 都去判断当前<code>tmp</code>的长度是否为<code>k</code>，如果为<code>k</code>，就把<code>tmp</code>加入答案并直接返回。</p>
<p>可以做一个剪枝，如果当前<code>tmp</code>的大小为 <code>s</code>，未确定状态的区间<code>[cur, n]</code>的长度为<code>t</code>，如果<code>s + t &lt; k</code>，那么即使<code>t</code>个都被选中，也不可能构造出一个长度为<code>k</code>的序列，故这种情况就没有必要继续向下递归，即可以在每次递归开始的时候做一次这样的判断：<code>temp.size() + (n - cur + 1) &lt; k</code>。</p>
<p>时间复杂度：<code>O((n, k) × k)</code>，空间复杂度：<code>O(n + k) = O(n)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() + (n - cur + <span class="number">1</span>) &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、组合总和-III【LeetCode-216-medium】"><a href="#2、组合总和-III【LeetCode-216-medium】" class="headerlink" title="2、组合总和 III【LeetCode 216 | medium】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">组合总和 III【LeetCode 216 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。说明：所有数字都是正整数。解集不能包含重复的组合。 </span><br><span class="line">示例 1:</span><br><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong>同上一题。在判断的时候加上和是否相等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() + (n - cur + <span class="number">1</span>) &lt; k || tmp.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() == k &amp;&amp; <span class="built_in">accumulate</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), <span class="number">0</span>) == sum) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);		</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k, sum);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, n, k, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">9</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、单词接龙-II【LeetCode-126-hard】"><a href="#3、单词接龙-II【LeetCode-126-hard】" class="headerlink" title="3、单词接龙 II【LeetCode 126 | hard】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder-ii/">单词接龙 II【LeetCode 126 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk 这样的单词序列，并满足：</span><br><span class="line">每对相邻的单词之间仅有单个字母不同。</span><br><span class="line">转换过程中的每个单词 si（1 &lt;&#x3D; i &lt;&#x3D; k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。</span><br><span class="line">sk &#x3D;&#x3D; endWord</span><br><span class="line">给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：[[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</span><br><span class="line">解释：存在 2 种最短的转换序列：</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</span><br><span class="line">&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：[]</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典 wordList 中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p><strong>【解法】</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4、矩阵中的路径【剑指Offer-12-medium】"><a href="#4、矩阵中的路径【剑指Offer-12-medium】" class="headerlink" title="4、矩阵中的路径【剑指Offer 12 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径【剑指Offer 12 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br><span class="line">例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424132400.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br><span class="line"> </span><br><span class="line">提示：1 &lt;&#x3D; board.length &lt;&#x3D; 200，1 &lt;&#x3D; board[i].length &lt;&#x3D; 200，board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="5、机器人的运动范围【剑指Offer-13-medium】"><a href="#5、机器人的运动范围【剑指Offer-13-medium】" class="headerlink" title="5、机器人的运动范围【剑指Offer 13 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围【剑指Offer 13 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</span><br><span class="line">示例 1：</span><br><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：1 &lt;&#x3D; n,m &lt;&#x3D; 100，0 &lt;&#x3D; k &lt;&#x3D; 20</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6、不同的二叉搜索树-II【LeetCode-95-medium】"><a href="#6、不同的二叉搜索树-II【LeetCode-95-medium】" class="headerlink" title="6、不同的二叉搜索树 II【LeetCode 95 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II【LeetCode 95 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个整数n，请你生成并返回所有由n个节点组成且节点值从 1 到 n 互不相同的不同二叉搜索树。可以按任意顺序返回答案。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210618212344.png"></p>
<p><strong>【解法】</strong>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为<code>n</code>，如果枚举根节点的值为<code>i</code>，那么根据二叉搜索树的性质可以知道左子树的节点值的集合为<code>[1…i−1]</code>，右子树的节点值的集合为<code>[i+1…n]</code>。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此可以用回溯的方法来解决。</p>
<p>定义<code>generateTrees(start, end)</code>函数表示当前值的集合为<code>[start,end]</code>，返回序列<code>[start,end]</code>生成的所有可行的二叉搜索树。枚举<code>[start,end]</code>中的值<code>i</code>为当前二叉搜索树的根，那么序列划分为了<code>[start,i−1]</code>和 <code>[i+1,end]</code>两部分。递归调用这两部分，即<code>generateTrees(start, i - 1)</code>和<code>generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，最后一步只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p>
<p>递归的入口即为<code>generateTrees(1, n)</code>，出口为当<code>start&gt;end</code>的时候，当前二叉搜索树为空，返回空节点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">			vector&lt;TreeNode*&gt; left_trees = <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">			vector&lt;TreeNode*&gt; right_trees = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : left_trees) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : right_trees) &#123;</span><br><span class="line">					TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">					node-&gt;left = l;</span><br><span class="line">					node-&gt;right = r;</span><br><span class="line">					allTrees.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> allTrees;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/BDC683FB0DA3F895F1DB53B3F311DE4C.png"></p>
<h4 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h4><h5 id="1、打印从1到最大的n位数【剑指Offer-15-easy】"><a href="#1、打印从1到最大的n位数【剑指Offer-15-easy】" class="headerlink" title="1、打印从1到最大的n位数【剑指Offer 15| easy】 "></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数【剑指Offer 15| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br><span class="line">示例 1:</span><br><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class="line"> </span><br><span class="line">说明：用返回一个整数列表来代替打印，n 为正整数</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>







<h5 id="2、顺时针打印矩阵【剑指Offer-29-easy】"><a href="#2、顺时针打印矩阵【剑指Offer-29-easy】" class="headerlink" title="2、顺时针打印矩阵【剑指Offer 29| easy】 "></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵【剑指Offer 29| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; matrix.length &lt;&#x3D; 100，0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、圆圈中最后剩下的数字【剑指Offer-62-easy】"><a href="#3、圆圈中最后剩下的数字【剑指Offer-62-easy】" class="headerlink" title="3、圆圈中最后剩下的数字【剑指Offer 62 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字【剑指Offer 62 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</span><br><span class="line">例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</span><br><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 10^5，1 &lt;&#x3D; m &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="4、扑克牌中的顺子【剑指Offer-61-easy】"><a href="#4、扑克牌中的顺子【剑指Offer-61-easy】" class="headerlink" title="4、扑克牌中的顺子【剑指Offer 61 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">扑克牌中的顺子【剑指Offer 61 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">限制：数组长度为5，数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="5、表示数值的字符串【剑指Offer-20-medium】"><a href="#5、表示数值的字符串【剑指Offer-20-medium】" class="headerlink" title="5、表示数值的字符串【剑指Offer 20 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串【剑指Offer 20 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、&quot;5e2&quot;、&quot;-123&quot;、&quot;3.1416&quot;、&quot;-1E-16&quot;、&quot;0123&quot;都表示数值，但&quot;12e&quot;、&quot;1a3.14&quot;、&quot;1.2.3&quot;、&quot;+-5&quot;及&quot;12e+5.4&quot;都不是。</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="6、数值的整数次方【剑指Offer-16-medium】"><a href="#6、数值的整数次方【剑指Offer-16-medium】" class="headerlink" title="6、数值的整数次方【剑指Offer 16 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方【剑指Offer 16 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">-2^31 &lt;&#x3D; n &lt;&#x3D; 2^31-1</span><br><span class="line">-10^4 &lt;&#x3D; x^n &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="7、数字序列中某一位的数字【剑指Offer-44-medium】"><a href="#7、数字序列中某一位的数字【剑指Offer-44-medium】" class="headerlink" title="7、数字序列中某一位的数字【剑指Offer 44 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">数字序列中某一位的数字【剑指Offer 44 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="8、构建乘积数组【剑指Offer-66-medium】"><a href="#8、构建乘积数组【剑指Offer-66-medium】" class="headerlink" title="8、构建乘积数组【剑指Offer 66 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">构建乘积数组【剑指Offer 66 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</span><br><span class="line">示例:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br><span class="line"> </span><br><span class="line">提示：所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">a.length &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="9、1～n-整数中-1-出现的次数【剑指Offer-43-medium】"><a href="#9、1～n-整数中-1-出现的次数【剑指Offer-43-medium】" class="headerlink" title="9、1～n 整数中 1 出现的次数【剑指Offer 43 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">1～n 整数中 1 出现的次数【剑指Offer 43 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</span><br><span class="line">例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="10、大数加法-【牛客网】"><a href="#10、大数加法-【牛客网】" class="headerlink" title="10、大数加法 【牛客网】"></a>10、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/11ae12e8c6fe48f883cad618c2e81475?tpId=188&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking">大数加法 【牛客网】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。（字符串长度不大于100000，保证字符串仅由&#39;0&#39;~&#39;9&#39;这10种字符组成）</span><br><span class="line">示例1</span><br><span class="line">输入：&quot;1&quot;,&quot;99&quot;</span><br><span class="line">返回值：&quot;100&quot;</span><br><span class="line"></span><br><span class="line">说明：1+99&#x3D;100 </span><br></pre></td></tr></table></figure>

<p>【解法】解法和链表加法一样，考虑进位。（本文中链表第10题）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">solve</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>, j = t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">	string result;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			tmp = (s[i] - <span class="string">&#x27;0&#x27;</span>) + (t[j] - <span class="string">&#x27;0&#x27;</span>) + flag;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			tmp = (i &gt;= <span class="number">0</span>) ? (s[i] - <span class="string">&#x27;0&#x27;</span>) + flag : (t[j] - <span class="string">&#x27;0&#x27;</span>) + flag;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			result.<span class="built_in">append</span>(<span class="built_in">to_string</span>(tmp - <span class="number">10</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">			result.<span class="built_in">append</span>(<span class="built_in">to_string</span>(tmp));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;  <span class="comment">// 最后一位如果有进位，需要加上</span></span><br><span class="line">		result.<span class="built_in">append</span>(<span class="built_in">to_string</span>(flag));</span><br><span class="line">	&#125;</span><br><span class="line">	std::<span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/">https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/28/Windows10%E6%9B%B4%E6%96%B0Nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___90FzfXFEEjo___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Windows10更新Nvidia显卡驱动</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/23/%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《现代操作系统》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">【剑指Offer 05 | easy】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">一、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II%E3%80%90%E5%89%91%E6%8C%87Offer-32-2-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、从上到下打印二叉树 II【剑指Offer 32-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%90%E5%89%91%E6%8C%87Offer-27-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、二叉树的镜像【剑指Offer 27 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-28-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、对称的二叉树【剑指Offer 28 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%90%E5%89%91%E6%8C%87Offer-55-1-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、二叉树的深度【剑指Offer 55-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-55-2-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、平衡二叉树【剑指Offer 55-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-54-easy%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、二叉搜索树的第k大节点【剑指Offer 54 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90%E5%89%91%E6%8C%87Offer-68-1-easy%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90%E5%89%91%E6%8C%87Offer-68-2-easy%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、二叉树的最近公共祖先【剑指Offer 68-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%90%E5%89%91%E6%8C%87Offer-26-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、树的子结构【剑指Offer 26 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%EF%BC%89%E3%80%90%E5%89%91%E6%8C%87Offer-07-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、重建二叉树（前序和中序）【剑指Offer 07 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90LeetCode-106-medium%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、从中序与后序遍历序列构造二叉树【LeetCode 106 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-32-1-medium%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、从上到下打印二叉树【剑指Offer 32-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III%E3%80%90%E5%89%91%E6%8C%87Offer-32-3-medium%E3%80%91"><span class="toc-number">13.</span> <span class="toc-text">13、从上到下打印二叉树 III【剑指Offer 32-3 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-33-medium%E3%80%91"><span class="toc-number">14.</span> <span class="toc-text">14、二叉搜索树的后序遍历序列【剑指Offer 33 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%90%E5%89%91%E6%8C%87Offer-34-medium%E3%80%91"><span class="toc-number">15.</span> <span class="toc-text">15、二叉树中和为某一值的路径【剑指Offer 34 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-37-medium%E3%80%91"><span class="toc-number">16.</span> <span class="toc-text">16、序列化和反序列化二叉树【剑指Offer 37 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5"><span class="toc-number"></span> <span class="toc-text">二、数组和矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E3%80%90LeetCode-189-medium%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、旋转数组【LeetCode 189 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-11-easy%E3%80%91%E3%80%90%E5%90%8CLeetCode-154%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、旋转数组的最小数字【剑指Offer 11 | easy】【同LeetCode 154】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%90LeetCode-153-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、寻找旋转排序数组中的最小值【LeetCode 153 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II%E3%80%90LeetCode-81-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、搜索旋转排序数组 II【LeetCode 81 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E3%80%90%E5%89%91%E6%8C%87Offer-11-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-40-easy%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、最小的k个数【剑指Offer 40 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-39-easy%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、数组中出现次数超过一半的数字【剑指Offer 39 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%B1%82%E4%BC%97%E6%95%B0-II%E3%80%90LeetCode-229-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、求众数 II【LeetCode 229 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、在排序数组中查找数字 I【剑指Offer 05 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%90%E5%89%91%E6%8C%87Offer-04-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、二维数组中的查找【剑指Offer 04 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%810%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-53-2-easy%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、0～n-1中缺失的数字【剑指Offer 53-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-45-medium%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、把数组排成最小的数【剑指Offer 45 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E3%80%90%E5%89%91%E6%8C%87Offer-51-hard%E3%80%91"><span class="toc-number">13.</span> <span class="toc-text">13、数组中的逆序对【剑指Offer 51 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E5%AF%BB%E6%89%BE%E7%AC%ACK%E5%A4%A7-%E7%89%9B%E5%AE%A2%E7%BD%91"><span class="toc-number">14.</span> <span class="toc-text">14、寻找第K大 | 牛客网</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">15.</span> <span class="toc-text">15、最长无重复子数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E3%80%90LeetCode-88-easy%E3%80%91"><span class="toc-number">16.</span> <span class="toc-text">16、合并两个有序数组【LeetCode 88 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E5%8A%A0%E4%B8%80%E3%80%90LeetCode-66-easy%E3%80%91"><span class="toc-number">17.</span> <span class="toc-text">17、加一【LeetCode 66 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E3%80%90LeetCode-118-easy%E3%80%91"><span class="toc-number">18.</span> <span class="toc-text">18、杨辉三角【LeetCode 118 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0%E3%80%90LeetCode-414-easy%E3%80%91"><span class="toc-number">19.</span> <span class="toc-text">19、第三大的数【LeetCode 414 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90LeetCode-268-easy%E3%80%91"><span class="toc-number">20.</span> <span class="toc-text">20、丢失的数字【LeetCode 268 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II-%E3%80%90LeetCode-219-easy%E3%80%91"><span class="toc-number">21.</span> <span class="toc-text">21、存在重复元素 II 【LeetCode 219 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E3%80%90LeetCode-167-easy%E3%80%91"><span class="toc-number">22.</span> <span class="toc-text">22、两数之和 II - 输入有序数组【LeetCode 167 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E3%80%81%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E3%80%90LeetCode-54-medium%E3%80%91"><span class="toc-number">23.</span> <span class="toc-text">23、螺旋矩阵【LeetCode 54 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24%E3%80%81%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II%E3%80%90LeetCode-59-medium%E3%80%91"><span class="toc-number">24.</span> <span class="toc-text">24、螺旋矩阵 II【LeetCode 59 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E3%80%81%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%E3%80%90LeetCode-57-medium%E3%80%91"><span class="toc-number">25.</span> <span class="toc-text">25、插入区间【LeetCode 57 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26%E3%80%81%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E3%80%90LeetCode-74-medium%E3%80%91"><span class="toc-number">26.</span> <span class="toc-text">26、搜索二维矩阵【LeetCode 74 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27%E3%80%81%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E3%80%90LeetCode-26-easy%E3%80%91"><span class="toc-number">27.</span> <span class="toc-text">27、删除有序数组中的重复项【LeetCode 26 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28%E3%80%81%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II-%E3%80%90LeetCode-80-medium%E3%80%91"><span class="toc-number">28.</span> <span class="toc-text">28、删除有序数组中的重复项 II 【LeetCode 80 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29%E3%80%81%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%E3%80%90LeetCode-128-medium%E3%80%91"><span class="toc-number">29.</span> <span class="toc-text">29、最长连续序列【LeetCode 128 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30%E3%80%81%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90LeetCode-209-medium%E3%80%91"><span class="toc-number">30.</span> <span class="toc-text">30、长度最小的子数组【LeetCode 209 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31%E3%80%81%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%E3%80%90LeetCode-73-medium%E3%80%91"><span class="toc-number">31.</span> <span class="toc-text">31、矩阵置零【LeetCode 73 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E3%80%81%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%E3%80%90LeetCode-41-hard%E3%80%91"><span class="toc-number">32.</span> <span class="toc-text">32、缺失的第一个正数【LeetCode 41 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#33%E3%80%81%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC%E3%80%90LeetCode-162-medium%E3%80%91"><span class="toc-number">33.</span> <span class="toc-text">33、寻找峰值【LeetCode 162 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#34%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-03-easy%E3%80%91%E3%80%90LeetCode-442-medium%E3%80%91"><span class="toc-number">34.</span> <span class="toc-text">34、数组中重复的数字【剑指Offer 03 | easy】【LeetCode 442 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#35%E3%80%81%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4%E3%80%90LeetCode-228-medium%E3%80%91"><span class="toc-number">35.</span> <span class="toc-text">35、汇总区间【LeetCode 228 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#36%E3%80%81%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E3%80%90LeetCode-628-easy%E3%80%91"><span class="toc-number">36.</span> <span class="toc-text">36、三个数的最大乘积【LeetCode 628 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#37%E3%80%81%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I%E3%80%90LeetCode-643-easy%E3%80%91"><span class="toc-number">37.</span> <span class="toc-text">37、子数组最大平均数 I【LeetCode 643 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#38%E3%80%81%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I%E3%80%90LeetCode-561-easy%E3%80%91"><span class="toc-number">38.</span> <span class="toc-text">38、数组拆分 I【LeetCode 561 | easy】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">三、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、替换空格【剑指Offer 05 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%90%E5%89%91%E6%8C%87Offer-50-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、第一个只出现一次的字符【剑指Offer 50 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%E3%80%90%E5%89%91%E6%8C%87Offer-42-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、连续子数组的最大和【剑指Offer 42 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E3%80%90%E5%89%91%E6%8C%87Offer-58-1-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、翻转单词顺序【剑指Offer 58-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer58-2-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、左旋转字符串【剑指Offer58-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-38-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、字符串的排列【剑指Offer 38 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-46-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、把数字翻译成字符串【剑指Offer 46 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-48-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、最长不含重复字符的子字符串【剑指Offer 48 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-67-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、把字符串转换成整数【剑指Offer 67 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E3%80%90LeetCode-5-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、最长回文子串 【LeetCode 5 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E3%80%90LeetCode-1143-medium%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、最长公共子序列 【LeetCode 1143 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E3%80%90LeetCode-14-easy%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、最长公共前缀 【LeetCode 14 | easy】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">四、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-06-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、从尾到头打印链表【剑指Offer 06 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-24-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、反转链表【剑指Offer 24 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-25-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、合并两个排序的链表【剑指Offer 25 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-22-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、链表中倒数第k个节点【剑指Offer 22 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-18-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、删除链表的节点【剑指Offer 18 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-52-easy%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、两个链表的第一个公共节点【剑指Offer 52 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%90%E5%89%91%E6%8C%87Offer-35-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、复杂链表的复制【剑指Offer 35 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-36-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、二叉搜索树与双向链表【剑指Offer 36 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E3%80%90LeetCode-2-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、两数相加【LeetCode 2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II-%E3%80%90LeetCode-445-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、两数相加 II 【LeetCode 445 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%90LeetCode-19-medium%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、删除链表的倒数第 N 个结点【LeetCode 19 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-23-hard%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、合并K个升序链表【LeetCode 23 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%90LeetCode-83-easy%E3%80%91"><span class="toc-number">13.</span> <span class="toc-text">13、 删除排序链表中的重复元素【LeetCode 83 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II%E3%80%90LeetCode-82-medium%E3%80%91"><span class="toc-number">14.</span> <span class="toc-text">14、删除排序链表中的重复元素 II【LeetCode 82 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-61-medium%E3%80%91"><span class="toc-number">15.</span> <span class="toc-text">15、旋转链表【LeetCode 61 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90LeetCode-24-medium%E3%80%91"><span class="toc-number">16.</span> <span class="toc-text">16、两两交换链表中的节点【LeetCode 24 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-25-hard%E3%80%91"><span class="toc-number">17.</span> <span class="toc-text">17、K 个一组翻转链表【LeetCode 25 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF-%E6%89%BE%E5%87%BA%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E3%80%90LeetCode-142-medium%E3%80%91"><span class="toc-number">18.</span> <span class="toc-text">18、判断链表是否有环&#x2F;找出环的入口【LeetCode 142 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E3%80%90LeetCode-203-easy%E3%80%91"><span class="toc-number">19.</span> <span class="toc-text">19、移除链表元素 【LeetCode 203 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E3%80%90LeetCode-143-medium%E3%80%91"><span class="toc-number">20.</span> <span class="toc-text">20、重排链表 【LeetCode 143 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E3%80%90LeetCode-147-medium%E3%80%91"><span class="toc-number">21.</span> <span class="toc-text">21、对链表进行插入排序 【LeetCode 147 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-328-medium%E3%80%91"><span class="toc-number">22.</span> <span class="toc-text">22、奇偶链表【LeetCode 328 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#23%E3%80%81%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%90LeetCode-109-medium%E3%80%91"><span class="toc-number">23.</span> <span class="toc-text">23、有序链表转换二叉搜索树【LeetCode 109 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#24%E3%80%81%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90LeetCode-1721-medium%E3%80%91"><span class="toc-number">24.</span> <span class="toc-text">24、交换链表中的节点【LeetCode 1721 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#25%E3%80%81%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-725-medium%E3%80%91"><span class="toc-number">25.</span> <span class="toc-text">25、分隔链表【LeetCode 725 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#26%E3%80%81%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-234-easy%E3%80%91"><span class="toc-number">26.</span> <span class="toc-text">26、回文链表【LeetCode 234 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#27%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9%E3%80%90LeetCode-1019-medium%E3%80%91"><span class="toc-number">27.</span> <span class="toc-text">27、链表中的下一个更大节点【LeetCode 1019 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-1367-medium%E3%80%91"><span class="toc-number">28.</span> <span class="toc-text">28、二叉树中的链表【LeetCode 1367 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#29%E3%80%81%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9%E3%80%90LeetCode-1171-medium%E3%80%91"><span class="toc-number">29.</span> <span class="toc-text">29、从链表中删去总和值为零的连续节点【LeetCode 1171 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#30%E3%80%81%E8%AE%BE%E8%AE%A1%E5%89%8D%E4%B8%AD%E5%90%8E%E9%98%9F%E5%88%97%E3%80%90LeetCode-1670-medium%E3%80%91"><span class="toc-number">30.</span> <span class="toc-text">30、设计前中后队列【LeetCode 1670 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#31%E3%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6%E3%80%90LeetCode-817-medium%E3%80%91"><span class="toc-number">31.</span> <span class="toc-text">31、链表组件【LeetCode 817 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#32%E3%80%81%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-430-medium%E3%80%91"><span class="toc-number">32.</span> <span class="toc-text">32、扁平化多级双向链表【LeetCode 430 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88-%E9%98%9F%E5%88%97-%E5%A0%86"><span class="toc-number"></span> <span class="toc-text">五、栈 &#x2F; 队列 &#x2F; 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-09-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、用两个栈实现队列【剑指Offer 09 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E3%80%90%E5%89%91%E6%8C%87Offer-30-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、包含min函数的栈【剑指Offer 30 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-31-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、栈的压入、弹出序列【剑指Offer 31 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-59-2-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、队列的最大值【剑指Offer 59-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-41-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、数据流中的中位数【剑指Offer 41 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II-%E3%80%90LeetCode-227-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、基本计算器 II 【LeetCode 227 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、表达式求值 【牛客网】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number"></span> <span class="toc-text">七、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-10-1-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、斐波那契数列【剑指Offer 10-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%E3%80%90%E5%89%91%E6%8C%87Offer-10-2-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、青蛙跳台阶问题【剑指Offer 10-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90%E3%80%90%E5%89%91%E6%8C%87Offer-14-1-medium%E3%80%91%E3%80%90LeetCode-343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、剪绳子【剑指Offer 14-1 | medium】【LeetCode 343 | 整数拆分】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-47-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、礼物的最大价值【剑指Offer 47 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%B8%91%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-49-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、丑数【剑指Offer 49 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E3%80%90LeetCode-131-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、分割回文串【LeetCode 131 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-60-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、n个骰子的点数【剑指Offer 60 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%E3%80%90%E5%89%91%E6%8C%87Offer-63-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、股票的最大利润【剑指Offer 63 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E3%80%90%E5%89%91%E6%8C%87Offer-19-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、正则表达式匹配【剑指Offer 19 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II%E3%80%90LeetCode-63-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、不同路径 II【LeetCode 63 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF%E3%80%90LeetCode-easy%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、使用最小花费爬楼梯【LeetCode | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%E3%80%90LeetCode-1025-easy%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、除数博弈【LeetCode 1025 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E6%8C%89%E6%91%A9%E5%B8%88%E3%80%90LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%9817-16-easy%E3%80%91"><span class="toc-number">13.</span> <span class="toc-text">13、按摩师【LeetCode 面试题17.16 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E3%80%90LeetCode-198-medium%E3%80%91"><span class="toc-number">14.</span> <span class="toc-text">14、打家劫舍【LeetCode 198 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II%E3%80%90LeetCode-213-medium%E3%80%91"><span class="toc-number">15.</span> <span class="toc-text">15、打家劫舍 II【LeetCode 213 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90LeetCode-97-medium%E3%80%91"><span class="toc-number">16.</span> <span class="toc-text">16、交错字符串【LeetCode 97 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">17.</span> <span class="toc-text">17、二维区域和检索 - 矩阵不可变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#18%E3%80%81%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%E3%80%90LeetCode-91-medium%E3%80%91"><span class="toc-number">18.</span> <span class="toc-text">18、解码方法【LeetCode 91 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#19%E3%80%81%E7%9B%AE%E6%A0%87%E5%92%8C%E3%80%90LeetCode-494-medium%E3%80%91"><span class="toc-number">19.</span> <span class="toc-text">19、目标和【LeetCode 494 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#20%E3%80%81%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%90LeetCode-673-medium%E3%80%91"><span class="toc-number">20.</span> <span class="toc-text">20、最长递增子序列的个数【LeetCode 673 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#21%E3%80%81%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E3%80%90LeetCode-523-medium%E3%80%91"><span class="toc-number">21.</span> <span class="toc-text">21、连续的子数组和【LeetCode 523 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#22%E3%80%81%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90LeetCode-516-medium%E3%80%91"><span class="toc-number">22.</span> <span class="toc-text">22、最长回文子序列【LeetCode 516 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">八、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90-II%E3%80%90%E5%89%91%E6%8C%87Offer-14-2-medium%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、剪绳子 II【剑指Offer 14-2 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number"></span> <span class="toc-text">九、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-15-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、二进制中1的个数【剑指Offer 15| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%E3%80%90%E5%89%91%E6%8C%87Offer-65-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、不用加减乘除做加法【剑指Offer 65 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-56-1-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、数组中数字出现的次数【剑指Offer 56-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II%E3%80%90%E5%89%91%E6%8C%87Offer-56-2-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、数组中数字出现的次数 II【剑指Offer 56-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%B1%821-2-%E2%80%A6-n%E3%80%90%E5%89%91%E6%8C%87Offer-64-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、求1+2+…+n【剑指Offer 64 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number"></span> <span class="toc-text">十、滑动窗口和双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-57-2-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、和为s的连续正数序列【剑指Offer 57-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-57-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、和为s的两个数字【剑指Offer 57 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-59-1-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、滑动窗口的最大值【剑指Offer 59-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%AE%B9%E5%99%A8%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98-%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、容器盛水问题 |【牛客网】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81DFS%E5%92%8CBFS-%E5%9B%9E%E6%BA%AF"><span class="toc-number"></span> <span class="toc-text">十一、DFS和BFS+回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%BB%84%E5%90%88%E3%80%90LeetCode-77-medium%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、组合【LeetCode 77 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III%E3%80%90LeetCode-216-medium%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、组合总和 III【LeetCode 216 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-II%E3%80%90LeetCode-126-hard%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、单词接龙 II【LeetCode 126 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%90%E5%89%91%E6%8C%87Offer-12-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、矩阵中的路径【剑指Offer 12 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%90%E5%89%91%E6%8C%87Offer-13-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、机器人的运动范围【剑指Offer 13 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II%E3%80%90LeetCode-95-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、不同的二叉搜索树 II【LeetCode 95 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number"></span> <span class="toc-text">十二、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-15-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、打印从1到最大的n位数【剑指Offer 15| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%E3%80%90%E5%89%91%E6%8C%87Offer-29-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、顺时针打印矩阵【剑指Offer 29| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-62-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、圆圈中最后剩下的数字【剑指Offer 62 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%E3%80%90%E5%89%91%E6%8C%87Offer-61-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、扑克牌中的顺子【剑指Offer 61 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-20-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、表示数值的字符串【剑指Offer 20 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%E3%80%90%E5%89%91%E6%8C%87Offer-16-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、数值的整数次方【剑指Offer 16 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-44-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、数字序列中某一位的数字【剑指Offer 44 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%E3%80%90%E5%89%91%E6%8C%87Offer-66-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、构建乘积数组【剑指Offer 66 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%811%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-43-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、1～n 整数中 1 出现的次数【剑指Offer 43 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95-%E3%80%90%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、大数加法 【牛客网】</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>