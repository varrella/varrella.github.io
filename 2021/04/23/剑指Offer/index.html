<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer &amp;&amp; Leetcode | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="【剑指Offer 05 | easy】本篇笔记中的题解参考了https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;jyd&#x2F;。 一、二叉树二叉树的数据结构： 123456struct TreeNode &amp;#123;	int val;	TreeNode* left;	TreeNode* right;	TreeNode(int x) :val(x), left(nullptr), right(nullpt">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer &amp;&amp; Leetcode">
<meta property="og:url" content="https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="【剑指Offer 05 | easy】本篇笔记中的题解参考了https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;jyd&#x2F;。 一、二叉树二叉树的数据结构： 123456struct TreeNode &amp;#123;	int val;	TreeNode* left;	TreeNode* right;	TreeNode(int x) :val(x), left(nullptr), right(nullpt">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-bfd4836.jpg">
<meta property="article:published_time" content="2021-04-23T14:37:14.000Z">
<meta property="article:modified_time" content="2021-05-31T15:12:44.052Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-bfd4836.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-31 23:12:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-bfd4836.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指Offer &amp;&amp; Leetcode</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-23T14:37:14.000Z" title="Created 2021-04-23 22:37:14">2021-04-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-05-31T15:12:44.052Z" title="Updated 2021-05-31 23:12:44">2021-05-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指Offer &amp;&amp; Leetcode"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h5 id="【剑指Offer-05-easy】"><a href="#【剑指Offer-05-easy】" class="headerlink" title="【剑指Offer 05 | easy】"></a>【剑指Offer 05 | easy】</h5><p>本篇笔记中的题解参考了<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/jyd/%E3%80%82">https://leetcode-cn.com/u/jyd/。</a></p>
<h4 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a>一、二叉树</h4><p>二叉树的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1、从上到下打印二叉树-II【剑指Offer-32-2-easy】"><a href="#1、从上到下打印二叉树-II【剑指Offer-32-2-easy】" class="headerlink" title="1、从上到下打印二叉树 II【剑指Offer 32-2 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II【剑指Offer 32-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历，用队列的size()来表示每层的节点个数。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	queue&lt;TreeNode*&gt; Q;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">				tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">				Q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、二叉树的镜像【剑指Offer-27-easy】"><a href="#2、二叉树的镜像【剑指Offer-27-easy】" class="headerlink" title="2、二叉树的镜像【剑指Offer 27 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像【剑指Offer 27 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class="line">例如输入：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line">镜像输出：</span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】递归。用tmp暂存root的左子节点，递归右子节点，返回值作为root的左子节点；递归左子节点，返回值作为root的右子节点。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode* tmp = root-&gt;left;</span><br><span class="line">	root-&gt;left = <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">	root-&gt;right = <span class="built_in">mirrorTree</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、对称的二叉树【剑指Offer-28-easy】"><a href="#3、对称的二叉树【剑指Offer-28-easy】" class="headerlink" title="3、对称的二叉树【剑指Offer 28 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树【剑指Offer 28 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>【解法】递归。对于两棵子树L和R，判断两节点 L-&gt;left 和 R-&gt;right 是否对称，即 recur(L-&gt;left, R-&gt;right) ；<br>判断两节点 L-&gt;right 和 R-&gt;left是否对称，即 recur(L-&gt;right, R-&gt;left) ；对称则应该为L的左子树节点的值等于R的右子树节点的值。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* L, TreeNode* R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> &amp;&amp; R == <span class="literal">nullptr</span>) &#123;  <span class="comment">// L和R都为空，则true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> || R == <span class="literal">nullptr</span> || L-&gt;val != R-&gt;val) &#123; <span class="comment">// L和R有一个为空或者二者值不相等，则为false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归比较L-&gt;left和R-&gt;right以及L-&gt;right和R-&gt;left是否相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(L-&gt;left, R-&gt;right) &amp;&amp; <span class="built_in">recur</span>(L-&gt;right, R-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="built_in">recur</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、二叉树的深度【剑指Offer-55-1-easy】"><a href="#4、二叉树的深度【剑指Offer-55-1-easy】" class="headerlink" title="4、二叉树的深度【剑指Offer 55-1 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度【剑指Offer 55-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span><br><span class="line">例如：给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br><span class="line"></span><br><span class="line">提示：节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历。用队列的size()来表示每层的节点个数。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		queue&lt;TreeNode*&gt; Q;</span><br><span class="line">		Q.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">				Q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			height++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、平衡二叉树【剑指Offer-55-2-easy】"><a href="#5、平衡二叉树【剑指Offer-55-2-easy】" class="headerlink" title="5、平衡二叉树【剑指Offer 55-2 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">平衡二叉树【剑指Offer 55-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span><br><span class="line">示例 1:给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   2</span><br><span class="line">    &#x2F; \</span><br><span class="line">   3   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false 。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 树的结点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法1（最优）】后序遍历+剪枝，对二叉树做后序遍历，从底至顶返回子树深度，因为在遍历到一个节点之前已经遍历了它的左右子树，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBalanced</span>(root-&gt;left, l) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right, r)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(l - r) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			depth = <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalanced</span>(root, depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】先序遍历+判断深度。构造一个获取当前子树的深度的函数 depth(root) ，通过比较左右子树的深度差 abs(depth(root.left) - depth(root.right)) &lt;= 1 是否成立，来判断某子树是否是二叉平衡树。然后递归判断左右子树是否都是平衡树。时间复杂度O(NlogN)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left), <span class="built_in">depth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">abs</span>(<span class="built_in">depth</span>(root-&gt;left) - <span class="built_in">depth</span>(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、二叉搜索树的第k大节点【剑指Offer-54-easy】"><a href="#6、二叉搜索树的第k大节点【剑指Offer-54-easy】" class="headerlink" title="6、二叉搜索树的第k大节点【剑指Offer 54 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点【剑指Offer 54 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一棵二叉搜索树，请找出其中第k大的节点。</span><br><span class="line">示例 1:输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">示例 2:输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br><span class="line"> </span><br><span class="line">限制：1 ≤ k ≤ 二叉搜索树元素个数</span><br></pre></td></tr></table></figure>

<p>【解法】二叉搜索树的中序遍历的倒序为递减序列。在遍历的过程中不断将k-1，直到为0。时间复杂度O(NlogN)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> k, res;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">			res = root-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">		<span class="built_in">dfs</span>(root);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="7、二叉搜索树的最近公共祖先【剑指Offer-68-1-easy】"><a href="#7、二叉搜索树的最近公共祖先【剑指Offer-68-1-easy】" class="headerlink" title="7、二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line">说明：所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br><span class="line">例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424130042.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>【解法】迭代法。循环搜索，当p、q都在root的左子树中，则遍历到root-&gt;left；当p、q都在root的右子树中，则遍历到root-&gt;right；如果p、q在root的两侧，则root即为最近公共祖先。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (root) &#123;</span><br><span class="line">		<span class="comment">// p、q都在root的左子树中</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">			root = root-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// p、q都在root的右子树中</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">			root = root-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p、q分别在root的两侧</span></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】递归。若p、q都在root的左子树中，则递归遍历左子树；若p、q都在root的右子树中，则递归遍历右子树；时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p、q都在root的左子树中</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// p、q都在root的右子树中</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、二叉树的最近公共祖先【剑指Offer-68-2-easy】"><a href="#8、二叉树的最近公共祖先【剑指Offer-68-2-easy】" class="headerlink" title="8、二叉树的最近公共祖先【剑指Offer 68-2 | easy】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先【剑指Offer 68-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</span><br><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424130223.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>【解法】递归左子树，返回值为left；递归右子树，返回值为right；left和right同时为空，则返回空；left和right同时不为空，说明p、q在root异侧，返回root；当left为空right不为空，则p、q都不在左子树中，返回right；当right为空left不为空，则p、q都不在右子树中，返回left。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果树为空则直接返回空；如果root等于p、q其中一个，那么最近公共祖先即为root，返回root</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归遍历左子树，在左子树中寻找p或q</span></span><br><span class="line">	TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">	<span class="comment">// 递归遍历右子树，在右子树中寻找p或q</span></span><br><span class="line">	TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 左子树中没找到p和q，则必然在右子树中;右子树中没找到p和q，则必然在左子树中;</span></span><br><span class="line">    <span class="comment">// 否则p、q在root两侧，则root即为最近公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> (left == <span class="literal">nullptr</span>) ? right: ((right == <span class="literal">nullptr</span>) ? left : root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、树的子结构【剑指Offer-26-medium】"><a href="#9、树的子结构【剑指Offer-26-medium】" class="headerlink" title="9、树的子结构【剑指Offer 26 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构【剑指Offer 26 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line">B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br><span class="line">例如:给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】递归判断B是否是A的左子树的子结构，B是否是A的右子树的子结构。时间复杂度O(MN)，空间复杂度O(M)，M、N分别为A、B的节点数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当A或B为空时直接返回false；若树 B 是树 A 的子结构，则有三种情况：</span></span><br><span class="line">    <span class="comment">// 以 节点 A 为根节点的子树 包含树 B， 即(recur(A, B)</span></span><br><span class="line">    <span class="comment">// 树 B 是 树 A 左子树的子结构，对应 isSubStructure(A-&gt;left, B)；</span></span><br><span class="line">    <span class="comment">// 树 B 是 树 A 右子树的子结构，对应 isSubStructure(A-&gt;right, B)；</span></span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">nullptr</span> &amp;&amp; B != <span class="literal">nullptr</span>) &amp;&amp; (<span class="built_in">recur</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || 			<span class="built_in">isSubStructure</span>(A-&gt;right, B));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断以A为根节点的树和以B为根节点的树是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">nullptr</span> || A-&gt;val != B-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">recur</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、重建二叉树【剑指Offer-07-medium】"><a href="#10、重建二叉树【剑指Offer-07-medium】" class="headerlink" title="10、重建二叉树【剑指Offer 07 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树【剑指Offer 07 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，给出：</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p>【解法】哈希表中保存中序遍历序列值和索引的对应关系，在建树的过程中遍历前序遍历序列，找出根节点，根据哈希表找到根节点在中序序列中的索引，根据索引值递归构造左子树和右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; preorder;</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dic;</span><br><span class="line">    <span class="comment">// root_index为前序序列中根节点对应的索引值，left为树的左边界，right为树的右边界</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">recur</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[root_index]);</span><br><span class="line">		<span class="keyword">int</span> index = dic[preorder[root_index]];</span><br><span class="line">        <span class="comment">// 左子树的根节点索引为上一个根节点索引值加1</span></span><br><span class="line">		node-&gt;left = <span class="built_in">recur</span>(root_index + <span class="number">1</span>, left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// index - left + 1为左子树加根节点的长度，加上根的索引值root_index，即为右子树的根节点索引</span></span><br><span class="line">		node-&gt;right = <span class="built_in">recur</span>(root_index + index - left + <span class="number">1</span>, index + <span class="number">1</span>, right);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;preorder = preorder;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			dic[inorder[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">recur</span>(<span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="11、从上到下打印二叉树【剑指Offer-32-1-medium】"><a href="#11、从上到下打印二叉树【剑指Offer-32-1-medium】" class="headerlink" title="11、从上到下打印二叉树【剑指Offer 32-1 | medium】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树【剑指Offer 32-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span><br><span class="line">例如:给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回：[3,9,20,15,7]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历。队列。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、从上到下打印二叉树-III【剑指Offer-32-3-medium】"><a href="#12、从上到下打印二叉树-III【剑指Offer-32-3-medium】" class="headerlink" title="12、从上到下打印二叉树 III【剑指Offer 32-3 | medium】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">从上到下打印二叉树 III【剑指Offer 32-3 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span><br><span class="line">例如:给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】层次遍历。把每层的节点存入vector中，并记录当前层次，如果当前层次为偶数，则逆序。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;TreeNode*&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">int</span> layer = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">		layer++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			TreeNode* node = Q.<span class="built_in">front</span>();</span><br><span class="line">			tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">			Q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (layer % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		result.<span class="built_in">push_back</span>(tmp);		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、二叉搜索树的后序遍历序列【剑指Offer-33-medium】"><a href="#13、二叉搜索树的后序遍历序列【剑指Offer-33-medium】" class="headerlink" title="13、二叉搜索树的后序遍历序列【剑指Offer 33 | medium】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列【剑指Offer 33 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span><br><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"> </span><br><span class="line">示例 1：</span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">提示：数组长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法1】借助一个单调栈  存储值递增的节点；每当遇到值递减的节点 ，则通过出栈来更新节点的父节点 root，每轮判断当前节点和父节点的关系，如果大于root，则不满足二叉搜索树定义，返回false；如果小于root，则满足二叉搜索树的定义，则继续遍历。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> root = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder[i] &gt; root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() &gt; postorder[i]) &#123;</span><br><span class="line">            root = S.<span class="built_in">top</span>();  <span class="comment">// 更新root</span></span><br><span class="line">            S.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        S.<span class="built_in">push</span>(postorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】根据二叉搜索树的性质递归判断所有子树的正确性。遍历后序序列[i, j]，寻找第一个大于根节点的节点，索引为m，此时可以划分出左子树区间[i, m-1]，[m, j-1]，递归判断左右子树区间对应的是否是二叉搜索树。时间复杂度O(N^2)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从左到右找到第一个比根节点大的节点对应的索引</span></span><br><span class="line">	<span class="keyword">while</span> (postorder[p] &lt; postorder[right]) &#123;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m = p;</span><br><span class="line">	<span class="comment">// 判断右子树中的节点是否都大于根节点</span></span><br><span class="line">	<span class="keyword">while</span> (postorder[p] &gt; postorder[right]) &#123;</span><br><span class="line">		++p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// p == right表示满足右子树都大于根节点，递归判断两个区间是否是二叉搜索树</span></span><br><span class="line">	<span class="keyword">return</span> p == right &amp;&amp; <span class="built_in">recur</span>(postorder, left, m - <span class="number">1</span>) &amp;&amp; <span class="built_in">recur</span>(postorder, m, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">recur</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、二叉树中和为某一值的路径【剑指Offer-34-medium】"><a href="#14、二叉树中和为某一值的路径【剑指Offer-34-medium】" class="headerlink" title="14、二叉树中和为某一值的路径【剑指Offer 34 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径【剑指Offer 34 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</span><br><span class="line">示例:给定如下二叉树，以及目标和 target &#x3D; 22，</span><br><span class="line">              5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   8</span><br><span class="line">           &#x2F;   &#x2F; \</span><br><span class="line">          11  13  4</span><br><span class="line">         &#x2F;  \    &#x2F; \</span><br><span class="line">        7    2  5   1</span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">提示：节点总数 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】二叉树的搜索问题，DFS+回溯。遍历每个节点，将当前节点添加到当前路径中，遍历到叶节点的时候判断当前路径和是否和目标值相等，相等则符合要求，否则回溯。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;target, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">	target -= root-&gt;val;</span><br><span class="line">	<span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root-&gt;left, target, result, path);</span><br><span class="line">	<span class="built_in">dfs</span>(root-&gt;right, target, result, path);</span><br><span class="line">	target += root-&gt;val;   <span class="comment">// 遍历完左右子树后回溯</span></span><br><span class="line">	path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">	<span class="built_in">dfs</span>(root, target, result, path);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、序列化二叉树【剑指Offer-37-medium】"><a href="#15、序列化二叉树【剑指Offer-37-medium】" class="headerlink" title="15、序列化二叉树【剑指Offer 37 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">序列化二叉树【剑指Offer 37 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line">示例: 你可以将以下二叉树：</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>

<p>【解法】序列化过程中，层次遍历，遇到空节点则表示为”# “；</p>
<p>反序列化过程中，遍历字符串，将每个值构造一个对应的节点存入数组中，遍历节点数组，根据左右节点和根节点的索引关系构造左右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	ostringstream output;</span><br><span class="line">	queue&lt;TreeNode*&gt; que;</span><br><span class="line">	que.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) output &lt;&lt; <span class="string">&quot;# &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			output &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> output.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;TreeNode*&gt; node_vec;</span><br><span class="line">	string val;</span><br><span class="line">	<span class="function">istringstream <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (input &gt;&gt; val) &#123;</span><br><span class="line">		<span class="keyword">if</span> (val == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">			node_vec.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node_vec.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node_vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node_vec[i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node_vec[i]-&gt;left = node_vec[pos++];</span><br><span class="line">		node_vec[i]-&gt;right = node_vec[pos++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node_vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【补充说明】ostringstream：向string中写入数据，使用它来格式化字符串，最后通过str()得到stream中的string拷贝。</p>
<p>istringstream：从string中读取数据，例如我们有一行单词，然后对该行单词中的各个单词逐个处理。</p>
<h4 id="二、数组和矩阵"><a href="#二、数组和矩阵" class="headerlink" title="二、数组和矩阵"></a>二、数组和矩阵</h4><h5 id="1、数组中重复的数字【剑指Offer-03-easy】"><a href="#1、数组中重复的数字【剑指Offer-03-easy】" class="headerlink" title="1、数组中重复的数字【剑指Offer 03 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字【剑指Offer 03 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】找出数组中重复的数字。</span><br><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：2 &lt;&#x3D; n &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<p><strong>【解法1】</strong>哈希表，遍历数组，存放次数每个元素出现的次数。时间复杂度 O(N)，空间复杂度 O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; unmap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unmap[num]) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;				</span><br><span class="line">        &#125;		</span><br><span class="line">        unmap[num] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【解法2】</strong>就地交换。注意所有数字都在 0～n-1 的范围内，即数组元素的索引和值是一对多的关系，因此可以建立索引和值的映射。第一次遇到数字nums[i]时，将其交换到索引i处；当第二次遇到数字nums[i]时，一定有nums[nums[i]]=nums[i]。时间复杂度 O(N)，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i) &#123; <span class="comment">// 如果值等于索引，则遍历下一个元素</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 代表索引nums[i]处和索引i处的元素值都为nums[i],即找到一组重复值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将值和索引对应</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、旋转数组的最小数字【剑指Offer-11-easy】"><a href="#2、旋转数组的最小数字【剑指Offer-11-easy】" class="headerlink" title="2、旋转数组的最小数字【剑指Offer 11 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字【剑指Offer 11 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </span><br><span class="line">示例 1：</span><br><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>【解法】二分查找，left和right分别指向数组两端，mid为left和right中点；</p>
<p>如果比较nums[left]和nums[mid]，如<code>[3, 4, 5, 1, 2]</code>与 <code>[1, 2, 3, 4, 5]</code> ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，无法进行查询；</p>
<p>如果比较nums[right]和nums[mid]，如<code>[1, 2, 3, 4, 5]</code>、<code>[3, 4, 5, 1, 2]</code>、<code>[2, 3, 4, 5 ,1]</code>，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p>
<p>时间复杂度O(logN)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123; <span class="comment">// 中间元素小于右边元素，则最小值在数组左半部分</span></span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123; <span class="comment">// 中间元素大于右边元素，则最小值在数组右半部</span></span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">// 中间元素等于右边元素，则不能草率地下定结论最小数字在哪一边，但把 right 舍弃掉，并不影响结果</span></span><br><span class="line">			right -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、调整数组顺序使奇数位于偶数前面【剑指Offer-11-easy】"><a href="#3、调整数组顺序使奇数位于偶数前面【剑指Offer-11-easy】" class="headerlink" title="3、调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</span><br><span class="line">示例：</span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class="line"> </span><br><span class="line">提示：0 &lt;&#x3D; nums.length &lt;&#x3D; 50000，1 &lt;&#x3D; nums[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】设置头尾双指针，头指针向右遍历找到第一个偶数，尾指针向左遍历找到第一个奇数，二者交换，在遍历过程中始终保证头指针小于等于尾指针。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// i从左向右指向第一个偶数，j从右向左指向第一个奇数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; (nums[i] &amp; <span class="number">1</span>)) &#123; <span class="comment">// nums[i]是奇数，i++</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; !(nums[j] &amp; <span class="number">1</span>)) &#123; <span class="comment">// nums[j]是偶数，j--</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、最小的k个数【剑指Offer-40-easy】"><a href="#4、最小的k个数【剑指Offer-40-easy】" class="headerlink" title="4、最小的k个数【剑指Offer 40 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数【剑指Offer 40 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br><span class="line">示例 1：</span><br><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 10000，0 &lt;&#x3D; arr[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法1】Top k问题的最优解，快速选择算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>【解法2】快排。时间复杂度O(NlogN)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[j] &gt;= nums[left] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (nums[i] &lt;= nums[left] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">	result.<span class="built_in">assign</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法3】最大堆。维护元素个数为k的最大堆，时间复杂度O(Nlogk)，空间复杂度O(k)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Q.<span class="built_in">size</span>() &lt; k) &#123; <span class="comment">// 当堆中元素个数小于k时直接入堆</span></span><br><span class="line">            Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 当堆中已有k个元素时，堆顶元素和新来的元素中最小的值入堆</span></span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Q.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(Q.<span class="built_in">top</span>());</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、数组中出现次数超过一半的数字【剑指Offer-39-easy】"><a href="#5、数组中出现次数超过一半的数字【剑指Offer-39-easy】" class="headerlink" title="5、数组中出现次数超过一半的数字【剑指Offer 39 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字【剑指Offer 39 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p>【解法】本题常见的三种解法：</p>
<ul>
<li>哈希表统计法： 遍历数组 nums ，用 HashMap 统计各数字的数量，即可找出众数 。此方法时间和空间复杂度均为 O(N) 。</li>
<li>数组排序法： 将数组 nums 排序，数组中点的元素 一定为众数。</li>
<li>【最优解】摩尔投票法： 核心理念为票数正负抵消 。时间和空间复杂度分别为 O(N)和O(1) 。</li>
</ul>
<p>【摩尔投票法】设输入数组 nums 的众数为 x，数组长度为 n 。本题将 “数组中出现次数超过一半的数字” 简称为 <strong>“众数”</strong>。</p>
<p>推论一： 若记众数的票数为 +1 ，非众数的票数为 −1 ，则一定有所有数字的票数和 &gt; 0 。</p>
<p>推论二： 若数组的前 a 个数字的票数和 = 0 ，则数组剩余 (n−a) 个数字的票数和一定仍 &gt; 0 ，即后(n−a) 个数字的众数仍为 x 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 找到众数</span></span><br><span class="line">	<span class="keyword">int</span> vote = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vote == <span class="number">0</span>) &#123;</span><br><span class="line">			x = num;</span><br><span class="line">		&#125;</span><br><span class="line">		vote += (x == num) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断找到的数是否超过数组元素的一半，如果题目中未提示是否存在超过一半的数的话需要加上这个判断</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num == x) &#123;</span><br><span class="line">			++count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count &gt; nums.<span class="built_in">size</span>() / <span class="number">2</span> ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、在排序数组中查找数字-I【剑指Offer-05-easy】"><a href="#6、在排序数组中查找数字-I【剑指Offer-05-easy】" class="headerlink" title="6、在排序数组中查找数字 I【剑指Offer 05 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">在排序数组中查找数字 I【剑指Offer 05 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】统计一个数字在排序数组中出现的次数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p>【解法】排序数组中的查找用二分法。进行两次二分，第一次查找右边界right，第二次查找左边界left，right-left-1的值即为次数。优化方法：第一次找到 target 的右边界，第二次找到 target-1 的右边界，两数相减即为次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(nums, target) - <span class="built_in">helper</span>(nums, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、二维数组中的查找【剑指Offer-04-medium】"><a href="#7、二维数组中的查找【剑指Offer-04-medium】" class="headerlink" title="7、二维数组中的查找【剑指Offer 04 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找【剑指Offer 04 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line">示例:现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; n &lt;&#x3D; 1000，0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】根据数组的特点，指定两个指针 i 和 j，初始时 i 指向最后一行，j 指向第一列。比较当前值和target的大小，如果<code>matrix[i][j]</code>大于target，说明<code>matrix[i][j]</code>所在的行中所有的值都大于target，因此 i–，即向上一行；如果<code>matrix[i][j]</code>小于target，说明<code>matrix[i][j]</code>所在的列中当前值以上的所有值都小于target，因此 j++，即向右一行。时间复杂度O(M+N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">			--i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、0～n-1中缺失的数字【剑指Offer-53-2-easy】"><a href="#8、0～n-1中缺失的数字【剑指Offer-53-2-easy】" class="headerlink" title="8、0～n-1中缺失的数字【剑指Offer 53-2 | easy】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字【剑指Offer 53-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。比较<code>nums[mid]</code> 和 索引 mid 之间是否对应，如果相等，则在右半部分中查找；否则在左半部分查找。时间复杂度O(logN)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">            i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、把数组排成最小的数【剑指Offer-45-medium】"><a href="#9、把数组排成最小的数【剑指Offer-45-medium】" class="headerlink" title="9、把数组排成最小的数【剑指Offer 45 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数【剑指Offer 45 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br><span class="line"> </span><br><span class="line">提示:0 &lt; nums.length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】排序数组中的搜索：二分法。本质上是一个排序问题，设数组 nums 中任意两数字的字符串为 x 和 y，则规定排序判断规则为：</p>
<p>若拼接字符串 x + y &gt; y + x，则 x “大于” y ；反之，若 x + y &lt; y + x，则 x “小于” y ；x “小于” y 代表：排序完成后，数组中 x 应在 y 左边；“大于” 则反之。如：x = “30”, y = “3”, x + y = “303” &lt; y + x = “330”，所以 x 应该放在 y 的左侧。利用快排完成排序，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = left, j = right;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 从右到左找到第一个满足 x + y &lt; y + x 的j</span></span><br><span class="line">		<span class="keyword">while</span> ((str[j] + str[left] &gt;= str[left] + str[j]) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 从左到右找到第一个满足 x + y &gt; y + x 的i</span></span><br><span class="line">		<span class="keyword">while</span> ((str[i] + str[left] &lt;= str[left] + str[i]) &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(str[i], str[j]);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(str[i], str[left]);</span><br><span class="line">	<span class="built_in">quickSort</span>(str, left, i - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quickSort</span>(str, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; str;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">		str.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">quickSort</span>(str, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	string result;</span><br><span class="line">	<span class="keyword">for</span> (string s : str) &#123;</span><br><span class="line">		result.<span class="built_in">append</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、数组中的逆序对【剑指Offer-51-hard】"><a href="#10、数组中的逆序对【剑指Offer-51-hard】" class="headerlink" title="10、数组中的逆序对【剑指Offer 51 | hard】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对【剑指Offer 51 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p>【解法】归并排序和逆序对息息相关。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 较短排序数组 合并为 较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210501202136.png"></p>
<p>时间复杂度 O(NlogN) ，空间复杂度 O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">merge</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="built_in">merge</span>(left, mid, nums);</span><br><span class="line">            <span class="built_in">merge</span>(mid + <span class="number">1</span>, right, nums);</span><br><span class="line">            <span class="built_in">mergeSort</span>(left, mid, right, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> 	</span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">((right - left + <span class="number">1</span>), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count += (mid - i + <span class="number">1</span>);</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 把右边剩余的数移入数组</span></span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; tmp.<span class="built_in">size</span>(); ++index) &#123;</span><br><span class="line">            nums[index + left] = tmp[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h4><h5 id="1、替换空格【剑指Offer-05-easy】"><a href="#1、替换空格【剑指Offer-05-easy】" class="headerlink" title="1、替换空格【剑指Offer 05 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格【剑指Offer 05 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】遍历一遍字符串，记录字符串中的空格数量，将字符串扩容；扩容后从尾部开始遍历，如果i对应的字符是空格的话，就在j~j-2位置替换成”%20”。时间复杂度 O(N) ，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// i指向原字符串的最后一位</span></span><br><span class="line">    s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + <span class="number">2</span> * count);</span><br><span class="line">    <span class="comment">// j指向扩容后的字符串的最后一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>; --j, --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[j] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[j] = <span class="string">&#x27;%&#x27;</span>;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、第一个只出现一次的字符【剑指Offer-50-easy】"><a href="#2、第一个只出现一次的字符【剑指Offer-50-easy】" class="headerlink" title="2、第一个只出现一次的字符【剑指Offer 50 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">第一个只出现一次的字符【剑指Offer 50 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</span><br><span class="line">示例:</span><br><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</span><br></pre></td></tr></table></figure>

<p>【解法】利用哈希表来记录字符是否重复出现，遍历字符串，若该字符在哈希表中出现过，对应的值为false，若该字符没出现过，则对应的值为true。第二次遍历字符串，如果在哈希表中对应的值为true，则该字符即为第一个只出现一次的字符。时间复杂度O(n)，空间复杂度O(∣Σ∣)，其中Σ 是字符集，在本题中 s 只包含小写字母，因此 ∣Σ∣≤26。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; dic;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : s) &#123;</span><br><span class="line">        dic[c] = (dic.<span class="built_in">find</span>(c) == dic.<span class="built_in">end</span>());    <span class="comment">//如果没找到，说明是第一次出现为true，如果是多次出现，则是false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic[c]) &#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：unordered_map::count()是C++中的内置方法，用于通过给定 key 对unordered_map中存在的元素数量进行计数，由于unordered_map不允许存储具有重复键的元素，因此count()函数本质上检查unordered_map中是否存在具有给定键的元素。如果Map中存在具有给定键的值，则此函数返回1，否则返回0。</p>
<p>通过unordered_map::find()来判断key是否存在，如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回unordered_map::end。</p>
<h5 id="3、连续子数组的最大和【剑指Offer-42-easy】"><a href="#3、连续子数组的最大和【剑指Offer-42-easy】" class="headerlink" title="3、连续子数组的最大和【剑指Offer 42 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和【剑指Offer 42 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</span><br><span class="line">要求时间复杂度为O(n)。</span><br><span class="line">示例1:</span><br><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br><span class="line"> </span><br><span class="line">提示：1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5，-100 &lt;&#x3D; arr[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】动态规划。状态转移方程：<br>$$<br>dp[i] = dp[i-1]+nums[i],   dp[i-1]&gt;0<br>$$</p>
<p>$$<br>dp[i]=nums[i],dp[i-1]&lt;=0<br>$$</p>
<p>时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        nums[i] += <span class="built_in">max</span>(<span class="number">0</span>, nums[i - <span class="number">1</span>]);</span><br><span class="line">        result = <span class="built_in">max</span>(result, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、翻转单词顺序【剑指Offer-58-1-easy】"><a href="#4、翻转单词顺序【剑指Offer-58-1-easy】" class="headerlink" title="4、翻转单词顺序【剑指Offer 58-1 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">翻转单词顺序【剑指Offer 58-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line"> </span><br><span class="line">说明：无空格字符构成一个单词。输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>【解法】双指针。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个字符</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左寻找第一个空格</span></span><br><span class="line">        <span class="keyword">int</span> i = j;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加单词到结果，每个单词后面加上一个空格</span></span><br><span class="line">        result.<span class="built_in">append</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - i) + <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="comment">// 继续往前分割单词</span></span><br><span class="line">        j = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后的空格</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、左旋转字符串【剑指Offer58-2-easy】"><a href="#5、左旋转字符串【剑指Offer58-2-easy】" class="headerlink" title="5、左旋转字符串【剑指Offer58-2 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串【剑指Offer58-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br><span class="line">示例 1：</span><br><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】字符串截取。也可用求余的方法计算下标。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    string str1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, n);</span><br><span class="line">    string str2 = s.<span class="built_in">substr</span>(n, s.<span class="built_in">size</span>() - n);</span><br><span class="line">    result = str2 + str1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求余计算下标</span></span><br><span class="line">    <span class="comment">// string result;</span></span><br><span class="line">    <span class="comment">// for (int i = n; i &lt; n + s.length(); i++) &#123;</span></span><br><span class="line">    <span class="comment">//     result += (s[i % s.length()]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return result;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、字符串的排列【剑指Offer-38-medium】"><a href="#6、字符串的排列【剑指Offer-38-medium】" class="headerlink" title="6、字符串的排列【剑指Offer 38 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">字符串的排列【剑指Offer 38 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span><br><span class="line">示例:</span><br><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8</span><br></pre></td></tr></table></figure>

<p>【解法】DFS+回溯。先固定一位，然后交换后两位。时间复杂度 O(N!N)： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，即复杂度为 O(N!)；字符串拼接操作 join() 使用 O(N) ；因此总体时间复杂度为 O(N!N) 。空间复杂度 O(N^2) ： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N) ；递归中辅助 Set 累计存储的字符数量最多为 N + (N-1) + … + 2 + 1 = (N+1)N/2，即占用 O(N^2)的额外空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> index, vector&lt;string&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 添加排列方案</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 重复，进行剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">find</span>(s[i]) != st.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[index]); <span class="comment">// 交换，将s[i]固定在第index位</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, index + <span class="number">1</span>, result); <span class="comment">// 开启固定第index+1位字符</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i], s[index]); <span class="comment">// 恢复交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、把数字翻译成字符串【剑指Offer-46-medium】"><a href="#7、把数字翻译成字符串【剑指Offer-46-medium】" class="headerlink" title="7、把数字翻译成字符串【剑指Offer 46 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串【剑指Offer 46 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; num &lt; 231</span><br></pre></td></tr></table></figure>

<p>【解法】动态规划。状态转移方程：<br>$$<br>如果后两位能表示一个字符：dp[i]=dp[i-1]+dp[i-2]<br>$$</p>
<p>$$<br>如果后两位不能表示一个字符：dp[i]=dp[i-1]<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>);  <span class="comment">// 保持下标一致</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 判断这两个字符能否符合要求，有两种情况：</span></span><br><span class="line">        <span class="comment">// 前一位字符为&#x27;1&#x27;，后一位字符能在&#x27;0&#x27;-&#x27;9&#x27;之间</span></span><br><span class="line">        <span class="comment">// 前一位字符为&#x27;2&#x27;，后一位字符只能在&#x27;0&#x27;-&#x27;5&#x27;之间</span></span><br><span class="line">        <span class="keyword">if</span> ((s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            || (s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、最长不含重复字符的子字符串【剑指Offer-48-medium】"><a href="#8、最长不含重复字符的子字符串【剑指Offer-48-medium】" class="headerlink" title="8、最长不含重复字符的子字符串【剑指Offer 48 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">最长不含重复字符的子字符串【剑指Offer 48 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"> </span><br><span class="line">提示：s.length &lt;&#x3D; 40000</span><br></pre></td></tr></table></figure>

<p>【解法】滑动窗口，通过left和right限定窗口的位置，确保窗口内的元素彼此不同。当窗口最右边的元素在窗口内存在了，则向右移动left直至排除掉重复的元素。used数组用来记录哪些字符已经被使用过了。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(<span class="number">256</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// 若元素重复，则left一直向右移，直至该重复元素处</span></span><br><span class="line">        <span class="keyword">while</span> (used[s[right]]) &#123;</span><br><span class="line">            used[s[left]] = <span class="literal">false</span>;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, right - left + <span class="number">1</span>);</span><br><span class="line">        used[s[right]] = <span class="literal">true</span>;</span><br><span class="line">        ++right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9、把字符串转换成整数【剑指Offer-67-medium】"><a href="#9、把字符串转换成整数【剑指Offer-67-medium】" class="headerlink" title="9、把字符串转换成整数【剑指Offer 67 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数【剑指Offer 67 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。</span><br><span class="line">说明：</span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">     </span><br><span class="line">示例 3:</span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">     </span><br><span class="line">示例 5:</span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<p>【解法】注意考虑各种情况。时间复杂度 O(N)，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 去掉开头的空格</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; str.<span class="built_in">size</span>() &amp;&amp; str[k] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == str.<span class="built_in">size</span>()) &#123; <span class="comment">// 如果全是空格，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;   <span class="comment">// flag标记正负数</span></span><br><span class="line">    <span class="keyword">if</span> (str[k] == <span class="string">&#x27;+&#x27;</span> || str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (str[k] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">214748364</span> || (result == <span class="number">214748364</span> &amp;&amp; tmp &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + tmp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag ? result : (-result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、链表"><a href="#四、链表" class="headerlink" title="四、链表"></a>四、链表</h4><h5 id="1、从尾到头打印链表【剑指Offer-06-easy】"><a href="#1、从尾到头打印链表【剑指Offer-06-easy】" class="headerlink" title="1、从尾到头打印链表【剑指Offer 06 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表【剑指Offer 06 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line">示例 1：</span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】利用栈后进先出的原则，遍历链表将每个节点的值存入栈中，出栈的顺序即为链表逆序。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        S.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(S.<span class="built_in">top</span>());</span><br><span class="line">        S.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、反转链表【剑指Offer-24-easy】"><a href="#2、反转链表【剑指Offer-24-easy】" class="headerlink" title="2、反转链表【剑指Offer 24 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表【剑指Offer 24 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br><span class="line">示例:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>

<p>【解法】迭代。定义一个结点总是指向前驱，注意ListNode* nex = head-&gt;next;这句要放到while循环中。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;	</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        ListNode* nex = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、合并两个排序的链表【剑指Offer-25-easy】"><a href="#3、合并两个排序的链表【剑指Offer-25-easy】" class="headerlink" title="3、合并两个排序的链表【剑指Offer 25 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表【剑指Offer 25 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br><span class="line">示例1：</span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>【解法】同时遍历两个链表，按递增顺序，如果最后某个链表有剩余，就将这个链表剩余部分接到新链表的最后。时间复杂度O(M+N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* r = new_head;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            r-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    	r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">    	r-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">    	r-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、链表中倒数第k个节点【剑指Offer-22-easy】"><a href="#4、链表中倒数第k个节点【剑指Offer-22-easy】" class="headerlink" title="4、链表中倒数第k个节点【剑指Offer 22 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点【剑指Offer 22 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p>【解法】使用双指针，一开始former和latter同时指向head，然后former指针向前移动k步（即former和latter两个指针相差k个结点），然后两个指针再同时移动，知道former移动到链表结尾为空。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* former = head;</span><br><span class="line">    ListNode* latter = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!former) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        former = former-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (former) &#123;</span><br><span class="line">        latter = latter-&gt;next;</span><br><span class="line">        former = former-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> latter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、删除链表的节点【剑指Offer-18-easy】"><a href="#5、删除链表的节点【剑指Offer-18-easy】" class="headerlink" title="5、删除链表的节点【剑指Offer 18 | easy】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点【剑指Offer 18 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</span><br><span class="line">示例 1:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="line"> </span><br><span class="line">说明：题目保证链表中节点的值互不相同。若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点。</span><br></pre></td></tr></table></figure>

<p>【解法】双指针，定义一个指向前驱结点的指针，遍历链表寻找要删除的结点，找到后利用pre-&gt;next=p-&gt;next将其删除。时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">		<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* pre = head;</span><br><span class="line">	ListNode* p = head-&gt;next;</span><br><span class="line">	<span class="comment">// pre指向前驱，遍历链表寻找要删除的结点</span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; p-&gt;val != val) &#123;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p) &#123; <span class="comment">// 此时找到了要删除的结点</span></span><br><span class="line">		pre-&gt;next = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、两个链表的第一个公共节点【剑指Offer-52-easy】"><a href="#6、两个链表的第一个公共节点【剑指Offer-52-easy】" class="headerlink" title="6、两个链表的第一个公共节点【剑指Offer 52 | easy】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点【剑指Offer 52 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个链表，找出它们的第一个公共节点。</span><br><span class="line">如果两个链表没有交点，返回 null；在返回结果后，两个链表仍须保持原有的结构；可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br><span class="line">如下面的两个链表：在节点 c1 开始相交。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424124955.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125056.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125126.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 3：</span><br><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424125151.png"></p>
<p>【解法】使用两个指针 A，B分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 A到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 B到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。时间复杂度O(M+N)，空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* A = headA;</span><br><span class="line">	ListNode* B = headB;</span><br><span class="line">	<span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">		A = (A != <span class="literal">nullptr</span>) ? A-&gt;next : headB;</span><br><span class="line">		B = (B != <span class="literal">nullptr</span>) ? B-&gt;next : headA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、复杂链表的复制【剑指Offer-35-medium】"><a href="#7、复杂链表的复制【剑指Offer-35-medium】" class="headerlink" title="7、复杂链表的复制【剑指Offer 35 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制【剑指Offer 35 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span><br><span class="line">提示：-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000</span><br><span class="line">Node.random 为空（null）或指向链表中的节点。</span><br><span class="line">节点数目不超过 1000 。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134207.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134221.png"></p>
<p>【解法】遍历链表，每次对应生成一个新结点，用哈希表存放新结点和旧结点之间的对应关系。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 哈希表存放新结点和旧结点之间的对应关系</span></span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; unmap;</span><br><span class="line">        Node* p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            unmap[p] = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            unmap[p]-&gt;next = unmap[p-&gt;next];</span><br><span class="line">            unmap[p]-&gt;random = unmap[p-&gt;random];</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unmap[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="8、二叉搜索树与双向链表【剑指Offer-36-medium】"><a href="#8、二叉搜索树与双向链表【剑指Offer-36-medium】" class="headerlink" title="8、二叉搜索树与双向链表【剑指Offer 36 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表【剑指Offer 36 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。为了让您更好地理解问题，以下面的二叉搜索树为例：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134404.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</span><br><span class="line">下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</span><br><span class="line">特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424134443.png"></p>
<p>【解法】DFS中序遍历保证结点的值从小到大排序。设置一个前驱结点，在遍历的过程中，保证前驱结点和当前结点相互指向。时间复杂度O(N)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = <span class="literal">NULL</span>;</span><br><span class="line">        right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, Node* _left, Node* _right) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 找到第一个结点，head指向它</span></span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 不是第一个结点，则前驱结点和当前结点相互指向</span></span><br><span class="line">            pre-&gt;right = cur;   </span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="9、两数相加【LeetCode-2-medium】"><a href="#9、两数相加【LeetCode-2-medium】" class="headerlink" title="9、两数相加【LeetCode 2 | medium】"></a><strong>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加【LeetCode 2 | medium】</a></strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。</span><br><span class="line">请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><br><span class="line"></span><br><span class="line">示例1：</span><br><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br><span class="line"></span><br><span class="line">示例2：</span><br><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p>【解法】每次相加考虑是否有进位，如果有进位那么就加上1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">	ListNode* p = l1;</span><br><span class="line">	ListNode* q = l2;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* r = new_head;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || q) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = (p == <span class="literal">nullptr</span>) ? <span class="number">0</span> : p-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> y = (q == <span class="literal">nullptr</span>) ? <span class="number">0</span> : q-&gt;val;</span><br><span class="line">		<span class="keyword">int</span> sum = x + y + flag;</span><br><span class="line">		flag = (sum &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">		r = r-&gt;next;	</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (q) &#123;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		r-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(flag);</span><br><span class="line">		r = r-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10、删除链表的倒数第-N-个结点【LeetCode-19-medium】"><a href="#10、删除链表的倒数第-N-个结点【LeetCode-19-medium】" class="headerlink" title="10、删除链表的倒数第 N 个结点【LeetCode 19 | medium】"></a>10、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点【LeetCode 19 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span><br><span class="line">提示：链表中结点的数目为 sz，1 &lt;&#x3D; sz &lt;&#x3D; 30</span><br><span class="line">0 &lt;&#x3D; Node.val &lt;&#x3D; 100，1 &lt;&#x3D; n &lt;&#x3D; sz</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531113520.png"></p>
<p>【解法】双指针，前后指针相差n个节点，这样就保证了当前指针遍历到结尾为空时，后指针刚好指向要删除的节点的前一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">	dummyHead-&gt;next = head;</span><br><span class="line">	ListNode* p = dummyHead, * q = dummyHead;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* delNode = p-&gt;next;</span><br><span class="line">	p-&gt;next = delNode-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> delNode;</span><br><span class="line"></span><br><span class="line">	ListNode* retNode = dummyHead-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> dummyHead;</span><br><span class="line">	<span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11、合并K个升序链表【LeetCode-23-hard】"><a href="#11、合并K个升序链表【LeetCode-23-hard】" class="headerlink" title="11、合并K个升序链表【LeetCode 23 | hard】"></a>11、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表【LeetCode 23 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><br><span class="line">示例1：</span><br><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p>【解法】遍历每个链表，开辟一个新的数组，将所有节点保存到新数组中，然后根据值大小进行排序，最后将新数组中的每个节点连成一个链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-&gt;val &lt; b-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	vector&lt;ListNode*&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (lists[i]) &#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">			lists[i] = lists[i]-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (vec.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		vec[i - <span class="number">1</span>]-&gt;next = vec[i];</span><br><span class="line">	&#125;</span><br><span class="line">	vec.<span class="built_in">back</span>()-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】将链表数组分成两部分，两部分分别递归调用，最后两部分的结果调用合并两个链表的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	ListNode* p = new_head;</span><br><span class="line">	<span class="keyword">while</span> (headA &amp;&amp; headB) &#123;</span><br><span class="line">		<span class="keyword">if</span> (headA-&gt;val &lt;= headB-&gt;val) &#123;</span><br><span class="line">			p-&gt;next = headA;</span><br><span class="line">			headA = headA-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p-&gt;next = headB;</span><br><span class="line">			headB = headB-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (headA) &#123;</span><br><span class="line">		p-&gt;next = headA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (headB) &#123;</span><br><span class="line">		p-&gt;next = headB;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = lists.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = len / <span class="number">2</span>;</span><br><span class="line">	vector&lt;ListNode*&gt; tmp_vec1, tmp_vec2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; ++i) &#123;</span><br><span class="line">		tmp_vec1.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* tmp1 = <span class="built_in">mergeKLists</span>(tmp_vec1);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt; len; ++i) &#123;</span><br><span class="line">		tmp_vec2.<span class="built_in">push_back</span>(lists[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* tmp2 = <span class="built_in">mergeKLists</span>(tmp_vec2);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(tmp1, tmp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12、-删除排序链表中的重复元素【LeetCode-83-easy】"><a href="#12、-删除排序链表中的重复元素【LeetCode-83-easy】" class="headerlink" title="12、 删除排序链表中的重复元素【LeetCode 83 | easy】"></a>12、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/"> 删除排序链表中的重复元素【LeetCode 83 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次。返回同样按升序排列的结果链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191014.png"></p>
<p>【解法】定义两个指针p和q来比较两个节点的值是否相等，如果后一个指针q的值等于前一个指针p的值，那么删除q指向的节点，若不等于，则p和q同时往后移一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	ListNode* q = p-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val == q-&gt;val) &#123;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = q;</span><br><span class="line">			q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13、删除排序链表中的重复元素-II【LeetCode-82-medium】"><a href="#13、删除排序链表中的重复元素-II【LeetCode-82-medium】" class="headerlink" title="13、删除排序链表中的重复元素 II【LeetCode 82 | medium】"></a>13、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II【LeetCode 82 | medium】</a></h5><p>](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。返回同样按升序排列的结果链表。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191217.png"></p>
<p>【解法】一次遍历。重复元素在链表中出现的位置是连续的，因此只需要对链表进行一次遍历就可以删除重复元素。由于链表的头结点可能会删除，因此定义一个哑节点指向头节点，定义一个遍历的指针p指向哑节点。随后开始对链表进行遍历。如果当前 <code>p-&gt;next</code> 与<code>p-&gt;next-&gt;next</code> 对应的元素相同，那么我们就需要将 <code>p-&gt;next</code> 以及所有后面拥有相同元素值的链表节点全部删除。我们记下这个元素值<code>x</code>，随后不断将<code>p-&gt;next</code> 从链表中移除，直到 <code>p-&gt;next</code>为空节点或者其元素值不等于<code>x</code>为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    ListNode* p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;val == x) &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14、旋转链表【LeetCode-61-medium】"><a href="#14、旋转链表【LeetCode-61-medium】" class="headerlink" title="14、旋转链表【LeetCode 61 | medium】"></a>14、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-list/">旋转链表【LeetCode 61 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表的头节点 head，旋转链表，将链表每个节点向右移动 k 个位置。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191250.png"></p>
<p>【解法】闭合为环。当<code>k&gt;=len</code>时，需要向右移动<code>k mod len</code>次，因为每<code>len</code>次移动都会让链表恢复原状，新链表的最后一个节点即为<code>len - k mod len</code>个节点（从1开始计数）可以先将链表连接成环，然后再从指定位置断开。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;  <span class="comment">// 计算链表长度</span></span><br><span class="line">		len++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;next = head;    <span class="comment">// 首尾相连成环</span></span><br><span class="line">	<span class="keyword">int</span> add = len - k % len;  <span class="comment">// 定位到新链表的尾部</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add; ++i) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* new_head = p-&gt;next; <span class="comment">// 新链表的头节点</span></span><br><span class="line">	p-&gt;next = <span class="literal">nullptr</span>;  <span class="comment">// 首尾断开</span></span><br><span class="line">	<span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15、两两交换链表中的节点【LeetCode-24-medium】"><a href="#15、两两交换链表中的节点【LeetCode-24-medium】" class="headerlink" title="15、两两交换链表中的节点【LeetCode 24 | medium】"></a>15、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">两两交换链表中的节点【LeetCode 24 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191358.png"></p>
<p>【解法】创建哑节点，定义<code>pre</code>指向哑节点，每次两两交换哑节点之后的两个节点，一次交换之后<code>pre</code>每次指向交换后的两个节点中的后一个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">	ListNode* new_head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	new_head-&gt;next = head;</span><br><span class="line">	ListNode* pre = new_head;</span><br><span class="line">	<span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next) &#123;</span><br><span class="line">		ListNode* p = pre-&gt;next;</span><br><span class="line">		ListNode* q = pre-&gt;next-&gt;next;</span><br><span class="line">		pre-&gt;next = q;</span><br><span class="line">		p-&gt;next = q-&gt;next;</span><br><span class="line">		q-&gt;next = p;</span><br><span class="line">		pre = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="16、K-个一组翻转链表【LeetCode-25-hard】"><a href="#16、K-个一组翻转链表【LeetCode-25-hard】" class="headerlink" title="16、K 个一组翻转链表【LeetCode 25 | hard】"></a>16、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表【LeetCode 25 | hard】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210531191327.png"></p>
<p>【解法】需要把链表节点按照 <code>k</code> 个一组分组，所以可以使用一个指针 <code>head</code> 依次指向每组的头节点。这个指针每次向前移动 <code>k</code> 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 <code>k</code>。若是，我们就翻转这部分链表，否则不需要翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转链表，返回头节点和尾节点，方便后续连接</span></span><br><span class="line">pair&lt; ListNode*, ListNode*&gt; reverseKNodes(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">	ListNode* pre = tail-&gt;next;</span><br><span class="line">	ListNode* p = head;</span><br><span class="line">	<span class="comment">// 反转链表</span></span><br><span class="line">	<span class="keyword">while</span> (pre != tail) &#123;</span><br><span class="line">		ListNode* q = p-&gt;next;</span><br><span class="line">		p-&gt;next = pre;</span><br><span class="line">		pre = p;</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123; tail, head &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	ListNode* hair = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">	hair-&gt;next = head;</span><br><span class="line">	ListNode* pre = hair;</span><br><span class="line">	<span class="keyword">while</span> (head) &#123;</span><br><span class="line">		ListNode* tail = pre;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">			tail = tail-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (!tail) &#123; <span class="comment">// 如果为空，则代表后面的节点个数不足k个，直接返回</span></span><br><span class="line">				<span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ListNode* nex = tail-&gt;next;</span><br><span class="line">		<span class="comment">// 反转含有k个节点的链表部分</span></span><br><span class="line">		pair&lt;ListNode*, ListNode*&gt; result = <span class="built_in">reverseKNodes</span>(head, tail);</span><br><span class="line">		head = result.first;</span><br><span class="line">		tail = result.second;</span><br><span class="line">		<span class="comment">// 将反转后的链表连接到原来的链表上</span></span><br><span class="line">		pre-&gt;next = head;</span><br><span class="line">		tail-&gt;next = nex;</span><br><span class="line">		pre = tail;</span><br><span class="line">		head = tail-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



























<h4 id="五、栈-队列-堆"><a href="#五、栈-队列-堆" class="headerlink" title="五、栈 / 队列 / 堆"></a>五、栈 / 队列 / 堆</h4><h5 id="1、用两个栈实现队列【剑指Offer-09-easy】"><a href="#1、用两个栈实现队列【剑指Offer-09-easy】" class="headerlink" title="1、用两个栈实现队列【剑指Offer 09 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列【剑指Offer 09 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; values &lt;&#x3D; 10000</span><br><span class="line">最多会对 appendTail、deleteHead 进行 10000 次调用</span><br></pre></td></tr></table></figure>

<p>【解法】时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。对于删除操作，虽然看起来是 O(N)的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)，空间复杂度：O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (!_s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        _s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!_s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                _s2.<span class="built_in">push</span>(_s1.<span class="built_in">top</span>());</span><br><span class="line">                _s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = _s2.<span class="built_in">top</span>();</span><br><span class="line">            _s2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _s2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2、包含min函数的栈【剑指Offer-30-easy】"><a href="#2、包含min函数的栈【剑指Offer-30-easy】" class="headerlink" title="2、包含min函数的栈【剑指Offer 30 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">包含min函数的栈【剑指Offer 30 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</span><br><span class="line">示例:</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br><span class="line"> </span><br><span class="line">提示：各函数的调用总次数不超过 20000 次</span><br></pre></td></tr></table></figure>

<p>【解法】维护一个保存最小值的栈，和存放数据的栈一同插入和删除来保证每次插入删除后，最小值栈的栈顶总是当前数据元素中的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        _data.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (_min.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _min.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; _min.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                _min.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _min.<span class="built_in">push</span>(_min.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _data.<span class="built_in">pop</span>();</span><br><span class="line">        _min.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _min.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _min;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、栈的压入、弹出序列【剑指Offer-31-medium】"><a href="#3、栈的压入、弹出序列【剑指Offer-31-medium】" class="headerlink" title="3、栈的压入、弹出序列【剑指Offer 31 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列【剑指Offer 31 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<p>【解法】遍历pushed数组入栈，如果栈顶和popped数组元素相同则弹出，最后根据栈是否为空来判断是否是正确的出栈顺序。时间复杂度仍为 O(N)，空间复杂度为O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		S.<span class="built_in">push</span>(pushed[i]);</span><br><span class="line">		<span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() == popped[j])&#123;</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、队列的最大值【剑指Offer-59-2-medium】"><a href="#4、队列的最大值【剑指Offer-59-2-medium】" class="headerlink" title="4、队列的最大值【剑指Offer 59-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">队列的最大值【剑指Offer 59-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1</span><br><span class="line">示例 1：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; value &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p>【解法】双端队列。维护一个递减的双端队列，时间复杂度O(1)，空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _deq.<span class="built_in">empty</span>() ? <span class="number">-1</span> : _deq.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        _que.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="comment">// 若入队元素比队尾数字更大，则弹出队尾数字，维护队列的单调性</span></span><br><span class="line">        <span class="keyword">while</span> (!_deq.<span class="built_in">empty</span>() &amp;&amp; _deq.<span class="built_in">back</span>() &lt; value) &#123;</span><br><span class="line">            _deq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _deq.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = _que.<span class="built_in">front</span>();</span><br><span class="line">        _que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 只有当x和双端队列队首元素相同是才弹出，保证了双端队列队首元素总是最大值</span></span><br><span class="line">        <span class="keyword">if</span> (x == _deq.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            _deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; _que;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; _deq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="5、数据流中的中位数【剑指Offer-41-medium】"><a href="#5、数据流中的中位数【剑指Offer-41-medium】" class="headerlink" title="5、数据流中的中位数【剑指Offer 41 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数【剑指Offer 41 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line">例如：</span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line">[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br><span class="line"></span><br><span class="line">限制：最多会对 addNum、findMedian 进行 50000 次调用。</span><br></pre></td></tr></table></figure>

<p>【解法】优先队列（堆）。建立一个小顶堆A和一个大顶堆B，各保存一半元素：小顶堆中保存较大的一半，大顶堆中保存较小的一半，中位数可根据两个堆顶元素计算获得。设元素总数为 N = m + n ，其中 m 和 n分别是 A和 B 中的元素个数。当m=n（即 N为偶数）时，需要向A中添加一个元素，实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A，中位数为 ( A 的堆顶元素 + B 的堆顶元素 )/2 ；当m≠n（即 N 为 奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B ，则中位数为 A 的堆顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当两堆的数据个数相等时候，左边堆添加元素。</span></span><br><span class="line"><span class="comment">         * 采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后</span></span><br><span class="line"><span class="comment">         * 将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。</span></span><br><span class="line"><span class="comment">         * 同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (_big.<span class="built_in">size</span>() == _small.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            _small.<span class="built_in">push</span>(num);</span><br><span class="line">            _big.<span class="built_in">push</span>(_small.<span class="built_in">top</span>());</span><br><span class="line">            _small.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;           </span><br><span class="line">            _big.<span class="built_in">push</span>(num);</span><br><span class="line">            _small.<span class="built_in">push</span>(_big.<span class="built_in">top</span>());</span><br><span class="line">            _big.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;    </span><br><span class="line">        <span class="keyword">if</span> (_small.<span class="built_in">size</span>() == _big.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result = (_small.<span class="built_in">top</span>() + _big.<span class="built_in">top</span>())  * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _big.<span class="built_in">top</span>() * <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 最大堆，存放较小的一半数字，堆顶为最大值</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; _big;</span><br><span class="line">    <span class="comment">// 最小堆， 存放较大的一半数字，堆顶为最小值</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; _small;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="六、递归"><a href="#六、递归" class="headerlink" title="六、递归"></a>六、递归</h4><h4 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h4><h5 id="1、斐波那契数列【剑指Offer-10-1-easy】"><a href="#1、斐波那契数列【剑指Offer-10-1-easy】" class="headerlink" title="1、斐波那契数列【剑指Offer 10-1 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">斐波那契数列【剑指Offer 10-1 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1, F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】斐波那契方程即为状态转移方程：dp[i+1]=dp[i]+dp[i-1]。但是没必要定义一个dp数组，用两个辅助变量即可进行空间优化。时间复杂度O(N），空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">1</span>, fn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fn = (f0 + f1) % <span class="number">1000000007</span>;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、青蛙跳台阶问题【剑指Offer-10-2-easy】"><a href="#2、青蛙跳台阶问题【剑指Offer-10-2-easy】" class="headerlink" title="2、青蛙跳台阶问题【剑指Offer 10-2 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶问题【剑指Offer 10-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：0 &lt;&#x3D; n &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】思路同斐波那契数列。dp数组采用空间优化。时间复杂度O(N），空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>, fn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		fn = (f1 + f2) % <span class="number">1000000007</span>;</span><br><span class="line">		f1 = f2;</span><br><span class="line">		f2 = fn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、剪绳子【剑指Offer-14-1-medium】"><a href="#3、剪绳子【剑指Offer-14-1-medium】" class="headerlink" title="3、剪绳子【剑指Offer 14-1 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剪绳子【剑指Offer 14-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>

<p>【解法1】动态规划。dp[i]<code>表示长度为</code>i<code>的绳子剪成</code>m<code>段后的最大乘积，初始化</code>dp[2] = 1。先剪下一段 j，如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪；剩下（i-j）长度，可以剪也可以不剪，如果不剪的话长度乘积即为 j×(i-j)，如果剪的话长度乘积即为j×dp[i-j]，两者取最大值。时间复杂度O(N^2^），空间复杂度O(N)。</p>
<p>状态转移方程：<br>$$<br>dp[i]=max(dp[i], max(j*(i-j), j*dp[i-j]))<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】贪心算法：假设将长度为n的绳子分为a段，即n=n1+n2+……+na，等价于求解：<br>$$<br>max(n1<em>n2</em>……*na)<br>$$<br>有如下数学推论：当所有绳段长度相等时，乘积最大；最优的绳段长度为3。</p>
<p>所以计算长度为n的绳子可以分为长度为3的几段count，并计算余数a；当余数为0时，最大乘积即为pow(3, count)；当余数是1时，则将最后一个长度为3的段空出来，和余数为1的段合并成长度为4的段，最大成绩为2*2=4；当余数为2时，最大乘积即为2 * pow(3, count)。时间复杂度O(1），空间复杂度O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> a = n % <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">		sum = <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">		sum = <span class="number">4</span> * <span class="built_in">pow</span>(<span class="number">3</span>, count - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">		sum = <span class="number">2</span> * <span class="built_in">pow</span>(<span class="number">3</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、礼物的最大价值【剑指Offer-47-medium】"><a href="#4、礼物的最大价值【剑指Offer-47-medium】" class="headerlink" title="4、礼物的最大价值【剑指Offer 47 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值【剑指Offer 47 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</span><br><span class="line">示例 1:</span><br><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br><span class="line"></span><br><span class="line">提示：0 &lt; grid.length &lt;&#x3D; 200，0 &lt; grid[0].length &lt;&#x3D; 200</span><br></pre></td></tr></table></figure>

<p>【解法】时间复杂度O(MN），空间优化后空间复杂度O(1)。状态转移方程：<br>$$<br>dp[i][j] = grid[i][j] + max(dp[i - 1][j], dp[i][j - 1]);<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地修改数组进行空间优化，不增加额外空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;  <span class="comment">// 处理第一行</span></span><br><span class="line">		grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  <span class="comment">// 处理第一列</span></span><br><span class="line">		grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  <span class="comment">// 处理第一行</span></span><br><span class="line">			grid[i][j] += <span class="built_in">max</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> grid[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、丑数【剑指Offer-49-medium】"><a href="#5、丑数【剑指Offer-49-medium】" class="headerlink" title="5、丑数【剑指Offer 49 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数【剑指Offer 49 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</span><br><span class="line">示例:</span><br><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br><span class="line"></span><br><span class="line">说明:  1 是丑数。n 不超过1690。</span><br></pre></td></tr></table></figure>

<p>【解法】用三个指针a、b、c，初始值为1，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。状态转移方程：<br>$$<br>dp[i]=min(2<em>dp[a],3</em>dp[b],5<em>dp[c])<br>$$<br>然后分别比较dp[i]和2</em>dp[a]，3<em>dp[b]，5</em>dp[c]是否相等，如果相等则对应的指针加1。时间复杂度O(N），空间复杂度O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">2</span> * dp[a], n3 = <span class="number">3</span> * dp[b], n5 = <span class="number">5</span> * dp[c];</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(n2, n3), n5);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n2) &#123;</span><br><span class="line">            ++a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n3) &#123;</span><br><span class="line">            ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n5) &#123;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6、n个骰子的点数【剑指Offer-60-medium】"><a href="#6、n个骰子的点数【剑指Offer-60-medium】" class="headerlink" title="6、n个骰子的点数【剑指Offer 60 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数【剑指Offer 60 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="line">你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br><span class="line">示例 1:</span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 11</span><br></pre></td></tr></table></figure>

<p>【解法】假设已知n-1个骰子的解为f(n-1)，此时添加一个骰子，求n个骰子的点数和为x的概率为f(n,x)。当添加骰子的点数为 1 时，前 n - 1个骰子的点数和应为 x - 1，方可组成点数和 x；同理，当此骰子为 2 时，前 n - 1 个骰子应为 x - 2；以此类推，直至此骰子点数为 6 。将这 6 种情况的概率相加，即可得到概率 f(n, x) 。递推公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210427195338.png"></p>
<p>但是 f(n-1, x-i)会有越界问题，转换为正向递推，概率 f(n-1, x) 只和 f(n, x + 1) ,  f(n, x + 1) , ……,  f(n, x + 6)相关，遍历 f(n - 1) 中各点数和的概率，并将其添加至 f(n) 中所有相关项，即可完成 f(n - 1) 至 f(n) 的递推。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6.0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span> * i + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                tmp[j + k] += dp[j] / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7、股票的最大利润【剑指Offer-63-medium】"><a href="#7、股票的最大利润【剑指Offer-63-medium】" class="headerlink" title="7、股票的最大利润【剑指Offer 63 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润【剑指Offer 63 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span><br><span class="line">示例 1:</span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p>【解法】前i天的最大利润等于前i-1天的最大利润和第i天卖出的最大利润中的最大值。</p>
<p>状态转移方程，用常量进行空间优化，时间复杂度O(N），空间优化后空间复杂度O(1)：<br>$$<br>dp[i] = max(dp[i], prices[i] - minval);<br>$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> minval = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		minval = <span class="built_in">min</span>(minval, prices[i]);  <span class="comment">// 找price最小值</span></span><br><span class="line">		profit = <span class="built_in">max</span>(profit, prices[i] - minval);  <span class="comment">// 比较前一天的利润，和今天卖出获得的利润</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8、正则表达式匹配【剑指Offer-19-medium】"><a href="#8、正则表达式匹配【剑指Offer-19-medium】" class="headerlink" title="8、正则表达式匹配【剑指Offer 19 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">正则表达式匹配【剑指Offer 19 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数用来匹配包含&#39;. &#39;和&#39;*&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。</span><br><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入：</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#39;*&#39;。</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="八、贪心算法"><a href="#八、贪心算法" class="headerlink" title="八、贪心算法"></a>八、贪心算法</h4><h5 id="1、剪绳子-II【剑指Offer-14-2-medium】"><a href="#1、剪绳子-II【剑指Offer-14-2-medium】" class="headerlink" title="1、剪绳子 II【剑指Offer 14-2 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剪绳子 II【剑指Offer 14-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line">示例 1：</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br><span class="line"></span><br><span class="line">提示：2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure>



<h4 id="九、位运算"><a href="#九、位运算" class="headerlink" title="九、位运算"></a>九、位运算</h4><h5 id="1、二进制中1的个数【剑指Offer-15-easy】"><a href="#1、二进制中1的个数【剑指Offer-15-easy】" class="headerlink" title="1、二进制中1的个数【剑指Offer 15| easy】 "></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数【剑指Offer 15| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</span><br><span class="line">示例 1：</span><br><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br><span class="line"> </span><br><span class="line">提示：输入必须是长度为 32 的 二进制串。</span><br></pre></td></tr></table></figure>

<p>【解法1】与运算：设二进制数字 n ，则有：</p>
<ul>
<li>若 n &amp; 1 = 0，则 n 二进制最右一位为 0 ；<br>若 n &amp; 1 = 1，则 n 二进制 最右一位为1 。</li>
</ul>
<p>时间复杂度 O(log2n)，逐位判断需循环log2n次，其中n代表数字 n 最高位 1 的所在位数，空间复杂度 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【解法2】巧用 n &amp; (n - 1)</p>
<p>(n−1) ： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。<br>n &amp; (n - 1)： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502160033.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ++res;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、不用加减乘除做加法【剑指Offer-65-easy】"><a href="#2、不用加减乘除做加法【剑指Offer-65-easy】" class="headerlink" title="2、不用加减乘除做加法【剑指Offer 65 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法【剑指Offer 65 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</span><br><span class="line">示例:</span><br><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">提示：a, b 均可能是负数或 0，结果不会溢出 32 位整数</span><br></pre></td></tr></table></figure>

<p>【解法】位运算实现加法，设两数字的二进制形式 a, b，其求和 s = a + b，a(i)代表 a 的二进制第 i 位，则分为以下四种情况：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502161551.png" style="zoom: 67%;" />

<p>无进位和和异或运算相同，仅为和与运算相同，因此无进位和 n 与进位 c的计算公式如下：<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502161733.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = a ^ b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、数组中数字出现的次数【剑指Offer-56-1-medium】"><a href="#3、数组中数字出现的次数【剑指Offer-56-1-medium】" class="headerlink" title="3、数组中数字出现的次数【剑指Offer 56-1 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数【剑指Offer 56-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br><span class="line"> </span><br><span class="line">限制：2 &lt;&#x3D; nums.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】所有元素进行异或运算，最终算的结果即为两个不同的数异或的结果。将所有元素分为两组，两个不同的数分别在两个组中，分组的方法如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502170832.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, m = <span class="number">1</span>, n = <span class="number">0</span>;  <span class="comment">// x、y分别为出现1次的两个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 先求所有数异或，异或的结果即为出现1次的两个数的异或，即(x^y)</span></span><br><span class="line">        n ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((n &amp; m) == <span class="number">0</span>) &#123;  <span class="comment">// 找到(x异或y)的右边第一个1,对应的m</span></span><br><span class="line">        m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;  <span class="comment">// 相当于将原数组分为两组，每组包含一个仅出现1次的数字，剩下的数字均出现两次，异或的结果即为本身</span></span><br><span class="line">        <span class="keyword">if</span> (num &amp; m) &#123;</span><br><span class="line">            x ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            y ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; x, y &#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h5 id="4、数组中数字出现的次数-II【剑指Offer-56-2-medium】"><a href="#4、数组中数字出现的次数-II【剑指Offer-56-2-medium】" class="headerlink" title="4、数组中数字出现的次数 II【剑指Offer 56-2 | medium】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II【剑指Offer 56-2 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; nums.length &lt;&#x3D; 10000，1 &lt;&#x3D; nums[i] &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】考虑数字的二进制形式，对于出现三次的数字，各二进制位 出现的次数都是 3 的倍数。因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210502202826.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// int类型有32位，统计每一位1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">            count[j] += num &amp; <span class="number">1</span>;</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将count各元素对3求余，则结果为 “只出现一次的数字” 的各二进制位</span></span><br><span class="line">    <span class="comment">// 利用 左移操作 和 或运算 ，可将 countscounts 数组中各二进位的值恢复到数字 resres 上（循环区间是 i \in [0, 31]i∈[0,31] ）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        res &lt;&lt;= <span class="number">1</span>;   <span class="comment">// 左移一位</span></span><br><span class="line">        res |= count[<span class="number">31</span> - i] % m;  <span class="comment">// 恢复第i位的直到res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5、求1-2-…-n【剑指Offer-64-medium】"><a href="#5、求1-2-…-n【剑指Offer-64-medium】" class="headerlink" title="5、求1+2+…+n【剑指Offer 64 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n【剑指Offer 64 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</span><br><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<p>【解法】递归，用位运算作为递归的出口。逻辑运算符的短路效应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">sumNums</span>(n - <span class="number">1</span>)); <span class="comment">// 实现n=1时递归终止</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="十、滑动窗口和双指针"><a href="#十、滑动窗口和双指针" class="headerlink" title="十、滑动窗口和双指针"></a>十、滑动窗口和双指针</h4><h5 id="1、和为s的连续正数序列【剑指Offer-57-2-easy】"><a href="#1、和为s的连续正数序列【剑指Offer-57-2-easy】" class="headerlink" title="1、和为s的连续正数序列【剑指Offer 57-2 | easy】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列【剑指Offer 57-2 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br><span class="line">示例 1：</span><br><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; target &lt;&#x3D; 10^5</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2、和为s的两个数字【剑指Offer-57-easy】"><a href="#2、和为s的两个数字【剑指Offer-57-easy】" class="headerlink" title="2、和为s的两个数字【剑指Offer 57 | easy】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字【剑指Offer 57 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</span><br><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br><span class="line"></span><br><span class="line">限制：1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5，1 &lt;&#x3D; nums[i] &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3、滑动窗口的最大值【剑指Offer-59-1-medium】"><a href="#3、滑动窗口的最大值【剑指Offer-59-1-medium】" class="headerlink" title="3、滑动窗口的最大值【剑指Offer 59-1 | medium】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值【剑指Offer 59-1 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br><span class="line">示例:</span><br><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br><span class="line"> </span><br><span class="line">提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="十一、DFS和BFS-回溯"><a href="#十一、DFS和BFS-回溯" class="headerlink" title="十一、DFS和BFS+回溯"></a>十一、DFS和BFS+回溯</h4><h5 id="1、矩阵中的路径【剑指Offer-12-medium】"><a href="#1、矩阵中的路径【剑指Offer-12-medium】" class="headerlink" title="1、矩阵中的路径【剑指Offer 12 | medium】"></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">矩阵中的路径【剑指Offer 12 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br><span class="line">例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210424132400.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br><span class="line"> </span><br><span class="line">提示：1 &lt;&#x3D; board.length &lt;&#x3D; 200，1 &lt;&#x3D; board[i].length &lt;&#x3D; 200，board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2、机器人的运动范围【剑指Offer-13-medium】"><a href="#2、机器人的运动范围【剑指Offer-13-medium】" class="headerlink" title="2、机器人的运动范围【剑指Offer 13 | medium】"></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围【剑指Offer 13 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</span><br><span class="line">示例 1：</span><br><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：1 &lt;&#x3D; n,m &lt;&#x3D; 100，0 &lt;&#x3D; k &lt;&#x3D; 20</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h4><h5 id="1、打印从1到最大的n位数【剑指Offer-15-easy】"><a href="#1、打印从1到最大的n位数【剑指Offer-15-easy】" class="headerlink" title="1、打印从1到最大的n位数【剑指Offer 15| easy】 "></a>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数【剑指Offer 15| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br><span class="line">示例 1:</span><br><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class="line"> </span><br><span class="line">说明：用返回一个整数列表来代替打印，n 为正整数</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>







<h5 id="2、顺时针打印矩阵【剑指Offer-29-easy】"><a href="#2、顺时针打印矩阵【剑指Offer-29-easy】" class="headerlink" title="2、顺时针打印矩阵【剑指Offer 29| easy】 "></a>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵【剑指Offer 29| easy】 </a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br><span class="line"></span><br><span class="line">限制：0 &lt;&#x3D; matrix.length &lt;&#x3D; 100，0 &lt;&#x3D; matrix[i].length &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、圆圈中最后剩下的数字【剑指Offer-62-easy】"><a href="#3、圆圈中最后剩下的数字【剑指Offer-62-easy】" class="headerlink" title="3、圆圈中最后剩下的数字【剑指Offer 62 | easy】"></a>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字【剑指Offer 62 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</span><br><span class="line">例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</span><br><span class="line">示例 1：</span><br><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt;&#x3D; 10^5，1 &lt;&#x3D; m &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="4、扑克牌中的顺子【剑指Offer-61-easy】"><a href="#4、扑克牌中的顺子【剑指Offer-61-easy】" class="headerlink" title="4、扑克牌中的顺子【剑指Offer 61 | easy】"></a>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">扑克牌中的顺子【剑指Offer 61 | easy】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</span><br><span class="line">示例 1:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">示例 2:</span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line">限制：数组长度为5，数组的数取值为 [0, 13]</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="5、表示数值的字符串【剑指Offer-20-medium】"><a href="#5、表示数值的字符串【剑指Offer-20-medium】" class="headerlink" title="5、表示数值的字符串【剑指Offer 20 | medium】"></a>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">表示数值的字符串【剑指Offer 20 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、&quot;5e2&quot;、&quot;-123&quot;、&quot;3.1416&quot;、&quot;-1E-16&quot;、&quot;0123&quot;都表示数值，但&quot;12e&quot;、&quot;1a3.14&quot;、&quot;1.2.3&quot;、&quot;+-5&quot;及&quot;12e+5.4&quot;都不是。</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="6、数值的整数次方【剑指Offer-16-medium】"><a href="#6、数值的整数次方【剑指Offer-16-medium】" class="headerlink" title="6、数值的整数次方【剑指Offer 16 | medium】"></a>6、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方【剑指Offer 16 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</span><br><span class="line">示例 1：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; 10</span><br><span class="line">输出：1024.00000</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：x &#x3D; 2.10000, n &#x3D; 3</span><br><span class="line">输出：9.26100</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：x &#x3D; 2.00000, n &#x3D; -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">-2^31 &lt;&#x3D; n &lt;&#x3D; 2^31-1</span><br><span class="line">-10^4 &lt;&#x3D; x^n &lt;&#x3D; 10^4</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="7、数字序列中某一位的数字【剑指Offer-44-medium】"><a href="#7、数字序列中某一位的数字【剑指Offer-44-medium】" class="headerlink" title="7、数字序列中某一位的数字【剑指Offer 44 | medium】"></a>7、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">数字序列中某一位的数字【剑指Offer 44 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line">限制：0 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="8、构建乘积数组【剑指Offer-66-medium】"><a href="#8、构建乘积数组【剑指Offer-66-medium】" class="headerlink" title="8、构建乘积数组【剑指Offer 66 | medium】"></a>8、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">构建乘积数组【剑指Offer 66 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</span><br><span class="line">示例:</span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br><span class="line"> </span><br><span class="line">提示：所有元素乘积之和不会溢出 32 位整数</span><br><span class="line">a.length &lt;&#x3D; 100000</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="9、1～n-整数中-1-出现的次数【剑指Offer-43-medium】"><a href="#9、1～n-整数中-1-出现的次数【剑指Offer-43-medium】" class="headerlink" title="9、1～n 整数中 1 出现的次数【剑指Offer 43 | medium】"></a>9、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">1～n 整数中 1 出现的次数【剑指Offer 43 | medium】</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">【题目描述】输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</span><br><span class="line">例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</span><br><span class="line">示例 1：</span><br><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br><span class="line"> </span><br><span class="line">限制：1 &lt;&#x3D; n &lt; 2^31</span><br></pre></td></tr></table></figure>

<p>【解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/">https://varrella.github.io/2021/04/23/%E5%89%91%E6%8C%87Offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-bfd4836.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/28/Windows10%E6%9B%B4%E6%96%B0Nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___3jcRnpA38Ac___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Windows10更新Nvidia显卡驱动</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/23/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___1-M0WfGD7kI___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《现代操作系统》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">【剑指Offer 05 | easy】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">一、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II%E3%80%90%E5%89%91%E6%8C%87Offer-32-2-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、从上到下打印二叉树 II【剑指Offer 32-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%E3%80%90%E5%89%91%E6%8C%87Offer-27-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、二叉树的镜像【剑指Offer 27 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-28-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、对称的二叉树【剑指Offer 28 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E3%80%90%E5%89%91%E6%8C%87Offer-55-1-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、二叉树的深度【剑指Offer 55-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-55-2-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、平衡二叉树【剑指Offer 55-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-54-easy%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、二叉搜索树的第k大节点【剑指Offer 54 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90%E5%89%91%E6%8C%87Offer-68-1-easy%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、二叉搜索树的最近公共祖先【剑指Offer 68-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%90%E5%89%91%E6%8C%87Offer-68-2-easy%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、二叉树的最近公共祖先【剑指Offer 68-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%90%E5%89%91%E6%8C%87Offer-26-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、树的子结构【剑指Offer 26 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-07-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、重建二叉树【剑指Offer 07 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-32-1-medium%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、从上到下打印二叉树【剑指Offer 32-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III%E3%80%90%E5%89%91%E6%8C%87Offer-32-3-medium%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、从上到下打印二叉树 III【剑指Offer 32-3 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-33-medium%E3%80%91"><span class="toc-number">13.</span> <span class="toc-text">13、二叉搜索树的后序遍历序列【剑指Offer 33 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%90%E5%89%91%E6%8C%87Offer-34-medium%E3%80%91"><span class="toc-number">14.</span> <span class="toc-text">14、二叉树中和为某一值的路径【剑指Offer 34 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%90%E5%89%91%E6%8C%87Offer-37-medium%E3%80%91"><span class="toc-number">15.</span> <span class="toc-text">15、序列化二叉树【剑指Offer 37 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5"><span class="toc-number"></span> <span class="toc-text">二、数组和矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-03-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、数组中重复的数字【剑指Offer 03 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-11-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、旋转数组的最小数字【剑指Offer 11 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E3%80%90%E5%89%91%E6%8C%87Offer-11-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、调整数组顺序使奇数位于偶数前面【剑指Offer 11 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-40-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、最小的k个数【剑指Offer 40 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-39-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、数组中出现次数超过一半的数字【剑指Offer 39 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、在排序数组中查找数字 I【剑指Offer 05 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%90%E5%89%91%E6%8C%87Offer-04-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、二维数组中的查找【剑指Offer 04 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%810%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-53-2-easy%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、0～n-1中缺失的数字【剑指Offer 53-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-45-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、把数组排成最小的数【剑指Offer 45 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E3%80%90%E5%89%91%E6%8C%87Offer-51-hard%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、数组中的逆序对【剑指Offer 51 | hard】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">三、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%E3%80%90%E5%89%91%E6%8C%87Offer-05-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、替换空格【剑指Offer 05 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E3%80%90%E5%89%91%E6%8C%87Offer-50-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、第一个只出现一次的字符【剑指Offer 50 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%E3%80%90%E5%89%91%E6%8C%87Offer-42-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、连续子数组的最大和【剑指Offer 42 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E3%80%90%E5%89%91%E6%8C%87Offer-58-1-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、翻转单词顺序【剑指Offer 58-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer58-2-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、左旋转字符串【剑指Offer58-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-38-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、字符串的排列【剑指Offer 38 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-46-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、把数字翻译成字符串【剑指Offer 46 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-48-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、最长不含重复字符的子字符串【剑指Offer 48 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-67-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、把字符串转换成整数【剑指Offer 67 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">四、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-06-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、从尾到头打印链表【剑指Offer 06 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-24-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、反转链表【剑指Offer 24 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-25-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、合并两个排序的链表【剑指Offer 25 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-22-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、链表中倒数第k个节点【剑指Offer 22 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-18-easy%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、删除链表的节点【剑指Offer 18 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%E3%80%90%E5%89%91%E6%8C%87Offer-52-easy%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、两个链表的第一个公共节点【剑指Offer 52 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%90%E5%89%91%E6%8C%87Offer-35-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、复杂链表的复制【剑指Offer 35 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E3%80%90%E5%89%91%E6%8C%87Offer-36-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、二叉搜索树与双向链表【剑指Offer 36 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E3%80%90LeetCode-2-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、两数相加【LeetCode 2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9%E3%80%90LeetCode-19-medium%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">10、删除链表的倒数第 N 个结点【LeetCode 19 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-23-hard%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">11、合并K个升序链表【LeetCode 23 | hard】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%90LeetCode-83-easy%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">12、 删除排序链表中的重复元素【LeetCode 83 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II%E3%80%90LeetCode-82-medium%E3%80%91"><span class="toc-number">13.</span> <span class="toc-text">13、删除排序链表中的重复元素 II【LeetCode 82 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-61-medium%E3%80%91"><span class="toc-number">14.</span> <span class="toc-text">14、旋转链表【LeetCode 61 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%90LeetCode-24-medium%E3%80%91"><span class="toc-number">15.</span> <span class="toc-text">15、两两交换链表中的节点【LeetCode 24 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%E3%80%90LeetCode-25-hard%E3%80%91"><span class="toc-number">16.</span> <span class="toc-text">16、K 个一组翻转链表【LeetCode 25 | hard】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88-%E9%98%9F%E5%88%97-%E5%A0%86"><span class="toc-number"></span> <span class="toc-text">五、栈 &#x2F; 队列 &#x2F; 堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-09-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、用两个栈实现队列【剑指Offer 09 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E3%80%90%E5%89%91%E6%8C%87Offer-30-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、包含min函数的栈【剑指Offer 30 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-31-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、栈的压入、弹出序列【剑指Offer 31 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-59-2-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、队列的最大值【剑指Offer 59-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-41-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、数据流中的中位数【剑指Offer 41 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%80%92%E5%BD%92"><span class="toc-number"></span> <span class="toc-text">六、递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number"></span> <span class="toc-text">七、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-10-1-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、斐波那契数列【剑指Offer 10-1 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98%E3%80%90%E5%89%91%E6%8C%87Offer-10-2-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、青蛙跳台阶问题【剑指Offer 10-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90%E3%80%90%E5%89%91%E6%8C%87Offer-14-1-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、剪绳子【剑指Offer 14-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-47-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、礼物的最大价值【剑指Offer 47 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%B8%91%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-49-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、丑数【剑指Offer 49 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-60-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、n个骰子的点数【剑指Offer 60 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%E3%80%90%E5%89%91%E6%8C%87Offer-63-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、股票的最大利润【剑指Offer 63 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E3%80%90%E5%89%91%E6%8C%87Offer-19-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、正则表达式匹配【剑指Offer 19 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">八、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%89%AA%E7%BB%B3%E5%AD%90-II%E3%80%90%E5%89%91%E6%8C%87Offer-14-2-medium%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、剪绳子 II【剑指Offer 14-2 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number"></span> <span class="toc-text">九、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-15-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、二进制中1的个数【剑指Offer 15| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%E3%80%90%E5%89%91%E6%8C%87Offer-65-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、不用加减乘除做加法【剑指Offer 65 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-56-1-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、数组中数字出现的次数【剑指Offer 56-1 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II%E3%80%90%E5%89%91%E6%8C%87Offer-56-2-medium%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、数组中数字出现的次数 II【剑指Offer 56-2 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%B1%821-2-%E2%80%A6-n%E3%80%90%E5%89%91%E6%8C%87Offer-64-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、求1+2+…+n【剑指Offer 64 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number"></span> <span class="toc-text">十、滑动窗口和双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%E3%80%90%E5%89%91%E6%8C%87Offer-57-2-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、和为s的连续正数序列【剑指Offer 57-2 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-57-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、和为s的两个数字【剑指Offer 57 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%90%E5%89%91%E6%8C%87Offer-59-1-medium%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、滑动窗口的最大值【剑指Offer 59-1 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81DFS%E5%92%8CBFS-%E5%9B%9E%E6%BA%AF"><span class="toc-number"></span> <span class="toc-text">十一、DFS和BFS+回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%90%E5%89%91%E6%8C%87Offer-12-medium%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、矩阵中的路径【剑指Offer 12 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%E3%80%90%E5%89%91%E6%8C%87Offer-13-medium%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、机器人的运动范围【剑指Offer 13 | medium】</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number"></span> <span class="toc-text">十二、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-15-easy%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">1、打印从1到最大的n位数【剑指Offer 15| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%E3%80%90%E5%89%91%E6%8C%87Offer-29-easy%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">2、顺时针打印矩阵【剑指Offer 29| easy】 </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-62-easy%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">3、圆圈中最后剩下的数字【剑指Offer 62 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%E3%80%90%E5%89%91%E6%8C%87Offer-61-easy%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">4、扑克牌中的顺子【剑指Offer 61 | easy】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%89%91%E6%8C%87Offer-20-medium%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">5、表示数值的字符串【剑指Offer 20 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%E3%80%90%E5%89%91%E6%8C%87Offer-16-medium%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">6、数值的整数次方【剑指Offer 16 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E5%89%91%E6%8C%87Offer-44-medium%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">7、数字序列中某一位的数字【剑指Offer 44 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%E3%80%90%E5%89%91%E6%8C%87Offer-66-medium%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">8、构建乘积数组【剑指Offer 66 | medium】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%811%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E3%80%90%E5%89%91%E6%8C%87Offer-43-medium%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">9、1～n 整数中 1 出现的次数【剑指Offer 43 | medium】</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-bfd4836.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>