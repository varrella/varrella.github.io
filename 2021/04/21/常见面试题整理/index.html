<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常见面试题 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、计算机网络1、网络模型和各个层的协议（1）网络模型OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。 五层协议 （5层）：物理层、数据链路层、网络层、传输层、 应用层。 （2）每一层的协议 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关） 数据链路：PPP、FR、HDL">
<meta property="og:type" content="article">
<meta property="og:title" content="常见面试题">
<meta property="og:url" content="https://varrella.github.io/2021/04/21/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="一、计算机网络1、网络模型和各个层的协议（1）网络模型OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。 五层协议 （5层）：物理层、数据链路层、网络层、传输层、 应用层。 （2）每一层的协议 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关） 数据链路：PPP、FR、HDL">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___6asyCyR0K1Q___0___.jpg">
<meta property="article:published_time" content="2021-04-21T04:20:02.000Z">
<meta property="article:modified_time" content="2021-04-22T13:47:19.120Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___6asyCyR0K1Q___0___.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/04/21/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-22 21:47:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___6asyCyR0K1Q___0___.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常见面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-04-21T04:20:02.000Z" title="Created 2021-04-21 12:20:02">2021-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-04-22T13:47:19.120Z" title="Updated 2021-04-22 21:47:19">2021-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常见面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h4><h5 id="1、网络模型和各个层的协议"><a href="#1、网络模型和各个层的协议" class="headerlink" title="1、网络模型和各个层的协议"></a>1、网络模型和各个层的协议</h5><h6 id="（1）网络模型"><a href="#（1）网络模型" class="headerlink" title="（1）网络模型"></a>（1）网络模型</h6><p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br> TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br> 五层协议 （5层）：物理层、数据链路层、网络层、传输层、 应用层。</p>
<h6 id="（2）每一层的协议"><a href="#（2）每一层的协议" class="headerlink" title="（2）每一层的协议"></a>（2）每一层的协议</h6><p> 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）<br> 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br> 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br> 传输层：TCP、UDP、SPX<br> 会话层：NFS、SQL、NETBIOS、RPC<br> 表示层：JPEG、MPEG、ASII<br> 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p>
<h6 id="（3）每一层的作用"><a href="#（3）每一层的作用" class="headerlink" title="（3）每一层的作用"></a>（3）每一层的作用</h6><p> 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br> 数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br> 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br> 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br> 会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br> 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）<br> 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<h5 id="2、TCP和UDP的区别"><a href="#2、TCP和UDP的区别" class="headerlink" title="2、TCP和UDP的区别"></a>2、TCP和UDP的区别</h5><ul>
<li>TCP面向连接，UDP无连接（发送数据前不需要建立链接）</li>
<li>TCP面向字节流（文件传输），UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对IP电话，实时视频会议等）</li>
<li>TCP首部开销20字节，UDP的首部开销小，只有8个字节</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付</li>
<li>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，数据传输慢，UDP则是不可靠信道，数据传输快。</li>
</ul>
<h5 id="3、TCP如何保证数据的可靠传输的"><a href="#3、TCP如何保证数据的可靠传输的" class="headerlink" title="3、TCP如何保证数据的可靠传输的"></a>3、TCP如何保证数据的可靠传输的</h5><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>4种拥塞控制算法：慢启动，拥塞避免，快速重传和快速恢复。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114428.png"></p>
<ul>
<li>针对发送端发出的数据包的确认应答信号ACK、通常将推迟几分之一秒(可能是要对包做完整校验)</li>
<li>针对数据包丢失或者出现定时器超时的重发机制</li>
<li>针对数据包到达接收端主机顺序乱掉的顺序控制、对失序数据进行重新排序，然后才交给应用层</li>
<li>针对高效传输数据包的流动窗口控制</li>
<li>针对避免网络拥堵时候的流量控制</li>
<li>针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的慢启动算法和拥塞控制。</li>
</ul>
<p>（1）确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</p>
<p>（2）数据校验</p>
<p>（3）数据合理分片和排序：</p>
<p>UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.tcp会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。</p>
<p>（4）流量控制：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
<p>（5）拥塞控制：当网络拥塞时，减少数据的发送。</p>
<h5 id="4、TCP三次握手的过程"><a href="#4、TCP三次握手的过程" class="headerlink" title="4、TCP三次握手的过程"></a>4、TCP三次握手的过程</h5><p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114556.png"></p>
<p>ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段<br> SYN：同步序号，用于建立连接过程<br> FIN： finish标志，用于释放连接</p>
<ul>
<li>客户端发送确认序号SYN=1，初始序号seq=X的包，连接的服务器的端口</li>
<li>服务端返回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号设置为x+1。并发送一个自己的序列号 y</li>
<li>客户端发送确认包(ACK) SYN标志位为0，ACK标志位为1，并且把服务器发来的 y ，+1 作为确认号发送给对方，且序列号设置为第二次的确认号x+1</li>
</ul>
<h5 id="5、TCP四次挥手"><a href="#5、TCP四次挥手" class="headerlink" title="5、TCP四次挥手"></a>5、TCP四次挥手</h5><p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114648.png"></p>
<p>TCP连接是全双工的，因此每个方向都必须单独进行关闭。</p>
<ul>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送，并发送一个自己的ISN（u）</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（u+1）。同时发送一个自己的ISN(v)</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN、ACK给客户端A，确认号为收到的序号加1（u+1），与上一次不变。同时发送一个自己的ISN（w）</li>
<li>客户端A发送ACK报文确认，并将确认序号设置为收到序号加1（w+1），序列号就是上一次的确认号（u+1）</li>
</ul>
<h5 id="6、DNS域名系统工作原理"><a href="#6、DNS域名系统工作原理" class="headerlink" title="6、DNS域名系统工作原理"></a>6、DNS域名系统工作原理</h5><ul>
<li>查询 浏览器、操作系统 缓存</li>
<li>请求 <strong>本地域名服务器</strong></li>
<li>本地域名服务器未命中缓存，其请求 <strong>根域名服务器</strong></li>
<li>根域名服务器返回所查询域的<strong>主域名服务器</strong>。（主域名、顶级域名，如com、cn）</li>
<li>本地域名服务器请求主域名服务器，获取该域名的 <strong>名称服务器</strong>（域名注册商的服务器）</li>
<li>本地域名服务器向 名称服务器 请求 域名-IP 映射</li>
<li>缓存解析结果</li>
</ul>
<h5 id="7、ARP地址解析协议工作原理"><a href="#7、ARP地址解析协议工作原理" class="headerlink" title="7、ARP地址解析协议工作原理"></a>7、ARP地址解析协议工作原理</h5><p>每台主机都有一个ARP列表，存放IP地址和MAC地址的对应关系。<br> 当源主机向目标主机发送数据时，首先查看ARP列表中IP地址对应的目标主机的MAC地址，如果找到则直接发送数据；如果找不到，就向该网段中的所有主机发送ARP请求包，里面存放源IP地址，源MAC地址，目标IP地址。<br> 当该网段中的所有主机收到该ARP响应包之后，首先查看目标ip地址是否与自己相匹配，如果不是则忽略，如果是，就将源ip地址和源MAC地址存放到自己的ARP列表中，然后将自己的MAC地址存放到ARP响应包中发送给源主机；<br> 目标主机收到ARP响应包，则取出对应的IP和MAC地址存放到ARP列表中，并发送数据。若未收到则ARP查询失败。<br> 广播ARP请求，单播ARP响应。</p>
<h5 id="8、连续ARQ和滑动窗口协议"><a href="#8、连续ARQ和滑动窗口协议" class="headerlink" title="8、连续ARQ和滑动窗口协议"></a>8、连续ARQ和滑动窗口协议</h5><p>连续ARQ协议：所谓连续就是在发送完一个数据帧后，不是停下来等待确认帧，而是可以连续再发若干帧，边发可以边等待确认帧，如果收到了确认帧，又可以继续发送数据帧， 由于减少了等待的时间，利用率就提高了。<br> 但是连续ARQ在收到一个否认帧或超时后，所有该帧后面的帧都要重发而不管该帧后面的帧是否正确传送，于是便有了选择重传ARQ协议。</p>
<p>滑动窗口协议：允许发送方发送多个分组而不需等待确认。（滑动窗口协议是TCP使用的一种流量控制方法，此协议能够加速数据的传输）</p>
<h5 id="9、HTTP和HTTPS的区别"><a href="#9、HTTP和HTTPS的区别" class="headerlink" title="9、HTTP和HTTPS的区别"></a>9、HTTP和HTTPS的区别</h5><p>HTTP协议时超文本传输协议。<br> HTTPS是安全的超文本传输协议，是安全版的HTTP协议，使用安全套接字层(SSL)进行信息交换。<br> HTTPS协议主要针对解决HTTP协议以下不足：<br> 1.通信使用明文（不加密），内容可能会被窃听<br> 2.不验证通信方身份，应此可能遭遇伪装<br> 3.无法证明报文的完整性（即准确性），所以可能已遭篡改<br> HTTP+加密+认证+完整性保护=HTTPS</p>
<p>HTTP端口 80<br> HTTPS端口443<br> HTTPS采用对称加密、<br> SSL位于应用层于传输层TCP之间，原本数据由应用层直接交由传输层处理，现在会经过SSL加密再进行传输。<br> HTTPS也不是绝对安全的，针对SSL的中间人攻击方式主要有两类，分别是SSL劫持攻击和SSL剥离攻击。<br> SSL劫持攻击就是 SSL证书欺骗攻击，将自己接入到客户端和目标网站之间； 在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥。</p>
<h5 id="10、在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#10、在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="10、在浏览器中输入url地址-&gt;&gt;显示主页的过程"></a>10、在浏览器中输入url地址-&gt;&gt;显示主页的过程</h5><ul>
<li>浏览器解析域名</li>
<li>TCP建立连接</li>
<li>浏览器向服务器发送HTTP请求</li>
<li>服务器解析请求并返回HTTP报文</li>
<li>浏览器解析并渲染页面</li>
<li>断开连接</li>
</ul>
<p>​     <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421114841.png"> </p>
<h5 id="11、HTTP常见状态码"><a href="#11、HTTP常见状态码" class="headerlink" title="11、HTTP常见状态码"></a>11、HTTP常见状态码</h5><p>200 ：请求成功，成功返回网页<br> 301 ：资源（网页等）被永久转移到其它URL<br> 302 ：资源（网页等）被临时转移到其它URL<br> 304 ：请求未修改、命中缓存<br> 401 ：未授权<br> 403 ：服务器拒绝请求<br> 404 ：请求的网页或资源不存在<br> 500 ：内部服务器错误，无法完成请求<br> 502 ：错误网关<br> 503 ：请求未完成，服务器临时过载或宕机<br> 504 ：网关超时</p>
<h5 id="12、HTTP的请求和响应"><a href="#12、HTTP的请求和响应" class="headerlink" title="12、HTTP的请求和响应"></a>12、HTTP的请求和响应</h5><p>HTTP请求信息由3部分组成：</p>
<ul>
<li>请求方法（GET/POST）、URI、协议/版本</li>
<li>请求头(Request Header)：Content-Type、端口号Host、Cookie</li>
<li>请求正文：包含客户提交的查询字符串信息</li>
<li>请求头和请求正文之间是一个空行</li>
</ul>
<p> HTTP响应也由3个部分构成：</p>
<ul>
<li>状态行：状态代码及描述 如404、500</li>
<li>响应头(Response Header)：Content-Type 、Server、Date</li>
<li>响应正文：html代码</li>
</ul>
<h5 id="13、HTTP请求方法有哪些"><a href="#13、HTTP请求方法有哪些" class="headerlink" title="13、HTTP请求方法有哪些"></a>13、HTTP请求方法有哪些</h5><p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115113.png"></p>
<h5 id="14、简述HTTP中GET和POST的区别"><a href="#14、简述HTTP中GET和POST的区别" class="headerlink" title="14、简述HTTP中GET和POST的区别"></a>14、简述HTTP中GET和POST的区别</h5><p>从原理性看：</p>
<p>根据HTTP规范，GET用于信息获取，而且应该是安全和幂等的（对同一URL的多个请求应该返回同样的结果）</p>
<p>根据HTTP规范，POST请求表示可能修改服务器上资源的请求</p>
<p>从表面上看：</p>
<p>GET请求的数据会附在URL后面（（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连），POST的数据放在HTTP包体</p>
<p>POST安全性比GET安全性高</p>
<h5 id="15、IP地址的分类"><a href="#15、IP地址的分类" class="headerlink" title="15、IP地址的分类"></a>15、IP地址的分类</h5><p>A类地址(1~126)：网络号占前8位，以0开头，主机号占后24位。</p>
<p>B类地址(128~191)：网络号占前16位，以10开头，主机号占后16位。</p>
<p>C类地址(192~223)：网络号占前24位，以110开头，主机号占后8位。</p>
<p>D类地址(224~239)：以1110开头，保留位多播地址。</p>
<p>E类地址(240~255)：以1111开头，保留位今后使用。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115155.png"></p>
<p>​     <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115239.png"></p>
<h5 id="16、交换机、路由器、网关的概念，并知道各自的用途"><a href="#16、交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="16、交换机、路由器、网关的概念，并知道各自的用途"></a>16、交换机、路由器、网关的概念，并知道各自的用途</h5><p>交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。用途:人工交换 电路程控 集线比较</p>
<p>路由器:路由器就是连接两个以上个别网络的设备。用途:连通不同的网络信息传输。</p>
<p>网关:又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备。用途:用于两个高层协议不同的网络互连。</p>
<h5 id="17、常见端口号及对应的服务"><a href="#17、常见端口号及对应的服务" class="headerlink" title="17、常见端口号及对应的服务"></a>17、常见端口号及对应的服务</h5><p> <img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421115314.png"></p>
<h4 id="二、操作系统"><a href="#二、操作系统" class="headerlink" title="二、操作系统"></a>二、操作系统</h4><h5 id="1、进程和线程以及它们的区别："><a href="#1、进程和线程以及它们的区别：" class="headerlink" title="1、进程和线程以及它们的区别："></a>1、进程和线程以及它们的区别：</h5><p>进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。</p>
<p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
<p>一个进程可以有多个线程，多个线程也可以并发执行</p>
<h5 id="2、线程同步的方式有哪些？"><a href="#2、线程同步的方式有哪些？" class="headerlink" title="2、线程同步的方式有哪些？"></a>2、线程同步的方式有哪些？</h5><p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</p>
<p>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>
<p>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p>
<h5 id="3、进程的通信方式有哪些？"><a href="#3、进程的通信方式有哪些？" class="headerlink" title="3、进程的通信方式有哪些？"></a>3、进程的通信方式有哪些？</h5><p>主要分为：管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET</p>
<p>管道主要分为：普通管道PIPE 、流管道（s_pipe）、命名管道（name_pipe）</p>
<p>管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程</p>
<p>命名管道也是半双工的通信方式，它允许无亲缘关系的进程间进行通信</p>
<p>信号量是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</p>
<p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识。</p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问。 </p>
<h5 id="4、什么是缓冲区溢出？有什么危害？其原因是什么？"><a href="#4、什么是缓冲区溢出？有什么危害？其原因是什么？" class="headerlink" title="4、什么是缓冲区溢出？有什么危害？其原因是什么？"></a>4、什么是缓冲区溢出？有什么危害？其原因是什么？</h5><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝额服务</li>
<li>跳转并且执行一段恶意代码</li>
<li>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</li>
</ul>
<h5 id="5、什么是死锁？死锁产生的条件？"><a href="#5、什么是死锁？死锁产生的条件？" class="headerlink" title="5、什么是死锁？死锁产生的条件？"></a>5、什么是死锁？死锁产生的条件？</h5><p> 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<p> 死锁产生的四个条件（有一个条件不成立，则不会产生死锁）：</p>
<ul>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
<li>如果对死锁还不是太熟悉，建议阅读：死锁产生的原因和解锁的方法</li>
</ul>
<h5 id="6、进程有哪几种状态？"><a href="#6、进程有哪几种状态？" class="headerlink" title="6、进程有哪几种状态？"></a>6、进程有哪几种状态？</h5><p> 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</p>
<p>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</p>
<p>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</p>
<h5 id="7、分页和分段有什么区别？"><a href="#7、分页和分段有什么区别？" class="headerlink" title="7、分页和分段有什么区别？"></a>7、分页和分段有什么区别？</h5><p>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</p>
<p>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</p>
<p>段向用户提供二维地址空间；页向用户提供的是一维地址空间</p>
<p>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</p>
<h5 id="8、操作系统中进程调度策略有哪几种？"><a href="#8、操作系统中进程调度策略有哪几种？" class="headerlink" title="8、操作系统中进程调度策略有哪几种？"></a>8、操作系统中进程调度策略有哪几种？</h5><p> FCFS(先来先服务)，优先级，时间片轮转，多级反馈</p>
<h5 id="9、进程同步有哪几种机制"><a href="#9、进程同步有哪几种机制" class="headerlink" title="9、进程同步有哪几种机制"></a>9、进程同步有哪几种机制</h5><p> 原子操作、信号量机制、自旋锁管程、会合、分布式系统</p>
<h5 id="10、死锁的处理基本策略和常用方法"><a href="#10、死锁的处理基本策略和常用方法" class="headerlink" title="10、死锁的处理基本策略和常用方法"></a>10、死锁的处理基本策略和常用方法</h5><p>解决死锁的基本方法如下： </p>
<p>预防死锁、避免死锁、检测死锁、解除死锁</p>
<p>解决四多的常用策略如下：</p>
<p>鸵鸟策略、预防策略、避免策略、检测与解除死锁</p>
<h4 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a>三、数据库</h4><h5 id="1、什么是索引？为什么要用索引？"><a href="#1、什么是索引？为什么要用索引？" class="headerlink" title="1、什么是索引？为什么要用索引？"></a>1、什么是索引？为什么要用索引？</h5><ul>
<li>什么是索引？</li>
</ul>
<p>数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库中表的数据。索引的实现通常使用B树和变种的B+树(mysql常用的索引就是B+树)。除了数据之外，数据库系统还维护为满足特定查找算法的数据结构，这些数据结构以某种方式引用数据。这种数据结构就是索引。</p>
<p>简言之，索引就类似于书本、字典的目录！</p>
<ul>
<li>为什么要用索引？</li>
</ul>
<p>打个比方，如果正确合理设计并且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。</p>
<p>一言以蔽之，合理使用索引，可以加快数据库的查询效率和提升程序性能。</p>
<h5 id="2、索引的作用与缺点"><a href="#2、索引的作用与缺点" class="headerlink" title="2、索引的作用与缺点"></a>2、索引的作用与缺点</h5><ul>
<li><p>作用</p>
<p>通过创建索引，可以在查询的过程中，提高系统的性能</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</p>
<p>在使用分组和排序子句进行数据检索时，可以减少查询中分组和排序的时间</p>
</li>
<li><p>缺点</p>
<p>创建索引和维护索引要耗费时间，而且时间随着数据量的增加而增大</p>
<p>索引需要占用物理空间，如果要建立聚簇索引，所需要的空间会更大</p>
<p>在对表中的数据进行增加删除和修改时需要耗费较多的时间，因为索引也要动态地维护</p>
</li>
</ul>
<h5 id="3、创建索引的场景"><a href="#3、创建索引的场景" class="headerlink" title="3、创建索引的场景"></a>3、创建索引的场景</h5><p>  ① 经常需要搜索的列上</p>
<p>  ② 作为主键的列上</p>
<p>  ③ 经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度</p>
<p>  ④ 经常需要根据范围进行搜索的列上</p>
<p>  ⑤ 经常需要排序的列上</p>
<p>  ⑥ 经常使用在where子句上面的列上</p>
<h5 id="4、不应创建索引的场景"><a href="#4、不应创建索引的场景" class="headerlink" title="4、不应创建索引的场景"></a>4、不应创建索引的场景</h5><p>  ① 查询中很少用到的列</p>
<p>  ② 对于那些具有很少数据值的列，比如数据表中的性别列，bit数据类型的列</p>
<p>  ③ 对于那些定义为text、image的列，因为这些列的数据量相当大</p>
<p>  ④ 当对修改性能的要求远远大于搜索性能时，因为当增加索引时，会提高搜索性能，但是会降低修改性能</p>
<h5 id="5、索引的分类"><a href="#5、索引的分类" class="headerlink" title="5、索引的分类"></a>5、索引的分类</h5><ul>
<li><p>主键索引：设定为主键后数据库会自动建立索引，innodb为聚簇索引</p>
</li>
<li><p>单列索引：一个索引只包含单个列，一个表可以有多个单列索引</p>
</li>
<li><p>唯一索引： 索引列的值必须唯一，但允许有空值</p>
</li>
<li><p>复合索引：一个索引包含多个列，在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)。如果一个表中的数据在查询时有多个字段总是同时出现则这些字段就可以作为复合索引，形成索引覆盖可以提高查询的效率。</p>
</li>
<li><p>聚集索引</p>
<p>指索引项的排序方式和表中数据记录排序方式一致的索引。它会根据聚集索引键的顺序来存储表中的数据，即对表的数据按索引键的顺序进行排序，然后重新存储到磁盘上。因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引。</p>
<p>比如字典中，用‘拼音’查汉字，就是聚集索引。因为正文中字都是按照拼音排序的。而用‘偏旁部首’查汉字，就是非聚集索引，因为正文中的字并不是按照偏旁部首排序的，我们通过检字表得到正文中的字在索引中的映射，然后通过映射找到所需要的字。</p>
<p>聚集索引的使用场合为： </p>
<p>a、查询命令的回传结果是以该字段为排序依据的；<br>b、查询的结果返回一个区间的值；<br>c、查询的结果返回某值相同的大量结果集。<br>聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。</p>
</li>
<li><p>非聚集索引</p>
<p>与聚集索引相反， 索引顺序与物理存储顺序不一致。</p>
<p>非聚集索引的使用场合为： </p>
<p>a、查询所获数据量较少时； </p>
<p>b、某字段中的数据的唯一性比较高时；</p>
<p>非聚集索引必须是稠密索引</p>
</li>
<li><p>聚簇索引<br>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。</p>
<p>聚簇索引的特点：</p>
<p>① 聚簇索引具有唯一性，由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引。</p>
<p>② 表中行的物理顺序和索引中行的物理顺序是相同的，在创建任何非聚簇索引之前创建聚簇索引，这是因为聚簇索引改变了表中行的物理顺序，数据行 按照一定的顺序排列，并且自动维护这个顺序；</p>
<p>③ 聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键（类似oracle中的RowId）来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。</p>
</li>
<li><p>非聚簇索引</p>
<p>不是聚簇索引的二级索引，也叫辅助索引，都称为非聚簇索引。将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。</p>
</li>
<li><p>稠密索引</p>
<p>在稠密索引中，文件中的每个搜索码值都对应一个索引值。也就是说，稠密索引为数据记录文件的每一条记录都设一个键-指针对。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421124925.png"></p>
</li>
<li><p>稀疏索引</p>
<p>在稀疏索引中，只为搜索码的某些值建立索引项。也就是说，稀疏索引为数据记录文件的每个存储块设一个键-指针对，存储块意味着块内存储单元连续。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421130635.png"></p>
</li>
</ul>
<h5 id="6、聚集索引和非聚集索引的区别及优缺点"><a href="#6、聚集索引和非聚集索引的区别及优缺点" class="headerlink" title="6、聚集索引和非聚集索引的区别及优缺点"></a>6、聚集索引和非聚集索引的区别及优缺点</h5><p>区别：</p>
<p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个<br>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续<br>聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。<br>非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。<br>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>
<p>优势与缺点：</p>
<p>聚集索引插入数据时速度要慢（时间花费在“物理存储的排序”上，也就是首先要找到位置然后插入），查询数据比非聚集数据的速度快。</p>
<h5 id="7、索引的底层原理，为什么用B-树而不用B树？"><a href="#7、索引的底层原理，为什么用B-树而不用B树？" class="headerlink" title="7、索引的底层原理，为什么用B+树而不用B树？"></a>7、索引的底层原理，为什么用B+树而不用B树？</h5><h6 id="（1）B-树和B-树"><a href="#（1）B-树和B-树" class="headerlink" title="（1）B+树和B-树"></a>（1）B+树和B-树</h6><ul>
<li><p>优势</p>
<p>B+树每个节点可以包含更多的节点，这样做有两个原因，一个是降低树的高度，另外一个是将数据范围变为多个区间，区间越多，数据检索越快</p>
<p>所有查询都要查找到叶子节点，查询性能稳定</p>
<p>所有叶子节点形成有序链表，便于范围查询</p>
</li>
<li><p>区别</p>
<p>B+树内节点不存储数据，所有数据存储在叶节点导致查询时间复杂度固定为 log n<br>B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)<br>B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等<br>B+树更适合外部存储(存储磁盘数据)。由于内节点无 data 域，每个节点能索引的范围更大更精确</p>
</li>
</ul>
<h6 id="（2）问题1：MySQL中存储索引用到的数据结构是B-树，B-树的查询时间跟树的高度有关，是log-n-，如果用hash存储，那么查询时间是O-1-。既然hash比B-树更快，为什么mysql用B-树来存储索引呢？"><a href="#（2）问题1：MySQL中存储索引用到的数据结构是B-树，B-树的查询时间跟树的高度有关，是log-n-，如果用hash存储，那么查询时间是O-1-。既然hash比B-树更快，为什么mysql用B-树来存储索引呢？" class="headerlink" title="（2）问题1：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？"></a>（2）问题1：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？</h6><p>从内存角度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p>
<p>从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</p>
<h6 id="（3）问题2：为什么不用红黑树或者二叉排序树？"><a href="#（3）问题2：为什么不用红黑树或者二叉排序树？" class="headerlink" title="（3）问题2：为什么不用红黑树或者二叉排序树？"></a>（3）问题2：为什么不用红黑树或者二叉排序树？</h6><p>树的查询时间跟树的高度有关，B+树是一棵多路搜索树可以降低树的高度，提高查找效率</p>
<h6 id="（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？"><a href="#（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？" class="headerlink" title="（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？"></a>（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？</h6><p>这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时候B+树的多路存储威力就出来了，可以每次加载B+树的一个结点，然后一步步往下找，</p>
<h6 id="（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B-树吗？"><a href="#（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B-树吗？" class="headerlink" title="（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？"></a>（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？</h6><p>B+树是在B树的基础上进行改造，它的数据都在叶子结点，同时叶子结点之间还加了指针形成链表。</p>
<p>下面是一个4路B+树，它的数据都在叶子结点，并且有链表相连。<br><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421125451.png"></p>
<h6 id="（6）为什么B-树要这样设计？"><a href="#（6）为什么B-树要这样设计？" class="headerlink" title="（6）为什么B+树要这样设计？"></a>（6）为什么B+树要这样设计？</h6><p>这个跟它的使用场景有关，B+树在数据库的索引中用得比较多，数据库中select数据，不一定只选一条，很多时候会选中多条，比如按照id进行排序后选100条。如果是多条的话，B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p>
<p>比如选出7到19只需要在叶子结点中就能找到。<br><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture20210421125531.png"></p>
<h4 id="四、Linux"><a href="#四、Linux" class="headerlink" title="四、Linux"></a>四、Linux</h4><h5 id="1、软链接和硬链接的区别？"><a href="#1、软链接和硬链接的区别？" class="headerlink" title="1、软链接和硬链接的区别？"></a>1、软链接和硬链接的区别？</h5><p>1、语法上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">软链接：ln -s 源文件 目标文件</span><br><span class="line">硬链接：ln 源文件 目标文件</span><br><span class="line">源文件：即你要对谁建立链接</span><br></pre></td></tr></table></figure>

<p>2、原理上</p>
<ul>
<li>硬链接(hard link)：文件A是文件B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。</li>
</ul>
<ul>
<li>软链接(soft link)：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</li>
</ul>
<p>3、使用限制上</p>
<ul>
<li><p>硬链接：<br>不能对目录创建硬链接，原因有几种，最重要的是：文件系统不能存在链接环（目录创建时的”..”除外，这个系统可以识别出来），存在环的后果会导致例如文件遍历等操作的混乱(du，pwd等命令的运作原理就是基于文件硬链接，顺便一提，ls -l 结果的第二列也是文件的硬链接数，即inode节点的链接数)</p>
<p>不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下。</p>
<p>不能对不存在的文件创建硬链接，由原理即可知原因。</p>
</li>
<li><p>软链接：<br>可以对目录创建软链接，遍历操作会忽略目录的软链接。</p>
<p>可以跨文件系统</p>
<p>可以对不存在的文件创建软链接，因为放的只是一个字符串，至于这个字符串是不是对于一个实际的文件，就是另外一回事了</p>
</li>
</ul>
<p>4、作用上</p>
<ul>
<li>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。只删除一个连接并不影响节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li>
<li>软链接又称之为符号连接（Symbolic Link）。软链接文件类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/04/21/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">https://varrella.github.io/2021/04/21/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___6asyCyR0K1Q___0___.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/04/23/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___24Pi2uS66-M___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《现代操作系统》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">一、计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%84%E4%B8%AA%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">1、网络模型和各个层的协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">（1）网络模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">（2）每一层的协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">（3）每一层的作用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">2、TCP和UDP的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="toc-number">1.3.</span> <span class="toc-text">3、TCP如何保证数据的可靠传输的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">4、TCP三次握手的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.5.</span> <span class="toc-text">5、TCP四次挥手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">6、DNS域名系统工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81ARP%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">7、ARP地址解析协议工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E8%BF%9E%E7%BB%ADARQ%E5%92%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.</span> <span class="toc-text">8、连续ARQ和滑动窗口协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">9、HTTP和HTTPS的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80-gt-gt-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">10、在浏览器中输入url地址-&gt;&gt;显示主页的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11%E3%80%81HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.11.</span> <span class="toc-text">11、HTTP常见状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12%E3%80%81HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"><span class="toc-number">1.12.</span> <span class="toc-text">12、HTTP的请求和响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.13.</span> <span class="toc-text">13、HTTP请求方法有哪些</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E8%BF%B0HTTP%E4%B8%ADGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">14、简述HTTP中GET和POST的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.15.</span> <span class="toc-text">15、IP地址的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#16%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E3%80%81%E7%BD%91%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%B9%B6%E7%9F%A5%E9%81%93%E5%90%84%E8%87%AA%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.16.</span> <span class="toc-text">16、交换机、路由器、网关的概念，并知道各自的用途</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#17%E3%80%81%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.17.</span> <span class="toc-text">17、常见端口号及对应的服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">二、操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">1、进程和线程以及它们的区别：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2、线程同步的方式有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3、进程的通信方式有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F%E5%85%B6%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4、什么是缓冲区溢出？有什么危害？其原因是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5、什么是死锁？死锁产生的条件？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">6、进程有哪几种状态？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7、分页和分段有什么区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8、操作系统中进程调度策略有哪几种？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.</span> <span class="toc-text">9、进程同步有哪几种机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">10、死锁的处理基本策略和常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">三、数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1、什么是索引？为什么要用索引？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2、索引的作用与缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.</span> <span class="toc-text">3、创建索引的场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%B8%8D%E5%BA%94%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.</span> <span class="toc-text">4、不应创建索引的场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">5、索引的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.6.</span> <span class="toc-text">6、聚集索引和非聚集索引的区别及优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8B%E6%A0%91%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">7、索引的底层原理，为什么用B+树而不用B树？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89B-%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">3.7.1.</span> <span class="toc-text">（1）B+树和B-树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%97%AE%E9%A2%981%EF%BC%9AMySQL%E4%B8%AD%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AFB-%E6%A0%91%EF%BC%8CB-%E6%A0%91%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E8%B7%9F%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%9C%89%E5%85%B3%EF%BC%8C%E6%98%AFlog-n-%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%94%A8hash%E5%AD%98%E5%82%A8%EF%BC%8C%E9%82%A3%E4%B9%88%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E6%98%AFO-1-%E3%80%82%E6%97%A2%E7%84%B6hash%E6%AF%94B-%E6%A0%91%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%94%A8B-%E6%A0%91%E6%9D%A5%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="toc-number">3.7.2.</span> <span class="toc-text">（2）问题1：MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。既然hash比B+树更快，为什么mysql用B+树来存储索引呢？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%97%AE%E9%A2%982%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E6%88%96%E8%80%85%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%9F"><span class="toc-number">3.7.3.</span> <span class="toc-text">（3）问题2：为什么不用红黑树或者二叉排序树？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%97%A2%E7%84%B6%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%99%8D%E4%BD%8E%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%EF%BC%8C%E9%82%A3%E4%B9%88%E6%97%A0%E9%99%90%E5%A2%9E%E5%8A%A0%E6%A0%91%E7%9A%84%E8%B7%AF%E6%95%B0%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9C%80%E4%BC%98%E7%9A%84%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">3.7.4.</span> <span class="toc-text">（4）既然增加树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E6%AF%94B%E6%A0%91%E6%9B%B4%E4%BC%98%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B6%89%E5%8F%8A%E5%88%B0%E7%A3%81%E7%9B%98%E6%93%8D%E4%BD%9CB%E6%A0%91%E5%B0%B1%E6%9B%B4%E4%BC%98%E4%BA%86%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%A0%E8%83%BD%E8%AE%B2%E8%AE%B2B-%E6%A0%91%E5%90%97%EF%BC%9F"><span class="toc-number">3.7.5.</span> <span class="toc-text">（5）在内存中，红黑树比B树更优，但是涉及到磁盘操作B树就更优了，那么你能讲讲B+树吗？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88B-%E6%A0%91%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">3.7.6.</span> <span class="toc-text">（6）为什么B+树要这样设计？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Linux"><span class="toc-number">4.</span> <span class="toc-text">四、Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1、软链接和硬链接的区别？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___6asyCyR0K1Q___0___.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>