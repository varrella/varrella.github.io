<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis 笔记 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、内部数据结构1、简单动态字符串（Sds，Simple Dynamic String）（1）Sds在Redis中的作用 实现字符串对象（StringObject）； 在Redis程序内部用作char*类型的替代品；  Redis是一个键值对数据库，数据库的值可以是字符串、集合、列表等多种类型的对象，而数据库的键则总是字符串对象。 对于那些包含字符串值的字符串对象来说，每个字符串对象都包含一个sd">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 笔记">
<meta property="og:url" content="https://varrella.github.io/2021/07/12/redis%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="一、内部数据结构1、简单动态字符串（Sds，Simple Dynamic String）（1）Sds在Redis中的作用 实现字符串对象（StringObject）； 在Redis程序内部用作char*类型的替代品；  Redis是一个键值对数据库，数据库的值可以是字符串、集合、列表等多种类型的对象，而数据库的键则总是字符串对象。 对于那些包含字符串值的字符串对象来说，每个字符串对象都包含一个sd">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg">
<meta property="article:published_time" content="2021-07-12T03:48:36.138Z">
<meta property="article:modified_time" content="2021-07-12T14:21:12.494Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/07/12/redis%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-12 22:21:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-12T03:48:36.138Z" title="Created 2021-07-12 11:48:36">2021-07-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-12T14:21:12.494Z" title="Updated 2021-07-12 22:21:12">2021-07-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="一、内部数据结构"><a href="#一、内部数据结构" class="headerlink" title="一、内部数据结构"></a>一、内部数据结构</h4><h5 id="1、简单动态字符串（Sds，Simple-Dynamic-String）"><a href="#1、简单动态字符串（Sds，Simple-Dynamic-String）" class="headerlink" title="1、简单动态字符串（Sds，Simple Dynamic String）"></a>1、简单动态字符串（Sds，Simple Dynamic String）</h5><h6 id="（1）Sds在Redis中的作用"><a href="#（1）Sds在Redis中的作用" class="headerlink" title="（1）Sds在Redis中的作用"></a>（1）<code>Sds</code>在<code>Redis</code>中的作用</h6><ul>
<li>实现字符串对象（<code>StringObject</code>）；</li>
<li>在<code>Redis</code>程序内部用作<code>char*</code>类型的替代品；</li>
</ul>
<p><code>Redis</code>是一个键值对数据库，数据库的值可以是字符串、集合、列表等多种类型的对象，而数据库的键则总是字符串对象。 对于那些包含字符串值的字符串对象来说，每个字符串对象都包含一个<code>sds</code>值。（字符串还可以保存<code>long</code>类型的值，当字符串对象保存的是字符串时，它包含的才是<code>sds</code>值，否则的话，它就是一个<code>long</code>类型的值）</p>
<h6 id="（2）sds的实现"><a href="#（2）sds的实现" class="headerlink" title="（2）sds的实现"></a>（2）<code>sds</code>的实现</h6><p><code>sds</code>既可以高效地 实现追加和长度计算，并且它还是二进制安全的。<code>sds</code>的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> len;     <span class="comment">// buf 已占用长度    </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;    <span class="comment">// buf 剩余可用长度   </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  <span class="comment">// 实际保存字符串数据的地方</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，类型<code>sds</code>是<code>char *</code>的别名，而结构<code>sdshdr</code>则保存了<code>len</code>、<code>free</code>和<code>buf</code>三个属性。通过对<code>buf</code>分配一些额外的空间（执行<code>APPEND</code>之后），并使用<code>free</code>记录未使用空间的大小，<code>sdshdr</code>可以让执行追加操作所需的内存重分配次数大大减少。</p>
<p>在目前版本的<code>Redis</code>中，<code>SDS_MAX_PREALLOC</code>的值为 1024 * 1024 ，也就是说，当大小小于 1MB 的字符串执行追加操作时，<code>sdsMakeRoomFor</code>就为它们分配多于所需大小一倍的空间；当 字符串的大小大于 1MB ，那么<code>sdsMakeRoomFor</code>就为它们额外多分配 1MB 的空间。</p>
<p><code>sds</code>模块基于<code>sds</code>类型和<code>sdshdr</code>结构提供了以下<code>API</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712214905.png"></p>
<h5 id="2、双端链表"><a href="#2、双端链表" class="headerlink" title="2、双端链表"></a>2、双端链表</h5><h6 id="（1）双端链表的作用"><a href="#（1）双端链表的作用" class="headerlink" title="（1）双端链表的作用"></a>（1）双端链表的作用</h6><p>双端链表还是<code>Redis</code>列表类型的底层实现之一，当对列表类型的键进行操作，比如执行<code>RPUSH</code>、<code>LPOP</code>或<code>LLEN</code>等命令时，程序在底层操作的可能就是双端链表。</p>
<ul>
<li>节点带有前驱和后继指针，访问前驱节点和后继节点的复杂度为<code>O(1)</code>，并且对链表的迭代可以在从表头到表尾和从表尾到表头两个方向进行；</li>
<li>链表带有指向表头和表尾的指针，因此对表头和表尾进行处理的复杂度为<code>O(1)</code>；</li>
<li>链表带有记录节点数量的属性，所以可以在<code>O(1)</code>复杂度内返回链表的节点数量；</li>
</ul>
<p><code>Redis</code>列表使用两种数据结构作为底层实现：<strong>双端链表</strong>和<strong>压缩列表</strong>。因为双端链表占用的内存比压缩列表要多，所以当创建新的列表键时，列表会优先考虑使用压缩列表作为底层实现，并且在有需要的时候，才从压缩列表实现转换到双端链表实现。 </p>
<h6 id="（2）双端链表的实现"><a href="#（2）双端链表的实现" class="headerlink" title="（2）双端链表的实现"></a>（2）双端链表的实现</h6><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712214831.png" style="zoom:50%;" />

<p>双端链表的实现由<code>listNode</code>和<code>list</code>两个数据结构构成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">其中，listNode 是双端链表的节点：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 前驱节点    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 后继节点   </span></span><br><span class="line">    <span class="keyword">void</span> *value;            <span class="comment">// 值</span></span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line">而 <span class="built_in">list</span> 则是双端链表本身：</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span>    </span><br><span class="line">    listNode *head;      <span class="comment">// 表头指针   </span></span><br><span class="line">    listNode *tail;      <span class="comment">// 表尾指针    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;   <span class="comment">// 节点数量    </span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  <span class="comment">// 复制函数    </span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  <span class="comment">// 释放函数   </span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 比对函数</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>以下是用于操作双端链表的<code>API</code>，它们的作用以及算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712215531.png"></p>
<h5 id="3、字典"><a href="#3、字典" class="headerlink" title="3、字典"></a>3、字典</h5><h6 id="（1）字典的作用："><a href="#（1）字典的作用：" class="headerlink" title="（1）字典的作用："></a>（1）字典的作用：</h6><ul>
<li><p>实现数据库键空间</p>
<p><code>Redis</code>是一个键值对数据库，数据库中的键值对就由字典保存：每个数据库都有一个与之相对应的字典，这个字典被称之为键空间。 当用户添加一个键值对到数据库时（不论键值对是什么类型），程序就将该键值对添加到键空间；当用户从数据库中删除一个键值对时，程序就会将这个键值对从键空间中删除；</p>
</li>
<li><p>用作<code>Hash</code>类型键的其中一种底层实现。因为压缩列表比字典更节省内存，所以程序在创建新<code>Hash</code>键时，默认使用压缩列表作为底层实现，当有需要时，程序才会将底层实现从压缩列表转换到字典。</p>
</li>
</ul>
<h6 id="（2）字典的实现"><a href="#（2）字典的实现" class="headerlink" title="（2）字典的实现"></a>（2）字典的实现</h6><p><code>Redis</code>选择了高效且实现简单的<strong>哈希表</strong>作为字典的底层实现。每个字典使用两个哈希表，用于实现渐进式<code>rehash</code>。0 号哈希表（<code>ht[0]</code>）是字典主要使用的哈希表，而 1 号哈希表（<code>ht[1]</code>）则只有在程序 对 0 号哈希表进行<code>rehash</code>时才使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;<span class="comment">// 特定于类型的处理函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;<span class="comment">// 类型处理函数的私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// 哈希表（2 个）</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;<span class="comment">// 记录 rehash 进度的标志，值为-1 表示 rehash 未进行</span></span><br><span class="line">    <span class="keyword">int</span> iterators;<span class="comment">// 当前正在运作的安全迭代器数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>以下是用于处理<code>dict</code>类型的<code>API</code>，它们的作用及相应的算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712215510.png"></p>
<h6 id="（3）哈希表的实现"><a href="#（3）哈希表的实现" class="headerlink" title="（3）哈希表的实现"></a>（3）哈希表的实现</h6><p>使用链地址法来处理碰撞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;   <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>      <span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 链往后继节点</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;     <span class="comment">// 哈希表节点指针数组（俗称桶，bucket）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;    <span class="comment">// 指针数组的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">// 指针数组的长度掩码，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;    <span class="comment">// 哈希表现有的节点数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p><strong>整个字典的结构：</strong></p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712220052.png" style="zoom:50%;" />

<h6 id="（4）哈希算法"><a href="#（4）哈希算法" class="headerlink" title="（4）哈希算法"></a>（4）哈希算法</h6><p><code>Redis</code>目前使用两种不同的哈希算法：</p>
<ul>
<li><code>MurmurHash2 32 bit</code>算法：这种算法的分布率和速度都非常好</li>
<li>基于<code>djb</code>算法实现的一个大小写无关散列算法</li>
</ul>
<p>使用哪种算法取决于具体应用所处理的数据：</p>
<ul>
<li>命令表以及<code>Lua</code>脚本缓存都用到了算法 2 </li>
<li>算法 1 的应用则更加广泛：数据库、集群、哈希键、阻塞操作等功能都用到了这个算法。</li>
</ul>
<h6 id="（5）添加新元素操作"><a href="#（5）添加新元素操作" class="headerlink" title="（5）添加新元素操作"></a>（5）添加新元素操作</h6><ul>
<li><p>字典为空</p>
<p>当第一次往空字典里添加键值对时，程序会根据<code>dict.h/DICT_HT_INITIAL_SIZE</code>里指定的大小为<code>d-&gt;ht[0]-&gt;table</code>分配空间（在目前的版本中，<code>DICT_HT_INITIAL_SIZE</code>的值为 4 ）。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712220535.png" style="zoom:50%;" /></li>
<li><p>添加新键值对时发生碰撞处理，采用链地址法解决冲突。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712220726.png" style="zoom:50%;" /></li>
<li><p>添加新键值对时触发了<code>rehash</code>操作</p>
<p>为了在字典的键值对不断增多的情况下保持良好的性能，字典需要对所使用的哈希表（<code>ht[0]</code>） 进行<code>rehash</code>操作：在不修改任何键值对的情况下，对哈希表进行扩容，尽量将比率维持在 1:1 左右。</p>
<p><code>dictAdd</code>在每次向字典添加新键值对之前，都会对哈希表<code>ht[0]</code>进行检查，对于<code>ht[0]</code>的<code>size</code>和<code>used</code>属性，如果它们之间的比率<code>ratio = used / size</code>满足以下任何一个条件的话，<code>rehash</code>过程就会被激活：</p>
<ul>
<li>自然<code>rehash</code>：<code>ratio &gt;= 1</code>，且变量<code>dict_can_resize</code>为真</li>
<li>强制<code>rehash</code>：<code>ratio</code>大于变量<code>dict_force_resize_ratio</code>（目前版本中，<code>dict_force_resize_ratio</code>的值为 5 ）。</li>
</ul>
</li>
</ul>
<h6 id="（6）rehash的执行过程"><a href="#（6）rehash的执行过程" class="headerlink" title="（6）rehash的执行过程"></a>（6）<code>rehash</code>的执行过程</h6><ul>
<li>设置字典的<code>rehashidx</code>为 0 ，标识着<code>rehash</code>的开始；创建一个比<code>ht[0]-&gt;table</code>更大的<code>ht[1]-&gt;table</code>，大小至少为<code>ht[0]-&gt;used</code>的两倍；</li>
<li>将<code>ht[0]-&gt;table</code>中的所有键值对迁移到<code>ht[1]-&gt;table</code>；因为<code>rehash</code>是<strong>分多次进行</strong>的，字典的<code>rehashidx</code>变量会记录<code>rehash</code>进行到<code>ht[0]</code>的哪个索引位置上。</li>
<li>将原有<code>ht[0]</code>的数据清空，并将<code>ht[1]</code>替换为新的<code>ht[0]</code>。创建一个新的空哈希表，并将它设置为<code>ht[1]</code>，将字典的<code>rehashidx</code>属性设置为 -1 ，标识<code>rehash</code>已停止；</li>
</ul>
<p>采用渐进式<code>rehash</code>，由于要求服务器必须阻塞直到<code>rehash</code>完成，这对于<code>Redis</code>服务器本身也是不能接受的，因此使用了渐进式的<code>rehash</code>方式：通过将<code>rehash</code>分散到多个步骤中进行，从而避免了集中式的计算。渐进式<code>rehash</code>主要由 <code>_dictRehashStep</code>和<code>dictRehashMilliseconds</code>两个函数进行。</p>
<h6 id="（7）字典的收缩"><a href="#（7）字典的收缩" class="headerlink" title="（7）字典的收缩"></a>（7）字典的收缩</h6><p>收缩<code>rehash</code>和扩展<code>rehash</code>的操作几乎一样，它执行以下步骤：</p>
<ul>
<li>创建一个比<code>ht[0]-&gt;table</code>小的<code>ht[1]-&gt;table</code>；</li>
<li>将<code>ht[0]-&gt;table</code>中的所有键值对迁移到<code>ht[1]-&gt;table</code>；</li>
<li>将原有<code>ht[0]</code>的数据清空，并将<code>ht[1]</code>替换为新的<code>ht[0]</code>；</li>
</ul>
<p>以下函数是这个迭代器的<code>API</code>，它们的作用及相关算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712221632.png"></p>
<h5 id="4、跳跃表"><a href="#4、跳跃表" class="headerlink" title="4、跳跃表"></a>4、跳跃表</h5><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712222047.png" style="zoom:50%;" />

<p>跳跃表是一种随机化数据结构，它的查找、添加、删除操作都可以在对数期望时间下完成。跳跃表目前在<code>Redis</code>的唯一作用就是作为有序集类型的底层数据结构（之一，另一个构成有序集的结构是字典）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span><span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表的节点由 redis.h/zskiplistNode 定义：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;<span class="comment">// member 对象</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">// 分值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span><span class="comment">// 层</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">// 前进指针</span></span><br><span class="line">    	<span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>以下是操作这两个数据结构的<code>API</code>，它们的作用以及相应的算法复杂度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712221919.png"></p>
<h4 id="二、内存映射数据结构"><a href="#二、内存映射数据结构" class="headerlink" title="二、内存映射数据结构"></a>二、内存映射数据结构</h4><h5 id="1、整数集合（intset）"><a href="#1、整数集合（intset）" class="headerlink" title="1、整数集合（intset）"></a>1、整数集合（intset）</h5><h6 id="（1）整数集合"><a href="#（1）整数集合" class="headerlink" title="（1）整数集合"></a>（1）整数集合</h6><p>用于有序、无重复的保存多个整数值，它会根据元素的值，自动选择改用什么长度的整数类型来保存元素。<code>intset</code>是集合键的底层实现之一，如果一个集合只保存着整数元素、且元素数量不多的情况下，那么<code>redis</code>就会用<code>intset</code>来保存集合元素。<code>Intset</code>是有序的，程序使用二分查找算法来实现查找操作，复杂度为<code>O(lgN)</code> 。</p>
<h6 id="（2）数据结构和主要操作"><a href="#（2）数据结构和主要操作" class="headerlink" title="（2）数据结构和主要操作"></a>（2）数据结构和主要操作</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;    <span class="comment">// 保存元素所使用的的类型的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;      <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];    <span class="comment">// 保存元素的数组</span></span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>

<p><code>encoding</code>的值可以使以下三种之一：</p>
<ul>
<li><code># define INTSET_ENC_INT16 (sizeof(int16_t))</code></li>
<li><code># define INTSET_ENC_INT32 (sizeof(int32_t))</code></li>
<li><code># define INTSET_ENC_INT64 (sizeof(int64_t))</code></li>
</ul>
<p><code>contents</code>数组是实际保存元素的地方，数组中的元素有以下另两个特性：</p>
<ul>
<li>无重复元素；</li>
<li>元素在数组中从小到大排列。</li>
</ul>
<p>下表列出了处理<code>intset</code>的一些主要操作，以及这些操作的算法复杂度：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712115759.png" style="zoom:80%;" />

<p><strong>实例：创建并插入元素：</strong></p>
<p>创建<code>intset</code>之后，就可以对它添加新元素了。 添加新元素到<code>intset</code>的工作由 <code>intset.c/intsetAdd</code>函数完成，它需要处理以下三种情况： </p>
<ul>
<li>元素已存在于集合，不做动作；</li>
<li>元素不存在于集合，并且添加新元素并不需要升级（现有的编码方式适用于新元素）；</li>
<li>元素不存在于集合，但是要在升级之后，才能添加新元素。在添加新元素时，如果<code>intsetAdd</code>发现新元素不能用现有的编码方式来保存，它就会将升级集 合和添加新元素的任务转交给<code>intsetUpgradeAndAdd</code>来完成：</li>
</ul>
<p>并且，<code>intsetAdd</code>需要维持<code>intset-&gt;contents</code>的以下性质：</p>
<ul>
<li>确保数组中没有重复元素；</li>
<li>确保数组中的元素按从小到大排序。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">intset *is = intsetNew();   <span class="comment">// encoding 使用 INTSET_ENC_INT16 作为初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，不需要升级</span></span><br><span class="line">intsetAdd(is, <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">12</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/** 此时：</span></span><br><span class="line"><span class="comment"> is-&gt;encoding = INTSET_ENC_INT16;</span></span><br><span class="line"><span class="comment"> is-&gt;length = 3;</span></span><br><span class="line"><span class="comment"> is-&gt;contents = [5, 10, 12]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素，需要升级</span></span><br><span class="line">intsetAdd(is, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">65535</span>, <span class="literal">NULL</span>);</span><br><span class="line">intsetAdd(is, <span class="number">70000</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/** 此时：</span></span><br><span class="line"><span class="comment"> is-&gt;encoding = INTSET_ENC_INT32;</span></span><br><span class="line"><span class="comment"> is-&gt;length = 3;</span></span><br><span class="line"><span class="comment"> is-&gt;contents = [1, 65535, 70000]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">intsetAdd(is, <span class="number">4294967295</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/** 此时：</span></span><br><span class="line"><span class="comment"> is-&gt;encoding = INTSET_ENC_INT64;</span></span><br><span class="line"><span class="comment"> is-&gt;length = 4;</span></span><br><span class="line"><span class="comment"> is-&gt;contents = [1, 65535, 70000, 4294967295]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<p><strong>升级过程：</strong></p>
<p><code>intsetUpgradeAndAdd</code>需要完成以下几个任务：</p>
<ul>
<li>对新元素进行检测，看保存这个新元素需要什么类型的编码</li>
<li>将集合<code>encoding</code>属性的值设置为新编码类型，并根据新编码类型，对整个 <code>contents</code>数组进行内存重分配；</li>
<li>调整<code>contents</code>数组内原有元素在内存中的排列方式，让它们从旧编码调整为新编码。（<code>intset</code>只进行从较短整数到较长整数的转换，并不会更改元素里面的值；集合编码元素的方式，由元素中长度最大的那个值来决定）</li>
<li>将新元素添加到集合中。 </li>
</ul>
<p><strong>【一个实例帮助理解】：</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设有一个`intset`，里面包含三个用`<span class="keyword">int16_t</span>`方式保存的数值，分别是 <span class="number">1</span> 、<span class="number">2</span> 和 <span class="number">3</span> ，它的结构如下：</span><br><span class="line">intset-&gt;encoding = INTSET_ENC_INT16;</span><br><span class="line">intset-&gt;length = <span class="number">3</span>;</span><br><span class="line">intset-&gt;contents = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">其中，`intset-&gt;contents`在内存中的排列如下： </span><br><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span> </span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> |</span><br></pre></td></tr></table></figure>

<p>现在要将一个长度为<code>int32_t</code>的值 65535 加入到集合中，<code>intset</code>需要执行以下步骤：</p>
<ul>
<li>将<code>encoding</code>属性设置为<code>INTSET_ENC_INT32</code></li>
<li>根据<code>encoding</code>属性的值，对<code>contents</code>数组进行内存重分配。 重分配完成之后，<code>contents</code>在内存中的排列如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span>  <span class="number">63</span>  <span class="number">95</span>  <span class="number">127</span></span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | ? | ? | ? |</span><br><span class="line">contents 数组现在共有可容纳 <span class="number">4</span> 个 <span class="keyword">int32_t</span> 值的空间。</span><br></pre></td></tr></table></figure>

<p>因为原来的 3 个<code>int16_t</code>值还“挤在”<code>contents</code>前面的 48 个位里，所以程序需要对它们进行移动和类型转换，从而让它们适应集合的新编码方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">首先是移动 <span class="number">3</span> ：</span><br><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span>  <span class="number">63</span>  <span class="number">95</span>  <span class="number">127</span></span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | ? | <span class="number">3</span> | ? |</span><br><span class="line">                |       ^</span><br><span class="line">                |       |</span><br><span class="line">                +-------+</span><br><span class="line">           <span class="keyword">int16_t</span> -&gt; <span class="keyword">int32_t</span></span><br><span class="line"></span><br><span class="line">接着移动 <span class="number">2</span> ：</span><br><span class="line">bit   <span class="number">0</span>   <span class="number">15</span>  <span class="number">31</span>  <span class="number">47</span>  <span class="number">63</span>  <span class="number">95</span>  <span class="number">127</span></span><br><span class="line">value | <span class="number">1</span> | <span class="number">2</span> |   <span class="number">2</span>   | <span class="number">3</span> | ? |</span><br><span class="line">            |     ^</span><br><span class="line">            |     |</span><br><span class="line">            +-----+</span><br><span class="line">      <span class="keyword">int16_t</span> -&gt; <span class="keyword">int32_t</span></span><br><span class="line">    </span><br><span class="line">最后，移动 <span class="number">1</span> ：</span><br><span class="line">bit   <span class="number">0</span>  <span class="number">15</span>  <span class="number">31</span> <span class="number">47</span> <span class="number">63</span> <span class="number">95</span> <span class="number">127</span></span><br><span class="line">value |  <span class="number">1</span>   |  <span class="number">2</span>  | <span class="number">3</span> | ? |</span><br><span class="line">        |^</span><br><span class="line">        V|</span><br><span class="line"><span class="keyword">int16_t</span> -&gt; <span class="keyword">int32_t</span></span><br><span class="line">    </span><br><span class="line">最后，将新值 <span class="number">65535</span> 添加到数组：</span><br><span class="line">bit   <span class="number">0</span> <span class="number">15</span>  <span class="number">31</span> <span class="number">47</span>  <span class="number">63</span>   <span class="number">95</span>     <span class="number">127</span></span><br><span class="line">value |  <span class="number">1</span>  |   <span class="number">2</span>  |  <span class="number">3</span> | <span class="number">65535</span> |</span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                           add</span><br><span class="line">将 intset-&gt;length 设置为 <span class="number">4</span> 。</span><br><span class="line">    </span><br><span class="line">至此，集合的升级和添加操作完成，现在的 intset 结构如下：</span><br><span class="line">intset-&gt;encoding = INTSET_ENC_INT32;</span><br><span class="line">intset-&gt;length = <span class="number">4</span>;</span><br><span class="line">intset-&gt;contents = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">65535</span>];</span><br></pre></td></tr></table></figure>

<h5 id="2、压缩列表（Ziplist）"><a href="#2、压缩列表（Ziplist）" class="headerlink" title="2、压缩列表（Ziplist）"></a>2、压缩列表（Ziplist）</h5><h6 id="（1）压缩列表"><a href="#（1）压缩列表" class="headerlink" title="（1）压缩列表"></a>（1）压缩列表</h6><p><code>Ziplist</code>是由一系列特殊编码的内存块构成的列表，一个<code>ziplist</code>可以包含多个节点，每 个节点可以保存一个长度受限的字符数组（不以<code>\0</code>结尾的<code>char</code>数组）或者整数。因为<code>ziplist</code>节约内存的性质，它被哈希键、列表键和有序集合键作为初始化的底层实现来使用。</p>
<h6 id="（2）ziplist的构成"><a href="#（2）ziplist的构成" class="headerlink" title="（2）ziplist的构成"></a>（2）ziplist的构成</h6><p><code>ziplist</code>的构成：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/ferufyheo.png"></p>
<p><code>ziplist</code>可以包含多个节点，每个节点可以划分为以下几个部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712142045.png"></p>
<ul>
<li><code>pre_entry_length</code>记录了前一个节点的长度，通过这个值，可以进行指针计算，从而跳转到 上一个节点。</li>
<li><code>encoding</code>和<code>length</code>两部分一起决定了<code>content</code>部分所保存的数据的类型（以及长度）。 其中，<code>encoding</code>域的长度为两个<code>bit</code>，它的值可以是00 、01 、10 和 11。00 、01 和 10 表示<code>content</code>部分保存着字符数组。 11 表示 <code>content</code>部分保存着整数。</li>
<li><code>content</code>部分保存着节点的内容，它的类型和长度由<code>encoding</code>和<code>length</code>决定。</li>
</ul>
<p><strong>用于操作<code>ziplist</code>的函数：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/gbklmglb.jpg"></p>
<p><strong>将节点添加到末端：</strong></p>
<p>将新节点添加到<code>ziplist</code>的末端需要执行以下三个步骤：</p>
<ul>
<li>记录到达<code>ziplist</code>末端所需的偏移量（因为之后的内存重分配可能会改变 <code>ziplist</code>的地址， 因此记录偏移量而不是保存指针）</li>
<li>根据新节点要保存的值，计算出编码这个值所需的空间大小，以及编码它前一个节点的长度所需的空间大小，然后对<code>ziplist</code>进行内存重分配。</li>
<li>设置新节点的各项属性：<code>pre_entry_length</code>、<code>encoding</code> 、<code>length</code>和 <code>content</code>。</li>
<li>更新<code>ziplist</code>的各项属性，比如记录空间占用的<code>zlbytes</code>，到达表尾节点的偏移量<code>zltail</code>，以及记录节点数量的<code>zllen</code>。</li>
</ul>
<h4 id="三、Redis-数据类型"><a href="#三、Redis-数据类型" class="headerlink" title="三、Redis 数据类型"></a>三、Redis 数据类型</h4><h5 id="1、redisObject-数据结构，以及-Redis-的数据类型"><a href="#1、redisObject-数据结构，以及-Redis-的数据类型" class="headerlink" title="1、redisObject 数据结构，以及 Redis 的数据类型"></a>1、redisObject 数据结构，以及 Redis 的数据类型</h5><p><code>redisObject</code>是<code>Redis</code>类型系统的核心，数据库中的每个键、值，以及<code>Redis</code>本身处理的参数， 都表示为这种数据类型。<code>redisObject</code>的定义位于<code>redis.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;      <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;   <span class="comment">// 对齐位</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;  <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;      <span class="comment">// LRU 时间（相对于 server.lruclock）</span></span><br><span class="line">    <span class="keyword">int</span> refcount;         <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;            <span class="comment">// 指向对象的值</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><code>type</code>、<code>encoding</code>和<code>ptr</code>是最重要的三个属性。<code>type</code>记录了对象所保存的值的类型，它的值可能是以下常量的其中一个（定义位于<code>redis.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0 <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1   <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2    <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3   <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4   <span class="comment">// 哈希表</span></span></span><br></pre></td></tr></table></figure>

<p><code>encoding</code>记录了对象所保存的值的编码，它的值可能是以下常量的其中一个（定义位于<code>redis.h</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0        <span class="comment">// 编码为字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1        <span class="comment">// 编码为整数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2         <span class="comment">// 编码为哈希表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3     <span class="comment">// 编码为 zipmap</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">// 编码为双端链表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5    <span class="comment">// 编码为压缩列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6     <span class="comment">// 编码为整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7   <span class="comment">// 编码为跳跃表</span></span></span><br></pre></td></tr></table></figure>

<p><code>ptr</code>是一个指针，指向实际保存值的数据结构，这个数据结构由<code>type</code>属性和 <code>encoding</code>属性决定。例如，如果一个<code>redisObject</code>的<code>type</code>属性为<code>REDIS_LIST</code>， <code>encoding</code>属性为<code>REDIS_ENCODING_LINKEDLIST</code>，那么这个对象就是一个<code>Redis</code>列表，它的值保存在一个双端链表内，而<code>ptr</code>指针就指向这个双端链表；如果一个 <code>redisObject</code>的<code>type</code>属性为<code>REDIS_HASH</code>，<code>encoding</code>属性为 <code>REDIS_ENCODING_ZIPMAP</code>，那么这个对象就是一个<code>Redis</code>哈希表，它的值保存在一个<code>zipmap</code>里，而<code>ptr</code>指针就指向这个<code>zipmap</code>，诸如此类。</p>
<p>下图展示了<code>redisObject</code>、<code>Redis</code>所有数据类型、以及<code>Redis</code>所有编码方式（底层实现）三者之间的关系：(<code>REDIS_ENCODING_ZIPMAP</code>没有出现在图中，因为从 <code>Redis 2.6</code>开始，它不再是任何数据类型的底层结构。)</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712144419.png" style="zoom: 50%;" />

<h5 id="2、命令的类型检查和多态"><a href="#2、命令的类型检查和多态" class="headerlink" title="2、命令的类型检查和多态"></a>2、命令的类型检查和多态</h5><p>对键<code>key</code>执行<code>LPOP</code>命令的完整过程：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712144643.png" style="zoom:50%;" />

<h5 id="3、对象共享"><a href="#3、对象共享" class="headerlink" title="3、对象共享"></a>3、对象共享</h5><p>有一些对象在<code>Redis</code>中非常常见，比如命令的返回值<code>OK</code>、<code>ERROR</code>、<code>WRONGTYPE</code> 等字符，另外， 一些小范围的整数，比如个位、十位、百位的整数都非常常见。为了利用这种常见情况，<code>Redis</code>在内部使用了一个<code>Flyweight</code>模式 ：通过预分配一些常见的值对象，并在多个数据结构之间共享这些对象，程序避免了重复分配的麻烦，也节约了一些 CPU 时间。 </p>
<p><code>Redis</code>预分配的值对象有如下这些：</p>
<ul>
<li>各种命令的返回值，比如执行成功时返回的<code>OK</code>，执行错误时返回的<code>ERROR</code>，类型错误时返回的<code>WRONGTYPE</code>，命令入队事务时返回的<code>QUEUED</code>等。 </li>
<li>包括0在内，小于<code>redis.h/REDIS_SHARED_INTEGERS</code>的所有整数 （<code>REDIS_SHARED_INTEGERS</code>的默认值为 10000）</li>
</ul>
<p>共享对象只能被字典和双端链表这类能<strong>带有指针</strong>的数据结构使用。像整数集合和压缩列表这些只能保存字符串、整数等字面值的内存数据结构，就不能使用共享对象。</p>
<h5 id="4、-引用计数以及对象的销毁"><a href="#4、-引用计数以及对象的销毁" class="headerlink" title="4、 引用计数以及对象的销毁"></a>4、 引用计数以及对象的销毁</h5><p><code>Redis</code>的对象系统使用了引用计数技术来负责维持和销毁对象，它的运作机制：</p>
<ul>
<li>每个<code>redisObject</code>结构都带有一个<code>refcount</code>属性，指示这个对象被引用了多少次。 </li>
<li>当新创建一个对象时，它的<code>refcount</code>属性被设置为 1 。</li>
<li>当对一个对象进行共享时，<code>Redis</code>将这个对象的<code>refcount</code>增一。 </li>
<li>当使用完一个对象之后，或者取消对共享对象的引用之后，程序将对象的 <code>refcount</code>减 一。</li>
<li>当对象的<code>refcount</code>降至 0 时，这个<code>redisObject</code>结构，以及它所引用的数据结构的内存，都会被释放。</li>
</ul>
<h5 id="5、字符串"><a href="#5、字符串" class="headerlink" title="5、字符串"></a>5、字符串</h5><p>字符串类型分别使用<code>REDIS_ENCODING_INT</code>和<code>REDIS_ENCODING_RAW</code>两种编码： </p>
<ul>
<li><code>REDIS_ENCODING_INT</code>使用<code>long</code>类型来保存<code>long</code>类型值。</li>
<li><code>REDIS_ENCODING_RAW</code>则使用<code>sdshdr</code>结构来保存<code>sds（也即是 char* )</code>、<code>long long</code>、<code>double</code>和<code>long double</code>类型值。 换句话来说，在<code>Redis</code>中，只有能表示为<code>long</code>类型的值，才会以整数的形式保存，其他类型的整数、小数和字符串，都是用<code>sdshdr</code>结构来保存。</li>
</ul>
<p>新创建的字符串默认使用<code>REDIS_ENCODING_RAW</code>编码，在将字符串作为键或者值保存进数据库时，程序会尝试将字符串转为<code>REDIS_ENCODING_INT</code>编码。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712145626.png" style="zoom:50%;" />

<h5 id="6、哈希表"><a href="#6、哈希表" class="headerlink" title="6、哈希表"></a>6、哈希表</h5><p><code>REDIS_HASH</code>（哈 希 表）是<code>HSET</code>、<code>HLEN</code>等命令的操作对象，它使用 <code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_HT</code>两种编码方式：</p>
<ul>
<li><p>字典编码的哈希表：将哈希表的键保存为字典的键，将哈希表的值保存为字典的值。 哈希表所使用的字典的键和值都是字符串对象。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712145920.png" style="zoom:50%;" /></li>
<li><p>压缩列表编码的哈希表：程序通过将键和值一同推入压缩列表，从而形成保存哈希表所需的键-值对结构，新添加的<code>key-value</code>对会被添加到压缩列表的表尾。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/efvfv.png" style="zoom:50%;" /></li>
</ul>
<p>创建空白哈希表时，程序默认使用<code>REDIS_ENCODING_ZIPLIST</code>编码。</p>
<p>当以下任何一个条件被满足时，程序将编码从切换为<code>REDIS_ENCODING_HT</code>：哈希表中某个键或某个值的长度大于<code>server.hash_max_ziplist_value</code>（默认值为 64 ）；压缩列表中的节点数量大于<code>server.hash_max_ziplist_entries</code>（默认值为 512 ）。</p>
<h5 id="7、列表"><a href="#7、列表" class="headerlink" title="7、列表"></a>7、列表</h5><p><code>REDIS_LIST</code>是<code>LPUSH</code>、<code>LRANGE</code>等命令的操作对象，它使用 <code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_LINKEDLIST</code>这两种方式编码：</p>
<ul>
<li>创建新列表时<code>Redis</code>默认使用<code>REDIS_ENCODING_ZIPLIST</code>编码。</li>
<li>当以下任意一个条件被满足时，列表会被转换成<code>REDIS_ENCODING_LINKEDLIST</code>编码：试图往列表新添加一个字符串值，且这个字符串的长度超过<code>server.list_max_ziplist_value</code>（默认值为 64 ）。<code>ziplist</code>包含的节点超过<code>server.list_max_ziplist_entries</code>（默认值为 512 ）。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712150539.png" style="zoom:50%;" />

<h6 id="阻塞的条件："><a href="#阻塞的条件：" class="headerlink" title="阻塞的条件："></a>阻塞的条件：</h6><p><code>BLPOP</code>、<code>BRPOP</code>和<code>BRPOPLPUSH</code>三个命令都可能造成客户端被阻塞，以下将这些命令统称为列表的阻塞原语。 阻塞原语并不是一定会造成客户端阻塞：只有当这些命令被用于空列表时，它们才会阻塞客户端。如果被处理的列表不为空的话，它们就执行无阻塞版本的<code>LPOP</code>、<code>RPOP</code>或<code>RPOPLPUSH</code>命令。</p>
<h6 id="脱离阻塞："><a href="#脱离阻塞：" class="headerlink" title="脱离阻塞："></a>脱离阻塞：</h6><p>当客户端被阻塞之后，脱离阻塞状态有以下三种方法：</p>
<ul>
<li>被动脱离：有其他客户端为造成阻塞的键推入了新元素。<code>LPUSH</code>、<code>RPUSH</code>和 <code>LINSERT</code>这三个添加新元素到列表的命令， 在底层都由一个 <code>pushGenericCommand</code>的函数实现，</li>
<li>主动脱离：到达执行阻塞原语时设定的最大阻塞时间。</li>
<li>强制脱离：客户端强制终止和服务器的连接，或者服务器停机。</li>
</ul>
<h5 id="8、集合"><a href="#8、集合" class="headerlink" title="8、集合"></a>8、集合</h5><p><code>REDIS_SET</code>（集 合）是<code>SADD</code>、<code>SRANDMEMBER</code>等命令的操作对象，它使用<code>REDIS_ENCODING_INTSET</code>和<code>REDIS_ENCODING_HT</code>两种方式编码：</p>
<ul>
<li>第一个添加到集合的元素，决定了创建集合时所使用的编码：<ul>
<li>如果第一个元素可以表示为<code>long long</code>类型值（也即是，它是一个整数），那么集合的初始编码为<code>REDIS_ENCODING_INTSET</code>。</li>
<li>否则，集合的初始编码为<code>REDIS_ENCODING_HT</code>。</li>
</ul>
</li>
<li>如果一个集合使用<code>REDIS_ENCODING_INTSET</code>编码，那么当以下任何一个条件被满足时，这个集合会被转换成<code>REDIS_ENCODING_HT</code>编码：<ul>
<li><code>intset</code>保存的整数值个数超过<code>server.set_max_intset_entries</code>（默认值为 512 ）。</li>
<li>试图往集合里添加一个新元素，并且这个元素<strong>不能</strong>被表示为<code>long long</code>类型（也即是， 它不是一个整数）。</li>
</ul>
</li>
</ul>
<h6 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h6><p><code>SINTER</code>和<code>SINTERSTORE</code>两个命令并交集；<code>SUNION</code>和<code>SUNIONSTORE</code> 两个命令求并集；<code>SDIFF</code>和<code>SDIFFSTORE</code>两个命令求集合差。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712151605.png" style="zoom:50%;" />

<h5 id="9、有序集"><a href="#9、有序集" class="headerlink" title="9、有序集"></a>9、有序集</h5><p><code>REDIS_ZSET</code>（有 序 集）是<code>ZADD</code>、<code>ZCOUNT</code>等命令的操作对象，它使用<code>REDIS_ENCODING_ZIPLIST</code>和<code>REDIS_ENCODING_SKIPLIST</code>两种方式编码：</p>
<ul>
<li><p><code>ZIPLIST</code>编码的有序集：将元素保存到<code>ziplist</code>数据结构里面。其中，每个有序集元素以两个相邻的<code>ziplist</code>节点表示，第一个节点保存元素的<code>member</code>域， 第二个元素保存元素的<code>score</code>域。 多个元素之间按<code>score</code>值从小到大排序，如果两个元素的<code>score</code>相同，那么按字典序对<code>member</code>进行对比，决定那个元素排在前面，那个元素排在后面。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/E288HVL7RW3O8EL7.png" style="zoom:50%;" /></li>
<li><p><code>SKIPLIST</code>编码的有序集：元素由<code>redis.h/zset</code>结构来保存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;     <span class="comment">// 字典</span></span><br><span class="line">    zskiplist *zsl; <span class="comment">// 跳跃表</span></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>通过使用字典结构，并将<code>member</code>作为键，<code>score</code>作为值，有序集可以在 <code>O(1)</code>复杂度内：</p>
<ul>
<li>检查给定<code>member</code>是否存在于有序集（被很多底层函数使用）；</li>
<li>取出<code>member</code>对应的<code>score</code>值（实现<code>ZSCORE</code>命令）。</li>
</ul>
<p>通过使用跳跃表，可以让有序集支持以下两种操作：</p>
<ul>
<li>在<code>O(log N)</code>期望时间、<code>O(N)</code>最坏时间内根据<code>score</code>对<code>member</code>进行定位（被很多底层 函数使用）；</li>
<li>范围性查找和处理操作，这是（高效地）实现<code>ZRANGE</code>、<code>ZRANK</code>和 <code>ZINTERSTORE</code>等命令的关键。</li>
</ul>
</li>
<li><p>在通过<code>ZADD</code>命令添加第一个元素到空<code>key</code>时，程序通过检查输入的第一个元素来决定该创建什么编码的有序集。如果第一个元素符合以下条件的话，就创建一个<code>REDIS_ENCODING_ZIPLIST</code>编码的有序集：</p>
<ul>
<li>服务器属性<code>server.zset_max_ziplist_entries</code>的值大于 0 （默认为 128 ）。</li>
<li>元素的<code>member</code>长度小于服务器属性<code>server.zset_max_ziplist_value</code>的值（默认为 64 ）。 </li>
</ul>
</li>
<li><p>否则，程序就创建一个<code>REDIS_ENCODING_SKIPLIST</code>编码的有序集。</p>
</li>
<li><p>对于一个<code>REDIS_ENCODING_ZIPLIST</code>编码的有序集，只要满足以下任一条件，就将它转换为<code>REDIS_ENCODING_SKIPLIST</code>编码：</p>
<ul>
<li><code>ziplist</code>所保存的元素数量超过服务器属性 <code>server.zset_max_ziplist_entries</code>的值 （默认值为 128 ）</li>
<li>新添加元素的<code>member</code>的长度大于服务器属性 <code>server.zset_max_ziplist_value</code>的值 （默认值为 64 ）</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712152428.png" style="zoom:50%;" />

<h4 id="四、功能与实现"><a href="#四、功能与实现" class="headerlink" title="四、功能与实现"></a>四、功能与实现</h4><h5 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h5><p><code>Redis</code>通过<code>MULTI</code>、<code>DISCARD</code>、<code>EXEC</code>和<code>WATCH</code>四个命令来实现事务功能。事务在执行的期间不会主动中断，服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令。一个事务从开始到执行会经历以下三个阶段：开始事务、 命令入队、执行事务。</p>
<h6 id="（1）开始事务"><a href="#（1）开始事务" class="headerlink" title="（1）开始事务"></a>（1）开始事务</h6><p>以<code>MULTI</code>开始一个事务，这个命令唯一做的就是，将客户端的<code>REDIS_MULTI</code>选项打开，让客户端从非事务状态切换到事务状态。</p>
<h6 id="（2）命令入队"><a href="#（2）命令入队" class="headerlink" title="（2）命令入队"></a>（2）命令入队</h6><p>当客户端处于非事务状态下时，所有发送给服务器端的命令都会立即被服务器执行。但是，当客户端进入事务状态之后，服务器在收到来自客户端的命令时，不会立即执行命令， 而是将这些命令全部放进一个事务队列里，然后返回<code>QUEUED</code>，表示命令已入队。事务队列是一个数组，每个数组项是都包含三个属性：要执行的命令、命令的参数、参数的个数。</p>
<h6 id="（3）执行事务"><a href="#（3）执行事务" class="headerlink" title="（3）执行事务"></a>（3）执行事务</h6><p>并不是所有的命令都会被放进事务队列，其中的例外就是<code>EXEC</code>、<code>DISCARD</code>、<code>MULTI</code>和<code>WATCH</code>这四个命令。当这四个命令从客户端发送到服务器时，它们会像客户端处于非事务状态一样，直接被服务器执行。</p>
<p>如果客户端正处于事务状态，那么当<code>EXEC</code>命令执行时，服务器根据客户端所保存的事务队列，以先进先出（FIFO）的方式执行事务队列中的命令：最先入队的命令最先执行，而最后入队的命令最后执行。执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<h6 id="（4）事务状态下的-DISCARD-、MULTI-和-WATCH-命令"><a href="#（4）事务状态下的-DISCARD-、MULTI-和-WATCH-命令" class="headerlink" title="（4）事务状态下的 DISCARD 、MULTI 和 WATCH 命令"></a>（4）事务状态下的 DISCARD 、MULTI 和 WATCH 命令</h6><p><code>DISCARD</code>命令用于取消一个事务，它清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回字符串<code>OK</code>给客户端，说明事务已被取消。 </p>
<p><code>Redis</code>的事务是不可嵌套的，当客户端已经处于事务状态，而客户端又再向服务器发送<code>MULTI</code>时，服务器只是简单地向客户端发送一个错误，然后继续等待其他命令的入队。<code>MULTI</code>命令的发送不会造成整个事务失败，也不会修改事务队列中已有的数据。</p>
<ul>
<li><p><strong>WATCH命令</strong></p>
<ul>
<li><p><code>WATCH</code>只能在客户端进入事务状态之前执行，在事务状态下发送<code>WATCH</code>命令会引发一个错误，但它不会造成整个事务失败，也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。该命令用于在事务开始之前监视任意数量的键：当调用<code>EXEC</code>命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不再执行，直接返回失败，保证事务的安全性。</p>
</li>
<li><p><code>WATCH</code>的实现</p>
<p>在每个代表数据库的<code>redis.h/redisDb</code>结构类型中，都保存了一个 <code>watched_keys</code>字典，字典 的键是这个数据库被监视的键，而字典的值则是一个链表，链表中保存了所有监视这个键的客户端。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712155321.png" style="zoom:50%;" />

<p>通过<code>watched_keys</code>字典，如果程序想检查某个键是否被监视，那么它只要检查字典中是否存在这个键即可；如果程序要获取监视某个键的所有客户端，那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p>
</li>
<li><p> <code>WATCH</code>的触发</p>
</li>
</ul>
<p>  在任何对数据库键空间进行修改的命令成功执行之后（比如<code>FLUSHDB 、SET 、DEL 、LPUSH 、SADD 、ZREM</code>等），<code>multi.c/touchWatchKey</code>函数都会被调用 ——它检查数据库的<code>watched_keys</code>字典，看是否有客户端在监视已经被命令修改的键，如果有的话，程序将所有监视这个/这些被修改键的客户端的<code>REDIS_DIRTY_CAS</code>选项打开。</p>
<p>  当客户端发送<code>EXEC</code>命令、触发事务执行时，服务器会对客户端的状态进行检查：</p>
<ul>
<li><p>如果客户端的<code>REDIS_DIRTY_CAS</code>选项已经被打开，那么说明被客户端监视的键至少有一 个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</p>
</li>
<li><p>如果<code>REDIS_DIRTY_CAS</code>选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712155959.png" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h6 id="（5）事务的-ACID-性质"><a href="#（5）事务的-ACID-性质" class="headerlink" title="（5）事务的 ACID 性质"></a>（5）事务的 ACID 性质</h6><p><code>Redis</code>的事务保证了<code>ACID</code>中的一致性和隔离性，但并不保证原子性和持久性。</p>
<ul>
<li><p>原子性</p>
<p>单个<code>Redis</code>命令的执行是原子性的，但<code>Redis</code>没有在事务上增加任何维持原子性的机制，所以<code>Redis</code>事务的执行并不是原子性的。当事务失败时，<code>Redis</code>也不会进行任何的重试或者回滚动作。</p>
</li>
<li><p>一致性</p>
<p>分为三部分来讨论：入队错误、执行错误、<code>Redis</code>进程被终结。</p>
<ul>
<li>入队错误：在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对等，那么服务器将向客户端返回一个出错信息，并且将客户端的事务状态设为<code>REDIS_DIRTY_EXEC</code>。 当客户端执行<code>EXEC</code>命令时，<code>Redis</code>会拒绝执行状态为<code>REDIS_DIRTY_EXEC</code>的事务，并返回失败信息。因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</li>
<li>执行错误：如果命令在事务执行的过程中发生错误，那么<code>Redis</code>只会将错误包含在事务的结果中，这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令，所以它对事务的一致性也没有影响。</li>
<li><code>Redis</code>进程被终结，根据<code>Redis</code>所使用的持久化模式，可能有以下情况出现：<ul>
<li>内存模式：如果<code>Redis</code>没有采取任何持久化机制，那么重启之后的数据库总是空白的，所 以数据总是一致的。</li>
<li><code>RDB</code>模式：在执行事务时，<code>Redis</code>不会中断事务去执行保存<code>RDB</code>的工作，只有在事务执行之后，保存<code>RDB</code>的工作才有可能开始。所以当 <code>RDB</code>模式下的<code>Redis</code>服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都<strong>不会</strong>被保存到<code>RDB</code>文件里。 恢复数据库需要使用现有的<code>RDB</code>文件，而这个<code>RDB</code>文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要<code>RDB</code>文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</li>
<li><code>AOF</code>模式：因为保存<code>AOF</code>文件的工作在后台线程进行，所以即使是在事务执行的中途， 保存<code>AOF</code>文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到<code>AOF</code>文件，有以下两种情况发生：<ul>
<li>如果事务语句未写入到<code>AOF</code>文件，或<code>AOF</code>未被<code>SYNC</code>调用保存到磁盘，那么当进程被杀死之后，<code>Redis</code>可以根据最近一次成功保存到磁盘的<code>AOF</code>文件来还原数据库，只要<code>AOF</code>文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</li>
<li>如果事务的部分语句被写入到<code>AOF</code>文件，并且<code>AOF</code>文件被成功保存，那么不完整的事务执行信息就会遗留在<code>AOF</code>文件里，当重启 <code>Redis</code>时，程序会检测到<code>AOF</code>文件并不完整，<code>Redis</code>会退出，并报告错误。需要使用<code>redis-check-aof</code>工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>隔离性</p>
<p><code>Redis</code>是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<code>Redis</code>的事务是总是带有隔离性的。</p>
</li>
<li><p>持久性</p>
<p>事 务的持久性由<code>Redis</code>所使用的持久化模式决定：</p>
<ul>
<li>在单纯的内存模式下，事务肯定是不持久的。</li>
<li>在<code>RDB</code>模式下，服务器可能在事务执行之后、<code>RDB</code>文件更新之前的这段时间失败，所以<code>RDB</code>模式下的<code>Redis</code>事务也是不持久的。 </li>
<li>在<code>AOF</code>的“总是<code>SYNC</code>”模式下，事务的每条命令在执行成功之后，都会立即调用<code>fsync</code>或<code>fdatasync</code>将事务数据写入到<code>AOF</code>文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。 其他<code>AOF</code>模式也和“总是<code>SYNC</code>”模式类似，所以它们都是不持久的。</li>
</ul>
</li>
</ul>
<h5 id="2、订阅与发布"><a href="#2、订阅与发布" class="headerlink" title="2、订阅与发布"></a>2、订阅与发布</h5><p><code>Redis</code>通过<code>PUBLISH</code>、<code>SUBSCRIBE</code>等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是<strong>订阅/发布到频道</strong>和<strong>订阅/发布到模式</strong>。</p>
<h6 id="订阅-发布到频道："><a href="#订阅-发布到频道：" class="headerlink" title="订阅/发布到频道："></a>订阅/发布到频道：</h6><h6 id="（1）频道的订阅与信息发送"><a href="#（1）频道的订阅与信息发送" class="headerlink" title="（1）频道的订阅与信息发送"></a>（1）频道的订阅与信息发送</h6><p><code>Redis</code>的<code>SUBSCRIBE</code>命令可以让客户端订阅任意数量的频道，每当有新信息发送到被订阅的频道时，信息就会被发送给所有订阅指定频道的客户端。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712163149.png" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712163243.png" style="zoom:50%;" />

<h6 id="（2）订阅频道-SUBSCRIBE"><a href="#（2）订阅频道-SUBSCRIBE" class="headerlink" title="（2）订阅频道 SUBSCRIBE"></a>（2）订阅频道 SUBSCRIBE</h6><p>每个<code>Redis</code>服务器进程都维持着一个表示服务器状态的<code>redis.h/redisServer</code>结构，结构的<code>pubsub_channels</code>属性是一个字典，这个字典就用于保存订阅频道的信息，其中字典的键为正在被订阅的频道，而字典的值则是一个链表，链表中保存了所有订阅这个 频道的客户端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *pubsub_channels;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712163444.png" style="zoom:50%;" />

<p>通过<code>pubsub_channels</code>字典，程序只要检查某个频道是否字典的键，就可以知道该频道是否正在被客户端订阅；只要取出某个键的值，就可以得到所有订阅该频道的客户端的信息。</p>
<h6 id="（3）发送信息到频道-PUBLISH"><a href="#（3）发送信息到频道-PUBLISH" class="headerlink" title="（3）发送信息到频道 PUBLISH"></a>（3）发送信息到频道 PUBLISH</h6><p>当调用<code>PUBLISH channel message</code>命令，程序首先根据<code>channel</code>定位到字典的键，然后将信息发送给字典值链表中的所有客户端。</p>
<h6 id="（4）-退订频道-UNSUBSCRIBE"><a href="#（4）-退订频道-UNSUBSCRIBE" class="headerlink" title="（4） 退订频道 UNSUBSCRIBE"></a>（4） 退订频道 UNSUBSCRIBE</h6><p>它从<code>pubsub_channels</code>字典的给定频道（键）中，删除关于当前客户端的信息，这样被退订频道的信息就不会再发送给这个客户端。</p>
<h6 id="订阅-发布到模式："><a href="#订阅-发布到模式：" class="headerlink" title="订阅/发布到模式："></a>订阅/发布到模式：</h6><h6 id="（1）-模式的订阅与信息发送"><a href="#（1）-模式的订阅与信息发送" class="headerlink" title="（1） 模式的订阅与信息发送"></a>（1） 模式的订阅与信息发送</h6><p>当使用<code>PUBLISH</code>命令发送信息到某个频道时，不仅所有订阅该频道的客户端会收到信息，如果有某个/某些模式和这个频道匹配的话，那么所有订阅这个/这些频道的客户端也同样会收到信息。</p>
<p>例如：当有信息发送到<code>tweet.shop.kindle</code>频道时，信息除了发送给<code>clientX</code>和 <code>clientY</code>之外，还会发送给订阅<code>tweet.shop.*</code>模式的<code>client123</code>和<code>client256</code>。 </p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712164156.png" style="zoom:50%;" />

<h6 id="（2）订阅模式"><a href="#（2）订阅模式" class="headerlink" title="（2）订阅模式"></a>（2）订阅模式</h6><p><code>redisServer.pubsub_patterns</code>属性是一个链表，链表中保存着所有和模式相关的信息，链表中的每个节点都包含一个<code>redis.h/pubsubPattern</code>结构：：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    redisClient *client;  <span class="comment">// client 属性保存着订阅模式的客户端</span></span><br><span class="line">    robj *pattern;   <span class="comment">// pattern 属性则保存着被订阅的模式。</span></span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>

<p>每当调用<code>PSUBSCRIBE</code>命令订阅一个模式时，程序就创建一个包含客户端信息和被订阅模式的<code>pubsubPattern</code>结构，并将该结构添加到 <code>redisServer.pubsub_patterns</code>链表中。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712165227.png" style="zoom:50%;" />

<h6 id="（3）发送信息到模式"><a href="#（3）发送信息到模式" class="headerlink" title="（3）发送信息到模式"></a>（3）发送信息到模式</h6><p>发送信息到模式的工作也是由<code>PUBLISH</code>命令进行的，除了将<code>message</code>发送到所有订阅<code>channel</code>的客户端之外，它还会将<code>channel</code>和<code>pubsub_patterns</code>中的模式进行对比，如果<code>channel</code>和某个模式匹配的话，那么也将<code>message</code>发送到订阅那个模式的客户端。</p>
<h6 id="（4）退订模式"><a href="#（4）退订模式" class="headerlink" title="（4）退订模式"></a>（4）退订模式</h6><p>使用<code>PUNSUBSCRIBE</code>命令可以退订指定的模式，这个命令执行的是订阅模式的反操作：程序会删除<code>redisServer.pubsub_patterns</code>链表中，所有和被退订模式相关联的<code>pubsubPattern</code>结构，这样客户端就不会再收到和模式相匹配的频道发来的信息。</p>
<h5 id="3、Lua脚本"><a href="#3、Lua脚本" class="headerlink" title="3、Lua脚本"></a>3、Lua脚本</h5><p>使用<code>EVAL</code>和<code>EVALSHA</code>执行<code>Lua</code>脚本。如果一个脚本的执行对任何副作用产生了依赖，那么这个脚本每次执行所产生的结果都可能会不一样。因此，<code>Redis</code>对<code>Lua</code>环境所能执行的脚本做了一个严格的限制：所有脚本都必须是无副作用的纯函数。</p>
<p><code>EVAL</code>直接对输入的脚本代码体进行求值；</p>
<p><code>EVALSHA</code>则要求输入某个脚本的<code>SHA1</code>校验和，这个校验和所对应的脚本必须至少被<code>EVAL</code>执行过一次，或者曾经使用<code>SCRIPT LOAD</code>载入过这个脚本。</p>
<h5 id="4、-慢查询日志"><a href="#4、-慢查询日志" class="headerlink" title="4、 慢查询日志"></a>4、 慢查询日志</h5><p><code>Redis</code>用一个链表以<code>FIFO</code>的顺序保存着所有慢查询日志。</p>
<h6 id="（1）相关数据结构"><a href="#（1）相关数据结构" class="headerlink" title="（1）相关数据结构"></a>（1）相关数据结构</h6><p>每条慢查询日志都以一个<code>slowlog.h/slowlogEntry</code>结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slowlogEntry</span> &#123;</span>    </span><br><span class="line">    robj **argv;  <span class="comment">// 命令参数    </span></span><br><span class="line">    <span class="keyword">int</span> argc;     <span class="comment">// 命令参数数量 </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">// 唯一标识符</span></span><br><span class="line">    <span class="comment">// 执行命令消耗的时间，以纳秒（1 / 1,000,000,000 秒）为单位</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration;    </span><br><span class="line">    <span class="keyword">time_t</span> time;  <span class="comment">// 命令执行时的时间</span></span><br><span class="line">&#125; slowlogEntry;</span><br></pre></td></tr></table></figure>

<p>记录服务器状态的<code>redis.h/redisServer</code>结构里保存了几个和慢查询有关的属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span>   </span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog; <span class="comment">// 保存慢查询日志的链表    </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id; <span class="comment">// 慢查询日志的当前 id 值    </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than; <span class="comment">// 慢查询时间限制   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len; <span class="comment">// 慢查询日志的最大条目数量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>slowlog</code>属性是一个链表，链表里的每个节点保存了一个慢查询日志结构，所有日志按添加时间从新到旧排序，新的日志在链表的左端，旧的日志在链表的右端。</p>
<p> <code>slowlog_entry_id</code>在创建每条新的慢查询日志时增一，用于产生慢查询日志的<code>ID</code>（这个 ID 在执行<code>SLOWLOG RESET</code>之后会被重置）。 </p>
<p><code>slowlog_log_slower_than</code>是用户指定的命令执行时间上限，执行时间大于等于这个值的命令会被慢查询日志记录。 在每次执行命令之前，<code>Redis</code>都会用一个参数记录命令执行前的时间，在命令执行完之后，再计算一次当前时间，然后将两个时间值相减，得出执行命令所耗费的时间值<code>duration</code>，并将<code>duration</code>传给 <code>slowlogPushEntryIfNeed</code>函数。 如果<code>duration</code>超过服务器设置的执行时间上限<code>server.slowlog_log_slower_than</code>的话，<code>slowlogPushEntryIfNeed</code>就会创建一条新的慢查询日志，并将它加入到慢查询日志链表里。</p>
<p><code>slowlog_max_len</code>慢查询日志的最大数量，当日志数量等于这个值时，添加一条新日志会造成最旧的一条日志被删除。</p>
<h4 id="五、内部运作机制"><a href="#五、内部运作机制" class="headerlink" title="五、内部运作机制"></a>五、内部运作机制</h4><h5 id="1、数据库"><a href="#1、数据库" class="headerlink" title="1、数据库"></a>1、数据库</h5><h6 id="（1）数据库的结构"><a href="#（1）数据库的结构" class="headerlink" title="（1）数据库的结构"></a>（1）数据库的结构</h6><p><code>Redis</code>中的每个数据库，都由一个<code>redis.h/redisDb</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span>    </span><br><span class="line">    <span class="keyword">int</span> id;        <span class="comment">// 保存着数据库以整数表示的号码    </span></span><br><span class="line">    dict *dict;    <span class="comment">// 保存着数据库中的所有键值对数据，这个属性也被称为键空间（key space）    </span></span><br><span class="line">    dict *expires; <span class="comment">// 保存着键的过期信息    </span></span><br><span class="line">    dict *blocking_keys;  <span class="comment">// 实现列表阻塞原语，如 BLPOP</span></span><br><span class="line">    dict *ready_keys;    </span><br><span class="line">    dict *watched_keys;   <span class="comment">// 用于实现 WATCH 命令</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><code>redisDb</code>结构的<code>id</code>域保存着数据库的号码。当<code>Redis</code>服务器初始化时， 它会创建出<code>redis.h/REDIS_DEFAULT_DBNUM</code>个数据库， 并 将所有数据库保存到 <code>redis.h/redisServer.db</code>数组中， 每个数据库的<code>id</code>为从 0 到 <code>REDIS_DEFAULT_DBNUM - 1</code>的值。当执行<code>SELECT number</code>命令时，程序直接使用<code>redisServer.db[number]</code>来切换数据库。</p>
<h6 id="（2）数据库键空间"><a href="#（2）数据库键空间" class="headerlink" title="（2）数据库键空间"></a>（2）数据库键空间</h6><p>因为<code>Redis</code>是一个键值对数据库，所以它的数据库本身也是一个字典。字典的键是一个字符串对象。字典的值则可以是包括字符串、列表、哈希表、集合或有序集在内的任意一种<code>Redis</code>类型 对象。在<code>redisDb</code>结构的<code>dict</code>属性中，保存着数据库的所有键值对数据。</p>
<h6 id="（3）数据库键空间的操作"><a href="#（3）数据库键空间的操作" class="headerlink" title="（3）数据库键空间的操作"></a>（3）数据库键空间的操作</h6><p>添加一个新键对到数据库，实际上就是将一个新的键值对添加到键空间字典中，其中键为字符串对象，而值则是任意一种<code>Redis</code>类型值对象。</p>
<p>例如在客户端执行<code>SET date 2013.2.1</code>命令之后，数据库则更新为：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712182313.png" style="zoom:50%;" />

<p>删除数据库中的一个键，实际上就是删除字典空间中对应的键对象和值对象。例如在客户端执行<code>DEL message</code>命令之后，数据库更新为下图状态：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712182457.png" style="zoom:50%;" />

<p>当对一个已存在于数据库的键执行更新操作时，数据库释放键原来的值对象，然后将指针指向新的值对象。</p>
<p>在客户端执行<code>SET message &quot;blah blah&quot;</code>命令之后，数据库更新为下图状态：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712182642.png" style="zoom:50%;" />

<p>其他操作：</p>
<ul>
<li><code>FLUSHDB</code>命令：删除键空间中的所有键值对。</li>
<li><code>RANDOMKEY</code>命令：从键空间中随机返回一个键。</li>
<li><code>DBSIZE</code>命令：返回键空间中键值对的数量。</li>
<li><code>EXISTS</code>命令：检查给定键是否存在于键空间中。</li>
<li><code>RENAME</code>命令：在键空间中，对给定键进行改名。</li>
</ul>
<h6 id="（4）键的过期时间和生存时间"><a href="#（4）键的过期时间和生存时间" class="headerlink" title="（4）键的过期时间和生存时间"></a>（4）键的过期时间和生存时间</h6><p>通过<code>EXPIRE</code>、<code>PEXPIRE</code>、<code>EXPIREAT</code>和<code>PEXPIREAT</code>四个命令，客户端可以给某个存在的键设置过期时间，当键的过期时间到达时，键就不再可用。虽然有那么多种不同单位和不同形式的设置方式，但是<code>expires</code>字典的值只保存“以毫秒为单位的过期 <code>UNIX</code>时间戳” ，这就是说，通过进行转换，所有命令的效果最后都和<code>PEXPIREAT</code>命令的效果一样。</p>
<ul>
<li><code>EXPIRE</code>以秒为单位设置键的生存时间；</li>
<li><code>PEXPIRE</code>以毫秒为单位设置键的生存时间；</li>
<li><code>EXPIREAT</code>以秒为单位，设置键的过期<code>UNIX</code>时间戳；</li>
<li><code>PEXPIREAT</code>以毫秒为单位，设置键的过期<code>UNIX</code>时间戳。</li>
</ul>
<p>命令<code>TTL</code>和<code>PTTL</code>则用于返回给定键距离过期还有多长时间；</p>
<h6 id="（5）过期时间的保存"><a href="#（5）过期时间的保存" class="headerlink" title="（5）过期时间的保存"></a>（5）过期时间的保存</h6><p>在数据库中，所有键的过期时间都被保存在<code>redisDb</code>结构的<code>expires</code>字典里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><code>expires</code>字典的键是一个指向<code>dict</code>字典（键空间）里某个键的指针，而字典的值则是键所指向的数据库键的到期时间，这个值以<code>long long</code>类型表示。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712183229.png" style="zoom:50%;" />

<h6 id="（6）过期键的判定"><a href="#（6）过期键的判定" class="headerlink" title="（6）过期键的判定"></a>（6）过期键的判定</h6><p>通过<code>expires</code>字典，可以用以下步骤检查某个键是否过期：</p>
<ul>
<li>检查键是否存在于<code>expires</code>字典：如果存在，那么取出键的过期时间；</li>
<li>检查当前<code>UNIX</code>时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则， 键未过期。</li>
</ul>
<h6 id="（7）过期键的清除"><a href="#（7）过期键的清除" class="headerlink" title="（7）过期键的清除"></a>（7）过期键的清除</h6><ul>
<li><p>定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理 器自动执行键的删除操作。</p>
<p>定时删除策略对内存是最友好的，因为它保证过期键会在第一时间被删除，过期键所消耗的内 存会立即被释放。但它对 CPU 时间是最不友好的，因为删除操作可能会占用大量的 CPU 时间 ，在内存不紧张、但是 CPU 时间非常紧张的时候（比如说，进行交集计算或排序的时候）， 将 CPU 时间花在删除那些和当前任务无关的过期键上，这种做法毫无疑问会是低效的。</p>
</li>
<li><p>惰性删除：放任键过期不管，但是在每次从<code>dict</code>字典中取出键值时，要检查键是否过 期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值。</p>
<p>惰性删除对 CPU 时间来说是最友好的：它只会在取出键时进行检查，这可以保证删除操作只 会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。 惰性删除的缺点是，它对内存是最不友好的。</p>
</li>
<li><p>定期删除：每隔一段时间，对<code>expires</code>字典进行检查，删除里面的过期键。定期删除是上述两种策略的一种折中，它每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，籍此来减少删除操作对 CPU 时间的影响。另一方面，通过定期删除过期键，它有效地减少了因惰性删除而带来的内存浪费。</p>
</li>
</ul>
<p><code>Redis</code>使用惰性删除和定期删除两种策略来删除过期的键。</p>
<h5 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h5><p>在运行情况下，<code>Redis</code>以数据结构的形式将数据维持在内存中，为了让这些数据在<code>Redis</code>重启 之后仍然可用，<code>Redis</code>分别提供了<code>RDB</code>和<code>AOF</code>两种持久化模式。 在 <code>Redis</code>运行时，<code>RDB</code>程序将当前内存中的<strong>数据库快照以二进制的方式</strong>保存到磁盘文件中，在<code>Redis</code>重启动时，<code>RDB</code>程序可以通过载入<code>RDB</code>文件来还原数据库的状态。</p>
<h6 id="（1）rdbSave-和-rdbLoad"><a href="#（1）rdbSave-和-rdbLoad" class="headerlink" title="（1）rdbSave 和 rdbLoad"></a>（1）rdbSave 和 rdbLoad</h6><p><code>RDB</code>功能最核心的是<code>rdbSave</code>和<code>rdbLoad</code>两个函数，前者用于生成<code>RDB</code>文件到磁盘，而后者则用于将<code>RDB</code>文件中的数据重新载入到内存中。</p>
<p><code>rdbSave</code>函数负责将内存中的数据库数据以<code>RDB</code>格式保存到磁盘中，如果<code>RDB</code>文件已存在， 那么新的<code>RDB</code>文件将替换已有的<code>RDB</code>文件。 在保存<code>RDB</code>文件期间，主进程会被阻塞，直到保存完成为止。<code>SAVE</code>和<code>BGSAVE</code>两个命令都会调用<code>rdbSave</code>函数，但它们调用的方式各有不同：</p>
<ul>
<li><code>SAVE</code>直接调用<code>rdbSave</code>，阻塞<code>Redis</code>主进程，直到保存完成为止。在主进程阻塞期间， 服务器不能处理客户端的任何请求。</li>
<li><code>BGSAVE</code>则<code>fork</code>出一个子进程，子进程负责调用<code>rdbSave</code>，并在保存完成之后向主进程发送信号，通知保存已完成。因为<code>rdbSave</code>在子进程被调用，所以 <code>Redis</code>服务器在<code>BGSAVE</code>执行期间仍然可以继续处理客户端的请求。</li>
</ul>
<h6 id="（2）SAVE-、BGSAVE-、AOF-写入和-BGREWRITEAOF"><a href="#（2）SAVE-、BGSAVE-、AOF-写入和-BGREWRITEAOF" class="headerlink" title="（2）SAVE 、BGSAVE 、AOF 写入和 BGREWRITEAOF"></a>（2）SAVE 、BGSAVE 、AOF 写入和 BGREWRITEAOF</h6><p>当<code>SAVE</code>执行时，<code>Redis</code>服务器是阻塞的，所以当<code>SAVE</code>正在执行时，新的<code>SAVE</code>、<code>BGSAVE</code>或<code>BGREWRITEAOF</code>调用都不会产生任何作用。</p>
<p>另外，因为<code>AOF</code>写入由后台线程完成，而<code>BGREWRITEAOF</code>则由子进程完成，所以在<code>SAVE</code>执行的过程中，<code>AOF</code>写入和<code>BGREWRITEAOF</code>可以同时进行。</p>
<p>在执行<code>SAVE</code>命令之前，服务器会检查<code>BGSAVE</code>是否正在执行当中，如果是的话，服务器就 不调用<code>rdbSave</code>，而是向客户端返回一个出错信息，告知在<code>BGSAVE</code>执行期间，不能执行<code>SAVE</code>。</p>
<p><code>BGREWRITEAOF</code>和<code>BGSAVE</code>两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑：并发出两个子进程，并且两个子进程都同时进行大量的磁盘写 入操作，这怎么想都不会是一个好主意。</p>
<h6 id="（3）RDB文件结构"><a href="#（3）RDB文件结构" class="headerlink" title="（3）RDB文件结构"></a>（3）RDB文件结构</h6><p>一个<code>RDB</code>文件可以分为以下几个部分：</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712205121.png" style="zoom:50%;" />

<p><code>REDIS</code>：文件的最开头保存着<code>REDIS</code>五个字符，标识着一个<code>RDB</code>文件的开始。</p>
<p><code>RDB-VERSION</code>：一个四字节长的以字符表示的整数，记录了该文件所使用的<code>RDB</code>版本号。</p>
<p><code>DB-DATA</code>：这个部分在一个<code>RDB</code>文件中会出现任意多次，每个<code>DB-DATA</code>部分保存着服务器上一个非空数据库的所有数据。</p>
<p><code>SELECT-DB</code>：这域保存着跟在后面的键值对所属的数据库号码。</p>
<p><code>KEY-VALUE-PAIRS</code>：因为空的数据库不会被保存到<code>RDB</code>文件，所以这个部分至少会包含一个键值对的数据。</p>
<p><code>EOF</code>：标志着数据库内容的结尾（不是文件的结尾），值为 <code>rdb.h/EDIS_RDB_OPCODE_EOF</code>（255）。</p>
<p><code>CHECK-SUM RDB</code>：文件所有内容的校验和，一个<code>uint_64</code>类型值。</p>
<h5 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h5><p><code>AOF</code>则以协议文本的方式，将所有<strong>对数据库进行过写入的命令</strong>（及其参数）记录到<code>AOF</code>文件，以此达到记录数据库状态的目的。</p>
<p>同步命令到<code>AOF</code>文件的整个过程可以分为三个阶段：</p>
<ul>
<li>命令传播：<code>Redis</code>将执行完的命令、命令的参数、命令的参数个数等信息发送到<code>AOF</code>程序中。</li>
<li>缓存追加：<code>AOF</code>程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的<code>AOF</code>缓存中。</li>
<li>文件写入和保存：<code>AOF</code>缓存中的内容被写入到<code>AOF</code>文件末尾，如果设定的 <code>AOF</code>保存 条件被满足的话，<code>fsync</code>函数或者<code>fdatasync</code>函数会被调用，将写入的内容真正地保存到磁盘中。</li>
</ul>
<p><code>Redis</code>目前支持三种<code>AOF</code>保存模式：</p>
<ul>
<li><p><code>AOF_FSYNC_NO</code>：不保存。在这种模式下，每次调用<code>flushAppendOnlyFile</code>函数，<code>WRITE</code>都会被执行，但<code>SAVE</code>会被略过。在这种模式下，<code>SAVE</code>只会在以下任意一种情况中被执行：<code>Redis</code>被关闭；<code>AOF</code>功能被关闭；系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行） 这三种情况下的<code>SAVE</code>操作都会引起<code>Redis</code>主进程阻塞。</p>
</li>
<li><p><code>AOF_FSYNC_EVERYSEC</code>：每一秒钟保存一次。在这种模式中，<code>SAVE</code>原则上每隔一秒钟就会执行一次（但在实际运行中，程序在这种模式下对<code>fsync</code>或 <code>fdatasync</code>的调用并不是每秒一次，它和调用<code>flushAppendOnlyFile</code>函数时 <code>Redis</code>所处的状态有关。），因为<code>SAVE</code>操作是由后台子线程调用 的，所以它不会引起服务器主进程阻塞。</p>
<img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210712210643.png" style="zoom:50%;" /></li>
<li><p><code>AOF_FSYNC_ALWAYS</code>：每执行一个命令保存一次。在这种模式下，每次执行完一个命令之后，<code>WRITE</code>和<code>SAVE</code>都会被执行。 另外，因为<code>SAVE</code>是由<code>Redis</code>主进程执行的，所以在<code>SAVE</code>执行期间，主进程会被阻塞，不能接受命令请求。</p>
</li>
</ul>
<h6 id="（1）AOF重写和AOF后台重写"><a href="#（1）AOF重写和AOF后台重写" class="headerlink" title="（1）AOF重写和AOF后台重写"></a>（1）AOF重写和AOF后台重写</h6><p>根据键的类型，使用适当的写入命令来重现键的当前值，这就是<code>AOF</code>重写的实现原理。例如，如果服务器对键<code>list</code>执行了以下四条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list 1 2 3 4 &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">RPOP list &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">LPOP list &#x2F;&#x2F; [2, 3]</span><br><span class="line">LPUSH list 1 &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>如果要保存这个列表的当前状态，并且尽量减少所使用的命令数，那么最简单的方式不是去<code>AOF</code>文件上分析前面执行的四条命令，而是直接读取<code>list</code>键在数据库的当前值，然后用一 条<code>RPUSH 1 2 3</code>命令来代替前面的四条命令。</p>
<p><code>Redis</code>不希望<code>AOF</code>重写造成调用线程阻塞，导致服务器无法处理请求，所以<code>Redis</code>决定将<code>AOF</code>重写程序放到（后台）子进程里执行，不过，使用子进程也有一个问题需要解决：因为子进程在进行<code>AOF</code>重写期间，主进程还需要继续处理命令，而新的命令可能对现有的数据进行修改，这会让当前数据库的数据和重写后的<code>AOF</code>文件中的数据不一致。</p>
<p>为了解决这个问题，<code>Redis</code>增加了一个<code>AOF</code>重写缓存，这个缓存在<code>fork</code>出子进程之后开始启用，<code>Redis</code>主进程在接到新的写命令之后，除了会将这个写命令的协议内容追加到现有的<code>AOF</code>文件之外，还会追加到这个缓存中。</p>
<p>换言之，当子进程在执行<code>AOF</code>重写时，主进程需要执行以下三个工作：</p>
<ul>
<li>处理命令请求。</li>
<li>将写命令追加到现有的<code>AOF</code>文件中。</li>
<li>将写命令追加到<code>AOF</code>重写缓存中。</li>
</ul>
<p>当子进程完成<code>AOF</code>重写之后，它会向父进程发送一个完成信号，父进程在接到完成信号之后， 会调用一个信号处理函数，并完成以下工作：</p>
<ul>
<li>将<code>AOF</code>重写缓存中的内容全部写入到新<code>AOF</code>文件中。</li>
<li>对新的<code>AOF</code>文件进行改名，覆盖原有的<code>AOF</code>文件。</li>
</ul>
<p><code>AOF</code>重写可以由用户通过调用<code>BGREWRITEAOF</code>手动触发。</p>
<h5 id="4、事件"><a href="#4、事件" class="headerlink" title="4、事件"></a>4、事件</h5><h6 id="（1）文件事件"><a href="#（1）文件事件" class="headerlink" title="（1）文件事件"></a>（1）文件事件</h6><p><code>Redis</code>将这类因为对套接字进行多路复用而产生的事件称为文件事件，文件事件可 以分为读事件和写事件两类。</p>
<ul>
<li><p>读事件</p>
<p>当一个新的客户端连接到服务器时，服务器会给为该客户端绑定读事件，直到客户端断开连接之后，这个读事件才会被移除。 读事件在整个网络连接的生命期内，都会在等待和就绪两种状态之间切换：</p>
<ul>
<li>当客户端只是连接到服务器，但并没有向服务器发送命令时，该客户端的读事件就处于<strong>等待</strong>状态。</li>
<li>当客户端给服务器发送命令请求，并且请求已到达时（相应的套接字可以无阻塞地执行读操作），该客户端的读事件处于<strong>就绪</strong>状态。</li>
</ul>
</li>
<li><p>写事件</p>
<p>服务器只会在有命令结果要传回给客户端时，才会为客户端关联写事件，并且在命令结果传送完毕之后，客户端和写事件的关联就会被移除。 一个写事件会在两种状态之间切换：</p>
<ul>
<li>当服务器有命令结果需要返回给客户端，但客户端还未能执行无阻塞写，那么写事件处于<strong>等待</strong>状态。</li>
<li>当服务器有命令结果需要返回给客户端，并且客户端可以进行无阻塞写，那么写事件处于<strong>就绪</strong>状态。</li>
</ul>
</li>
</ul>
<p>在同一次文件事件处理器的调用中，单个客户端只能执行其中一种事件（要么读，要么写， 但不能又读又写），当出现读事件和写事件同时就绪的情况时，事件处理器优先处理读事件。 这也就是说，当服务器有命令结果要返回客户端，而客户端又有新命令请求进入时，服务器先处理新命令请求。</p>
<h6 id="（2）时间事件"><a href="#（2）时间事件" class="headerlink" title="（2）时间事件"></a>（2）时间事件</h6><p>时间事件记录着那些要在指定时间点运行的事件，多个时间事件以无序链表的形式保存在服务器状态中。 每个时间事件主要由三个属性组成：</p>
<ul>
<li><code>when</code>：以毫秒格式的<code>UNIX</code>时间戳为单位，记录了应该在什么时间点执行事件处理函数。</li>
<li><code>timeProc</code>：事件处理函数。根据<code>timeProc</code>函数的返回值，可以将时间事件划分为两类：<ul>
<li>如果事件处理函数返回<code>ae.h/AE_NOMORE</code>，那么这个事件为单次执行事件，该事件会在指 定的时间被处理一次，之后该事件就会被删除，不再执行。</li>
<li>如果事件处理函数返回一个非<code>AE_NOMORE</code>的整数值，那么这个事件为循环执行事件，该事件会在指定的时间被处理，之后它会按照事件处理函数的返回值，更新事件的<code>when</code>属 性，让这个事件在之后的某个时间点再次运行，并以这种方式一直更新并运行下去。</li>
</ul>
</li>
<li><code>next</code>指向下一个时间事件，形成链表。</li>
</ul>
<p>一种事件会等待另一种事件执行完毕之后，才开始执行，事件之间不会出现抢占。事件处理器先处理文件事件（处理命令请求），再执行时间事件（调用 <code>serverCron</code>）。文件事件的等待时间（类<code>poll</code>函数的最大阻塞时间），由距离到达时间最短的时间事件决定。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/07/12/redis%E7%AC%94%E8%AE%B0/">https://varrella.github.io/2021/07/12/redis%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/06/10/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-1920x1080-bg-12d9d47.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《高性能MySQL》读书笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">一、内部数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88Sds%EF%BC%8CSimple-Dynamic-String%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1、简单动态字符串（Sds，Simple Dynamic String）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Sds%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">（1）Sds在Redis中的作用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89sds%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">（2）sds的实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2、双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">（1）双端链表的作用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">（2）双端链表的实现</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.</span> <span class="toc-text">3、字典</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AD%97%E5%85%B8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">（1）字典的作用：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">（2）字典的实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">（3）哈希表的实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">（4）哈希算法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.5.</span> <span class="toc-text">（5）添加新元素操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89rehash%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">（6）rehash的执行过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%AD%97%E5%85%B8%E7%9A%84%E6%94%B6%E7%BC%A9"><span class="toc-number">1.3.7.</span> <span class="toc-text">（7）字典的收缩</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">4、跳跃表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、内存映射数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%EF%BC%88intset%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">1、整数集合（intset）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">2.1.1.</span> <span class="toc-text">（1）整数集合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">（2）数据结构和主要操作</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%EF%BC%88Ziplist%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2、压缩列表（Ziplist）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">（1）压缩列表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89ziplist%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">（2）ziplist的构成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">三、Redis 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81redisObject-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BB%A5%E5%8F%8A-Redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1、redisObject 数据结构，以及 Redis 的数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%91%BD%E4%BB%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">2、命令的类型检查和多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">3.3.</span> <span class="toc-text">3、对象共享</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">3.4.</span> <span class="toc-text">4、 引用计数以及对象的销毁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">5、字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.6.</span> <span class="toc-text">6、哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%88%97%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">7、列表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">3.7.1.</span> <span class="toc-text">阻塞的条件：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%84%B1%E7%A6%BB%E9%98%BB%E5%A1%9E%EF%BC%9A"><span class="toc-number">3.7.2.</span> <span class="toc-text">脱离阻塞：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">3.8.</span> <span class="toc-text">8、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">3.8.1.</span> <span class="toc-text">常用命令：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81%E6%9C%89%E5%BA%8F%E9%9B%86"><span class="toc-number">3.9.</span> <span class="toc-text">9、有序集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">四、功能与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">1、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%80%E5%A7%8B%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.1.1.</span> <span class="toc-text">（1）开始事务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%91%BD%E4%BB%A4%E5%85%A5%E9%98%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">（2）命令入队</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.1.3.</span> <span class="toc-text">（3）执行事务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84-DISCARD-%E3%80%81MULTI-%E5%92%8C-WATCH-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.4.</span> <span class="toc-text">（4）事务状态下的 DISCARD 、MULTI 和 WATCH 命令</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E4%BA%8B%E5%8A%A1%E7%9A%84-ACID-%E6%80%A7%E8%B4%A8"><span class="toc-number">4.1.5.</span> <span class="toc-text">（5）事务的 ACID 性质</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.</span> <span class="toc-text">2、订阅与发布</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E5%88%B0%E9%A2%91%E9%81%93%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">订阅&#x2F;发布到频道：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A2%91%E9%81%93%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">（1）频道的订阅与信息发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A2%E9%98%85%E9%A2%91%E9%81%93-SUBSCRIBE"><span class="toc-number">4.2.3.</span> <span class="toc-text">（2）订阅频道 SUBSCRIBE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E5%88%B0%E9%A2%91%E9%81%93-PUBLISH"><span class="toc-number">4.2.4.</span> <span class="toc-text">（3）发送信息到频道 PUBLISH</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89-%E9%80%80%E8%AE%A2%E9%A2%91%E9%81%93-UNSUBSCRIBE"><span class="toc-number">4.2.5.</span> <span class="toc-text">（4） 退订频道 UNSUBSCRIBE</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A2%E9%98%85-%E5%8F%91%E5%B8%83%E5%88%B0%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.2.6.</span> <span class="toc-text">订阅&#x2F;发布到模式：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89-%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">4.2.7.</span> <span class="toc-text">（1） 模式的订阅与信息发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.8.</span> <span class="toc-text">（2）订阅模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E5%88%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.9.</span> <span class="toc-text">（3）发送信息到模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%80%80%E8%AE%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.10.</span> <span class="toc-text">（4）退订模式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81Lua%E8%84%9A%E6%9C%AC"><span class="toc-number">4.3.</span> <span class="toc-text">3、Lua脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">4.4.</span> <span class="toc-text">4、 慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">（1）相关数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%86%85%E9%83%A8%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">五、内部运作机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">5.1.</span> <span class="toc-text">1、数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.1.</span> <span class="toc-text">（1）数据库的结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4"><span class="toc-number">5.1.2.</span> <span class="toc-text">（2）数据库键空间</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%A9%BA%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.3.</span> <span class="toc-text">（3）数据库键空间的操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4"><span class="toc-number">5.1.4.</span> <span class="toc-text">（4）键的过期时间和生存时间</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="toc-number">5.1.5.</span> <span class="toc-text">（5）过期时间的保存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">5.1.6.</span> <span class="toc-text">（6）过期键的判定</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E6%B8%85%E9%99%A4"><span class="toc-number">5.1.7.</span> <span class="toc-text">（7）过期键的清除</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81RDB"><span class="toc-number">5.2.</span> <span class="toc-text">2、RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89rdbSave-%E5%92%8C-rdbLoad"><span class="toc-number">5.2.1.</span> <span class="toc-text">（1）rdbSave 和 rdbLoad</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89SAVE-%E3%80%81BGSAVE-%E3%80%81AOF-%E5%86%99%E5%85%A5%E5%92%8C-BGREWRITEAOF"><span class="toc-number">5.2.2.</span> <span class="toc-text">（2）SAVE 、BGSAVE 、AOF 写入和 BGREWRITEAOF</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">（3）RDB文件结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81AOF"><span class="toc-number">5.3.</span> <span class="toc-text">3、AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89AOF%E9%87%8D%E5%86%99%E5%92%8CAOF%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99"><span class="toc-number">5.3.1.</span> <span class="toc-text">（1）AOF重写和AOF后台重写</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.4.</span> <span class="toc-text">4、事件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.4.1.</span> <span class="toc-text">（1）文件事件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text">（2）时间事件</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>