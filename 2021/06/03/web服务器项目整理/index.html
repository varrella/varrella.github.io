<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>web服务器项目整理 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0、项目介绍—–Linux下C++轻量级Web服务器 使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型 使用状态机解析 HTTP 请求报文，支持解析 GET 和 POST 请求 访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件 实现同步&#x2F;异步日志系统，记录服务器运行状态 经W">
<meta property="og:type" content="article">
<meta property="og:title" content="web服务器项目整理">
<meta property="og:url" content="https://varrella.github.io/2021/06/03/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="0、项目介绍—–Linux下C++轻量级Web服务器 使用 线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现) 的并发模型 使用状态机解析 HTTP 请求报文，支持解析 GET 和 POST 请求 访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件 实现同步&#x2F;异步日志系统，记录服务器运行状态 经W">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturedn-3840x2400-bg-d459300.jpg">
<meta property="article:published_time" content="2021-06-02T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-07T05:56:30.373Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturedn-3840x2400-bg-d459300.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/06/03/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-07 13:56:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturedn-3840x2400-bg-d459300.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">web服务器项目整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-06-02T16:00:00.000Z" title="Created 2021-06-03 00:00:00">2021-06-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-07T05:56:30.373Z" title="Updated 2021-06-07 13:56:30">2021-06-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="web服务器项目整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="0、项目介绍—–Linux下C-轻量级Web服务器"><a href="#0、项目介绍—–Linux下C-轻量级Web服务器" class="headerlink" title="0、项目介绍—–Linux下C++轻量级Web服务器"></a>0、项目介绍—–Linux下C++轻量级Web服务器</h3><ul>
<li>使用 <strong>线程池 + 非阻塞socket + epoll(ET和LT均实现) + 事件处理(Reactor和模拟Proactor均实现)</strong> 的并发模型</li>
<li>使用<strong>状态机</strong>解析 <strong>HTTP</strong> 请求报文，支持解析 <strong>GET 和 POST</strong> 请求</li>
<li>访问<strong>服务器数据库</strong>实现web端用户注册、登录功能，可以请求服务器图片和视频文件</li>
<li>实现<strong>同步/异步日志系统</strong>，记录服务器运行状态</li>
<li>经<strong>Webbench压力测试</strong>可以实现上万的并发连接数据交换</li>
<li>项目原代码：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">https://github.com/qinguoyi/TinyWebServer</a></li>
<li>项目代码框架：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210603232654.png"></p>
<h3 id="一、线程同步机制包装类"><a href="#一、线程同步机制包装类" class="headerlink" title="一、线程同步机制包装类"></a>一、线程同步机制包装类</h3><p>多线程同步，确保任一时刻只能有一个线程能进入关键代码段。分别封装成了三个类。</p>
<blockquote>
<ul>
<li>信号量</li>
<li>互斥锁</li>
<li>条件变量</li>
</ul>
</blockquote>
<h4 id="1、信号量的相关操作"><a href="#1、信号量的相关操作" class="headerlink" title="1、信号量的相关操作"></a>1、信号量的相关操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建信号量，初始化由sem指向的信号对象，设置它的共享选项，并给它一个初始的整数值；pshared控制信号量的类型，如果值为0，就表示这个信号量是当前进程的局部信号量，在当前进程的多个线程之间共享，否则信号量就可以在多个进程之间共享；value为sem的初始值。返回值：调用成功时返回0，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于以原子操作的方式将信号量的值减1。sem指向的对象是sem_init调用初始化的信号量。返回值：调用成功返回0，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于以原子操作的方式将信号量的值加1。sem指向的对象是sem_init调用初始化的信号量。</span></span><br><span class="line">返回值：调用成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于对用完的信号量的清理。只有用sem_init初始化的信号量才能用sem_destroy销毁。返回值：调用成功返回0，失败返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2、互斥量相关操作"><a href="#2、互斥量相关操作" class="headerlink" title="2、互斥量相关操作"></a>2、互斥量相关操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> 数据类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁函数，第一个参数mutex是只想要初始化的互斥锁的指针，</span></span><br><span class="line"><span class="comment">// 第二个参数mutex是指向属性对象的指针，定义的是初始化互斥锁的属性，一般为NULL，即默认属性。此外，也可以用宏PTHREAD_MUTEX_INTIALIZER 初始化静态分配的互斥锁。</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span> (<span class="keyword">pthread_mutex_t</span> *_mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutex_t</span> *mutexatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁毁互斥锁函数，参数为指向互斥锁的指针，当这两个函数成功完成时返回0.否则返回错误编号指明错误。</span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>(<span class="keyword">pthread_mutex_t</span> *mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请互斥锁，以阻塞的方式申请互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁解锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 申请互斥锁，以阻塞的方式申请互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放互斥锁，释放操作只能由占有该互斥锁的线程完成。</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(<span class="keyword">pthread_mutex_t</span> *mutex);</span><br></pre></td></tr></table></figure>

<h4 id="3、条件变量相关操作"><a href="#3、条件变量相关操作" class="headerlink" title="3、条件变量相关操作"></a>3、条件变量相关操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *cattr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于阻塞当前线程，等待别的线程使用 pthread_cond_signal() 或pthread_cond_broadcast()来唤醒它。pthread_cond_wait()必须与pthread_mutex 配套使用。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr, <span class="keyword">pthread_munex_t</span> *mptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞直到指定时间。函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。函数返回时，相应的互斥锁往往是锁定的，即使是函数出错返回。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr, <span class="keyword">pthread_mutex_t</span> *mptr, <span class="keyword">const</span> structtimespec * abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个信号给另外一个正在处于阻塞等待状态的线程，使其脱离阻塞状态,继续执行。如果没有线程处在阻塞等待状态,pthread_cond_signal也会成功返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放阻塞的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cptr)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4、locker-h"><a href="#4、locker-h" class="headerlink" title="4、locker.h"></a>4、<code>locker.h</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将信号量操作封装成类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem</span>(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sem</span>() &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将互斥量操作封装成类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">locker</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将条件变量封装成类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">cond</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">timewait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex, struct timespec t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = <span class="built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_broadcast</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



































<h3 id="二、http-连接请求处理类"><a href="#二、http-连接请求处理类" class="headerlink" title="二、http 连接请求处理类"></a>二、http 连接请求处理类</h3><p>根据状态转移，通过主从状态机封装了<code>http</code>连接类。其中，主状态机在内部调用从状态机，从状态机将处理状态和数据传给主状态机。</p>
<blockquote>
<ul>
<li>客户端发出 <code>http</code>连接请求</li>
<li>从状态机读取数据，更新自身状态和接收数据，传给主状态机</li>
<li>主状态机根据从状态机状态，更新自身状态，决定响应请求还是继续读取</li>
</ul>
</blockquote>
<h4 id="1、状态机"><a href="#1、状态机" class="headerlink" title="1、状态机"></a>1、状态机</h4><p><strong>（1）基本概念</strong></p>
<p>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。换句话说就是在一个时刻内，只会存在一种状态，但是达到触发条件，就会切换状态。</p>
<p><strong>（2）状态机的特征</strong></p>
<ul>
<li>状态总数是有限的</li>
<li>任一时刻，只处在一种状态之中</li>
<li>某种条件触发后，会从一种状态转变到另一种状态</li>
<li>事物状态变化是有规则的，A 状态可以变换到 B，B 可以变换到  C ， A 却不一定能变换到C</li>
<li>同一种行为，可以将事物从多种状态变成同种状态，但是不能从同种状态变成<strong>多种状态</strong></li>
</ul>
<p><strong>（3）状态机的要素</strong></p>
<p>状态机可归纳为4个要素，即<strong>现态、条件、动作、次态</strong>。“现态”和“条件”是因，“动作”和“次态”是果。</p>
<ul>
<li>现态：是指当前所处的状态。</li>
<li>条件：又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li>
<li>动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li>
<li>次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li>
</ul>
<h4 id="2、web-服务器中的有限状态机"><a href="#2、web-服务器中的有限状态机" class="headerlink" title="2、web 服务器中的有限状态机"></a>2、web 服务器中的有限状态机</h4><p>Web服务器中的有限状态机体现在两个方面：<code>http</code>和<code>tcp</code></p>
<ul>
<li><code>http</code>有限状态机体现在业务逻辑处理：<strong>从状态机</strong>负责读取报文的一行，<strong>主状态机</strong>负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。</li>
<li><code>tcp</code>有限状态机体现在对于连接情况的判断</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210603221922.png"></p>
<p>项目中的函数逻辑：</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210603221955.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http_conn.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对读入该connfd读缓冲区的请求报文进行解析，知道用户请求的内容是什么，根据这些请求返回相应的html页面</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="comment">// NO_REQUEST，表示请求不完整，需要继续接收请求数据</span></span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);</span><br><span class="line">    <span class="keyword">if</span> (!write_ret)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（1）http-报文"><a href="#（1）http-报文" class="headerlink" title="（1）http 报文"></a>（1）http 报文</h5><p><code>HTTP</code>请求报文由<strong>请求行</strong>（request line）、<strong>请求头部</strong>（header）、<strong>空行</strong>和<strong>请求数据</strong>四个部分组成。</p>
<ul>
<li><p><strong>GET</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/562f25980001b1b106000338.jpg</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host:img.mukewang.com</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64)</span><br><span class="line">AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept:image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer:http://www.imooc.com/</span><br><span class="line">Accept-Encoding:gzip, deflate, sdch</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8</span><br><span class="line">空行</span><br><span class="line">请求数据为空</span><br></pre></td></tr></table></figure></li>
<li><p><strong>POST</strong>：注意<code>POST</code>的请求内容不为空</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line">空行</span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>GET </code>和<code> POST</code> 的区别</strong></p>
<ul>
<li>最直观的区别就是<code>GET</code>把参数包含在<code>URL</code>中，<code>POST</code>通过<code>request body</code>传递参数。</li>
<li><code>GET</code>请求参数会被完整保留在浏览器历史记录里，而<code>POST</code>中的参数不会被保留。</li>
<li><code>GET</code>请求在<code>URL</code>中传送的参数是有长度限制。（大多数）浏览器通常都会限制<code>url</code>长度在<code>2K</code>个字节，而（大多数）服务器最多处理<code>64K</code>大小的<code>url</code>。</li>
<li><code>GET</code>产生一个<code>TCP</code>数据包；<code>POST</code>产生两个<code>TCP</code>数据包。对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应<code>200（返回数据）</code>；而对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应<code>100（指示信息—表示请求已接收，继续处理）continue</code>，浏览器再发送<code>data</code>，服务器响应<code>200 ok（返回数据）</code>。</li>
</ul>
</li>
</ul>
<h5 id="（1）从状态机：负责读取报文的一行"><a href="#（1）从状态机：负责读取报文的一行" class="headerlink" title="（1）从状态机：负责读取报文的一行"></a>（1）从状态机：负责读取报文的一行</h5><ul>
<li><p>在<code>HTTP</code>报文中，每一行的数据由<code>\r\n</code>（回车、换行符）作为结束字符，空行则是仅仅是字符<code>\r\n</code>。因此，可以通过查找<code>\r\n</code>将报文拆解成单独的行进行解析。从状态机负责读取<code>buffer</code>中的数据，将每行数据末尾的<code>\r\n</code>置为<code>\0\0</code>，并更新从状态机在<code>buffer</code>中读取的位置<code>m_checked_idx</code>，以此来驱动主状态机解析。</p>
</li>
<li><p>从状态机返回报文的三种状态，标识解析一行的读取状态：</p>
<ul>
<li>LINE_OK：完整读取一行</li>
<li>LINE_BAD：报文语法有误</li>
<li>LINE_OPEN：读取的行不完整</li>
</ul>
</li>
<li><p>从状态机实现流程如下：</p>
<ul>
<li>从状态机从<code>m_read_buf</code>中逐字节读取，判断当前字节，如果当前字节是<code>\r</code><ul>
<li>接下来的字符是<code>\n</code>，将<code>\r\n</code>修改成<code>\0\0</code>，将<code>m_checked_idx</code>指向下一行的开头，则返回<code>LINE_OK</code>。</li>
<li>接下来达到了<code>buffer</code>末尾，表示<code>buffer</code>还需要继续接收，返回<code>LINE_OPEN</code>。</li>
<li>否则，表示语法错误，返回<code>LINE_BAD</code>。</li>
</ul>
</li>
<li>当前字节不是<code>\r</code>，当前字符是<code>\n </code>（一般是上次读取到<code>\r</code>就到了<code>buffer</code>末尾，没有接收完整，这次再接收时会出现这种情况）<ul>
<li>如果前一个字符是<code>\r</code>，则将<code>\r\n</code>修改成<code>\0\0</code>，将<code>m_checked_idx</code>指向下一行的开头，则返回<code>LINE_OK</code></li>
</ul>
</li>
<li>当前字节既不是<code>\r</code>，也不是<code>\n</code><ul>
<li>表示接收不完整，需要继续接收，返回<code>LINE_OPEN</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210603214017.png"></p>
<h5 id="（2）从状态机的代码实现-http-conn-cpp"><a href="#（2）从状态机的代码实现-http-conn-cpp" class="headerlink" title="（2）从状态机的代码实现 http_conn.cpp"></a>（2）从状态机的代码实现 http_conn.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从状态机，用于分析出一行内容</span></span><br><span class="line"><span class="comment">// 返回值为行的读取状态，有LINE_OK, LINE_BAD, LINE_OPEN</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_read_buf[m_checked_idx];  <span class="comment">// 判断当前位置的字符</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>) <span class="comment">// 如果当前字符是&#x27;\r&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx)  <span class="comment">// 接下来到达buffer结尾</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;   <span class="comment">// 接下来的字符是 ‘\n’</span></span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 如果当前字符是&#x27;\n&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_checked_idx &gt; <span class="number">1</span> &amp;&amp; m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;   <span class="comment">// 判断前一个字符是否是&#x27;\r&#x27;</span></span><br><span class="line">                m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（3）主状态机：负责对该数据进行解析"><a href="#（3）主状态机：负责对该数据进行解析" class="headerlink" title="（3）主状态机：负责对该数据进行解析"></a>（3）主状态机：负责对该数据进行解析</h5><ul>
<li><p>主状态机初始状态是<code>CHECK_STATE_REQUESTLINE</code>，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行的末尾<code>\r\n</code>符号改为<code>\0\0</code>，以便于主状态机直接取出对应字符串进行处理。每解析一部分都会将整个请求的<code>m_check_state</code>状态改变，状态机也就是根据这个状态来进行不同部分的解析跳转的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过while循环 封装主状态机 对每一行进行循环处理</span></span><br><span class="line"><span class="comment">// 此时 从状态机已经修改完毕 主状态机可以取出完整的行进行解析</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化从状态机的状态</span></span><br><span class="line">    LINE_STATUS line_status = LINE_OK;</span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="keyword">char</span> *text = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断条件，这里就是从状态机驱动主状态机</span></span><br><span class="line">    <span class="keyword">while</span> ((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m_start_line 是每一个数据行在 m_read_buf 中的起始位置</span></span><br><span class="line">        <span class="comment">// m_checked_idx 表示从状态机在 m_read_buf 中的读取位置</span></span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三种状态转换逻辑</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (m_check_state)</span><br><span class="line">        &#123;            </span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:</span><br><span class="line">        &#123;   <span class="comment">// 解析请求行</span></span><br><span class="line">            ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_HEADER:</span><br><span class="line">        &#123;   <span class="comment">// 解析请求头</span></span><br><span class="line">            ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="comment">// 作为get请求 则需要跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_CONTENT:</span><br><span class="line">        &#123;   <span class="comment">// 解析消息体</span></span><br><span class="line">            ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于post请求 跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 跳出循环 代表解析完了消息体</span></span><br><span class="line">            line_status = LINE_OPEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>主状态机三种状态，标识解析位置：</p>
<ul>
<li><p><code>CHECK_STATE_REQUESTLINE</code>，解析请求行，也就是<code>GET</code>中的<code>GET /562f25980001b1b106000338.jpg HTTP/1.1</code>这一行，或者<code>POST</code>中的<code>POST / HTTP1.1</code>这一行。通过请求行的解析可以判断该<code>HTTP</code>请求的类型<code>（GET/POST）</code>，而请求行中最重要的部分就是<code>URL</code>部分，我们会将这部分保存下来用于后面的生成<code>HTTP</code>响应。</p>
<ul>
<li><p>主状态机的初始状态，调用<code>parse_request_line()</code>函数解析请求行</p>
</li>
<li><p>解析函数从<code>m_read_buf</code>中解析<code>HTTP</code>请求行，获得请求方法、目标<code>URL</code>及<code>HTTP</code>版本号</p>
</li>
<li><p>解析完成后主状态机的状态变为<code>CHECK_STATE_HEADER</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析http请求行，获得请求方法，目标url及http版本号</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 请求行中最先含有空格和\t任一字符的位置并返回，strpbrk函数检索字符串str1中第一个匹配字符串str2中字符的字符</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="comment">// 没有目标字符 则代表报文格式有问题</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于将前面的数据取出</span></span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 取出数据 确定请求方式</span></span><br><span class="line">    <span class="keyword">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        m_method = GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_method = POST;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m_url 此时跳过了第一个空格或者\t字符，但是后面还可能存在</span></span><br><span class="line">    <span class="comment">// 不断后移找到请求资源的第一个字符</span></span><br><span class="line">    m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断http的版本号</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前社长项目仅支持http1.1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对请求资源的前七个字符进行判断</span></span><br><span class="line">    <span class="comment">// 对某些带有http://的报文进行单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">8</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不符合规则的报文</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当url为/时，显示判断界面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(m_url) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url, <span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主状态机状态转移</span></span><br><span class="line">    m_check_state = CHECK_STATE_HEADER;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>CHECK_STATE_HEADER</code>，解析请求头，<code>GET</code>和<code>POST</code>中<strong>空行以上，请求行以下</strong>的部分。</p>
<ul>
<li><p>调用<code>parse_headers()</code>函数解析请求头部信息</p>
</li>
<li><p>判断是空行还是请求头，若是空行，进而判断<code>content-length</code>是否为0，如果不是0，表明是<code>POST</code>请求，则状态转移到<code>CHECK_STATE_CONTENT</code>，否则说明是<code>GET</code>请求，则报文解析结束。</p>
</li>
<li><p>若解析的是请求头部字段，则主要分析<code>connection</code>字段，<code>content-length</code>字段，其他字段可以直接跳过，也可以根据需求继续分析。</p>
</li>
<li><p><code>connection</code>字段判断是<code>keep-alive</code>还是<code>close</code>，决定是长连接还是短连接</p>
</li>
<li><p><code>content-length</code>字段，这里用于读取<code>post</code>请求的消息体长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析http请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是空行还是请求头</span></span><br><span class="line">    <span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 具体判断是get还是post请求</span></span><br><span class="line">        <span class="keyword">if</span> (m_content_length != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// post请求需要改变主状态机的状态</span></span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析头部连接字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        <span class="comment">// 跳过空格和\t字符</span></span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否为长连接</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头 内容长度字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析请求头部host字段</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;oop!unknow header: %s&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>CHECK_STATE_CONTENT</code>，解析消息体，仅用于解析<code>POST</code>请求。对于<code>GET</code>来说这部分是空的，因为这部分内容已经以明文的方式包含在了请求行中的<code>URL</code>部分了；只有<code>POST</code>的这部分是有数据的，项目中的这部分数据为<strong>用户名和密码</strong>，我们会根据这部分内容做登录和校验，并涉及到与数据库的连接。</p>
<ul>
<li><p>仅用于解析<code>POST</code>请求，调用<code>parse_content()</code>函数解析消息体</p>
</li>
<li><p>用于保存<code>post</code>请求消息体，为后面的登录和注册做准备</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断http请求是否被完整读入</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否读取了消息体</span></span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="（4）do-request-具体处理函数"><a href="#（4）do-request-具体处理函数" class="headerlink" title="（4）do_request() 具体处理函数"></a>（4）do_request() 具体处理函数</h5><p><code>process_read()</code>返回值是对请求文件的分析结果，一部分是语法错误的<code>BAD_REQUEST</code>，一部分则是我们认可的规则然后作出的对应的响应。</p>
<p><code>do_request()</code>的具体做法是将网站根目录和<code>url</code>文件拼接，然后通过<code>stat</code>判断目标文件属性，若目标文件存在、对所有用户可读且不是目录时，则使用<code>mmap</code>将其映射到内存地址<code>m_file_address</code>处，并告诉调用者获取文件成功<code>FILE_REQUEST</code>。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将初始化的 m_real_file 赋值为网站根目录</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file, doc_root);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">    <span class="comment">// printf(&quot;m_url:%s\n&quot;, m_url);</span></span><br><span class="line">    <span class="comment">// 找到m_url中/的位置</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理cgi</span></span><br><span class="line">    <span class="comment">// 实现登录和注册校验</span></span><br><span class="line">    <span class="keyword">if</span> (cgi == <span class="number">1</span> &amp;&amp; (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> || *(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据标志判断是登录检测还是注册检测</span></span><br><span class="line">        <span class="keyword">char</span> flag = m_url[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(m_url_real, m_url + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">// user=123&amp;passwd=123</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; m_string[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = m_string[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; m_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = m_string[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">            <span class="comment">// 没有重名的，进行增加数据</span></span><br><span class="line">            <span class="keyword">char</span> *sql_insert = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) == users.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                m_lock.<span class="built_in">lock</span>();</span><br><span class="line">                <span class="keyword">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);</span><br><span class="line">                users.<span class="built_in">insert</span>(pair&lt;string, string&gt;(name, password));</span><br><span class="line">                m_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是登录，直接判断</span></span><br><span class="line">        <span class="comment">// 若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) != users.<span class="built_in">end</span>() &amp;&amp; users[name] == password)</span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/welcome.html&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/logError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求资源为/0，表示跳转注册界面</span></span><br><span class="line">    <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求资源为/1，表示跳转登录界面</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/picture.html&quot;</span>);</span><br><span class="line">        <span class="comment">// 将网站目录和/log.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/video.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/fans.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(m_file_stat.st_mode))</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(m_real_file, O_RDONLY);</span><br><span class="line">    m_file_address = (<span class="keyword">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（5）process-write-函数"><a href="#（5）process-write-函数" class="headerlink" title="（5）process_write()函数"></a>（5）process_write()函数</h5><p>接下来要做的就是根据读取结果对用户做出响应了，也就是到了<code>process_write(read_ret);</code>这一步，该函数根据<code>process_read()</code>的返回结果来判断应该返回给用户什么响应，我们最常见的就是<code>404</code>错误了，说明客户请求的文件不存在，除此之外还有其他类型的请求出错的响应。假设用户请求的文件存在，而且已经被<code>mmap</code>到<code>m_file_address</code>这里了，那么我们就将做如下写操作，将响应写到这个<code>connfd</code>的写缓存<code>m_write_buf</code>中去。</p>
<p>首先将<strong>状态行</strong>写入写缓存，<strong>响应头</strong>也是要写进<code>connfd</code>的写缓存（<code>HTTP</code>类自己定义的，与<code>socket</code>无关）中的，对于请求的文件，我们已经直接将其映射到<code>m_file_address</code>里面，然后将该<code>connfd</code>文件描述符上修改为<code>EPOLLOUT</code>（可写）事件，然后<code>epoll_Wait</code>监测到这一事件后，使用<code>writev</code>来将响应信息和请求文件<strong>聚集写</strong>到<strong>TCP Socket</strong>本身定义的发送缓冲区（这个缓冲区大小一般是默认的，但我们也可以通过<code>setsockopt</code>来修改）中，交由内核发送给用户。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERNAL_ERROR:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">500</span>, error_500_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_500_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BAD_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">404</span>, error_404_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_404_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FORBIDDEN_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">403</span>, error_403_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_403_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FILE_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">200</span>, ok_200_title);</span><br><span class="line">        <span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_headers</span>(m_file_stat.st_size);</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">add_content</span>(ok_string))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、半同步-半反应堆–线程池"><a href="#三、半同步-半反应堆–线程池" class="headerlink" title="三、半同步/半反应堆–线程池"></a>三、半同步/半反应堆–线程池</h3><p>使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。</p>
<blockquote>
<ul>
<li>同步I/O模拟proactor模式</li>
<li>半同步/半反应堆</li>
<li>线程池</li>
</ul>
</blockquote>
<p>通常使用同步I/O模型（如<code>epoll_wait</code>）实现Reactor，使用异步I/O（如<code>aio_read</code>和<code>aio_write</code>）实现Proactor。但在此项目中，我们使用的是<strong>同步I/O模拟的Proactor</strong>事件处理模式。</p>
<h4 id="1、Web服务器如何接收客户端发来的HTTP请求报文呢"><a href="#1、Web服务器如何接收客户端发来的HTTP请求报文呢" class="headerlink" title="1、Web服务器如何接收客户端发来的HTTP请求报文呢?"></a>1、Web服务器如何接收客户端发来的HTTP请求报文呢?</h4><p>远端的很多用户会尝试去<code>connect()</code>这个<code>Web Server</code>上正在<code>listen</code>的这个<code>port</code>，而监听到的这些连接会排队等待被<code>accept()</code>。由于用户连接请求是随机到达的异步事件，每当监听socket（<code>listenfd</code>）<code>listen</code>到新的客户连接并且放入监听队列，我们都需要告诉我们的Web服务器有连接来了，<code>accept</code>这个连接，并分配一个逻辑单元来处理这个用户请求。</p>
<p>而且，我们在处理这个请求的同时，还需要继续监听其他客户的请求并分配其另一逻辑单元来处理（并发，同时处理多个事件，用线程池实现并发）。这里，服务器通过<strong>epoll</strong>这种I/O复用技术（还有select和poll）来实现对监听socket（<code>listenfd</code>）和连接socket（客户请求）的同时监听。注意I/O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发），为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。</p>
<h4 id="2、Web服务器如何处理以及响应接收到的HTTP请求报文呢"><a href="#2、Web服务器如何处理以及响应接收到的HTTP请求报文呢" class="headerlink" title="2、Web服务器如何处理以及响应接收到的HTTP请求报文呢?"></a>2、Web服务器如何处理以及响应接收到的HTTP请求报文呢?</h4><p>该项目使用线程池（半同步半反应堆模式）并发处理用户请求，主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等等）。将<code>listenfd</code>上到达的<code>connection</code>通过 <code>accept()</code>接收，并返回一个新的<code>socket</code>文件描述符<code>connfd</code>用于和用户通信，并对用户请求返回响应，同时将这个<code>connfd</code>注册到内核事件表中，等用户发来请求报文。</p>
<p>这个过程是：通过<code>epoll_wait</code>发现这个<code>connfd</code>上有可读事件了（<code>EPOLLIN</code>），主线程就将这个<code>HTTP</code>的请求报文读进这个连接<code>socket</code>的读缓存中<code>users[sockfd].read()</code>，然后将该任务对象（指针）插入线程池的请求队列中<code>pool-&gt;append(users + sockfd);</code>，线程池的实现还需要依靠<strong>锁机制</strong>以及<strong>信号量</strong>机制来实现线程同步，保证操作的原子性。</p>
<h4 id="2、两种事件处理模式（Reactor-Proactor）"><a href="#2、两种事件处理模式（Reactor-Proactor）" class="headerlink" title="2、两种事件处理模式（Reactor/Proactor）"></a>2、两种事件处理模式（Reactor/Proactor）</h4><ul>
<li><code>Reactor</code>模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。</li>
<li><code>Proactor</code>模式：将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后<code>users[sockfd].read()</code>，选择一个工作线程来处理客户请求<code>pool-&gt;append(users + sockfd)</code>。</li>
</ul>
<h4 id="3、同步和异步-I-O"><a href="#3、同步和异步-I-O" class="headerlink" title="3、同步和异步 I/O"></a>3、同步和异步 I/O</h4><ul>
<li><strong>同步（阻塞）I/O</strong>：在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</li>
<li><strong>异步（非阻塞）I/O</strong>：当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</li>
</ul>
<h4 id="4、三种-I-O-复用方式（select-poll-epoll）"><a href="#4、三种-I-O-复用方式（select-poll-epoll）" class="headerlink" title="4、三种 I/O 复用方式（select/poll/epoll）"></a>4、三种 I/O 复用方式（select/poll/epoll）</h4><ul>
<li>对于<code>select</code>和<code>poll</code>来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；<code>epoll</code>则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，<code>epoll</code>可能会慢于<code>select</code>和<code>poll</code>由于这些大量的系统调用开销。</li>
<li><code>select</code>使用线性表描述文件描述符集合，文件描述符有上限；<code>poll</code>使用链表来描述；<code>epoll</code>底层通过红黑树来描述，并且维护一个<code>ready list</code>，将事件表中已经就绪的事件添加到这里，在使用<code>epoll_wait</code>调用时，仅观察这个<code>list</code>中有没有数据即可。</li>
<li><code>select</code>和<code>poll</code>的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行<code>select</code>或<code>poll</code>调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；<code>epoll</code>则不需要去以这种方式检查，当有活动产生时，会自动触发<code>epoll</code>回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的<code>ready list</code>中等待<code>epoll_wait</code>调用后被处理。</li>
<li><code>select</code>和<code>poll</code>都只能工作在相对低效的<code>LT</code>模式下，而<code>epoll</code>同时支持<code>LT</code>和<code>ET</code>模式。</li>
<li>综上，当监测的<code>fd</code>数量较小，且各个<code>fd</code>都很活跃的情况下，建议使用<code>select</code>和<code>poll</code>；当监听的<code>fd</code>数量较多，且单位时间仅部分fd活跃的情况下，使用<code>epoll</code>会明显提升性能。</li>
</ul>
<p>4、epoll 对文件操作符的两种操作模式</p>
<ul>
<li><code>LT（电平触发）</code>：类似<code>select</code>，<code>LT</code>会去遍历在<code>epoll</code>事件表中每个文件描述符，来观察是否有我们感兴趣的事件发生，如果有（触发了该文件描述符上的回调函数），<code>epoll_wait</code>就会以非阻塞的方式返回。若该<code>epoll</code>事件没有被处理完（没有返回<code>EWOULDBLOCK</code>），该事件还会被后续的<code>epoll_wait</code>再次触发。</li>
<li><code>ET（边缘触发）</code>：<code>ET</code>在发现有我们感兴趣的事件发生后，立即返回，并且<code>sleep</code>这一事件的<code>epoll_wait</code>，不管该事件有没有结束。</li>
<li>在使用<code>ET</code>模式时，必须要保证该文件描述符是非阻塞的（确保在没有数据可读时，该文件描述符不会一直阻塞）；并且每次调用<code>read</code>和<code>write</code>的时候都必须等到它们返回<code>EWOULDBLOCK</code>（确保所有数据都已读完或写完）。</li>
</ul>
<h4 id="5、threadpool-h"><a href="#5、threadpool-h" class="headerlink" title="5、threadpool.h"></a>5、threadpool.h</h4><p>项目中线程池类被声明为一个模板类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="keyword">int</span> actor_model, connection_pool *connPool, <span class="keyword">int</span> thread_number = <span class="number">8</span>, <span class="keyword">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T *request, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append_p</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_thread_number;        <span class="comment">//线程池中的线程数</span></span><br><span class="line">    <span class="keyword">int</span> m_max_requests;         <span class="comment">//请求队列中允许的最大请求数</span></span><br><span class="line">    <span class="keyword">pthread_t</span> *m_threads;       <span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">    std::list&lt;T *&gt; m_workqueue; <span class="comment">//请求队列</span></span><br><span class="line">    locker m_queuelocker;       <span class="comment">//保护请求队列的互斥锁</span></span><br><span class="line">    sem m_queuestat;            <span class="comment">//是否有任务需要处理</span></span><br><span class="line">    connection_pool *m_connPool;  <span class="comment">//数据库</span></span><br><span class="line">    <span class="keyword">int</span> m_actor_model;          <span class="comment">//模型切换</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>( <span class="keyword">int</span> actor_model, connection_pool *connPool, <span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests) : <span class="built_in">m_actor_model</span>(actor_model), <span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>), <span class="built_in">m_connPool</span>(connPool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_number &lt;= <span class="number">0</span> || max_requests &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_thread_number];    <span class="comment">// 定义 m_thread_number 个线程</span></span><br><span class="line">    <span class="keyword">if</span> (!m_threads)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环创建线程，并将工作线程按要求进行运行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将线程进行分离后，不用单独对工作线程进行回收</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_detach</span>(m_threads[i]))  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放线程池数组</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~<span class="built_in">threadpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// append_p 和 append 函数（区别是 lfd 和 cfd ，因为这里有模式问题）</span></span><br><span class="line"><span class="comment">// 将“待办工作”加入到请求队列，传入的是fd，reactor模式下的请求入队</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T *request, <span class="keyword">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 请求队列的长度大于请求队列中允许的最大请求数</span></span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读写事件</span></span><br><span class="line">    request-&gt;m_state = state;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);   <span class="comment">// 将新任务放到请求队列中</span></span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();       <span class="comment">// 信号量的值加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把新任务放到list的尾部，proactor模式下的请求入队</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::<span class="built_in">append_p</span>(T *request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);   <span class="comment">// 将新任务放到请求队列中</span></span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();      <span class="comment">// 信号量的值加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程:pthread_create时就调用了它</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 线程回调函数/工作函数，arg 其实是 this，所以该操作其实是获取threadpool对象地址</span></span><br><span class="line">    threadpool *pool = (threadpool *)arg;</span><br><span class="line">    <span class="comment">// 线程池中每一个线程创建时都会调用run()，睡眠在队列中</span></span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数会调用这个函数工作</span></span><br><span class="line"><span class="comment">// 工作线程就是不断地等任务队列有新任务，然后就加锁取任务-&gt;取到任务解锁-&gt;执行任务</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();       <span class="comment">// 信号量减1，信号量等待</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();     <span class="comment">// 被唤醒后先加互斥锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_workqueue.<span class="built_in">empty</span>())  <span class="comment">// 如果请求队列为空，则解锁，进行下一轮循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T *request = m_workqueue.<span class="built_in">front</span>();   <span class="comment">// 请求队列不为空则取出链表头部的任务结构体</span></span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();             <span class="comment">// 请求队列解锁</span></span><br><span class="line">        <span class="keyword">if</span> (!request)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 给出了两种模式的处理方式：Reactor 和 Proactor</span></span><br><span class="line">        <span class="comment">// Reactor</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_actor_model)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == request-&gt;m_state)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">read_once</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;request-&gt;mysql, m_connPool)</span></span>;</span><br><span class="line">                    request-&gt;<span class="built_in">process</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">write</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// default:Proactor</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            connectionRAII <span class="built_in">mysqlcon</span>(&amp;request-&gt;mysql, m_connPool);</span><br><span class="line">            request-&gt;<span class="built_in">process</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、定时器处理非活动连接"><a href="#四、定时器处理非活动连接" class="headerlink" title="四、定时器处理非活动连接"></a>四、定时器处理非活动连接</h3><h4 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h4><ul>
<li><strong>非活跃</strong>：是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。</li>
<li><strong>定时事件</strong>：是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。</li>
<li><strong>定时器</strong>：是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。</li>
<li><strong>定时器容器</strong>：是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。</li>
<li>如果某一用户<code>connect()</code>到服务器之后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。这时候就应该利用定时器把这些超时的非活动连接释放掉，关闭其占用的文件描述符。</li>
</ul>
<h4 id="2、Linux下提供了三种定时的方法"><a href="#2、Linux下提供了三种定时的方法" class="headerlink" title="2、Linux下提供了三种定时的方法"></a>2、Linux下提供了三种定时的方法</h4><ul>
<li><code>socket</code>选项<code>SO_RECVTIMEO</code>和<code>SO_SNDTIMEO</code></li>
<li><code>SIGALRM</code>信号</li>
<li><code>I/O</code>复用系统调用的超时参数</li>
</ul>
<p>由于项目中使用的是<code>SIGALRM</code>信号，利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。从上面的简要描述中，可以看出定时器处理非活动连接模块，主要分为两部分，其一为<strong>定时方法与信号通知流程</strong>，其二为<strong>定时器及其容器设计与定时任务的处理</strong>。</p>
<h4 id="3、定时器触发方式"><a href="#3、定时器触发方式" class="headerlink" title="3、定时器触发方式"></a>3、定时器触发方式</h4><p>这个问题其实很有意思，通常我们以前学习到处理信号的方式是把信号发生之后的要处理的逻辑全部放在信号的回调函数中。在这时候我们也许忽略了一个事实：在<code>Linux</code>环境下当我们回调一个信号的回调函数时候这段时间系统会忽略至少这个同样的信号（这是当然的不然就有可能死循环等出错），那么我们为了不让这些被忽略的信号被忽略太久，我们得想尽办法尽量缩短这个回调函数的执行时间。那么怎样才能做到这样呢？</p>
<p>一个理所当然的思路是：<strong>把回调函数的逻辑搬到主函数执行</strong>。那么怎样做到这一点：<strong>统一事件源</strong>。原理很简单，这时我们的信号回调函数不要处理逻辑，而是在回调函数中通过管道给主函数发送信息，那么当主函数监听到读时间并且判断到是从管道读端来的，那就知道这个信号到了我主函数应该处理了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210603223507.png"></p>
<h4 id="4、定时器的数据结构"><a href="#4、定时器的数据结构" class="headerlink" title="4、定时器的数据结构"></a>4、定时器的数据结构</h4><p><strong>有三种定时器的存储结构：链表、时间轮、时间堆</strong>。项目中使用的是最好实现的<strong>链表定时器</strong>。</p>
<p>我们有一个定时器结点类<code>util_timer</code>，每个结点表示一个客户连接，它保存了双向链表的前后指针，客户数据<code>client_data</code>和回调函数。如果我们判断到这个结点长时间无反应，所以我们调用这个回调函数传入<code>client_data</code>，然后回调函数就会把这个客户断开，并且做一些善后工作。</p>
<p>我们还有链表类<code>sort_timer_lst</code>，这个链表是一个时间递增的结点链表，即从链表头到尾这个客户的最后一次反应时间是递增的。这个链表类当然有插入和删除结点函数。并且还有<code>adjust_timer</code>调整链表位置函数，作用是当一个客户有了反应，那么我们需要更新他的最后一次反应时间，那么为了维护链表的递增特性，我们需要这么一个调整位置的函数。此外，这个类还有一个检查函数(定时清扫)，作用是我们上文提到统一了事件源，把信号回调函数逻辑搬到主函数执行，所以这个定时清扫检查逻辑就是在这个检查函数。主函数判断到信号来了，就执行这个函数进行检查链表中长时间无反应的结点进行清扫。</p>
<h4 id="5、具体实现"><a href="#5、具体实现" class="headerlink" title="5、具体实现"></a>5、具体实现</h4><h5 id="（1）lst-timer-h"><a href="#（1）lst-timer-h" class="headerlink" title="（1）lst_timer.h"></a>（1）lst_timer.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接资源结构体成员需要用到定时器类</span></span><br><span class="line"><span class="comment">// 需要前向声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开辟用户socket结构, 对应于最大处理fd</span></span><br><span class="line"><span class="comment">// 连接资源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    sockaddr_in address;   <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="keyword">int</span> sockfd;            <span class="comment">// socket文件描述符</span></span><br><span class="line">    util_timer *timer;     <span class="comment">// 定时器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">util_timer</span>() : <span class="built_in">prev</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">time_t</span> expire;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* cb_func)(client_data *);</span><br><span class="line">    <span class="comment">// 连接资源</span></span><br><span class="line">    client_data *user_data;</span><br><span class="line">    <span class="comment">// 前向定时器</span></span><br><span class="line">    util_timer *prev;</span><br><span class="line">    <span class="comment">// 后继定时器</span></span><br><span class="line">    util_timer *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目中的定时器容器为带头尾结点的升序双向链表，具体的为每个连接创建一个定时器，</span></span><br><span class="line"><span class="comment">// 将其添加到链表中，并按照超时时间升序排列。执行定时任务时，将到期的定时器从链表中删除。</span></span><br><span class="line"><span class="comment">// 从实现上看，主要涉及双向链表的插入，删除操作，其中添加定时器的事件复杂度是O(n),</span></span><br><span class="line"><span class="comment">// 删除定时器的事件复杂度是O(1)。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sort_timer_lst</span>();</span><br><span class="line">    ~<span class="built_in">sort_timer_lst</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加定时器，内部调用私有成员 add_timer</span></span><br><span class="line">    <span class="comment">// 若当前链表中只有头尾节点，直接插入, 否则，将定时器按升序插入</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// adjust_timer 函数，当定时任务发生变化,调整对应定时器在链表中的位置</span></span><br><span class="line">    <span class="comment">// 客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间，这里只是往后延长超时时间</span></span><br><span class="line">    <span class="comment">// 被调整的目标定时器在尾部，或定时器新的超时值仍然小于下一个定时器的超时，不用调整</span></span><br><span class="line">    <span class="comment">// 否则先将定时器从链表取出，重新插入链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// del_timer函数将超时的定时器从链表中删除, 常规双向链表删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span>;</span><br><span class="line"></span><br><span class="line">    util_timer *head;</span><br><span class="line">    util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Utils</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Utils</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> timeslot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对文件描述符设置非阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot, <span class="keyword">int</span> TRIGMode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 信号处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_error</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">char</span> *info)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> *u_pipefd;</span><br><span class="line">    sort_timer_lst m_timer_lst;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> u_epollfd;</span><br><span class="line">    <span class="keyword">int</span> m_TIMESLOT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="（2）lst-timer-cpp"><a href="#（2）lst-timer-cpp" class="headerlink" title="（2）lst_timer.cpp"></a>（2）lst_timer.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">sort_timer_lst::<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort_timer_lst::~<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">&#123;   <span class="comment">// 常规销毁链表</span></span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加定时器，内部调用私有成员add_timer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = tail = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的定时器超时时间小于当前头部结点, 直接将当前定时器结点作为头部结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire)</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;next = head;</span><br><span class="line">        head-&gt;prev = timer;</span><br><span class="line">        head = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则调用私有成员，调整内部结点</span></span><br><span class="line">    <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整定时器，任务发生变化时，调整定时器在链表中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    util_timer *tmp = timer-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调整的定时器在链表尾部 或 定时器超时值仍然小于下一个定时器超时值，不调整</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被调整定时器是链表头结点，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被调整定时器在内部，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, timer-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::del_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中只有一个定时器，需要删除该定时器</span></span><br><span class="line">    <span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        tail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被删除的定时器为头结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被删除的定时器为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == tail)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被删除的定时器在链表内部，常规链表结点删除</span></span><br><span class="line">    timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="comment">// 遍历定时器链表</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//链表容器为升序排列，当前时间小于定时器的超时时间，那么说明后面的定时器也没有到期</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; tmp-&gt;expire)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前定时器到期，则调用回调函数，执行定时事件</span></span><br><span class="line">        tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line">        <span class="comment">// 将处理后的定时器从链表容器中删除，并重置头结点</span></span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要用于调整链表内部结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *prev = lst_head;</span><br><span class="line">    util_timer *tmp = prev-&gt;next;</span><br><span class="line">    <span class="comment">// 遍历当前结点之后的链表，按照超时时间找到目标定时器对应的位置，常规双向链表插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;prev = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历完发现，目标定时器需要放到尾结点处</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        prev-&gt;next = timer;</span><br><span class="line">        timer-&gt;prev = prev;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        tail = timer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::init</span><span class="params">(<span class="keyword">int</span> timeslot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_TIMESLOT = timeslot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Utils::setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot, <span class="keyword">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="comment">// 信号处理函数中仅仅通过管道发送信号值，不处理信号对应的逻辑，缩短异步执行时间，减少对主程序的影响。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为保证函数的可重入性，保留原来的errno</span></span><br><span class="line">    <span class="comment">// 可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据</span></span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">int</span> msg = sig;</span><br><span class="line">    <span class="comment">// 将信号值从管道写端写入，传输字符类型，而非整型</span></span><br><span class="line">    <span class="built_in">send</span>(u_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将原来的errno赋值为当前的errno</span></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置信号函数，仅关注 SIGTERM 和 SIGALRM 两个信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建 sigaction 结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    <span class="comment">// 信号处理函数中仅仅发送信号值，不做对应逻辑处理</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart)</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="comment">// 将所有信号添加到信号集中</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">// 执行sigaction函数</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(m_TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::show_error</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">send</span>(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *Utils::u_pipefd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Utils::u_epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(Utils::u_epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(user_data);</span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line">    http_conn::m_user_count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、同步-异步日志系统"><a href="#五、同步-异步日志系统" class="headerlink" title="五、同步/异步日志系统"></a>五、同步/异步日志系统</h3><h4 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h4><ul>
<li><strong>日志</strong>：由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。</li>
<li><strong>同步日志</strong>：日志写入函数与工作线程串行执行，由于涉及到<code>I/O</code>操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</li>
<li><strong>异步日志</strong>：将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。</li>
<li><strong>生产者-消费者模型</strong>：并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中<code>push</code>消息，消费者线程从缓冲区中<code>pop</code>消息。</li>
<li><strong>阻塞队列</strong>：将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。</li>
</ul>
<h4 id="2、单例模式：保证一个类只创建一个实例，同时提供全局访问的方法"><a href="#2、单例模式：保证一个类只创建一个实例，同时提供全局访问的方法" class="headerlink" title="2、单例模式：保证一个类只创建一个实例，同时提供全局访问的方法"></a>2、单例模式：保证一个类只创建一个实例，同时提供全局访问的方法</h4><h5 id="（1）实现思路"><a href="#（1）实现思路" class="headerlink" title="（1）实现思路"></a>（1）实现思路</h5><ul>
<li>私有化它的构造函数，以防止外界创建单例类的对象</li>
<li>使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例</li>
</ul>
<h5 id="（2）懒汉和饿汉模式"><a href="#（2）懒汉和饿汉模式" class="headerlink" title="（2）懒汉和饿汉模式"></a>（2）懒汉和饿汉模式</h5><ul>
<li>懒汉模式：不用的时候不去初始化，所以在第一次被使用时才进行初始化（实例的初始化放在<code>getinstance</code>函数内部）<ul>
<li>经典的线程安全懒汉模式，使用双检测锁模式（<code>p == NULL</code>检测了两次）</li>
<li>利用局部静态变量实现线程安全懒汉模式</li>
</ul>
</li>
<li>饿汉模式：在程序运行时立即初始化（实例的初始化放在<code>getinstance</code>函数外部，<code>getinstance</code>函数仅返回该唯一实例的指针）。</li>
</ul>
<h4 id="3、懒汉模式"><a href="#3、懒汉模式" class="headerlink" title="3、懒汉模式"></a>3、懒汉模式</h4><h5 id="（1）经典的线程安全懒汉模式"><a href="#（1）经典的线程安全懒汉模式" class="headerlink" title="（1）经典的线程安全懒汉模式"></a>（1）经典的线程安全懒汉模式</h5><h5 id="【问题】经典的线程安全懒汉模式中，为什么要用双检测，只检测一次不行吗？"><a href="#【问题】经典的线程安全懒汉模式中，为什么要用双检测，只检测一次不行吗？" class="headerlink" title="【问题】经典的线程安全懒汉模式中，为什么要用双检测，只检测一次不行吗？"></a>【问题】经典的线程安全懒汉模式中，为什么要用双检测，只检测一次不行吗？</h5><p>如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合<code>NULL == p</code>的情况，直接返回已创建好的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> single* p;            <span class="comment">// 私有静态指针变量指向唯一实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock; <span class="comment">// 静态锁，是由于静态函数只能访问静态成员</span></span><br><span class="line">    <span class="built_in">single</span>() &#123;                   <span class="comment">// 私有化构造函数</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>; <span class="comment">// 公有静态方法获取实例</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> single::lock;</span><br><span class="line">single* single::p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">            p = <span class="keyword">new</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）局部静态变量之线程安全懒汉模式"><a href="#（2）局部静态变量之线程安全懒汉模式" class="headerlink" title="（2）局部静态变量之线程安全懒汉模式"></a>（2）局部静态变量之线程安全懒汉模式</h5><p>前面的双检测锁模式，写起来不太优雅，《Effective C++》中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> single obj;</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用C++11之前的标准，还是需要加锁，这里同样给出加锁的版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="built_in">single</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> single::lock;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">static</span> single obj;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、饿汉模式"><a href="#4、饿汉模式" class="headerlink" title="4、饿汉模式"></a>4、饿汉模式</h4><p>饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数<code>getinstance()</code>，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> single* p;</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p = <span class="keyword">new</span> single;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的<code>static</code>对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 <code>getInstance() </code>方法会返回一个未定义的实例。</p>
<p><strong>项目中完成的是懒汉模式</strong>，即有日志需求的时候，会创造出一个<code>log</code>实例。<code>Log::get_instance()</code>是一个静态函数，可以通过类命名域直接调用来产生出单例。这个函数的返回值就是这个单例的指针，于是可以通过指向来完成对于日志写函数的调用。</p>
<h4 id="5、异步日志"><a href="#5、异步日志" class="headerlink" title="5、异步日志"></a>5、异步日志</h4><p>考虑设计一个日志队列，这个队列主要是用一个循环数组模拟队列来存储日志，这里要注意这个队列只是存储我们真正的目的是要写到文件里，所以只是存储并未达到目的。但是考虑到文件IO操作是比较慢的，所以我们采用的异步IO就是先写到内存里，然后日志线程自己有空的时候写到文件里。所以这一模块的关键就是<strong>日志队列和写日志的线程</strong>。</p>
<p>先来思考日志队列，他的需求就是时不时会有一段日志塞到这个队列中，又时不时会有这其中的一段日志被取出来，那么当然是<strong>队列不满才能往里塞，队列不空才能有东西取出来</strong>。这就是经典的<strong>生产者消费者模型</strong>。所以也就没什么好说的了，常规处理：要一个互斥锁和信号量，操作前都加锁就行。</p>
<h4 id="6、具体实现"><a href="#6、具体实现" class="headerlink" title="6、具体实现"></a>6、具体实现</h4><h5 id="（1）block-queue-h"><a href="#（1）block-queue-h" class="headerlink" title="（1）block_queue.h"></a>（1）block_queue.h</h5><p>这个代码实际上就是对一个<code>queue</code>的实现，当然你也可以用<code>stl</code>的<code>queue</code>。各有好处，这个<code>queue</code>的底层是一个数组，最大值为<code>1000</code>。里面存放了即将刷入文件的日志内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*循环数组实现的阻塞队列，m_back = (m_back + 1) % m_max_size;  </span></span><br><span class="line"><span class="comment">*线程安全，每个操作前都要先加互斥锁，操作完后，再解锁</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">block_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">block_queue</span>(<span class="keyword">int</span> max_size = <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        m_max_size = max_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[max_size];   <span class="comment">// 阻塞队列的string数组</span></span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">block_queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> [] m_array;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span>  <span class="comment">// 判断队列是否满了</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 判断队列是否为空</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T &amp;value)</span> <span class="comment">// 返回队首元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_front];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">back</span><span class="params">(T &amp;value)</span> <span class="comment">// 返回队尾元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_back];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_size;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_max_size;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往队列添加元素，需要将所有使用队列的线程先唤醒</span></span><br><span class="line">    <span class="comment">// 当有元素push进队列,相当于生产者生产了一个元素</span></span><br><span class="line">    <span class="comment">// 若当前没有线程等待条件变量,则唤醒无意义</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_back = (m_back + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        m_array[m_back] = item;</span><br><span class="line">        m_size++;</span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// pop时,如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;       </span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="keyword">int</span> ms_timeout)</span>  <span class="comment">// 增加了超时处理</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;</span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">timewait</span>(m_mutex.<span class="built_in">get</span>(), t))</span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    locker m_mutex;</span><br><span class="line">    cond m_cond;</span><br><span class="line">    T *m_array;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">    <span class="keyword">int</span> m_max_size;</span><br><span class="line">    <span class="keyword">int</span> m_front;</span><br><span class="line">    <span class="keyword">int</span> m_back;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="（2）log-h-和-log-cpp"><a href="#（2）log-h-和-log-cpp" class="headerlink" title="（2）log.h 和 log.cpp"></a>（2）log.h 和 log.cpp</h5><p>写日志线程，这一部分也比较简单，就是新建一个线程，这个线程不断循环，当日志队列有日志就从里面取出来写到文件去，这个过程需要加锁。项目默认的是同步写，这个可以测试性能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Log *<span class="title">get_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">flush_log_thread</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">        Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, <span class="keyword">int</span> close_log, <span class="keyword">int</span> log_buf_size = <span class="number">8192</span>, <span class="keyword">int</span> split_lines = <span class="number">5000000</span>, <span class="keyword">int</span> max_queue_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write_log</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">async_write_log</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string single_log;</span><br><span class="line">        <span class="comment">// 从阻塞队列中取出一个日志string，写入文件</span></span><br><span class="line">        <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> dir_name[<span class="number">128</span>]; <span class="comment">// 路径名</span></span><br><span class="line">    <span class="keyword">char</span> log_name[<span class="number">128</span>]; <span class="comment">// log文件名</span></span><br><span class="line">    <span class="keyword">int</span> m_split_lines;  <span class="comment">// 日志最大行数</span></span><br><span class="line">    <span class="keyword">int</span> m_log_buf_size; <span class="comment">// 日志缓冲区大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> m_count;  <span class="comment">// 日志行数记录</span></span><br><span class="line">    <span class="keyword">int</span> m_today;        <span class="comment">// 因为按天分类,记录当前时间是那一天</span></span><br><span class="line">    FILE *m_fp;         <span class="comment">// 打开log的文件指针</span></span><br><span class="line">    <span class="keyword">char</span> *m_buf;</span><br><span class="line">    block_queue&lt;string&gt; *m_log_queue; <span class="comment">// 阻塞队列</span></span><br><span class="line">    <span class="keyword">bool</span> m_is_async;                  <span class="comment">// 是否同步标志位</span></span><br><span class="line">    locker m_mutex;</span><br><span class="line">    <span class="keyword">int</span> m_close_log;    <span class="comment">// 关闭日志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">Log::<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_count = <span class="number">0</span>;</span><br><span class="line">    m_is_async = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步需要设置阻塞队列的长度，同步不需要设置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Log::init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, <span class="keyword">int</span> close_log, <span class="keyword">int</span> log_buf_size, <span class="keyword">int</span> split_lines, <span class="keyword">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果设置了max_queue_size, 则设置为异步</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_is_async = <span class="literal">true</span>;</span><br><span class="line">        m_log_queue = <span class="keyword">new</span> block_queue&lt;string&gt;(max_queue_size);</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">// flush_log_thread 为回调函数, 这里表示创建线程异步写日志</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_log_buf_size = log_buf_size;</span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="keyword">char</span>[m_log_buf_size];</span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, m_log_buf_size);</span><br><span class="line">    m_split_lines = split_lines;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">sys_tm</span> =</span> <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">my_tm</span> =</span> *sys_tm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">char</span> log_full_name[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, file_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_today = my_tm.tm_mday;</span><br><span class="line">    </span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> t = now.tv_sec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">sys_tm</span> =</span> <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">my_tm</span> =</span> *sys_tm;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入一个log，对m_count++, m_split_lines最大行数</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    m_count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>) <span class="comment">//everyday log</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> new_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">        <span class="keyword">char</span> tail[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);</span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    va_list valst;</span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);</span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入的具体时间内容格式</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">                     my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - <span class="number">1</span>, format, valst);</span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    log_str = m_buf;</span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Log::flush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 强制刷新写入流缓冲区</span></span><br><span class="line">    <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、数据库连接池、同步线程注册、登录校验"><a href="#六、数据库连接池、同步线程注册、登录校验" class="headerlink" title="六、数据库连接池、同步线程注册、登录校验"></a>六、数据库连接池、同步线程注册、登录校验</h3><p>数据库连接池</p>
<blockquote>
<ul>
<li>单例模式，保证唯一</li>
<li>list 实现连接池</li>
<li>连接池为静态大小</li>
<li>互斥锁实现线程安全</li>
</ul>
</blockquote>
<p>校验  </p>
<blockquote>
<ul>
<li>HTTP请求采用POST方式</li>
<li>登录用户名和密码校验</li>
<li>用户注册及多线程注册安全</li>
</ul>
</blockquote>
<h4 id="1、数据库访问的一般流程"><a href="#1、数据库访问的一般流程" class="headerlink" title="1、数据库访问的一般流程"></a>1、数据库访问的一般流程</h4><p>当系统需要访问数据库时，先系统创建数据库连接，完成数据库操作，然后系统断开数据库连接。从中可以看出，若系统需要频繁访问数据库，<strong>则需要频繁创建和断开数据库连接</strong>，而创建数据库连接是一个很耗时的操作，<strong>也容易对数据库造成安全隐患</strong>。若每次用户请求我们都需要新建一个数据库连接，请求结束后我们释放该数据库连接，当用户请求连接过多时，这种做法过于低效，所以类似<strong>线程池</strong>的做法，我们构建一个数据库连接池，预先生成一些数据库连接放在那里供用户请求使用。</p>
<h4 id="2、数据库连接池"><a href="#2、数据库连接池" class="headerlink" title="2、数据库连接池"></a>2、数据库连接池</h4><p>在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放。<strong>对于多于连接池中连接数的并发请求，应该在请求队列中排队等待</strong>。并且应用程序可以根据池中连接的使用率，<strong>动态增加或减少池中的连接数</strong>。 </p>
<ul>
<li><p>优点</p>
<p>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况。</p>
</li>
<li><p>连接池的建立</p>
<p>一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。</p>
</li>
<li><p>连接池中连接的使用管理<br>当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。<br>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。</p>
</li>
<li><p>连接池的关闭</p>
<p>当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源。</p>
</li>
</ul>
<h4 id="3、linux-下-mysql-常用函数"><a href="#3、linux-下-mysql-常用函数" class="headerlink" title="3、linux 下 mysql 常用函数"></a>3、linux 下 mysql 常用函数</h4><p>找不到<code>mysql/mysql.h</code>头文件的时候，需要安装一个库文件：<code>sudo apt install libmysqlclient-dev</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配或者初始化一个MYSQL对象，用于连接mysql服务端。如果你传入的参数是NULL指针，它将自动为你分配一个MYSQL对象，如果这个MYSQL对象是它自动分配的，那么在调用mysql_close的时候，会释放这个对象</span></span><br><span class="line"><span class="function">MySQL *<span class="title">mysql_init</span><span class="params">(MYSQL *mysql)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 尝试与运行在主机上的MySQL数据库引擎建立连接</span></span><br><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// mysql：mysql_init 函数返回的指针</span></span><br><span class="line"><span class="comment">// host：为 null 或 localhost 时链接的是本地的计算机</span></span><br><span class="line"><span class="comment">// user/passws：当 mysql 默认安装在unix（或类unix）系统中，root 账户是没有密码的，因此用户名使用 root，密码为null</span></span><br><span class="line"><span class="comment">// db：当db为空的时候，函数链接到默认数据库，在进行 mysql 安装时会存在默认的test数据库，因此此处可以使用test数据库名称</span></span><br><span class="line"><span class="comment">// port：port端口为0</span></span><br><span class="line"><span class="comment">// unix_socket：使用 unix连接方式，unix_socket为 null 时，表明不使用 socket 或管道机制</span></span><br><span class="line"><span class="comment">// client_flag：最后一个参数经常设置为0</span></span><br><span class="line"><span class="comment">// 如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span> <span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">const</span> <span class="keyword">char</span> *passwd, <span class="keyword">const</span> <span class="keyword">char</span> *db, <span class="keyword">unsigned</span> <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *unix_socket, <span class="keyword">unsigned</span> <span class="keyword">long</span> client_flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询语句，返回值为0表示查询成功</span></span><br><span class="line"><span class="built_in">mysql_query</span>(query, connection);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集，mysql的结果集其实就是一个MYSQL_RES结构。一旦完成了对结果集的操作，必须调用mysql_free_result()。</span></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_store_result</span><span class="params">(MYSQL *mysql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放由mysql_store_result()、mysql_use_result()、mysql_list_dbs()等为结果集分配的内存。完成对结果集的操作后，必须调用mysql_free_result()释放结果集使用的内存。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysql_free_result</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化结果集检索，但并不像mysql_store_result()那样将结果集实际读取到客户端。它必须通过对mysql_fetch_row()的调用，对每一行分别进行检索。这将直接从服务器读取结果，而不会将其保存在临时表或本地缓冲区内，与mysql_store_result()相比，速度更快而且使用的内存也更少。</span></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_use_result</span><span class="params">(MYSQL *mysql)</span></span>;  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不断获取下一行，然后循环输出。使用mysql_use_result()时，必须执行mysql_fetch_row()，直至返回NULL值，否则，未获取的行将作为下一个检索的一部分返回。</span></span><br><span class="line"><span class="function">MYSQL_ROW <span class="title">mysql_fetch_row</span><span class="params">(MYSQL_RES *result)</span></span>;   </span><br><span class="line">   </span><br><span class="line"><span class="comment">// 返回采用MYSQL_FIELD结构的结果集的列。重复调用该函数，以检索关于结果集中所有列的信息。未剩余字段时，mysql_fetch_field()返回NULL。</span></span><br><span class="line"><span class="function">MYSQL_FIELD *<span class="title">mysql_fetch_field</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于结果集，返回所有MYSQL_FIELD结构的数组。每个结构提供了结果集中1列的字段定义。</span></span><br><span class="line"><span class="function">MYSQL_FIELD *<span class="title">mysql_fetch_fields</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回采用MYSQL_FIELD结构的结果集的行数</span></span><br><span class="line"><span class="built_in">mysql_num_rows</span>(MYSQL_RES *result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="built_in">mysql_close</span>(MYSQL *mysql);</span><br></pre></td></tr></table></figure>

<h4 id="4、sql-connection-pool-h-sql-connection-pool-cpp"><a href="#4、sql-connection-pool-h-sql-connection-pool-cpp" class="headerlink" title="4、sql_connection_pool.h / sql_connection_pool.cpp"></a>4、<code>sql_connection_pool.h</code> / <code>sql_connection_pool.cpp</code></h4><p>改文件中定义了数据库连接池类。对于一个数据库连接池来讲，就是预先生成多个这样的数据库连接，然后放在一个链表中，同时维护最大连接数<code>MAX_CONN</code>，当前可用连接数<code>FREE_CONN</code>和当前已用连接数<code>CUR_CONN</code>这三个变量。同样注意在对连接池操作时（获取，释放），要用到锁机制，因为它被所有线程共享。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connection_pool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="keyword">int</span> Port, <span class="keyword">int</span> MaxConn, <span class="keyword">int</span> close_log)</span></span>; </span><br><span class="line">	<span class="function">MYSQL *<span class="title">GetConnection</span><span class="params">()</span></span>;				 <span class="comment">//获取数据库连接</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ReleaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">//释放连接	</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DestroyPool</span><span class="params">()</span></span>;					 <span class="comment">//销毁所有连接</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetFreeConn</span><span class="params">()</span></span>;					 <span class="comment">//获取空闲连接数量</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;  <span class="comment">//单例模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">connection_pool</span>();</span><br><span class="line">	~<span class="built_in">connection_pool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_MaxConn;  <span class="comment">//最大连接数</span></span><br><span class="line">	<span class="keyword">int</span> m_CurConn;  <span class="comment">//当前已使用的连接数</span></span><br><span class="line">	<span class="keyword">int</span> m_FreeConn; <span class="comment">//当前空闲的连接数</span></span><br><span class="line">	locker lock;</span><br><span class="line">	list&lt;MYSQL *&gt; connList; <span class="comment">//连接池</span></span><br><span class="line">	sem reserve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_url;			 <span class="comment">//主机地址</span></span><br><span class="line">	string m_Port;		     <span class="comment">//数据库端口号</span></span><br><span class="line">	string m_User;		 <span class="comment">//登陆数据库用户名</span></span><br><span class="line">	string m_PassWord;	 <span class="comment">//登陆数据库密码</span></span><br><span class="line">	string m_DatabaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">	<span class="keyword">int</span> m_close_log;	<span class="comment">//日志开关</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">connection_pool::<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	m_CurConn = <span class="number">0</span>;    <span class="comment">//当前已使用的连接数</span></span><br><span class="line">	m_FreeConn = <span class="number">0</span>;   <span class="comment">//当前空闲的连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection_pool *<span class="title">connection_pool::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> connection_pool connPool;</span><br><span class="line">	<span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connection_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="keyword">int</span> Port, <span class="keyword">int</span> MaxConn, <span class="keyword">int</span> close_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m_url = url;</span><br><span class="line">	m_User = User;</span><br><span class="line">	m_PassWord = PassWord;</span><br><span class="line">	m_DatabaseName = DBName;</span><br><span class="line">	m_Port = Port;</span><br><span class="line">	m_close_log = close_log;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">		con = <span class="built_in">mysql_init</span>(con);   <span class="comment">// 初始化一个MYSQL对象</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 建立数据库连接</span></span><br><span class="line">		con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		connList.<span class="built_in">push_back</span>(con);  <span class="comment">// 将建立好的数据库连接放入连接池中</span></span><br><span class="line">		++m_FreeConn;             <span class="comment">// 空闲连接数加 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	reserve = <span class="built_in">sem</span>(m_FreeConn);    <span class="comment">// 用空闲连接数来初始化信号量</span></span><br><span class="line">	m_MaxConn = m_FreeConn;       <span class="comment">// 此时最大连接数即为空闲连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">connection_pool::GetConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())     <span class="comment">// 数据库连接池为空，则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">wait</span>();    <span class="comment">// 信号量的值减少1</span></span><br><span class="line">	lock.<span class="built_in">lock</span>();       <span class="comment">// 申请互斥锁</span></span><br><span class="line"></span><br><span class="line">	con = connList.<span class="built_in">front</span>();  <span class="comment">// 取出一个连接</span></span><br><span class="line">	connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">	--m_FreeConn;      <span class="comment">// 空闲连接数减少1</span></span><br><span class="line">	++m_CurConn;       <span class="comment">// 当前已使用的连接数加1</span></span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();     <span class="comment">// 解锁</span></span><br><span class="line">	<span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">connection_pool::ReleaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">	connList.<span class="built_in">push_back</span>(con);   <span class="comment">// 将释放的连接放入数据库连接池中</span></span><br><span class="line">	++m_FreeConn;      <span class="comment">// 空闲连接数加1</span></span><br><span class="line">	--m_CurConn;       <span class="comment">// 当前已使用的连接数减1</span></span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">post</span>();    <span class="comment">// 信号量加1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connection_pool::DestroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lock.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)  <span class="comment">// 如果数据库连接池不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			MYSQL *con = *it;</span><br><span class="line">			<span class="built_in">mysql_close</span>(con);   <span class="comment">// 遍历数据库连接池，关闭每个连接</span></span><br><span class="line">		&#125;</span><br><span class="line">		m_CurConn = <span class="number">0</span>;          </span><br><span class="line">		m_FreeConn = <span class="number">0</span>;         </span><br><span class="line">		connList.<span class="built_in">clear</span>();       <span class="comment">// 清空链表</span></span><br><span class="line">	&#125;</span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前空闲的连接数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connection_pool::GetFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_FreeConn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection_pool::~<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DestroyPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该项目中不仅实现了数据库连接池，还将数据库连接的获取与释放通过<code>RAII</code>机制封装，避免手动释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connectionRAII</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool);</span><br><span class="line">	~<span class="built_in">connectionRAII</span>();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *conRAII;</span><br><span class="line">	connection_pool *poolRAII;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">	*SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">	</span><br><span class="line">	conRAII = *SQL;</span><br><span class="line">	poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>()&#123;</span><br><span class="line">	poolRAII-&gt;<span class="built_in">ReleaseConnection</span>(conRAII);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、登录校验"><a href="#5、登录校验" class="headerlink" title="5、登录校验"></a>5、登录校验</h4><p>对用户的登录及注册等<code>POST</code>请求，服务器是如何做校验的。当点击<strong>新用户</strong>按钮时，服务器对这个<code>POST</code>请求的响应是：返回用户一个登录界面；当你在用户名和密码框中输入后，你的<code>POST</code>请求报文中会连同你的用户名密码一起发给服务器，然后我们拿着你的用户名和密码在数据库连接池中取出一个连接用于<code>mysql_query()</code>进行查询。</p>
<p>【CGI校验：CGI（通用网关接口），它是一个运行在Web服务器上的程序，在编译的时候将相应的<code>.cpp</code>文件编程成<code>.cgi</code>文件并在主程序中调用即可（通过社长的<code>makefile</code>文件内容也可以看出）。这些CGI程序通常通过客户在其浏览器上点击一个<code>button</code>时运行。这些程序通常用来执行一些信息搜索、存储等任务，而且通常会生成一个动态的HTML网页来响应客户的HTTP请求。我们可以发现项目中的<code>sign.cpp</code>文件就是我们的CGI程序，将用户请求中的用户名和密码保存在一个<code>id_passwd.txt</code>文件中，通过将数据库中的用户名和密码存到一个<code>map</code>中用于校验。在主程序中通过<code>execl(m_real_file, &amp;flag, name, password, NULL);</code>这句命令来执行这个CGI文件，这里CGI程序仅用于校验，并未直接返回给用户响应。这个CGI程序的运行通过多进程来实现，根据其返回结果判断校验结果（使用<code>pipe</code>进行父子进程的通信，子进程将校验结果写到pipe的写端，父进程在读端读取）。】</p>
<h3 id="七、config-独立参数模块"><a href="#七、config-独立参数模块" class="headerlink" title="七、config 独立参数模块"></a>七、config 独立参数模块</h3><p>这里体现出整个项目的优点：<strong>模式切换</strong><br>也就是说这是一个复合的<strong>ET/LT</strong>。作者在<strong>Listenfd上和cfd</strong>上都建立了两种模式，意味着我们有四种组合方式。</p>
<p><code>config.cpp</code>具体参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Config::<span class="built_in">Config</span>()&#123;</span><br><span class="line">    <span class="comment">//端口号,默认9006</span></span><br><span class="line">    PORT = <span class="number">9006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式，默认同步</span></span><br><span class="line">    LOGWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式,默认listenfd LT + connfd LT</span></span><br><span class="line">    TRIGMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式，默认LT</span></span><br><span class="line">    LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式，默认LT</span></span><br><span class="line">    CONNTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接，默认不使用</span></span><br><span class="line">    OPT_LINGER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量,默认8</span></span><br><span class="line">    sql_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量,默认8</span></span><br><span class="line">    thread_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭日志,默认不关闭</span></span><br><span class="line">    close_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型,默认是proactor</span></span><br><span class="line">    actor_model = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config::parse_arg</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;p:l:m:o:s:t:c:a:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, str)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (opt)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            PORT = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            LOGWrite = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            TRIGMode = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            OPT_LINGER = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sql_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            thread_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            close_log = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            actor_model = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、main-函数和-webserver-类接口"><a href="#八、main-函数和-webserver-类接口" class="headerlink" title="八、main 函数和 webserver 类接口"></a>八、main 函数和 webserver 类接口</h3><h4 id="1、main函数"><a href="#1、main函数" class="headerlink" title="1、main函数"></a>1、main函数</h4><p><code>main</code>模块的主要功能是，驱动<code>Sever</code>。<code>WebServer</code>被单独作为一个类实现，并且封装好了调度函数。<code>main</code>函数相当于一个开关，我打开了服务器的开关让他进入了<code>listen</code>状态，同时也转身打开了数据库的开关。这个开关的信息，来自于<code>config</code>。</p>
<p><code>main.cpp</code>具体实现：首先打开线程池，然后设置运行模式，之后就是启动监听和进入工作循环（事务循环）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要修改的数据库信息,登录名,密码,库名</span></span><br><span class="line">    string user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    string passwd = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    string databasename = <span class="string">&quot;qgydb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//命令行解析</span></span><br><span class="line">    Config config;</span><br><span class="line">    config.<span class="built_in">parse_arg</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    WebServer server;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    server.<span class="built_in">init</span>(config.PORT, user, passwd, databasename, config.LOGWrite, </span><br><span class="line">                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num, </span><br><span class="line">                config.close_log, config.actor_model);</span><br><span class="line">    <span class="comment">//日志</span></span><br><span class="line">    server.<span class="built_in">log_write</span>();</span><br><span class="line">    <span class="comment">//数据库</span></span><br><span class="line">    server.<span class="built_in">sql_pool</span>();</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    server.<span class="built_in">thread_pool</span>();</span><br><span class="line">    <span class="comment">//触发模式</span></span><br><span class="line">    server.<span class="built_in">trig_mode</span>();</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    server.<span class="built_in">eventListen</span>();</span><br><span class="line">    <span class="comment">//运行</span></span><br><span class="line">    server.<span class="built_in">eventLoop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、webserver-类模块"><a href="#2、webserver-类模块" class="headerlink" title="2、webserver 类模块"></a>2、webserver 类模块</h4><ul>
<li><p><code>eventListen()</code>函数<br>简单的<code>socket</code>三连调用，作者加入了<code>assert</code>，提升了健壮性。之后就是调用<code>epoll</code>的三连了，将<code>lfd</code>上树，这里的上树封装为了<code>addfd</code>目的是为了可以更改模式。（<code>cfd</code>需要<code>one_shot</code>而<code>lfd</code>不需要）。之后就是创建了管道，这里牵扯到进程间通信的问题。这么做的好处就是统一事件源。因为正常情况下，信号处理与IO处理不走一条路，这里的信号主要是超时问题。<br>具体的做法是，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I/O复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过<code>epoll</code>来监测，从而实现统一处理。</p>
</li>
<li><p><code>eventLoop()</code>函数<br>这个函数可以说是始终伴随着程序始终。只要服务器不关，就一直不退出，因为退出了，<code>main()</code>函数也退出了。<br>明显看出，这一函数的逻辑就是不断的处理产生事件的节点。而在<code>epoll_wait</code>返回后，主要处理三种事件：</p>
<ul>
<li><p><strong>io事件—-dealwithread()函数</strong><br>按照之前的思想，对于整个并发模式的思路，存在两个模式的切换：<code>reactor</code>与<code>proactor</code>（同步io模拟出）。它们的区别是对于数据的读取者是谁，对于<code>reactor</code>是同步线程来完成，整个读就绪放在请求列表上；而对于<code>preactor</code>则是由主线程，也就是当前的<code>WebServer</code>进行一次调用，读取后将读完成纳入请求队列上。同样，对于当前的<code>fd</code>我们要对他进行时间片的调整。同样的，当时间到期时，在定时器对象中，会有对应的下树操作。</p>
</li>
<li><p><strong>信号—-dealwithsignal()函数</strong></p>
<p>与读写不同的是，这里的<code>signal</code>是处理函数，它不需要上队列。这里是通过管道的方式来告知<code>ebServer</code>。管道由<code>epoll</code>监控。</p>
</li>
<li><p><strong>新的连接—-dealclinetdata() / dealwithwrite()函数</strong></p>
</li>
</ul>
</li>
<li><p><code>time</code>函数集<br>把与时间片相关的调用，放在<code>WebServer里</code>，但是里面的细节，通过<code>time</code>这个类来实现。</p>
<ul>
<li><p><code>timer()</code>函数<br>首先搞清楚，timer在什么时候调用？答案是在<code>accept</code>得到<code>cfd</code>的时候。这时候通过<code>timer</code>函数不只是初始化了<code>cfd</code>的时间，而且整体初始化。也就是说，当前服务器已经认可了这一连接，完成了三次握手，并且得到了用户标识，允许传输数据。这里为了提升性能，给到了3倍阈值的超时。</p>
</li>
<li><p><code>adjust_timer()</code>与<code>deal_timer()</code>函数</p>
<p><code>adjust</code>可以看到是在产生事件之后，为了还能传输数据，再刷新一下你的时间或者给你延长；而<code>deal</code>则是对于坏连接的一个处理。</p>
</li>
</ul>
</li>
</ul>
<h5 id="（1）webserver-h"><a href="#（1）webserver-h" class="headerlink" title="（1）webserver.h"></a>（1）webserver.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>();</span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> port , string user, string passWord, string databaseName,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> log_write , <span class="keyword">int</span> opt_linger, <span class="keyword">int</span> trigmode, <span class="keyword">int</span> sql_num,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">int</span> thread_num, <span class="keyword">int</span> close_log, <span class="keyword">int</span> actor_model)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程池函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">thread_pool</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 数据库池函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sql_pool</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 写日志函数   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log_write</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 更改模式  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trig_mode</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">// 创建lfd </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eventListen</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 当服务器非关闭状态 用于处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eventLoop</span><span class="params">()</span></span>;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定时器的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">timer</span><span class="params">(<span class="keyword">int</span> connfd, struct sockaddr_in client_address)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deal_timer</span><span class="params">(util_timer *timer, <span class="keyword">int</span> sockfd)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用户数据 </span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dealclinetdata</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 信号</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dealwithsignal</span><span class="params">(<span class="keyword">bool</span>&amp; timeout, <span class="keyword">bool</span>&amp; stop_server)</span></span>; </span><br><span class="line">    <span class="comment">// 读事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dealwithread</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="comment">// 写事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dealwithwrite</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 监听端口</span></span><br><span class="line">    <span class="keyword">int</span> m_port;</span><br><span class="line">    <span class="keyword">char</span> *m_root;</span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">    <span class="keyword">int</span> m_log_write;</span><br><span class="line">    <span class="keyword">int</span> m_close_log;</span><br><span class="line">    <span class="comment">// 触发模式</span></span><br><span class="line">    <span class="keyword">int</span> m_actormodel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程通信模块</span></span><br><span class="line">    <span class="keyword">int</span> m_pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// epoll根</span></span><br><span class="line">    <span class="keyword">int</span> m_epollfd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于接受用户连接</span></span><br><span class="line">    http_conn *users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库相关</span></span><br><span class="line">    connection_pool *m_connPool;</span><br><span class="line">    string m_user;         <span class="comment">// 登陆数据库用户名</span></span><br><span class="line">    string m_passWord;     <span class="comment">// 登陆数据库密码</span></span><br><span class="line">    string m_databaseName; <span class="comment">// 使用数据库名</span></span><br><span class="line">    <span class="keyword">int</span> m_sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http线程池</span></span><br><span class="line">    threadpool&lt;http_conn&gt; *m_pool;</span><br><span class="line">    <span class="keyword">int</span> m_thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll_event 注册节点事件  </span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_listenfd;       <span class="comment">//监听fd 申请一次</span></span><br><span class="line">    <span class="keyword">int</span> m_OPT_LINGER;</span><br><span class="line">    <span class="keyword">int</span> m_TRIGMode;       <span class="comment">//触发模式 ET+LT LT+LT LT+ET  ET+ET </span></span><br><span class="line">    <span class="keyword">int</span> m_LISTENTrigmode; <span class="comment">// 监听 ET/LT</span></span><br><span class="line">    <span class="keyword">int</span> m_CONNTrigmode;   <span class="comment">// 连接 ET/LT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器相关</span></span><br><span class="line">    client_data *users_timer;</span><br><span class="line">    Utils utils;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="（2）webserver-cpp"><a href="#（2）webserver-cpp" class="headerlink" title="（2）webserver.cpp"></a>（2）webserver.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// http_conn类对象，预先为每个可能的客户连接分配一个http_conn对象</span></span><br><span class="line">    users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root文件夹路径</span></span><br><span class="line">    <span class="keyword">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(server_path, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">    m_root = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">    <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器</span></span><br><span class="line">    users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">    <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="keyword">delete</span>[] users_timer;</span><br><span class="line">    <span class="keyword">delete</span> m_pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::init</span><span class="params">(<span class="keyword">int</span> port, string user, string passWord, string databaseName, <span class="keyword">int</span> log_write, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> opt_linger, <span class="keyword">int</span> trigmode, <span class="keyword">int</span> sql_num, <span class="keyword">int</span> thread_num, <span class="keyword">int</span> close_log, <span class="keyword">int</span> actor_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_port = port;</span><br><span class="line">    m_user = user;</span><br><span class="line">    m_passWord = passWord;</span><br><span class="line">    m_databaseName = databaseName;</span><br><span class="line">    m_sql_num = sql_num;</span><br><span class="line">    m_thread_num = thread_num;</span><br><span class="line">    m_log_write = log_write;</span><br><span class="line">    m_OPT_LINGER = opt_linger;</span><br><span class="line">    m_TRIGMode = trigmode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_actormodel = actor_model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::trig_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//LT + LT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LT + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + LT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::log_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_close_log)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_log_write)</span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">800</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::sql_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化数据库连接池</span></span><br><span class="line">    m_connPool = connection_pool::<span class="built_in">GetInstance</span>();</span><br><span class="line">    m_connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>, m_user, m_passWord, m_databaseName, <span class="number">3306</span>, m_sql_num, m_close_log);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据库读取表</span></span><br><span class="line">    users-&gt;<span class="built_in">initmysql_result</span>(m_connPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::thread_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    m_pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;(m_actormodel, m_connPool, m_thread_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 完成了设置lfd与统一事件源，并且创建了带有一个节点的epoll树，同时完成了超时设定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::eventListen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 网络编程基础步骤</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果它的条件返回错误，则终止程序执行</span></span><br><span class="line">    <span class="built_in">assert</span>(m_listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP连接断开的时候调用closesocket函数，有优雅的断开和强制断开两种方式</span></span><br><span class="line">    <span class="comment">// 优雅关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;   <span class="comment">// 底层会将未发送完的数据发送完成后再释放资源，也就是优雅的退出</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">tmp</span> =</span> &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这种方式下，在调用closesocket的时候不会立刻返回，内核会延迟一段时间，这个时间就由 l_linger 得值来决定。</span></span><br><span class="line">        <span class="comment">// 如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，closesocket会返回正确，socket描述符优雅性退出。</span></span><br><span class="line">        <span class="comment">// 否则，closesocket会直接返回 错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则closesocket会直接返回值。</span></span><br><span class="line">        struct linger tmp = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bzero() 会将内存块（字符串）的前n个字节清零;</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 允许重用本地地址和端口</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in"><span class="keyword">sizeof</span></span>(flag));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传统绑定步骤</span></span><br><span class="line">    ret = <span class="built_in">bind</span>(m_listenfd, (struct sockaddr *)&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>(address));</span><br><span class="line">    <span class="comment">// &gt;=0的设定 因为只有小于0才是错误情况</span></span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传统监听步骤</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">init</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll创建内核事件表</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">    m_epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将lfd上树</span></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_listenfd, <span class="literal">false</span>, m_LISTENTrigmode);</span><br><span class="line">    http_conn::m_epollfd = m_epollfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建管道套接字</span></span><br><span class="line">    ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_pipefd);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置管道写端为非阻塞，为什么写端要非阻塞？</span></span><br><span class="line">    <span class="comment">// send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，</span></span><br><span class="line">    <span class="comment">// 这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</span></span><br><span class="line">    utils.<span class="built_in">setnonblocking</span>(m_pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置管道读端为ET非阻塞 统一事件源</span></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_pipefd[<span class="number">0</span>], <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 传递给主循环的信号值，这里只关注SIGALRM和SIGTERM</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="literal">false</span>);</span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每隔TIMESLOT时间触发SIGALRM信号，这个信号交由sig_handler来处理，每当监测到有这个信号的时候，都会将这个信号写到pipefd[1]里面，传递给主循环</span></span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具类,信号和描述符基础操作</span></span><br><span class="line">    Utils::u_pipefd = m_pipefd;</span><br><span class="line">    Utils::u_epollfd = m_epollfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::timer</span><span class="params">(<span class="keyword">int</span> connfd, struct sockaddr_in client_address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    users[connfd].<span class="built_in">init</span>(connfd, client_address, m_root, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化client_data数据</span></span><br><span class="line">    <span class="comment">// 创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中</span></span><br><span class="line">    users_timer[connfd].address = client_address;</span><br><span class="line">    users_timer[connfd].sockfd = connfd;</span><br><span class="line">    util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">    timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">    timer-&gt;cb_func = cb_func;</span><br><span class="line">    <span class="keyword">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    users_timer[connfd].timer = timer;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line"><span class="comment">// 并对新的定时器在链表上的位置进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;adjust timer once&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::deal_timer</span><span class="params">(util_timer *timer, <span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">    <span class="keyword">if</span> (timer)</span><br><span class="line">    &#123;</span><br><span class="line">        utils.m_timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;close fd %d&quot;</span>, users_timer[sockfd].sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WebServer::dealclinetdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>(client_address);</span><br><span class="line">    <span class="comment">// LT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_LISTENTrigmode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">timer</span>(connfd, client_address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ET</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">timer</span>(connfd, client_address);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WebServer::dealwithsignal</span><span class="params">(<span class="keyword">bool</span> &amp;timeout, <span class="keyword">bool</span> &amp;stop_server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sig;</span><br><span class="line">    <span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从管道读端读出信号值，成功返回字节数，失败返回-1</span></span><br><span class="line">    <span class="comment">// 正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span></span><br><span class="line">    ret = <span class="built_in">recv</span>(m_pipefd[<span class="number">0</span>], signals, <span class="built_in"><span class="keyword">sizeof</span></span>(signals), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 处理信号值对应的逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (signals[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SIGALRM:</span><br><span class="line">            &#123;</span><br><span class="line">                timeout = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            &#123;</span><br><span class="line">                stop_server = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::dealwithread</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reactor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// proactor</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;deal with the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">            m_pool-&gt;<span class="built_in">append_p</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::dealwithwrite</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">    <span class="comment">//reactor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;send data to the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::eventLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server)</span><br><span class="line">    &#123;   <span class="comment">// 监测发生事件的文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;epoll failure&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 轮询有事件产生的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理新到的客户连接</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == m_listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="built_in">dealclinetdata</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">                <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理信号</span></span><br><span class="line">            <span class="comment">// 管道读端对应文件描述符发生读事件，因为统一了事件源，信号处理当成读事件来处理</span></span><br><span class="line">            <span class="comment">// 怎么统一？就是信号回调函数哪里不立即处理而是写到：pipe的写端</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == m_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="built_in">dealwithsignal</span>(timeout, stop_server);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;dealclientdata failure&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理客户连接上接收到的数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithread</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithwrite</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在读端pipefd[0]读到这个信号的的时候，就会将timeout变量置为true并跳出循环，让timer_handler()函数取出来定时器容器上的到期任务，该定时器容器是通过升序链表来实现的，从头到尾对检查任务是否超时，若超时则调用定时器的回调函数cb_func()，关闭该socket连接，并删除其对应的定时器del_timer。</span></span><br><span class="line">        <span class="keyword">if</span> (timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">timer_handler</span>();</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;timer tick&quot;</span>);</span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、简易服务器压力测试"><a href="#九、简易服务器压力测试" class="headerlink" title="九、简易服务器压力测试"></a>九、简易服务器压力测试</h3><h4 id="1、Webbench-是什么，介绍一下原理"><a href="#1、Webbench-是什么，介绍一下原理" class="headerlink" title="1、Webbench 是什么，介绍一下原理"></a>1、Webbench 是什么，介绍一下原理</h4><p>父进程<code>fork</code>若干个子进程，每个子进程在用户要求时间或默认的时间内对目标<code>web</code>循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p>
<h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><p>一个服务器项目，你在本地浏览器键入<code>localhost:9000</code>发现可以运行无异常还不够，你需要对他进行压测（即服务器并发量测试），压测过了，才说明你的服务器比较稳定了。项目中用到了一个压测软件叫做<code>Webbench</code>，下载、解压，打开终端运行命令（<code>-c</code>表示客户端数， <code>-t</code>表示时间）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./webbench -c 10001 -t 5 http://127.0.0.1:9006/</span><br></pre></td></tr></table></figure>

<p>直接解压的<code>webbench-1.5</code>文件夹下的<code>webbench</code>文件可能会因为权限问题找不到命令或者无法执行，这时你需要重新编译一下该文件即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc webbench.c -o webbench</span><br></pre></td></tr></table></figure>

<p>然后我们就可以压测得到结果了（我本人电脑的用户数量<code>-c</code>设置为<code>10500</code>会造成资源不足的错误）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Webbench - Simple Web Benchmark 1.5</span><br><span class="line">Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http://127.0.0.1:9006/</span><br><span class="line">10001 clients, running 5 sec.</span><br><span class="line"></span><br><span class="line">Speed=1044336 pages/min, 2349459 bytes/sec.</span><br><span class="line">Requests: 87028 susceed, 0 failed.</span><br></pre></td></tr></table></figure>

<h3 id="十、常见面试问题"><a href="#十、常见面试问题" class="headerlink" title="十、常见面试问题"></a>十、常见面试问题</h3><h4 id="1、线程池相关"><a href="#1、线程池相关" class="headerlink" title="1、线程池相关"></a>1、线程池相关</h4><h5 id="（1）线程的同步机制有哪些？"><a href="#（1）线程的同步机制有哪些？" class="headerlink" title="（1）线程的同步机制有哪些？"></a>（1）线程的同步机制有哪些？</h5><p>信号量、条件变量、互斥量、事件。</p>
<h5 id="（2）线程池中的工作线程是一直等待吗？"><a href="#（2）线程池中的工作线程是一直等待吗？" class="headerlink" title="（2）线程池中的工作线程是一直等待吗？"></a>（2）线程池中的工作线程是一直等待吗？</h5><p>是的，等待新任务的唤醒；</p>
<h5 id="（3）你的线程池工作线程处理完一个任务后的状态是什么？"><a href="#（3）你的线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="（3）你的线程池工作线程处理完一个任务后的状态是什么？"></a>（3）你的线程池工作线程处理完一个任务后的状态是什么？</h5><p>如果请求队列为空，则该线程进入线程池中等待；若不为空，则该线程跟其他线程一起进行任务的竞争；</p>
<h5 id="（4）如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#（4）如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="（4）如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>（4）如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h5><p>该项目是基于IO复用的并发模式。<strong>需要注意的是，不是一个客户连接就对应一个线程</strong>！如果真是如此，淘宝双12服务器早就崩了！当客户连接有事件需要处理的时，<code>epoll</code>会进行事件提醒，而后将对应的任务加入请求队列，等待工作线程竞争执行。<strong>如果速度还是慢，那就只能够增大线程池容量</strong>，或者考虑集群分布式的做法。</p>
<h5 id="（5）如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢"><a href="#（5）如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢" class="headerlink" title="（5）如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?"></a>（5）如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</h5><p>会，因为线程的数量是固定的，如果一个客户请求长时间占用着线程资源，势必会影响到服务器对外的整体响应速度。解决的策略可以是给每一个线程处理任务设定一个时间阈值，当某一个客户请求时间过长，则将其置于任务请求最后，或断开连接。</p>
<h5 id="（6）线程池中的线程数量是依据什么确定的？"><a href="#（6）线程池中的线程数量是依据什么确定的？" class="headerlink" title="（6）线程池中的线程数量是依据什么确定的？"></a>（6）线程池中的线程数量是依据什么确定的？</h5><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量<code>N</code>：</p>
<p>如果你的CPU是4-cores的，对于<code>CPU</code>密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；</p>
<p>对于IO密集型的任务，一般要多于<code>CPU</code>的核数，因为线程间竞争的不是<code>CPU</code>的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费，</p>
<p>公式：<code>最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间)</code></p>
<h4 id="2、并发模型相关"><a href="#2、并发模型相关" class="headerlink" title="2、并发模型相关"></a>2、并发模型相关</h4><h5 id="（1）简单说一下服务器使用的并发模型？"><a href="#（1）简单说一下服务器使用的并发模型？" class="headerlink" title="（1）简单说一下服务器使用的并发模型？"></a>（1）简单说一下服务器使用的并发模型？</h5><p>该项目选用的半同步半反应堆的并发模型。</p>
<p>以Proactor模式为例的工作流程即是：主线程充当异步线程，负责监听所有socket上的事件</p>
<p>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</p>
<p>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</p>
<p>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</p>
<h5 id="（2）reactor、proactor、主从reactor模型的区别？"><a href="#（2）reactor、proactor、主从reactor模型的区别？" class="headerlink" title="（2）reactor、proactor、主从reactor模型的区别？"></a>（2）reactor、proactor、主从reactor模型的区别？</h5><p><strong>Reactor模式</strong>：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程，将socket可读可写事件放入请求队列，<strong>读写数据、接受新连接及处理客户请求均在工作线程中完成。(需要区别读和写事件)</strong></p>
<p><strong>Proactor模式</strong>：主线程和内核负责处理读写数据、接受新连接等<strong>I/O操作</strong>，<strong>工作线程仅负责业务逻辑（给予相应的返回url）</strong>，如处理客户请求。</p>
<p><strong>主从Reactor模式</strong>：核心思想是，主反应堆线程只负责分发Acceptor连接建立，已连接套接字上的I/O事件交给sub-reactor负责分发。其中 sub-reactor的数量，可以根据CPU的核数来灵活设置。<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/-wenli/p/13343397.html">下图</a>即是其工作流程：</p>
<h5 id="（3）你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"><a href="#（3）你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？" class="headerlink" title="（3）你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"></a>（3）<strong>你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</strong></h5><p>常用的有三种：<code>select/poll/epoll</code></p>
<ul>
<li>对于<code>select</code>和<code>poll</code>来说，所有文件描述符都是在用户态被加入其文件描述符集合的，<strong>每次调用都需要将整个集合拷贝到内核态</strong>；<code>epoll</code>则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要<strong>执行一个系统调用</strong>。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，<code>epoll</code>可能会慢于<code>select</code>和<code>poll</code>由于这些大量的系统调用开销。</li>
<li><code>select</code>使用线性表描述文件描述符集合，<strong>文件描述符有上限</strong>；<code>poll</code>使用<strong>链表来描述</strong>；<code>epoll</code>底层通过红黑树来描述，并且维护一个<code>ready list</code>，将事件表中已经就绪的事件添加到这里，在使用<code>epoll_wait</code>调用时，仅观察这个<code>list</code>中有没有数据即可。</li>
<li><code>select</code>和<code>poll</code>的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行<code>select</code>或<code>poll</code>调用时，<strong>它们会采用遍历的方式</strong>，遍历整个文件描述符集合去判断各个文件描述符是否有活动；<code>epoll</code>则不需要去以这种方式检查，当有活动产生时，<strong>会自动触发<code>epoll</code>回调函数通知<code>epoll</code>文件描述符</strong>，然后内核将这些就绪的文件描述符放到之前提到的<code>ready list</code>中等待<code>epoll_wait</code>调用后被处理。</li>
<li><code>select</code>和<code>poll</code>都只能工作在<strong>相对低效的<code>LT</code>模式下</strong>，而<code>epoll</code>同时支持<code>LT</code>和<code>ET</code>模式。</li>
<li>综上，<strong>当监测的<code>fd</code>数量较小</strong>，且各个<code>fd</code>都很活跃的情况下，建议使用<code>select</code>和<code>poll</code>；<strong>当监听的<code>fd</code>数量较多</strong>，且单位时间仅部分<code>fd</code>活跃的情况下，使用<code>epoll</code>会明显提升性能。</li>
</ul>
<h4 id="3、HTTP报文解析相关"><a href="#3、HTTP报文解析相关" class="headerlink" title="3、HTTP报文解析相关"></a>3、HTTP报文解析相关</h4><h5 id="（1）为什么要用状态机？"><a href="#（1）为什么要用状态机？" class="headerlink" title="（1）为什么要用状态机？"></a>（1）为什么要用状态机？</h5><p>有限状态机，是一种抽象的理论模型，它能够把有限个变量描述的状态变化过程，以可构造可验证的方式呈现出来。比如，封闭的有向图。有限状态机可以通过<code>if-else</code>,<code>switch-case</code>和函数指针来实现，从软件工程的角度看，主要是为了封装逻辑。有限状态机一种逻辑单元内部的一种高效编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。</p>
<h5 id="（2）https-的-ssl-连接过程？"><a href="#（2）https-的-ssl-连接过程？" class="headerlink" title="（2）https 的 ssl 连接过程？"></a>（2）https 的 ssl 连接过程？</h5><p><img src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/20210603211332.png"></p>
<h4 id="4、数据库登录注册相关"><a href="#4、数据库登录注册相关" class="headerlink" title="4、数据库登录注册相关"></a>4、数据库登录注册相关</h4><h5 id="（1）登录说一下？"><a href="#（1）登录说一下？" class="headerlink" title="（1）登录说一下？"></a>（1）登录说一下？</h5><p>具体的涉及到<strong>载入数据库表，提取用户名和密码，注册登录流程与页面跳转</strong>。</p>
<ul>
<li>载入数据库表，结合代码将数据库中的数据载入到服务器中；</li>
<li>提取用户名和密码，结合代码对报文进行解析，提取用户名和密码；</li>
<li>注册登录流程，结合代码对描述服务器进行注册和登录校验的流程；</li>
<li>页面跳转，结合代码对页面跳转机制进行详解</li>
</ul>
<h5 id="（2）你这个保存状态了吗？如果要保存，你会怎么做？"><a href="#（2）你这个保存状态了吗？如果要保存，你会怎么做？" class="headerlink" title="（2）你这个保存状态了吗？如果要保存，你会怎么做？"></a>（2）你这个保存状态了吗？如果要保存，你会怎么做？</h5><p>可以利用<code>session</code>或者<code>cookie</code>的方式进行状态的保存。</p>
<p><code>cookie</code>其实就是服务器给客户分配了一串“身份标识”，比如“123456789happy”这么一串字符串。每次客户发送数据时，都在<code>HTTP</code>报文附带上这个字符串，服务器就知道你是谁了；</p>
<p><code>session</code>是保存在服务器端的状态，每当一个客户发送<code>HTTP</code>报文过来的时候，服务器会在自己记录的用户数据中去找，类似于核对名单；</p>
<h5 id="（3）登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？"><a href="#（3）登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？" class="headerlink" title="（3）登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？"></a>（3）登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</h5><p>这个问题的关键在于大数据量情况下的用户登录验证怎么进行？</p>
<p>将所有的用户信息加载到内存中耗时耗利，对于大数据最遍历的方法就是<strong>进行hash，利用hash建立多级索引的方式来加快用户验证</strong>。具体操作如下：</p>
<p>首先，将10亿的用户信息，利用大致缩小1000倍的hash算法进行hash，这时就获得了100万的hash数据，每一个hash数据代表着一个<strong>用户信息块（一级）</strong>；</p>
<p>而后，再分别对这100万的hash数据再进行hash，例如最终剩下1000个<strong>hash数据（二级）</strong>。</p>
<p>在这种方式下，服务器只需要保存1000个二级hash数据，当用户请求登录的时候，先对用户信息进行一次hash，找到对应信息块（二级），在读取其对应的一级信息块，最终找到对应的用户数据，</p>
<h4 id="5、定时器相关"><a href="#5、定时器相关" class="headerlink" title="5、定时器相关"></a>5、定时器相关</h4><h5 id="（1）为什么要用定时器？"><a href="#（1）为什么要用定时器？" class="headerlink" title="（1）为什么要用定时器？"></a>（1）为什么要用定时器？</h5><p>处理定时任务，或者非活跃连接，节省系统资源；</p>
<h5 id="（2）说一下定时器的工作原理？"><a href="#（2）说一下定时器的工作原理？" class="headerlink" title="（2）说一下定时器的工作原理？"></a>（2）说一下定时器的工作原理？</h5><p>服务器就为各事件分配一个定时器。该项目使用<code>SIGALRM</code>信号来实现定时器，首先每一个定时事件都处于一个升序链表上，<strong>通过<code>alarm()</code>函数周期性触发<code>SIGALRM</code>信号</strong>，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接。</p>
<h5 id="（3）双向链表，删除和添加的时间复杂度说一下？还可以优化吗？"><a href="#（3）双向链表，删除和添加的时间复杂度说一下？还可以优化吗？" class="headerlink" title="（3）双向链表，删除和添加的时间复杂度说一下？还可以优化吗？"></a>（3）双向链表，删除和添加的时间复杂度说一下？还可以优化吗？</h5><p>添加一般情况下都是O(N)，删除只需要O(1)。从双向链表的方式优化不太现实，可以考虑使用最小堆、或者跳表的数据结构。</p>
<ul>
<li><p>最小堆以每个定时器的过期时间进行排序，最小的定时器位于堆顶，当<code>SIGALRM</code>信号触发<code>tick()</code>函数时执行过期定时器清除，如果堆顶的定时器时间过期，则删除，并重新建堆，再判定是否过期，如此循环直到未过期为止。插入，<code>O(logn)</code>；删除，<code>O(logN)</code>；</p>
</li>
<li><p>每次以固定的时间间隔触发<code>SIGALRM</code>信号，调用<code>tick</code>函数处理超时连接会造成一定的触发浪费，举个例子，若当前的<code>TIMESLOT=5</code>，即每隔5ms触发一次<code>SIGALRM</code>，跳出循环执行<code>tick</code>函数，这时如果当前即将超时的任务距离现在还有<code>20ms</code>，那么在这个期间，<code>SIGALRM</code>信号被触发了4次，<code>tick</code>函数也被执行了4次，可是在这4次中，前三次触发都是无意义的。对此，我们可以动态的设置<code>TIMESLOT</code>的值，每次将其值设置为<strong>当前最先超时的定时器与当前时间的时间差</strong>，这样每次调用<code>tick</code>函数，超时时间最小的定时器必然到期，并被处理，然后在从时间堆中取一个最先超时的定时器的时间与当前时间做时间差，更新<code>TIMESLOT</code>的值。</p>
</li>
</ul>
<h4 id="5、日志相关"><a href="#5、日志相关" class="headerlink" title="5、日志相关"></a>5、日志相关</h4><h5 id="（1）说下你的日志系统的运行机制？"><a href="#（1）说下你的日志系统的运行机制？" class="headerlink" title="（1）说下你的日志系统的运行机制？"></a>（1）说下你的日志系统的运行机制？</h5><p>初始化服务器时，利用单例模式初始化日志系统，根据配置文件确认是同步还是异步写入的方式。</p>
<h5 id="（2）为什么要异步？和同步的区别是什么？"><a href="#（2）为什么要异步？和同步的区别是什么？" class="headerlink" title="（2）为什么要异步？和同步的区别是什么？"></a>（2）为什么要异步？和同步的区别是什么？</h5><p>同步方式写入日志时会产生比较多的系统调用，若是某条日志信息过大，会阻塞日志系统，造成系统瓶颈。</p>
<p>异步方式采用生产者-消费者模型，具有较高的并发能力。</p>
<h5 id="（3）现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？"><a href="#（3）现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？" class="headerlink" title="（3）现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？"></a>（3）现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？</h5><p>为了便于故障排查，或服务器状态分析，看是否需要维护；可以使用消息队列进行消息的分发，例如mqtt、rabitmq等等；</p>
<h4 id="6、压测相关"><a href="#6、压测相关" class="headerlink" title="6、压测相关"></a>6、压测相关</h4><h5 id="（1）服务器并发量测试过吗？怎么测试的？"><a href="#（1）服务器并发量测试过吗？怎么测试的？" class="headerlink" title="（1）服务器并发量测试过吗？怎么测试的？"></a>（1）服务器并发量测试过吗？怎么测试的？</h5><p>测试过，利用<code>webbench</code>，至少满足万余的并发量。</p>
<h5 id="（2）webbench是什么？介绍一下原理"><a href="#（2）webbench是什么？介绍一下原理" class="headerlink" title="（2）webbench是什么？介绍一下原理"></a>（2）webbench是什么？介绍一下原理</h5><p>是一款轻量级的网址压力测试工具，可以实现高达3万的并发测试。</p>
<p>其原理：<code>Webbench</code>实现的核心原理是：父进程<code>fork</code>若干个子进程，每个子进程在用户要求时间或默认的时间内对目标<code>web</code>循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/06/03/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/">https://varrella.github.io/2021/06/03/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturedn-3840x2400-bg-d459300.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/10/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturewallroom-2560x1600-bg-232c519.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">《高性能MySQL》读书笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/02/%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___6asyCyR0K1Q___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">《STL源码剖析》笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E3%80%81%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%93Linux%E4%B8%8BC-%E8%BD%BB%E9%87%8F%E7%BA%A7Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">0、项目介绍—–Linux下C++轻量级Web服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">一、线程同步机制包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">1、信号量的相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BA%92%E6%96%A5%E9%87%8F%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">2、互斥量相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">3、条件变量相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81locker-h"><span class="toc-number">2.4.</span> <span class="toc-text">4、locker.h</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81http-%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">二、http 连接请求处理类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.1.</span> <span class="toc-text">1、状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.2.</span> <span class="toc-text">2、web 服务器中的有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89http-%E6%8A%A5%E6%96%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">（1）http 报文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%BB%8E%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9A%E8%B4%9F%E8%B4%A3%E8%AF%BB%E5%8F%96%E6%8A%A5%E6%96%87%E7%9A%84%E4%B8%80%E8%A1%8C"><span class="toc-number">3.2.2.</span> <span class="toc-text">（1）从状态机：负责读取报文的一行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BB%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-http-conn-cpp"><span class="toc-number">3.2.3.</span> <span class="toc-text">（2）从状态机的代码实现 http_conn.cpp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%BB%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9A%E8%B4%9F%E8%B4%A3%E5%AF%B9%E8%AF%A5%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90"><span class="toc-number">3.2.4.</span> <span class="toc-text">（3）主状态机：负责对该数据进行解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89do-request-%E5%85%B7%E4%BD%93%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.5.</span> <span class="toc-text">（4）do_request() 具体处理函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89process-write-%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.6.</span> <span class="toc-text">（5）process_write()函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E2%80%93%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">三、半同步&#x2F;半反应堆–线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%91%A2"><span class="toc-number">4.1.</span> <span class="toc-text">1、Web服务器如何接收客户端发来的HTTP请求报文呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%91%A2"><span class="toc-number">4.2.</span> <span class="toc-text">2、Web服务器如何处理以及响应接收到的HTTP请求报文呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%A4%E7%A7%8D%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Reactor-Proactor%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">2、两种事件处理模式（Reactor&#x2F;Proactor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5-I-O"><span class="toc-number">4.4.</span> <span class="toc-text">3、同步和异步 I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%B8%89%E7%A7%8D-I-O-%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88select-poll-epoll%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">4、三种 I&#x2F;O 复用方式（select&#x2F;poll&#x2F;epoll）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81threadpool-h"><span class="toc-number">4.6.</span> <span class="toc-text">5、threadpool.h</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">四、定时器处理非活动连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">1、基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Linux%E4%B8%8B%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%89%E7%A7%8D%E5%AE%9A%E6%97%B6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2、Linux下提供了三种定时的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">3、定时器触发方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text">4、定时器的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.</span> <span class="toc-text">5、具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89lst-timer-h"><span class="toc-number">5.5.1.</span> <span class="toc-text">（1）lst_timer.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89lst-timer-cpp"><span class="toc-number">5.5.2.</span> <span class="toc-text">（2）lst_timer.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">五、同步&#x2F;异步日志系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">6.1.</span> <span class="toc-text">1、基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AA%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8F%90%E4%BE%9B%E5%85%A8%E5%B1%80%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">2、单例模式：保证一个类只创建一个实例，同时提供全局访问的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">6.2.1.</span> <span class="toc-text">（1）实现思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%87%92%E6%B1%89%E5%92%8C%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">（2）懒汉和饿汉模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">3、懒汉模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BB%8F%E5%85%B8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.1.</span> <span class="toc-text">（1）经典的线程安全懒汉模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E3%80%90%E9%97%AE%E9%A2%98%E3%80%91%E7%BB%8F%E5%85%B8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%8F%8C%E6%A3%80%E6%B5%8B%EF%BC%8C%E5%8F%AA%E6%A3%80%E6%B5%8B%E4%B8%80%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">6.3.2.</span> <span class="toc-text">【问题】经典的线程安全懒汉模式中，为什么要用双检测，只检测一次不行吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.3.</span> <span class="toc-text">（2）局部静态变量之线程安全懒汉模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">4、饿汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97"><span class="toc-number">6.5.</span> <span class="toc-text">5、异步日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.6.</span> <span class="toc-text">6、具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89block-queue-h"><span class="toc-number">6.6.1.</span> <span class="toc-text">（1）block_queue.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89log-h-%E5%92%8C-log-cpp"><span class="toc-number">6.6.2.</span> <span class="toc-text">（2）log.h 和 log.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E3%80%81%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%86%8C%E3%80%81%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text">六、数据库连接池、同步线程注册、登录校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">1、数据库访问的一般流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">7.2.</span> <span class="toc-text">2、数据库连接池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81linux-%E4%B8%8B-mysql-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">3、linux 下 mysql 常用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81sql-connection-pool-h-sql-connection-pool-cpp"><span class="toc-number">7.4.</span> <span class="toc-text">4、sql_connection_pool.h &#x2F; sql_connection_pool.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C"><span class="toc-number">7.5.</span> <span class="toc-text">5、登录校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81config-%E7%8B%AC%E7%AB%8B%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9D%97"><span class="toc-number">8.</span> <span class="toc-text">七、config 独立参数模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81main-%E5%87%BD%E6%95%B0%E5%92%8C-webserver-%E7%B1%BB%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">八、main 函数和 webserver 类接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81main%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">1、main函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81webserver-%E7%B1%BB%E6%A8%A1%E5%9D%97"><span class="toc-number">9.2.</span> <span class="toc-text">2、webserver 类模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89webserver-h"><span class="toc-number">9.2.1.</span> <span class="toc-text">（1）webserver.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89webserver-cpp"><span class="toc-number">9.2.2.</span> <span class="toc-text">（2）webserver.cpp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">10.</span> <span class="toc-text">九、简易服务器压力测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Webbench-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">1、Webbench 是什么，介绍一下原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">2、使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">十、常见面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="toc-number">11.1.</span> <span class="toc-text">1、线程池相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.1.1.</span> <span class="toc-text">（1）线程的同步机制有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F"><span class="toc-number">11.1.2.</span> <span class="toc-text">（2）线程池中的工作线程是一直等待吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BD%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.1.3.</span> <span class="toc-text">（3）你的线程池工作线程处理完一个任务后的状态是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2%EF%BC%9F"><span class="toc-number">11.1.4.</span> <span class="toc-text">（4）如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%BE%88%E4%B9%85%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E5%91%A2%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%AD%96%E7%95%A5%E5%91%A2"><span class="toc-number">11.1.5.</span> <span class="toc-text">（5）如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E6%98%AF%E4%BE%9D%E6%8D%AE%E4%BB%80%E4%B9%88%E7%A1%AE%E5%AE%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">11.1.6.</span> <span class="toc-text">（6）线程池中的线程数量是依据什么确定的？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">11.2.</span> <span class="toc-text">2、并发模型相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">11.2.1.</span> <span class="toc-text">（1）简单说一下服务器使用的并发模型？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89reactor%E3%80%81proactor%E3%80%81%E4%B8%BB%E4%BB%8Ereactor%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.2.2.</span> <span class="toc-text">（2）reactor、proactor、主从reactor模型的区别？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%BD%A0%E7%94%A8%E4%BA%86epoll%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8epoll%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.2.3.</span> <span class="toc-text">（3）你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81HTTP%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90%E7%9B%B8%E5%85%B3"><span class="toc-number">11.3.</span> <span class="toc-text">3、HTTP报文解析相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9F"><span class="toc-number">11.3.1.</span> <span class="toc-text">（1）为什么要用状态机？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89https-%E7%9A%84-ssl-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">11.3.2.</span> <span class="toc-text">（2）https 的 ssl 连接过程？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3"><span class="toc-number">11.4.</span> <span class="toc-text">4、数据库登录注册相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%99%BB%E5%BD%95%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">11.4.1.</span> <span class="toc-text">（1）登录说一下？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%BD%A0%E8%BF%99%E4%B8%AA%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E4%BA%86%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BF%9D%E5%AD%98%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">11.4.2.</span> <span class="toc-text">（2）你这个保存状态了吗？如果要保存，你会怎么做？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%99%BB%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E4%BD%A0%E6%98%AFload%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8map%E5%8C%B9%E9%85%8D%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8910%E4%BA%BF%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8D%B3%E4%BD%BFload%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%90%8Ehash%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%BE%88%E8%80%97%E6%97%B6%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">11.4.3.</span> <span class="toc-text">（3）登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">11.5.</span> <span class="toc-text">5、定时器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">11.5.1.</span> <span class="toc-text">（1）为什么要用定时器？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">11.5.2.</span> <span class="toc-text">（2）说一下定时器的工作原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A0%E9%99%A4%E5%92%8C%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-number">11.5.3.</span> <span class="toc-text">（3）双向链表，删除和添加的时间复杂度说一下？还可以优化吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3"><span class="toc-number">11.6.</span> <span class="toc-text">5、日志相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">11.6.1.</span> <span class="toc-text">（1）说下你的日志系统的运行机制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%82%E6%AD%A5%EF%BC%9F%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.6.2.</span> <span class="toc-text">（2）为什么要异步？和同步的区别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%8E%B0%E5%9C%A8%E4%BD%A0%E8%A6%81%E7%9B%91%E6%8E%A7%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%A5%E6%97%A5%E5%BF%97%E5%88%86%E5%8F%91%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%EF%BC%9F"><span class="toc-number">11.6.3.</span> <span class="toc-text">（3）现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%8E%8B%E6%B5%8B%E7%9B%B8%E5%85%B3"><span class="toc-number">11.7.</span> <span class="toc-text">6、压测相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%8F%91%E9%87%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E7%9A%84%EF%BC%9F"><span class="toc-number">11.7.1.</span> <span class="toc-text">（1）服务器并发量测试过吗？怎么测试的？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89webbench%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86"><span class="toc-number">11.7.2.</span> <span class="toc-text">（2）webbench是什么？介绍一下原理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturedn-3840x2400-bg-d459300.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>