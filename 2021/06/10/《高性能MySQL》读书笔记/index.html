<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《高性能MySQL》读书笔记 | Varrella</title><meta name="author" content="Varrella"><meta name="copyright" content="Varrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Ch1、MySQL历史与架构一、MySQL逻辑架构最上层的服务并不是MySQL所独有的，大多数基于网络的客户端&#x2F; 服务器的工具或者服务都有类似的架构。 大多数MySQL的核心服务功能都在这第二层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能 都在这一层实现：存储过程、触发器、视图等。  第三层包含了存储引擎。存储引擎负责MySQL中数据">
<meta property="og:type" content="article">
<meta property="og:title" content="《高性能MySQL》读书笔记">
<meta property="og:url" content="https://varrella.github.io/2021/06/10/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Varrella">
<meta property="og:description" content="Ch1、MySQL历史与架构一、MySQL逻辑架构最上层的服务并不是MySQL所独有的，大多数基于网络的客户端&#x2F; 服务器的工具或者服务都有类似的架构。 大多数MySQL的核心服务功能都在这第二层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能 都在这一层实现：存储过程、触发器、视图等。  第三层包含了存储引擎。存储引擎负责MySQL中数据">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg">
<meta property="article:published_time" content="2021-06-10T14:14:25.739Z">
<meta property="article:modified_time" content="2021-06-11T14:27:11.762Z">
<meta property="article:author" content="Varrella">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://varrella.github.io/2021/06/10/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-11 22:27:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture微信图片_20210411174101.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Varrella</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《高性能MySQL》读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-06-10T14:14:25.739Z" title="Created 2021-06-10 22:14:25">2021-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-06-11T14:27:11.762Z" title="Updated 2021-06-11 22:27:11">2021-06-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《高性能MySQL》读书笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Ch1、MySQL历史与架构"><a href="#Ch1、MySQL历史与架构" class="headerlink" title="Ch1、MySQL历史与架构"></a>Ch1、MySQL历史与架构</h3><h5 id="一、MySQL逻辑架构"><a href="#一、MySQL逻辑架构" class="headerlink" title="一、MySQL逻辑架构"></a>一、MySQL逻辑架构</h5><p>最上层的服务并不是<code>MySQL</code>所独有的，大多数基于网络的客户端/ 服务器的工具或者服务都有类似的架构。</p>
<p>大多数<code>MySQL</code>的核心服务功能都在这第二层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能 都在这一层实现：存储过程、触发器、视图等。 </p>
<p>第三层包含了存储引擎。存储引擎负责<code>MySQL</code>中数据的存储和提 取。</p>
<p><img src="C:\Users\11951\AppData\Roaming\Typora\typora-user-images\image-20210610210204428.png" alt="image-20210610210204428"></p>
<h5 id="二、并发控制"><a href="#二、并发控制" class="headerlink" title="二、并发控制"></a>二、并发控制</h5><p><code>MySQL</code>在两个层面的并发控制：服务器层与存储引擎层。</p>
<h5 id="1、读写锁"><a href="#1、读写锁" class="headerlink" title="1、读写锁"></a>1、读写锁</h5><p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排他锁，也叫读锁和写锁。 </p>
<p>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，互不干扰。</p>
<p>写锁则是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样，才能确保在给定的 时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同 一资源。</p>
<h5 id="2、锁粒度"><a href="#2、锁粒度" class="headerlink" title="2、锁粒度"></a>2、锁粒度</h5><p>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p>
<h6 id="（1）表锁"><a href="#（1）表锁" class="headerlink" title="（1）表锁"></a>（1）表锁</h6><p>表锁是<code>MySQL</code>中最基本的锁策略，并且是开销最小的策略。在特定的场景中，表锁也可能有良好的性能。例如，<code>READ LOCAL</code>表锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面）</p>
<h6 id="（2）行级锁"><a href="#（2）行级锁" class="headerlink" title="（2）行级锁"></a>（2）行级锁</h6><p>行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。在<code>InnoDB</code>和<code>XtraDB</code>，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而<code>MySQL</code>服务器层没有实现。</p>
<h5 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h5><h5 id="1、事务的概念和特点"><a href="#1、事务的概念和特点" class="headerlink" title="1、事务的概念和特点"></a>1、事务的概念和特点</h5><p>事务就是一组原子性的<code>SQL</code>查询，或者说一个独立的工作单元。事务内的语句，要么全部执行 成功，要么全部执行失败。可以用<code>START TRANSACTION</code>语句开始一个事务，然后要么使用<code>COMMIT</code> 提交事务将修改的数据持久保留，要么使用<code>ROLLBACK</code> 撤销所 有的修改。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> checking <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> <span class="number">10233276</span>;</span><br><span class="line">UPDATE checking <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200.00</span> <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> <span class="number">10233276</span>;</span><br><span class="line">UPDATE savings <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">200.00</span> <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> <span class="number">10233276</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2、ACID特性"><a href="#2、ACID特性" class="headerlink" title="2、ACID特性"></a>2、ACID特性</h5><h6 id="（1）原子性（atomicity）"><a href="#（1）原子性（atomicity）" class="headerlink" title="（1）原子性（atomicity）"></a>（1）原子性（atomicity）</h6><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<h6 id="（2）一致性（consistency）"><a href="#（2）一致性（consistency）" class="headerlink" title="（2）一致性（consistency）"></a>（2）一致性（consistency）</h6><p>数据库总是从一个一致性的状态转换到另外一个一致性的状态。</p>
<h6 id="（3）隔离性（isolation）"><a href="#（3）隔离性（isolation）" class="headerlink" title="（3）隔离性（isolation）"></a>（3）隔离性（isolation）</h6><p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p>
<h6 id="（4）持久性（durability）"><a href="#（4）持久性（durability）" class="headerlink" title="（4）持久性（durability）"></a>（4）持久性（durability）</h6><p>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>
<p>一个实现了<code>ACID</code> 的数据库，相比没有实现<code>ACID</code>的数据库，通常会需要更强的<code>CPU</code>处理能力、更大的内存和更多的磁盘空间。对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。</p>
<h5 id="3、事务的隔离级别"><a href="#3、事务的隔离级别" class="headerlink" title="3、事务的隔离级别"></a>3、事务的隔离级别</h5><p>较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<h6 id="（1）READ-UNCOMMITTED（未提交读）"><a href="#（1）READ-UNCOMMITTED（未提交读）" class="headerlink" title="（1）READ UNCOMMITTED（未提交读）"></a>（1）READ UNCOMMITTED（未提交读）</h6><p>事务中的修改，即使没有提交， 对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。</p>
<h6 id="（2）READ-COMMITTED（提交读）"><a href="#（2）READ-COMMITTED（提交读）" class="headerlink" title="（2）READ COMMITTED（提交读）"></a>（2）READ COMMITTED（提交读）</h6><p>大多数数据库系统的默认隔离级别都是<code>READ COMMITTED</code> （但 <code>MySQL</code>不是）。一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。</p>
<h6 id="（3）REPEATABLE-READ（可重复读）"><a href="#（3）REPEATABLE-READ（可重复读）" class="headerlink" title="（3）REPEATABLE READ（可重复读）"></a>（3）REPEATABLE READ（可重复读）</h6><p>解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。<code>InnoDB</code>和<code>XtraDB</code>存储引 擎通过多版本并发控制（<code>MVCC，Multiversion Concurrency Control</code>）解决了幻读的问题。</p>
<h6 id="（4）SERIALIZABLE（可串行化）"><a href="#（4）SERIALIZABLE（可串行化）" class="headerlink" title="（4）SERIALIZABLE（可串行化）"></a>（4）SERIALIZABLE（可串行化）</h6><p>是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，<code>SERIALIZABLE</code>会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。</p>
<h5 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h5><p>当多个事务试图以不同的顺序锁定资源时，或多个事务同时锁定同一个资源时，会产生死锁。</p>
<h5 id="5、事务日志"><a href="#5、事务日志" class="headerlink" title="5、事务日志"></a>5、事务日志</h5><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬 盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序<code>I/O</code>，而不像随机<code>I/O</code>需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志，修改数据需要写两次磁盘。</p>
<h5 id="6、MySQL中的事务"><a href="#6、MySQL中的事务" class="headerlink" title="6、MySQL中的事务"></a>6、MySQL中的事务</h5><p><code>MySQL</code>提供了两种事务型的存储引擎：<code>InnoDB</code>和<code>NDB Cluster</code>。</p>
<ul>
<li><p>自动提交</p>
<p><code>MySQL</code>默认采用自动提交（<code>AUTOCOMMIT </code>）模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置<code>AUTOCOMMIT</code> 变量来启用或者禁用自动提交模式。</p>
<p><code>MySQL</code>可以通过执行<code>SET TRANSACTION ISOLATION LEVEL </code>命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure></li>
<li><p>隐式和显式锁定</p>
<p><code>InnoDB</code>采用的是两阶段锁定协议。在 事务执行过程中，随时都可以执行锁定，锁只有在执行<code>COMMIT</code>或者<code>ROLLBACK</code>的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，<code>InnoDB</code>会根据隔离级别在需要的时候自动加锁。另外，<code>InnoDB</code>也支持通过特定的语句进行显式锁定，这些语句不属于<code>SQL</code>规范：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> UPDATE</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="7、多版本并发控制"><a href="#7、多版本并发控制" class="headerlink" title="7、多版本并发控制"></a>7、多版本并发控制</h5><p>可以认为<code>MVCC</code>是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
<p>典型的有乐观并发控制和悲观并发控制。</p>
<p><code>MVCC</code>只在<code>REPEATABLE READ </code>和<code>READ COMMITTED </code>两个隔离级别下工作。其他两个隔离级别都和<code>MVCC</code>不兼容，因为<code>READ UNCOMMITTED</code> 总是读取最新的数据行，而不是符合当前事务版本的数据行。而<code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</p>
<h5 id="8、InnoDB存储引擎"><a href="#8、InnoDB存储引擎" class="headerlink" title="8、InnoDB存储引擎"></a>8、InnoDB存储引擎</h5><p><code>InnoDB</code>是<code>MySQL</code>的默认事务型引擎，也是最重要、使用最广泛的 存储引擎。它被设计用来处理大量的短期事务，短期事 务大部分情况是正常提交的，很少会被回滚。<code>InnoDB</code>的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。</p>
<p><code>InnoDB</code>采用<code>MVCC</code>来支持高并发，并且实现了四个标准的隔离级别。其默认级别是<code>REPEATABLE READ</code>（可重复读），并且通过间隙锁策略防止幻读的出现。间隙锁使得<code>InnoDB</code>不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>
<p><code>InnoDB</code>表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。不过它的二级索引（非主键索引）中必须包含主键列，所以如果主键列很大的话， 其他的所有索引都会很大。因此，若表上的索引较多的话，主键应当尽可能的小。</p>
<h5 id="9、-MyISAM存储引擎"><a href="#9、-MyISAM存储引擎" class="headerlink" title="9、 MyISAM存储引擎"></a>9、 MyISAM存储引擎</h5><p>在<code>MySQL 5.1</code>及之前的版本，<code>MyISAM</code>是默认的存储引擎。 <code>MyISAM</code>提供了大量的特性，包括全文索引、压缩、空间函数等，但<code>MyISAM</code>不支持事务和行级锁，而且有一个毫无疑问的缺陷就是 崩溃后无法安全恢复。</p>
<p><code>MyISAM</code>会将表存储在两个文件中：数据文件和索引文件，分别 以<code>.MYD</code> 和<code>.MYI</code>为扩展名。<code>MyISAM</code>表可以包含动态或者静态（长度固定）行。<code>MySQL</code>会根据表的定义来决定采用何种行格式。<code>MyISAM</code>表可 以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸。</p>
<ul>
<li><p>加锁与并发</p>
<p><code>MyISAM</code>对整张表加锁，而不是针对行。读取时会对需要读到 的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询 的同时，也可以往表中插入新的记录（这被称为并发插入， <code>CONCURRENT INSERT</code>）。</p>
</li>
<li><p>修复</p>
<p>对于<code>MyISAM</code>表，<code>MySQL</code>可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行 表的修复可能导致一些数据丢失，而且修复操作是非常慢的。</p>
</li>
<li><p>索引特性 </p>
<p>对于<code>MyISAM</code>表，即使是<code>BLOB</code>和<code>TEXT</code>等长字段，也可以基于其前500个字符创建索引。<code>MyISAM</code>也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p>
</li>
<li><p>延迟更新索引键</p>
<p>创建<code>MyISAM</code>表的时候，如果指定了<code>DELAY_KEY_WRITE</code>选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而 是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
</li>
</ul>
<h3 id="ch2、数据类型优化"><a href="#ch2、数据类型优化" class="headerlink" title="ch2、数据类型优化"></a>ch2、数据类型优化</h3><h5 id="1、整数类型"><a href="#1、整数类型" class="headerlink" title="1、整数类型"></a>1、整数类型</h5><p>有两种类型的数字：整数和实数。如果存储整数，可以使用这几种整数类型：<code>TINYINT</code>， <code>SMALLINT</code>，<code>MEDIUMINT</code>，<code>INT</code>，<code>BIGINT</code> 。分别使用<code>8，16，24，32，64</code>位存储空间。它们可以存储的值的范围从<code>−2^(N−1)</code>到<code>2(N−1) −1</code>，其中<code>N</code>是存储空间的位数。</p>
<p>整数类型有可选的<code>UNSIGNED</code>属性，表示不允许负值，这大致可以 使正数的上限提高一倍。例如<code>TINYINT UNSIGNED</code> 可以存储的范围是<code>0～ 255</code>，而<code>TINYINT</code>的存储范围是<code>−128～127</code>。</p>
<h5 id="2、实数类型"><a href="#2、实数类型" class="headerlink" title="2、实数类型"></a>2、实数类型</h5><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也可以使用<code>DECIMAL</code>存储比<code>BIGINT</code>还大的整数。<code>MySQL</code>既支持精确类型，也支持不精确类型。 <code>FLOAT</code> 和<code>DOUBLE</code> 类型支持使用标准的浮点运算进行近似计算。</p>
<p><code>DECIMAL</code>类型用于存储精确的小数。在<code>MySQL 5.0</code>和更高版 本，<code>DECIMAL</code>类型支持精确计算。浮点和<code>DECIMAL</code> 类型都可以指定精度。对于<code>DECIMAL</code>列，可以指定 小数点前后所允许的最大位数。这会影响列的空间消耗。</p>
<p>浮点类型在存储同样范围的值时，通常比<code>DECIMAL</code>使用更少的空 间。<code>FLOAT</code>使用<code>4</code>个字节存储。<code>DOUBLE</code>占用<code>8</code>个字节，相比<code>FLOAT</code>有更 高的精度和更大的范围。和整数类型一样，能选择的只是存储类型； <code>MySQL</code>使用<code>DOUBLE</code>作为内部浮点计算的类型。</p>
<h5 id="3、字符串类型"><a href="#3、字符串类型" class="headerlink" title="3、字符串类型"></a>3、字符串类型</h5><p><code>VARCHAR</code>和<code>CHAR</code>是两种最主要的字符串类型。</p>
<p><code>VARCHAR</code>类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间（例如，越短的字符串使用越少的空间）。下面这些情况下使用<code>VARCHAR</code>是合适的：字符串列的最大长度 比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像 <code>UTF-8</code>这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p>
<p><code>CHAR</code>类型是定长的：<code>MySQL</code>总是根据定义的字符串长度分配 足够的空间。<code>CHAR</code>适合存储很短的字符串，或者所有值都接近同一个长度。例 如，CHAR 非常适合存储密码的<code>MD5</code>值，因为这是一个定长的值。对于经 常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>更好，因为定长的<code>CHAR</code>类型不容易 产生碎片。对于非常短的列，<code>CHAR</code>比<code>VARCHAR</code>在存储空间上也更有效 率。例如用<code>CHAR(1)</code> 来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是<code>VARCHAR(1)</code> 却需要两个字节，因为还有一 个记录长度的额外字节。</p>
<h5 id="3、BLOB和TEXT类型"><a href="#3、BLOB和TEXT类型" class="headerlink" title="3、BLOB和TEXT类型"></a>3、BLOB和TEXT类型</h5><p><code>BLOB</code>和<code>TEXT</code>都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>实际上，它们分别属于两组不同的数据类型家族：字符类型是 <code>TINYTEXT，SMALLTEXT，TEXT，MEDIUMTEXT，LONGTEXT</code> ；对应的二进制类型是<code>TINYBLOB，SMALLBLOB，BLOB，MEDIUMBLOB，LONGBLOB</code> 。<code>BLOB</code> 是<code>SMALLBLOB</code> 的同义词，<code>TEXT</code> 是<code>SMALLTEXT</code> 的同义词。<code>BLOB</code> 和<code>TEXT</code> 家族之间仅有的不同是<code>BLOB</code> 类型存储的是二进制数据，没有排序规则或字符集，而<code>TEXT</code> 类型有字符集和排序规则。</p>
<p><code>MySQL</code>把每个<code>BLOB</code> 和<code>TEXT </code>值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当<code>BLOB </code>和<code>TEXT</code> 值太大时，<code>InnoDB</code>会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实际的值。</p>
<h5 id="4、使用枚举（ENUM-）代替字符串类型"><a href="#4、使用枚举（ENUM-）代替字符串类型" class="headerlink" title="4、使用枚举（ENUM ）代替字符串类型"></a>4、使用枚举（ENUM ）代替字符串类型</h5><p>有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。<code>MySQL</code>在存储枚举时非常 紧凑，会根据列表值的数量压缩到一个或者两个字节中。<code>MySQL</code>在内 部会将每个值在列表中的位置保存为整数，并且在表的<code>.frm</code> 文件中保 存“数字-字符串”映射关系的“查找表”。</p>
<p>枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用<code>ALTER TABLE</code> 。因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素，这样在 <code>MySQL 5.1</code>中就可以不用重建整个表来完成修改。</p>
<h5 id="5、日期和时间类型"><a href="#5、日期和时间类型" class="headerlink" title="5、日期和时间类型"></a>5、日期和时间类型</h5><p><code>MySQL</code>能存储的最小时间粒度为秒。</p>
<p><code>DATETIME</code> 这个类型能保存大范围的值，从1001年到9999年，精度为秒。 它把日期和时间封装到格式为<code>YYYYMMDDHHMMSS</code>的整数中， 与时区无关。使用8个字节的存储空间。</p>
<p><code>TIMETAMP</code>类型保存了从1970年1月1日午 夜（格林尼治标准时间）以来的秒数，它和<code>UNIX</code>时间戳相同。<code>TIMESTAMP</code> 只使用4个字节的存储空间，因此它的范围比 <code>DATETIME</code>小得多：只能表示从1970年到2038年。<code>MySQL</code>提供了 <code>FROM_UNIXTIME()</code> 函数把<code>Unix</code>时间戳转换为日期，并提供了 <code>UNIX_TIMESTAMP() </code>函数把日期转换为<code>Unix</code>时间戳。</p>
<h5 id="6、位数据类型"><a href="#6、位数据类型" class="headerlink" title="6、位数据类型"></a>6、位数据类型</h5><p>使用<code>BIT</code>列在一列中存储一个或多个<code>true/false</code>值。<code>BIT(1)</code>定 义一个包含单个位的字段，<code>BIT(2)</code>存储2个位，依此类推。<code>BIT</code> 列的 最大长度是64个位。</p>
<p> <code>BIT</code>的行为因存储引擎而异。<code>MyISAM</code>会打包存储所有的<code>BIT</code>列，所以17个单独的<code>BIT</code>列只需要17个位存储（假设没有可为<code>NULL</code> 的列），这样<code>MyISAM</code>只使用3个字节就能存储这17个<code>BIT</code>列。其他 存储引擎例如<code>Memory</code>和<code>InnoDB</code>，为每个<code>BIT</code>列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。</p>
<p><code>MySQL</code>把<code>BIT</code>当作字符串类型，而不是数字类型。当检索 <code>BIT(1)</code>的值时，结果是一个包含二进制0或1值的字符串，而不 是<code>ASCII</code>码的“0”或“1”。</p>
<p>如果需要保存很多<code>true/false</code>值，可以考虑合并这些列到一 个<code>SET</code>数据类型，它在<code>MySQL</code>内部是以一系列打包的位的集合来表示的。这样就有效地利用了存储空间，并且<code>MySQL</code>有像 <code>FIND_IN_SET() </code>和<code>FIELD() </code>这样的函数，方便地在查询中使用。它的主要缺点是改变列的定义的代价较高：需要<code>ALTER TABLE</code>，这对 大表来说是非常昂贵的操作</p>
<h5 id="7、加快-ALTER-TABLE-操作"><a href="#7、加快-ALTER-TABLE-操作" class="headerlink" title="7、加快 ALTER TABLE 操作"></a>7、加快 ALTER TABLE 操作</h5><p><code>MySQL</code>执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样操作可能需 要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。</p>
<p>不是所有的<code>ALTER TABLE</code> 操作都会引起表重建。例如，有两种方法可以改变或者删除一个列的默认值（一种方法很快，另外一种则很慢）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sakila.film</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> MODIFY <span class="keyword">COLUMN</span> rental_duration TINYINT(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br><span class="line"># <span class="keyword">SHOW</span> STATUS 显示这个语句做了<span class="number">1000</span>次读和<span class="number">1000</span>次插入操作。换句话说，它拷贝了整张表到一张新表，甚至列的类型、大小和可否为<span class="keyword">NULL</span>属性都没改变。</span><br></pre></td></tr></table></figure>

<p>理论上，<code>MySQL</code>可以跳过创建新表的步骤。列的默认值实际上存 在表的<code>.frm</code>文件中，所以可以直接修改这个文件而不需要改动表本身。 然而<code>MySQL</code>还没有采用这种优化的方法，所有的<code>MODIFY COLUMN</code>操作都 将导致表重建。 另外一种方法是通过<code>ALTER COLUMN (16) </code>操作来改变列的默认值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sakila.film</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> rental_duration <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">5</span>;</span><br><span class="line">#这个语句会直接修改.frm 文件而不涉及表数据。所以，这个操作是非常快的。</span><br></pre></td></tr></table></figure>

<h3 id="ch3、创建高性能的索引"><a href="#ch3、创建高性能的索引" class="headerlink" title="ch3、创建高性能的索引"></a>ch3、创建高性能的索引</h3><h5 id="1、索引概念"><a href="#1、索引概念" class="headerlink" title="1、索引概念"></a>1、索引概念</h5><p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的 顺序也十分重要，因为<code>MySQL</code>只能高效地使用索引的最左前缀列。<code>MySQL</code>中，索引是在存储引擎层而不是服务器层实现的。</p>
<h5 id="2、B-Tree索引"><a href="#2、B-Tree索引" class="headerlink" title="2、B-Tree索引"></a>2、B-Tree索引</h5><p><code>InnoDB</code>则使用的是<code>B+Tree</code>。</p>
<p><code>B-Tree</code>索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页（不同引擎的“指针”类型不同）。<code>B-Tree</code>对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<p>可以使用<code>B-Tree</code>索引的查询类型 。<code>B-Tree</code>索引适用于全键值、键值 范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。</p>
<ul>
<li>全值匹配：的是和索引中的所有列进行匹配；</li>
<li>匹配最左前缀：只使用索引的第一列；</li>
<li>匹配列前缀：也可以只匹配某一列的值的开头部分；</li>
<li>匹配范围值：用于查找某个范围之间的值；</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询：查询只需要访问 索引，而无须访问数据行。</li>
</ul>
<p>因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的<code>ORDER BY</code>操作（按顺序查找）。如果不是按照索引的最左列开始查找，则无法使用索引。不能跳过索引中的列。如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。</p>
<h5 id="3、哈希索引"><a href="#3、哈希索引" class="headerlink" title="3、哈希索引"></a>3、哈希索引</h5><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在<code>MySQL</code>中，只有<code>Memory</code>引擎显式支持哈希索引。这也是<code>Memory</code>引擎表的默认索引类型，<code>Memory</code>引擎同时也支持<code>B-Tree</code>索引。值得一 提的是，<code>Memory</code>引擎是支持非唯一哈希索引的，这在数据库世界里面 是比较与众不同的。如果多个列的哈希值相同，索引会以链表的方式存 放多个记录指针到同一个哈希条目中。</p>
<p>哈希索引的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li>
<li>哈希索引只支持等值比较查询，包括=、IN()、&lt;=&gt;（注意&lt;&gt;和&lt;=&gt; 是不同的操作）。也不支持任何范围查询。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<p><code>InnoDB</code>引擎有一个特殊的功能叫做“自适应哈希索引”。当<code>InnoDB</code>注意到某些索引值被使用得非常频繁时，它会在内存中基于<code>B-Tree</code>索引之上再创建一个哈希索引，这样就让<code>B-Tree</code>索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。</p>
<h5 id="4、索引的优点"><a href="#4、索引的优点" class="headerlink" title="4、索引的优点"></a>4、索引的优点</h5><p>最常见的<code>B-Tree</code>索引，按照顺序存储数据，所以<code>MySQL</code>可以用来做<code>ORDER BY</code> 和<code>GROUP BY </code>操作。因为数据是有序的，所以<code>B-Tree</code>也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所 以某些查询只使用索引就能够完成全部查询。</p>
<ul>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li> 索引可以将随机I/O变为顺序I/O。</li>
</ul>
<h5 id="5、高性能索引策略"><a href="#5、高性能索引策略" class="headerlink" title="5、高性能索引策略"></a>5、高性能索引策略</h5><h5 id="（1）独立的列"><a href="#（1）独立的列" class="headerlink" title="（1）独立的列"></a>（1）独立的列</h5><p>如果查询中的列不是独立的，则MySQL就不会使用 索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的 参数。 例如，下面这个查询无法使用actor_id 列的索引： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h5 id="（2）前缀索引和索引选择性"><a href="#（2）前缀索引和索引选择性" class="headerlink" title="（2）前缀索引和索引选择性"></a>（2）前缀索引和索引选择性</h5><p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的模拟哈希索引。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<p>索引的选择性是指，不重复的索引值和数据表的记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让<code>MySQL</code>在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性 能。对于<code>BLOB</code> 、<code>TEXT</code> 或者很长的<code>VARCHAR</code> 类型的列，必须使用前缀索引，因为<code>MySQL</code>不允许索引这些列的完整长度。</p>
<h5 id="（3）多列索引"><a href="#（3）多列索引" class="headerlink" title="（3）多列索引"></a>（3）多列索引</h5><p>在多个列上建立独立的单列索引大部分情况下并不能提高<code>MySQL</code> 的查询性能。<code>MySQL 5.0</code>和更新版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。</p>
<p>如下例，对这个查询<code>WHERE</code>条件，这两个单列索引都不是好的选择：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>MySQL 5.0</code>和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：<code>OR</code>条件的联合，<code>AND</code> 条件的相交，组合前两种情况的联合及相交。</p>
<h5 id="4-选择合适的索引列顺序"><a href="#4-选择合适的索引列顺序" class="headerlink" title="(4) 选择合适的索引列顺序"></a>(4) 选择合适的索引列顺序</h5><p>在一个多列<code>B-Tree</code>索引中，索引列的顺序意味着索引首先按照最左 列进行排序，其次是第二列，等等。</p>
<p>当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很 好的。这时候索引的作用只是用于优化<code>WHERE</code>条件的查找。在这种情况 下，这样设计的索引确实能够最快地过滤出需要的行，对于在<code>WHERE</code> 子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。这和前面介绍的选择前缀的长度需要考 虑的地方一样。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</p>
<h5 id="（5）聚簇索引"><a href="#（5）聚簇索引" class="headerlink" title="（5）聚簇索引"></a>（5）聚簇索引</h5><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但<code>InnoDB</code>的聚簇索引实际上在同一个结构中保存了<code>B-Tree</code>索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。</p>
<p>如果没有定义主键，<code>InnoDB</code>会选择一个唯一的非空索引代替。如果没有这样的索引，<code>InnoDB</code>会隐式定义一个主键来作为聚簇索引。</p>
<p>聚簇索引的优点：</p>
<ul>
<li>可以把相关数据保存在一起。</li>
<li>数据访问更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了<code>I/O</code>密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 <code>InnoDB</code>表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用<code>OPTIMIZE TABLE</code> 命令重新组织一 下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制<code>InnoDB</code>将每个被更新的行移动到新的位置。 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li> 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。 </li>
<li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。 </li>
<li>二级索引访问需要两次索引查找，而不是一次。二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次<code>B-Tree</code>查找而不是一次 。对于 <code>InnoDB</code>，自适应哈希索引能够减少这样的重复工作。</li>
</ul>
<h5 id="（6）覆盖索引"><a href="#（6）覆盖索引" class="headerlink" title="（6）覆盖索引"></a>（6）覆盖索引</h5><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值， 所以MySQL只能使用B-Tree索引做覆盖索引。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Varrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://varrella.github.io/2021/06/10/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">https://varrella.github.io/2021/06/10/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/12/redis%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturegg2880x1800-bg-d1ee002.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/03/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picture1___5YtjgRNTli4___0___.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">web服务器项目整理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ch1%E3%80%81MySQL%E5%8E%86%E5%8F%B2%E4%B8%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Ch1、MySQL历史与架构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、MySQL逻辑架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、并发控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.0.3.</span> <span class="toc-text">1、读写锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E9%94%81%E7%B2%92%E5%BA%A6"><span class="toc-number">1.0.4.</span> <span class="toc-text">2、锁粒度</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%A1%A8%E9%94%81"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">（1）表锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">（2）行级锁</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.0.5.</span> <span class="toc-text">三、事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.6.</span> <span class="toc-text">1、事务的概念和特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81ACID%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.7.</span> <span class="toc-text">2、ACID特性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88atomicity%EF%BC%89"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">（1）原子性（atomicity）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88consistency%EF%BC%89"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">（2）一致性（consistency）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88isolation%EF%BC%89"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">（3）隔离性（isolation）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88durability%EF%BC%89"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">（4）持久性（durability）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.0.8.</span> <span class="toc-text">3、事务的隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89READ-UNCOMMITTED%EF%BC%88%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%89"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">（1）READ UNCOMMITTED（未提交读）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89READ-COMMITTED%EF%BC%88%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%89"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">（2）READ COMMITTED（提交读）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%883%EF%BC%89REPEATABLE-READ%EF%BC%88%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89"><span class="toc-number">1.0.8.3.</span> <span class="toc-text">（3）REPEATABLE READ（可重复读）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%884%EF%BC%89SERIALIZABLE%EF%BC%88%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%89"><span class="toc-number">1.0.8.4.</span> <span class="toc-text">（4）SERIALIZABLE（可串行化）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-number">1.0.9.</span> <span class="toc-text">4、死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">1.0.10.</span> <span class="toc-text">5、事务日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.0.11.</span> <span class="toc-text">6、MySQL中的事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.12.</span> <span class="toc-text">7、多版本并发控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8%E3%80%81InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.0.13.</span> <span class="toc-text">8、InnoDB存储引擎</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9%E3%80%81-MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.0.14.</span> <span class="toc-text">9、 MyISAM存储引擎</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">ch2、数据类型优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、整数类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、实数类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.3.</span> <span class="toc-text">3、字符串类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81BLOB%E5%92%8CTEXT%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.4.</span> <span class="toc-text">3、BLOB和TEXT类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%EF%BC%88ENUM-%EF%BC%89%E4%BB%A3%E6%9B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.5.</span> <span class="toc-text">4、使用枚举（ENUM ）代替字符串类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.6.</span> <span class="toc-text">5、日期和时间类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E4%BD%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.0.7.</span> <span class="toc-text">6、位数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7%E3%80%81%E5%8A%A0%E5%BF%AB-ALTER-TABLE-%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.8.</span> <span class="toc-text">7、加快 ALTER TABLE 操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ch3%E3%80%81%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">ch3、创建高性能的索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">3.0.1.</span> <span class="toc-text">1、索引概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81B-Tree%E7%B4%A2%E5%BC%95"><span class="toc-number">3.0.2.</span> <span class="toc-text">2、B-Tree索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">3.0.3.</span> <span class="toc-text">3、哈希索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.0.4.</span> <span class="toc-text">4、索引的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5"><span class="toc-number">3.0.5.</span> <span class="toc-text">5、高性能索引策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97"><span class="toc-number">3.0.6.</span> <span class="toc-text">（1）独立的列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7"><span class="toc-number">3.0.7.</span> <span class="toc-text">（2）前缀索引和索引选择性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">3.0.8.</span> <span class="toc-text">（3）多列索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.0.9.</span> <span class="toc-text">(4) 选择合适的索引列顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">3.0.10.</span> <span class="toc-text">（5）聚簇索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">3.0.11.</span> <span class="toc-text">（6）覆盖索引</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/varrella/ImgHosting/blog_picturett-2560x1440-bg-183ceb7.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Varrella</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://varrella.github.io/">我始终相信，走过平湖烟雨，岁月山河，那些历尽劫数，尝遍百味的人，会更加生动而干净。</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>